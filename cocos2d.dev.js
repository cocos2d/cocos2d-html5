var cc = cc || {};
function ClassManager() {
  return arguments.callee.name || arguments.callee.toString().match(/^function ([^(]+)/)[1]
}
ClassManager.id = 0 | Math.random() * 998;
ClassManager.compileSuper = function(func, name, id) {
  var str = func.toString();
  var pstart = str.indexOf("(");
  var pend = str.indexOf(")");
  var params = str.substring(pstart + 1, pend);
  params = params.trim();
  var bstart = str.indexOf("{");
  var bend = str.lastIndexOf("}");
  var str = str.substring(bstart + 1, bend);
  while(str.indexOf("this._super") != -1) {
    var sp = str.indexOf("this._super");
    var bp = str.indexOf("(", sp);
    var bbp = str.indexOf(")", bp);
    var superParams = str.substring(bp + 1, bbp);
    superParams = superParams.trim();
    var coma = superParams ? "," : "";
    var Cstr = arguments.callee.ClassManager();
    str = str.substring(0, sp) + Cstr + "[" + id + "]." + name + ".call(this" + coma + str.substring(bp + 1)
  }
  return Function(params, str)
};
ClassManager.compileSuper.ClassManager = ClassManager;
ClassManager.getNewID = function() {
  return this.id++
};
(function() {
  var initializing = false, fnTest = /\b_super\b/;
  var releaseMode = document["ccConfig"] && document["ccConfig"]["CLASS_RELEASE_MODE"] ? document["ccConfig"]["CLASS_RELEASE_MODE"] : null;
  if(releaseMode) {
    console.log("release Mode")
  }
  cc.Class = function() {
  };
  cc.Class.extend = function(prop) {
    var _super = this.prototype;
    initializing = true;
    var prototype = new this;
    initializing = false;
    function Class() {
      if(!initializing && this.ctor) {
        this.ctor.apply(this, arguments)
      }
    }
    Class.id = ClassManager.getNewID();
    ClassManager[Class.id] = _super;
    for(var name in prop) {
      if(releaseMode && typeof prop[name] == "function" && typeof _super[name] == "function" && fnTest.test(prop[name])) {
        prototype[name] = ClassManager.compileSuper(prop[name], name, Class.id)
      }else {
        if(typeof prop[name] == "function" && typeof _super[name] == "function" && fnTest.test(prop[name])) {
          prototype[name] = function(name, fn) {
            return function() {
              var tmp = this._super;
              this._super = _super[name];
              var ret = fn.apply(this, arguments);
              this._super = tmp;
              return ret
            }
          }(name, prop[name])
        }else {
          prototype[name] = prop[name]
        }
      }
    }
    prototype.__pid = Class.id;
    Class.prototype = prototype;
    Class.prototype.constructor = Class;
    Class.extend = arguments.callee;
    Class.implement = function(prop) {
      for(var name in prop) {
        prototype[name] = prop[name]
      }
    };
    return Class
  }
})();
cc.inherits = function(childCtor, parentCtor) {
  function tempCtor() {
  }
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor;
  childCtor.prototype.constructor = childCtor
};
cc.base = function(me, opt_methodName, var_args) {
  var caller = arguments.callee.caller;
  if(caller.superClass_) {
    ret = caller.superClass_.constructor.apply(me, Array.prototype.slice.call(arguments, 1));
    return ret
  }
  var args = Array.prototype.slice.call(arguments, 2);
  var foundCaller = false;
  for(var ctor = me.constructor;ctor;ctor = ctor.superClass_ && ctor.superClass_.constructor) {
    if(ctor.prototype[opt_methodName] === caller) {
      foundCaller = true
    }else {
      if(foundCaller) {
        return ctor.prototype[opt_methodName].apply(me, args)
      }
    }
  }
  if(me[opt_methodName] === caller) {
    return me.constructor.prototype[opt_methodName].apply(me, args)
  }else {
    throw Error("cc.base called from a method of one name " + "to a method of a different name");
  }
};
cc.concatObjectProperties = function(dstObject, srcObject) {
  if(!dstObject) {
    dstObject = {}
  }
  for(var selKey in srcObject) {
    dstObject[selKey] = srcObject[selKey]
  }
  return dstObject
};
cc.create3DContext = function(canvas, opt_attribs) {
  var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
  var context = null;
  for(var ii = 0;ii < names.length;++ii) {
    try {
      context = canvas.getContext(names[ii], opt_attribs)
    }catch(e) {
    }
    if(context) {
      break
    }
  }
  return context
};
cc.Browser = {};
(function() {
  cc.Browser.ua = navigator.userAgent.toLowerCase();
  cc.Browser.platform = navigator.platform.toLowerCase();
  cc.Browser.UA = cc.Browser.ua.match(/(opera|ie|firefox|chrome|version)[\s\/:]([\w\d\.]+)?.*?(safari|version[\s\/:]([\w\d\.]+)|$)/) || [null, "unknown", 0];
  cc.Browser.mode = cc.Browser.UA[1] == "ie" && document.documentMode;
  cc.Browser.type = cc.Browser.UA[1] == "version" ? cc.Browser.UA[3] : cc.Browser.UA[1];
  cc.Browser.isMobile = cc.Browser.ua.indexOf("mobile") != -1 || cc.Browser.ua.indexOf("android") != -1;
  var c = document["ccConfig"] || {};
  cc._userRenderMode = parseInt(c["renderMode"]) || 0;
  if(cc._userRenderMode === 1) {
    cc.Browser.supportWebGL = false
  }else {
    cc.Browser.supportWebGL = !(window.WebGLRenderingContext == null);
    var tempCanvas = document.createElement("Canvas");
    var tempContext = cc.create3DContext(tempCanvas, {"stencil":true, "preserveDrawingBuffer":true});
    cc.Browser.supportWebGL = !(tempContext == null)
  }
  if(cc._userRenderMode === 2 && !cc.Browser.supportWebGL) {
    cc.__renderDoesnotSupport = true
  }
})();
cc.RenderDoesnotSupport = function() {
  if(cc.__renderDoesnotSupport === "undefined") {
    return false
  }
  return cc.__renderDoesnotSupport
};
cc.$ = function(x) {
  var parent = this == cc ? document : this;
  var el = x instanceof HTMLElement ? x : parent.querySelector(x);
  if(el) {
    el.find = el.find || cc.$;
    el.hasClass = el.hasClass || function(cls) {
      return this.className.match(new RegExp("(\\s|^)" + cls + "(\\s|$)"))
    };
    el.addClass = el.addClass || function(cls) {
      if(!this.hasClass(cls)) {
        if(this.className) {
          this.className += " "
        }
        this.className += cls
      }
      return this
    };
    el.removeClass = el.removeClass || function(cls) {
      if(this.hasClass(cls)) {
        this.className = this.className.replace(cls, "")
      }
      return this
    };
    el.remove = el.remove || function() {
      if(this.parentNode) {
        this.parentNode.removeChild(this)
      }
      return this
    };
    el.appendTo = el.appendTo || function(x) {
      x.appendChild(this);
      return this
    };
    el.prependTo = el.prependTo || function(x) {
      x.childNodes[0] ? x.insertBefore(this, x.childNodes[0]) : x.appendChild(this);
      return this
    };
    el.transforms = el.transforms || function() {
      this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
      return this
    };
    el.position = el.position || {x:0, y:0};
    el.rotation = el.rotation || 0;
    el.scale = el.scale || {x:1, y:1};
    el.skew = el.skew || {x:0, y:0};
    el.translates = function(x, y) {
      this.position.x = x;
      this.position.y = y;
      this.transforms();
      return this
    };
    el.rotate = function(x) {
      this.rotation = x;
      this.transforms();
      return this
    };
    el.resize = function(x, y) {
      this.scale.x = x;
      this.scale.y = y;
      this.transforms();
      return this
    };
    el.setSkew = function(x, y) {
      this.skew.x = x;
      this.skew.y = y;
      this.transforms();
      return this
    }
  }
  return el
};
switch(cc.Browser.type) {
  case "firefox":
    cc.$.pfx = "Moz";
    cc.$.hd = true;
    break;
  case "chrome":
  ;
  case "safari":
    cc.$.pfx = "webkit";
    cc.$.hd = true;
    break;
  case "opera":
    cc.$.pfx = "O";
    cc.$.hd = false;
    break;
  case "ie":
    cc.$.pfx = "ms";
    cc.$.hd = false;
    break;
  default:
    cc.$.pfx = "webkit";
    cc.$.hd = true
}
cc.$.trans = cc.$.pfx + "Transform";
cc.$.translate = cc.$.hd ? function(a) {
  return"translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function(a) {
  return"translate(" + a.x + "px, " + a.y + "px) "
};
cc.$.rotate = cc.$.hd ? function(a) {
  return"rotateZ(" + a + "deg) "
} : function(a) {
  return"rotate(" + a + "deg) "
};
cc.$.scale = function(a) {
  return"scale(" + a.x + ", " + a.y + ") "
};
cc.$.skew = function(a) {
  return"skewX(" + -a.x + "deg) skewY(" + a.y + "deg)"
};
cc.$new = function(x) {
  return cc.$(document.createElement(x))
};
cc.$.findpos = function(obj) {
  var curleft = 0;
  var curtop = 0;
  do {
    curleft += obj.offsetLeft;
    curtop += obj.offsetTop
  }while(obj = obj.offsetParent);
  return{x:curleft, y:curtop}
};
cc.clone = function(obj) {
  var newObj = obj instanceof Array ? [] : {};
  for(var key in obj) {
    var copy = obj[key];
    if(copy instanceof Array) {
      newObj[key] = cc.clone(copy)
    }else {
      if(typeof copy == "object" && !(copy instanceof cc.Node) && !(copy instanceof HTMLElement)) {
        newObj[key] = cc.clone(copy)
      }else {
        newObj[key] = copy
      }
    }
  }
  return newObj
};
cc.associateWithNative = function(jsobj, superclass) {
};
cc.IS_SHOW_DEBUG_ON_PAGE = cc.IS_SHOW_DEBUG_ON_PAGE || false;
cc._logToWebPage = function(message) {
  var logList = document.getElementById("logInfoList");
  if(!logList) {
    var logDiv = document.createElement("Div");
    logDiv.setAttribute("id", "logInfoDiv");
    cc.canvas.parentNode.appendChild(logDiv);
    logDiv.setAttribute("width", "300");
    logDiv.setAttribute("height", cc.canvas.height);
    logDiv.style.zIndex = "99999";
    logDiv.style.position = "absolute";
    logDiv.style.top = "0";
    logDiv.style.left = "0";
    logList = document.createElement("ul");
    logDiv.appendChild(logList);
    logList.setAttribute("id", "logInfoList");
    logList.style.height = "450px";
    logList.style.color = "#fff";
    logList.style.textAlign = "left";
    logList.style.listStyle = "disc outside";
    logList.style.fontSize = "12px";
    logList.style.fontFamily = "arial";
    logList.style.padding = "0 0 0 20px";
    logList.style.margin = "0";
    logList.style.textShadow = "0 0 3px #000";
    logList.style.zIndex = "99998";
    logList.style.position = "absolute";
    logList.style.top = "0";
    logList.style.left = "0";
    logList.style.overflowY = "hidden";
    var tempDiv = document.createElement("Div");
    logDiv.appendChild(tempDiv);
    tempDiv.style.width = "300px";
    tempDiv.style.height = cc.canvas.height + "px";
    tempDiv.style.opacity = "0.1";
    tempDiv.style.background = "#fff";
    tempDiv.style.border = "1px solid #dfdfdf";
    tempDiv.style.borderRadius = "8px"
  }
  var addMessage = document.createElement("li");
  addMessage.innerHTML = message;
  if(logList.childNodes.length == 0) {
    logList.appendChild(addMessage)
  }else {
    logList.insertBefore(addMessage, logList.childNodes[0])
  }
};
cc.log = function(message) {
  if(!cc.IS_SHOW_DEBUG_ON_PAGE) {
    console.log(message)
  }else {
    cc._logToWebPage(message)
  }
};
cc.MessageBox = function(message) {
  console.log(message)
};
cc.Assert = function(cond, message) {
  if(console.assert) {
    console.assert(cond, message)
  }else {
    if(!cond) {
      if(message) {
        alert(message)
      }
    }
  }
};
cc.initDebugSetting = function() {
  if(cc.COCOS2D_DEBUG == 0) {
    cc.log = function() {
    };
    cc.logINFO = function() {
    };
    cc.logERROR = function() {
    };
    cc.Assert = function() {
    }
  }else {
    if(cc.COCOS2D_DEBUG == 1) {
      cc.logINFO = cc.log;
      cc.logERROR = function() {
      }
    }else {
      if(cc.COCOS2D_DEBUG > 1) {
        cc.logINFO = cc.log;
        cc.logERROR = cc.log
      }
    }
  }
};
cc.LANGUAGE_ENGLISH = 0;
cc.LANGUAGE_CHINESE = 1;
cc.LANGUAGE_FRENCH = 2;
cc.LANGUAGE_ITALIAN = 3;
cc.LANGUAGE_GERMAN = 4;
cc.LANGUAGE_SPANISH = 5;
cc.LANGUAGE_RUSSIAN = 6;
cc.Codec = {name:"Jacob__Codec"};
cc.unzip = function() {
  return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments)
};
cc.unzipBase64 = function() {
  var tmpInput = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
  return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [tmpInput])
};
cc.unzipBase64AsArray = function(input, bytes) {
  bytes = bytes || 1;
  var dec = this.unzipBase64(input), ar = [], i, j, len;
  for(i = 0, len = dec.length / bytes;i < len;i++) {
    ar[i] = 0;
    for(j = bytes - 1;j >= 0;--j) {
      ar[i] += dec.charCodeAt(i * bytes + j) << j * 8
    }
  }
  return ar
};
cc.unzipAsArray = function(input, bytes) {
  bytes = bytes || 1;
  var dec = this.unzip(input), ar = [], i, j, len;
  for(i = 0, len = dec.length / bytes;i < len;i++) {
    ar[i] = 0;
    for(j = bytes - 1;j >= 0;--j) {
      ar[i] += dec.charCodeAt(i * bytes + j) << j * 8
    }
  }
  return ar
};
cc.StringToArray = function(input) {
  var tmp = input.split(","), ar = [], i;
  for(i = 0;i < tmp.length;i++) {
    ar.push(parseInt(tmp[i]))
  }
  return ar
};
cc.Codec.Base64 = {name:"Jacob__Codec__Base64"};
cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
cc.Codec.Base64.decode = function Jacob__Codec__Base64__decode(input) {
  var output = [], chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  while(i < input.length) {
    enc1 = this._keyStr.indexOf(input.charAt(i++));
    enc2 = this._keyStr.indexOf(input.charAt(i++));
    enc3 = this._keyStr.indexOf(input.charAt(i++));
    enc4 = this._keyStr.indexOf(input.charAt(i++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    output.push(String.fromCharCode(chr1));
    if(enc3 != 64) {
      output.push(String.fromCharCode(chr2))
    }
    if(enc4 != 64) {
      output.push(String.fromCharCode(chr3))
    }
  }
  output = output.join("");
  return output
};
cc.Codec.Base64.decodeAsArray = function Jacob__Codec__Base64___decodeAsArray(input, bytes) {
  var dec = this.decode(input), ar = [], i, j, len;
  for(i = 0, len = dec.length / bytes;i < len;i++) {
    ar[i] = 0;
    for(j = bytes - 1;j >= 0;--j) {
      ar[i] += dec.charCodeAt(i * bytes + j) << j * 8
    }
  }
  return ar
};
cc.uint8ArrayToUint32Array = function(uint8Arr) {
  if(uint8Arr.length % 4 != 0) {
    return null
  }
  var arrLen = uint8Arr.length / 4;
  var retArr = window.Uint32Array ? new Uint32Array(arrLen) : [];
  for(var i = 0;i < arrLen;i++) {
    var offset = i * 4;
    retArr[i] = uint8Arr[offset] + uint8Arr[offset + 1] * (1 << 8) + uint8Arr[offset + 2] * (1 << 16) + uint8Arr[offset + 3] * (1 << 24)
  }
  return retArr
};
cc.Codec.GZip = function Jacob__GZip(data) {
  this.data = data;
  this.debug = false;
  this.gpflags = undefined;
  this.files = 0;
  this.unzipped = [];
  this.buf32k = new Array(32768);
  this.bIdx = 0;
  this.modeZIP = false;
  this.bytepos = 0;
  this.bb = 1;
  this.bits = 0;
  this.nameBuf = [];
  this.fileout = undefined;
  this.literalTree = new Array(cc.Codec.GZip.LITERALS);
  this.distanceTree = new Array(32);
  this.treepos = 0;
  this.Places = null;
  this.len = 0;
  this.fpos = new Array(17);
  this.fpos[0] = 0;
  this.flens = undefined;
  this.fmax = undefined
};
cc.Codec.GZip.gunzip = function(string) {
  if(string.constructor === Array) {
  }else {
    if(string.constructor === String) {
    }
  }
  var gzip = new cc.Codec.GZip(string);
  return gzip.gunzip()[0][0]
};
cc.Codec.GZip.HufNode = function() {
  this.b0 = 0;
  this.b1 = 0;
  this.jump = null;
  this.jumppos = -1
};
cc.Codec.GZip.LITERALS = 288;
cc.Codec.GZip.NAMEMAX = 256;
cc.Codec.GZip.bitReverse = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 
22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 
107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255];
cc.Codec.GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
cc.Codec.GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99];
cc.Codec.GZip.cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
cc.Codec.GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
cc.Codec.GZip.prototype.gunzip = function() {
  this.outputArr = [];
  this.nextFile();
  return this.unzipped
};
cc.Codec.GZip.prototype.readByte = function() {
  this.bits += 8;
  if(this.bytepos < this.data.length) {
    return this.data.charCodeAt(this.bytepos++)
  }else {
    return-1
  }
};
cc.Codec.GZip.prototype.byteAlign = function() {
  this.bb = 1
};
cc.Codec.GZip.prototype.readBit = function() {
  var carry;
  this.bits++;
  carry = this.bb & 1;
  this.bb >>= 1;
  if(this.bb == 0) {
    this.bb = this.readByte();
    carry = this.bb & 1;
    this.bb = this.bb >> 1 | 128
  }
  return carry
};
cc.Codec.GZip.prototype.readBits = function(a) {
  var res = 0, i = a;
  while(i--) {
    res = res << 1 | this.readBit()
  }
  if(a) {
    res = cc.Codec.GZip.bitReverse[res] >> 8 - a
  }
  return res
};
cc.Codec.GZip.prototype.flushBuffer = function() {
  this.bIdx = 0
};
cc.Codec.GZip.prototype.addBuffer = function(a) {
  this.buf32k[this.bIdx++] = a;
  this.outputArr.push(String.fromCharCode(a));
  if(this.bIdx == 32768) {
    this.bIdx = 0
  }
};
cc.Codec.GZip.prototype.IsPat = function() {
  while(1) {
    if(this.fpos[this.len] >= this.fmax) {
      return-1
    }
    if(this.flens[this.fpos[this.len]] == this.len) {
      return this.fpos[this.len]++
    }
    this.fpos[this.len]++
  }
};
cc.Codec.GZip.prototype.Rec = function() {
  var curplace = this.Places[this.treepos];
  var tmp;
  if(this.len == 17) {
    return-1
  }
  this.treepos++;
  this.len++;
  tmp = this.IsPat();
  if(tmp >= 0) {
    curplace.b0 = tmp
  }else {
    curplace.b0 = 32768;
    if(this.Rec()) {
      return-1
    }
  }
  tmp = this.IsPat();
  if(tmp >= 0) {
    curplace.b1 = tmp;
    curplace.jump = null
  }else {
    curplace.b1 = 32768;
    curplace.jump = this.Places[this.treepos];
    curplace.jumppos = this.treepos;
    if(this.Rec()) {
      return-1
    }
  }
  this.len--;
  return 0
};
cc.Codec.GZip.prototype.CreateTree = function(currentTree, numval, lengths, show) {
  var i;
  this.Places = currentTree;
  this.treepos = 0;
  this.flens = lengths;
  this.fmax = numval;
  for(i = 0;i < 17;i++) {
    this.fpos[i] = 0
  }
  this.len = 0;
  if(this.Rec()) {
    return-1
  }
  return 0
};
cc.Codec.GZip.prototype.DecodeValue = function(currentTree) {
  var len, i, xtreepos = 0, X = currentTree[xtreepos], b;
  while(1) {
    b = this.readBit();
    if(b) {
      if(!(X.b1 & 32768)) {
        return X.b1
      }
      X = X.jump;
      len = currentTree.length;
      for(i = 0;i < len;i++) {
        if(currentTree[i] === X) {
          xtreepos = i;
          break
        }
      }
    }else {
      if(!(X.b0 & 32768)) {
        return X.b0
      }
      xtreepos++;
      X = currentTree[xtreepos]
    }
  }
  return-1
};
cc.Codec.GZip.prototype.DeflateLoop = function() {
  var last, c, type, i, len;
  do {
    last = this.readBit();
    type = this.readBits(2);
    if(type == 0) {
      var blockLen, cSum;
      this.byteAlign();
      blockLen = this.readByte();
      blockLen |= this.readByte() << 8;
      cSum = this.readByte();
      cSum |= this.readByte() << 8;
      if((blockLen ^ ~cSum) & 65535) {
        document.write("BlockLen checksum mismatch\n")
      }
      while(blockLen--) {
        c = this.readByte();
        this.addBuffer(c)
      }
    }else {
      if(type == 1) {
        var j;
        while(1) {
          j = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1;
          if(j > 23) {
            j = j << 1 | this.readBit();
            if(j > 199) {
              j -= 128;
              j = j << 1 | this.readBit()
            }else {
              j -= 48;
              if(j > 143) {
                j = j + 136
              }
            }
          }else {
            j += 256
          }
          if(j < 256) {
            this.addBuffer(j)
          }else {
            if(j == 256) {
              break
            }else {
              var len, dist;
              j -= 256 + 1;
              len = this.readBits(cc.Codec.GZip.cplext[j]) + cc.Codec.GZip.cplens[j];
              j = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3;
              if(cc.Codec.GZip.cpdext[j] > 8) {
                dist = this.readBits(8);
                dist |= this.readBits(cc.Codec.GZip.cpdext[j] - 8) << 8
              }else {
                dist = this.readBits(cc.Codec.GZip.cpdext[j])
              }
              dist += cc.Codec.GZip.cpdist[j];
              for(j = 0;j < len;j++) {
                var c = this.buf32k[this.bIdx - dist & 32767];
                this.addBuffer(c)
              }
            }
          }
        }
      }else {
        if(type == 2) {
          var j, n, literalCodes, distCodes, lenCodes;
          var ll = new Array(288 + 32);
          literalCodes = 257 + this.readBits(5);
          distCodes = 1 + this.readBits(5);
          lenCodes = 4 + this.readBits(4);
          for(j = 0;j < 19;j++) {
            ll[j] = 0
          }
          for(j = 0;j < lenCodes;j++) {
            ll[cc.Codec.GZip.border[j]] = this.readBits(3)
          }
          len = this.distanceTree.length;
          for(i = 0;i < len;i++) {
            this.distanceTree[i] = new cc.Codec.GZip.HufNode
          }
          if(this.CreateTree(this.distanceTree, 19, ll, 0)) {
            this.flushBuffer();
            return 1
          }
          n = literalCodes + distCodes;
          i = 0;
          var z = -1;
          while(i < n) {
            z++;
            j = this.DecodeValue(this.distanceTree);
            if(j < 16) {
              ll[i++] = j
            }else {
              if(j == 16) {
                var l;
                j = 3 + this.readBits(2);
                if(i + j > n) {
                  this.flushBuffer();
                  return 1
                }
                l = i ? ll[i - 1] : 0;
                while(j--) {
                  ll[i++] = l
                }
              }else {
                if(j == 17) {
                  j = 3 + this.readBits(3)
                }else {
                  j = 11 + this.readBits(7)
                }
                if(i + j > n) {
                  this.flushBuffer();
                  return 1
                }
                while(j--) {
                  ll[i++] = 0
                }
              }
            }
          }
          len = this.literalTree.length;
          for(i = 0;i < len;i++) {
            this.literalTree[i] = new cc.Codec.GZip.HufNode
          }
          if(this.CreateTree(this.literalTree, literalCodes, ll, 0)) {
            this.flushBuffer();
            return 1
          }
          len = this.literalTree.length;
          for(i = 0;i < len;i++) {
            this.distanceTree[i] = new cc.Codec.GZip.HufNode
          }
          var ll2 = new Array;
          for(i = literalCodes;i < ll.length;i++) {
            ll2[i - literalCodes] = ll[i]
          }
          if(this.CreateTree(this.distanceTree, distCodes, ll2, 0)) {
            this.flushBuffer();
            return 1
          }
          while(1) {
            j = this.DecodeValue(this.literalTree);
            if(j >= 256) {
              var len, dist;
              j -= 256;
              if(j == 0) {
                break
              }
              j--;
              len = this.readBits(cc.Codec.GZip.cplext[j]) + cc.Codec.GZip.cplens[j];
              j = this.DecodeValue(this.distanceTree);
              if(cc.Codec.GZip.cpdext[j] > 8) {
                dist = this.readBits(8);
                dist |= this.readBits(cc.Codec.GZip.cpdext[j] - 8) << 8
              }else {
                dist = this.readBits(cc.Codec.GZip.cpdext[j])
              }
              dist += cc.Codec.GZip.cpdist[j];
              while(len--) {
                var c = this.buf32k[this.bIdx - dist & 32767];
                this.addBuffer(c)
              }
            }else {
              this.addBuffer(j)
            }
          }
        }
      }
    }
  }while(!last);
  this.flushBuffer();
  this.byteAlign();
  return 0
};
cc.Codec.GZip.prototype.unzipFile = function(name) {
  var i;
  this.gunzip();
  for(i = 0;i < this.unzipped.length;i++) {
    if(this.unzipped[i][1] == name) {
      return this.unzipped[i][0]
    }
  }
};
cc.Codec.GZip.prototype.nextFile = function() {
  this.outputArr = [];
  this.modeZIP = false;
  var tmp = [];
  tmp[0] = this.readByte();
  tmp[1] = this.readByte();
  if(tmp[0] == 120 && tmp[1] == 218) {
    this.DeflateLoop();
    this.unzipped[this.files] = [this.outputArr.join(""), "geonext.gxt"];
    this.files++
  }
  if(tmp[0] == 31 && tmp[1] == 139) {
    this.skipdir();
    this.unzipped[this.files] = [this.outputArr.join(""), "file"];
    this.files++
  }
  if(tmp[0] == 80 && tmp[1] == 75) {
    this.modeZIP = true;
    tmp[2] = this.readByte();
    tmp[3] = this.readByte();
    if(tmp[2] == 3 && tmp[3] == 4) {
      tmp[0] = this.readByte();
      tmp[1] = this.readByte();
      this.gpflags = this.readByte();
      this.gpflags |= this.readByte() << 8;
      var method = this.readByte();
      method |= this.readByte() << 8;
      this.readByte();
      this.readByte();
      this.readByte();
      this.readByte();
      var compSize = this.readByte();
      compSize |= this.readByte() << 8;
      compSize |= this.readByte() << 16;
      compSize |= this.readByte() << 24;
      var size = this.readByte();
      size |= this.readByte() << 8;
      size |= this.readByte() << 16;
      size |= this.readByte() << 24;
      var filelen = this.readByte();
      filelen |= this.readByte() << 8;
      var extralen = this.readByte();
      extralen |= this.readByte() << 8;
      i = 0;
      this.nameBuf = [];
      while(filelen--) {
        var c = this.readByte();
        if(c == "/" | c == ":") {
          i = 0
        }else {
          if(i < cc.Codec.GZip.NAMEMAX - 1) {
            this.nameBuf[i++] = String.fromCharCode(c)
          }
        }
      }
      if(!this.fileout) {
        this.fileout = this.nameBuf
      }
      var i = 0;
      while(i < extralen) {
        c = this.readByte();
        i++
      }
      if(method == 8) {
        this.DeflateLoop();
        this.unzipped[this.files] = [this.outputArr.join(""), this.nameBuf.join("")];
        this.files++
      }
      this.skipdir()
    }
  }
};
cc.Codec.GZip.prototype.skipdir = function() {
  var tmp = [];
  var compSize, size, os, i, c;
  if(this.gpflags & 8) {
    tmp[0] = this.readByte();
    tmp[1] = this.readByte();
    tmp[2] = this.readByte();
    tmp[3] = this.readByte();
    compSize = this.readByte();
    compSize |= this.readByte() << 8;
    compSize |= this.readByte() << 16;
    compSize |= this.readByte() << 24;
    size = this.readByte();
    size |= this.readByte() << 8;
    size |= this.readByte() << 16;
    size |= this.readByte() << 24
  }
  if(this.modeZIP) {
    this.nextFile()
  }
  tmp[0] = this.readByte();
  if(tmp[0] != 8) {
    return 0
  }
  this.gpflags = this.readByte();
  this.readByte();
  this.readByte();
  this.readByte();
  this.readByte();
  this.readByte();
  os = this.readByte();
  if(this.gpflags & 4) {
    tmp[0] = this.readByte();
    tmp[2] = this.readByte();
    this.len = tmp[0] + 256 * tmp[1];
    for(i = 0;i < this.len;i++) {
      this.readByte()
    }
  }
  if(this.gpflags & 8) {
    i = 0;
    this.nameBuf = [];
    while(c = this.readByte()) {
      if(c == "7" || c == ":") {
        i = 0
      }
      if(i < cc.Codec.GZip.NAMEMAX - 1) {
        this.nameBuf[i++] = c
      }
    }
  }
  if(this.gpflags & 16) {
    while(c = this.readByte()) {
    }
  }
  if(this.gpflags & 2) {
    this.readByte();
    this.readByte()
  }
  this.DeflateLoop();
  size = this.readByte();
  size |= this.readByte() << 8;
  size |= this.readByte() << 16;
  size |= this.readByte() << 24;
  if(this.modeZIP) {
    this.nextFile()
  }
};
cc.INVALID_INDEX = -1;
cc.PI = Math.PI;
cc.FLT_MAX = parseFloat("3.402823466e+38F");
cc.RAD = cc.PI / 180;
cc.DEG = 180 / cc.PI;
cc.UINT_MAX = 4294967295;
cc.SWAP = function(x, y, ref) {
  if(typeof ref == "object" && typeof ref.x != "undefined" && typeof ref.y != "undefined") {
    var tmp = ref[x];
    ref[x] = ref[y];
    ref[y] = tmp
  }else {
    cc.Assert(false, "CC_SWAP is being modified from original macro, please check usage")
  }
};
cc.lerp = function(a, b, r) {
  return a + (b - a) * r
};
cc.RANDOM_MINUS1_1 = function() {
  return(Math.random() - 0.5) * 2
};
cc.RANDOM_0_1 = function() {
  return Math.random()
};
cc.DEGREES_TO_RADIANS = function(angle) {
  return angle * cc.RAD
};
cc.RADIANS_TO_DEGREES = function(angle) {
  return angle * cc.DEG
};
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
cc.BLEND_SRC = cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? 1 : 770;
cc.BLEND_DST = 771;
cc.NODE_DRAW_SETUP = function(node) {
  if(node._shaderProgram) {
    node._shaderProgram.use();
    node._shaderProgram.setUniformForModelViewProjectionMatrixWithMat4(node._mvpMatrix)
  }
};
cc.ENABLE_DEFAULT_GL_STATES = function() {
};
cc.DISABLE_DEFAULT_GL_STATES = function() {
};
cc.INCREMENT_GL_DRAWS = function(addNumber) {
  cc.g_NumberOfDraws += addNumber
};
cc.FLT_EPSILON = 1.192092896E-7;
cc.CONTENT_SCALE_FACTOR = cc.IS_RETINA_DISPLAY_SUPPORTED ? function() {
  return cc.Director.getInstance().getContentScaleFactor()
} : function() {
  return 1
};
cc.POINT_POINTS_TO_PIXELS = function(points) {
  return cc.p(points.x * cc.CONTENT_SCALE_FACTOR(), points.y * cc.CONTENT_SCALE_FACTOR())
};
cc.SIZE_POINTS_TO_PIXELS = function(sizeInPoints) {
  return cc.size(sizeInPoints.width * cc.CONTENT_SCALE_FACTOR(), sizeInPoints.height * cc.CONTENT_SCALE_FACTOR())
};
cc.SIZE_PIXELS_TO_POINTS = function(sizeInPixels) {
  return cc.size(sizeInPixels.width / cc.CONTENT_SCALE_FACTOR(), sizeInPixels.height / cc.CONTENT_SCALE_FACTOR())
};
cc.POINT_PIXELS_TO_POINTS = function(pixels) {
  return cc.p(pixels.x / cc.CONTENT_SCALE_FACTOR(), pixels.y / cc.CONTENT_SCALE_FACTOR())
};
cc.RECT_PIXELS_TO_POINTS = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(pixel) {
  return cc.rect(pixel.origin.x / cc.CONTENT_SCALE_FACTOR(), pixel.origin.y / cc.CONTENT_SCALE_FACTOR(), pixel.size.width / cc.CONTENT_SCALE_FACTOR(), pixel.size.height / cc.CONTENT_SCALE_FACTOR())
} : function(p) {
  return p
};
cc.RECT_POINTS_TO_PIXELS = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(point) {
  return cc.rect(point.origin.x * cc.CONTENT_SCALE_FACTOR(), point.origin.y * cc.CONTENT_SCALE_FACTOR(), point.size.width * cc.CONTENT_SCALE_FACTOR(), point.size.height * cc.CONTENT_SCALE_FACTOR())
} : function(p) {
  return p
};
if(!cc.Browser.supportWebGL) {
  var gl = gl || {};
  gl.ONE = 1;
  gl.ZERO = 0;
  gl.SRC_ALPHA = 770;
  gl.ONE_MINUS_SRC_ALPHA = 771;
  gl.ONE_MINUS_DST_COLOR = 775
}
cc.CHECK_GL_ERROR_DEBUG = function() {
  var _error = cc.renderContext.getError();
  if(_error) {
    cc.log("WebGL error " + _error)
  }
};
cc.SAX_NONE = 0;
cc.SAX_KEY = 1;
cc.SAX_DICT = 2;
cc.SAX_INT = 3;
cc.SAX_REAL = 4;
cc.SAX_STRING = 5;
cc.SAX_ARRAY = 6;
var Uint8Array = Uint8Array || Array;
if(/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
  var IEBinaryToArray_ByteStr_Script = "\x3c!-- IEBinaryToArray_ByteStr --\x3e\r\n" + "Function IEBinaryToArray_ByteStr(Binary)\r\n" + "   IEBinaryToArray_ByteStr = CStr(Binary)\r\n" + "End Function\r\n" + "Function IEBinaryToArray_ByteStr_Last(Binary)\r\n" + "   Dim lastIndex\r\n" + "   lastIndex = LenB(Binary)\r\n" + "   if lastIndex mod 2 Then\r\n" + "       IEBinaryToArray_ByteStr_Last = Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n" + "   Else\r\n" + "       IEBinaryToArray_ByteStr_Last = " + 
  '""' + "\r\n" + "   End If\r\n" + "End Function\r\n";
  var myVBScript = document.createElement("script");
  myVBScript.type = "text/vbscript";
  myVBScript.textContent = IEBinaryToArray_ByteStr_Script;
  document.body.appendChild(myVBScript);
  cc._convertResponseBodyToText = function(binary) {
    var byteMapping = {};
    for(var i = 0;i < 256;i++) {
      for(var j = 0;j < 256;j++) {
        byteMapping[String.fromCharCode(i + j * 256)] = String.fromCharCode(i) + String.fromCharCode(j)
      }
    }
    var rawBytes = IEBinaryToArray_ByteStr(binary);
    var lastChr = IEBinaryToArray_ByteStr_Last(binary);
    return rawBytes.replace(/[\s\S]/g, function(match) {
      return byteMapping[match]
    }) + lastChr
  }
}
cc.FileUtils = cc.Class.extend({_fileDataCache:null, _textFileCache:null, _directory:null, _filenameLookupDict:null, _searchResolutionsOrderArray:null, _searchPathArray:null, ctor:function() {
  this._fileDataCache = {};
  this._textFileCache = {};
  this._searchPathArray = [];
  this._searchPathArray.push("");
  this._searchResolutionsOrderArray = [];
  this._searchResolutionsOrderArray.push("")
}, getByteArrayFromFile:function(fileName, mode, size) {
  if(this._fileDataCache.hasOwnProperty(fileName)) {
    return this._fileDataCache[fileName]
  }
  return this._loadBinaryFileData(fileName)
}, _getXMLHttpRequest:function() {
  if(window.XMLHttpRequest) {
    return new window.XMLHttpRequest
  }else {
    return new ActiveXObject("MSXML2.XMLHTTP")
  }
}, unloadBinaryFileData:function(fileUrl) {
  if(this._fileDataCache.hasOwnProperty(fileUrl)) {
    delete this._fileDataCache[fileUrl]
  }
}, preloadBinaryFileData:function(fileUrl) {
  fileUrl = this.fullPathFromRelativePath(fileUrl);
  var selfPointer = this;
  var xhr = this._getXMLHttpRequest();
  xhr.open("GET", fileUrl, true);
  if(/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
    xhr.setRequestHeader("Accept-Charset", "x-user-defined");
    xhr.onreadystatechange = function(event) {
      if(xhr.readyState == 4) {
        if(xhr.status == 200) {
          var fileContents = cc._convertResponseBodyToText(xhr["responseBody"]);
          if(fileContents) {
            selfPointer._fileDataCache[fileUrl] = selfPointer._stringConvertToArray(fileContents)
          }
        }
        cc.Loader.getInstance().onResLoaded()
      }
    }
  }else {
    if(xhr.overrideMimeType) {
      xhr.overrideMimeType("text/plain; charset=x-user-defined")
    }
    xhr.onload = function(e) {
      var arrayStr = xhr.responseText;
      if(arrayStr) {
        cc.Loader.getInstance().onResLoaded();
        selfPointer._fileDataCache[fileUrl] = selfPointer._stringConvertToArray(arrayStr)
      }
    }
  }
  xhr.send(null)
}, _loadBinaryFileData:function(fileUrl) {
  var req = this._getXMLHttpRequest();
  req.open("GET", fileUrl, false);
  var arrayInfo = null;
  if(/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
    req.setRequestHeader("Accept-Charset", "x-user-defined");
    req.send(null);
    if(req.status != 200) {
      return null
    }
    var fileContents = cc._convertResponseBodyToText(req["responseBody"]);
    if(fileContents) {
      arrayInfo = this._stringConvertToArray(fileContents);
      this._fileDataCache[fileUrl] = arrayInfo
    }
  }else {
    if(req.overrideMimeType) {
      req.overrideMimeType("text/plain; charset=x-user-defined")
    }
    req.send(null);
    if(req.status != 200) {
      return null
    }
    arrayInfo = this._stringConvertToArray(req.responseText);
    this._fileDataCache[fileUrl] = arrayInfo
  }
  return arrayInfo
}, _stringConvertToArray:function(strData) {
  if(!strData) {
    return null
  }
  var arrData = new Uint8Array(strData.length);
  for(var i = 0;i < strData.length;i++) {
    arrData[i] = strData.charCodeAt(i) & 255
  }
  return arrData
}, unloadTextFileData:function(fileUrl) {
  if(this._textFileCache.hasOwnProperty(fileUrl)) {
    delete this._textFileCache[fileUrl]
  }
}, preloadTextFileData:function(fileUrl) {
  fileUrl = this.fullPathFromRelativePath(fileUrl);
  var selfPointer = this;
  var xhr = this._getXMLHttpRequest();
  xhr.open("GET", fileUrl, true);
  if(/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
    xhr.setRequestHeader("Accept-Charset", "x-user-defined");
    xhr.onreadystatechange = function(event) {
      if(xhr.readyState == 4) {
        if(xhr.status == 200) {
          var fileContents = cc._convertResponseBodyToText(xhr.responseBody);
          if(fileContents) {
            selfPointer._textFileCache[fileUrl] = fileContents
          }
        }
        cc.Loader.getInstance().onResLoaded()
      }
    }
  }else {
    if(xhr.overrideMimeType) {
      xhr.overrideMimeType("text/plain; charset=x-user-defined")
    }
    xhr.onload = function(e) {
      if(xhr.responseText) {
        cc.Loader.getInstance().onResLoaded();
        selfPointer._fileDataCache[fileUrl] = xhr.responseText
      }
    }
  }
  xhr.send(null)
}, _loadTextFileData:function(fileUrl) {
  var req = this._getXMLHttpRequest();
  req.open("GET", fileUrl, false);
  var arrayInfo = null;
  if(/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
    req.setRequestHeader("Accept-Charset", "x-user-defined");
    req.send(null);
    if(req.status != 200) {
      return null
    }
    var fileContents = cc._convertResponseBodyToText(req.responseBody);
    if(fileContents) {
      arrayInfo = fileContents;
      this._textFileCache[fileUrl] = fileContents
    }
  }else {
    if(req.overrideMimeType) {
      req.overrideMimeType("text/plain; charset=x-user-defined")
    }
    req.send(null);
    if(req.status != 200) {
      return null
    }
    arrayInfo = req.responseText;
    this._textFileCache[fileUrl] = arrayInfo
  }
  return arrayInfo
}, getTextFileData:function(fileUrl) {
  if(this._textFileCache.hasOwnProperty(fileUrl)) {
    return this._textFileCache[fileUrl]
  }
  return this._loadTextFileData(fileUrl)
}, getFileDataFromZip:function(pszZipFilePath, fileName, size) {
}, removeSuffixFromFile:function(path) {
}, popupNotify:true, fullPathFromRelativePath:function(pszRelativePath) {
  return pszRelativePath
}, fullPathForFilename:function(filename) {
  var found = false;
  var newFileName = this._getNewFilename(filename);
  var fullPath;
  if(newFileName && newFileName.length > 1 && newFileName.indexOf(":") == 1) {
    return newFileName
  }
  for(var i = 0;i < this._searchPathArray.length;i++) {
    var searchPath = this._searchPathArray[i];
    for(var j = 0;j < this._searchResolutionsOrderArray.length;j++) {
      var resourceDirectory = this._searchResolutionsOrderArray[j];
      fullPath = this._getPathForFilename(newFileName, resourceDirectory, searchPath);
      if(fullPath) {
        found = true;
        break
      }
    }
    if(found) {
      break
    }
  }
  return found ? fullPath : newFileName
}, loadFilenameLookup:function(filename) {
  var fullPath = this.fullPathForFilename(filename);
  if(fullPath.length > 0) {
    var dict = cc.SAXParser.getInstance().parse(fullPath);
    var metadataDict = dict["metadata"];
    var version = parseInt(metadataDict["version"]);
    if(version != 1) {
      cc.log("cocos2d: ERROR: Invalid filenameLookup dictionary version: " + version + ". Filename: " + filename);
      return
    }
    this.setFilenameLookupDictionary(dict["filenames"])
  }
}, setFilenameLookupDictionary:function(filenameLookupDict) {
  this._filenameLookupDict = filenameLookupDict
}, fullPathFromRelativeFile:function(filename, relativeFile) {
  var tmpPath;
  if(filename) {
    tmpPath = relativeFile.substring(0, relativeFile.lastIndexOf("/") + 1);
    return tmpPath + filename
  }else {
    tmpPath = relativeFile.substring(0, relativeFile.lastIndexOf("."));
    tmpPath = tmpPath + ".png";
    return tmpPath
  }
}, setSearchResolutionsOrder:function(searchResolutionsOrder) {
  this._searchResolutionsOrderArray = searchResolutionsOrder
}, getSearchResolutionsOrder:function() {
  return this._searchResolutionsOrderArray
}, setSearchPath:function(searchPaths) {
  this._searchPathArray = searchPaths
}, getSearchPath:function() {
  return this._searchPathArray
}, getResourceDirectory:function() {
  return this._directory
}, setResourcePath:function(resourcePath) {
}, dictionaryWithContentsOfFile:function(fileName) {
  var parser = cc.SAXParser.getInstance();
  this.rootDict = parser.parse(fileName);
  return this.rootDict
}, getStringFromFile:function(fileName) {
  return cc.SAXParser.getInstance().getList(fileName)
}, dictionaryWithContentsOfFileThreadSafe:function(fileName) {
  var tMaker = new cc.DictMaker;
  return tMaker.dictionaryWithContentsOfFile(fileName)
}, getWriteablePath:function() {
  return""
}, setPopupNotify:function(notify) {
  cc.popupNotify = notify
}, isPopupNotify:function() {
  return cc.popupNotify
}, _resourceRootPath:"", getResourceRootPath:function() {
  return this._resourceRootPath
}, setResourceRootPath:function(resourceRootPath) {
  this._resourceRootPath = resourceRootPath
}, _getNewFilename:function(filename) {
  var newFileName = null;
  var fileNameFound = this._filenameLookupDict ? this._filenameLookupDict[filename] : null;
  if(!fileNameFound || fileNameFound.length === 0) {
    newFileName = filename
  }else {
    newFileName = fileNameFound;
    cc.log("FOUND NEW FILE NAME: " + newFileName)
  }
  return newFileName
}, _getPathForFilename:function(filename, resourceDirectory, searchPath) {
  var ret;
  var resourceRootPath = this.getResourceRootPath();
  if(filename && filename.length > 0 && (filename.indexOf("/") === 0 || filename.indexOf("\\") === 0)) {
    ret = ""
  }else {
    if(resourceRootPath.length > 0) {
      ret = resourceRootPath;
      if(ret[ret.length - 1] != "\\" && ret[ret.length - 1] != "/") {
        ret += "/"
      }
    }else {
      ret = resourceRootPath
    }
  }
  var file = filename;
  var file_path = "";
  var pos = filename.lastIndexOf("/");
  if(pos != -1) {
    file_path = filename.substr(0, pos + 1);
    file = filename.substr(pos + 1)
  }
  var path = searchPath;
  if(path.length > 0 && path.lastIndexOf("/") !== path.length - 1) {
    path += "/"
  }
  path += file_path;
  path += resourceDirectory;
  if(path.length > 0 && path.lastIndexOf("/") !== path.length - 1) {
    path += "/"
  }
  path += file;
  ret += path;
  return ret
}});
cc.s_SharedFileUtils = null;
cc.FileUtils.getInstance = function() {
  if(cc.s_SharedFileUtils == null) {
    cc.s_SharedFileUtils = new cc.FileUtils
  }
  return cc.s_SharedFileUtils
};
cc.DictMaker = cc.Class.extend({rootDict:[], dictionaryWithContentsOfFile:function(fileName) {
  var parser = cc.SAXParser.getInstance();
  this.rootDict = parser.parse(fileName);
  return this.rootDict
}});
cc.Color3B = function(r1, g1, b1) {
  switch(arguments.length) {
    case 0:
      this.r = 0;
      this.g = 0;
      this.b = 0;
      break;
    case 1:
      if(r1 && r1 instanceof cc.Color3B) {
        this.r = 0 | r1.r || 0;
        this.g = 0 | r1.g || 0;
        this.b = 0 | r1.b || 0
      }else {
        this.r = 0;
        this.g = 0;
        this.b = 0
      }
      break;
    case 3:
      this.r = 0 | r1 || 0;
      this.g = 0 | g1 || 0;
      this.b = 0 | b1 || 0;
      break;
    default:
      throw"unknown argument type";break
  }
};
cc.c3b = function(r, g, b) {
  return new cc.Color3B(r, g, b)
};
cc.integerToColor3B = function(intValue) {
  intValue = intValue || 0;
  var offset = 255;
  var retColor = new cc.Color3B;
  retColor.r = intValue & offset;
  retColor.g = intValue >> 8 & offset;
  retColor.b = intValue >> 16 & offset;
  return retColor
};
cc.c3 = cc.c3b;
Object.defineProperties(cc, {WHITE:{get:function() {
  return cc.c3b(255, 255, 255)
}}, YELLOW:{get:function() {
  return cc.c3b(255, 255, 0)
}}, BLUE:{get:function() {
  return cc.c3b(0, 0, 255)
}}, GREEN:{get:function() {
  return cc.c3b(0, 255, 0)
}}, RED:{get:function() {
  return cc.c3b(255, 0, 0)
}}, MAGENTA:{get:function() {
  return cc.c3b(255, 0, 255)
}}, BLACK:{get:function() {
  return cc.c3b(0, 0, 0)
}}, ORANGE:{get:function() {
  return cc.c3b(255, 127, 0)
}}, GRAY:{get:function() {
  return cc.c3b(166, 166, 166)
}}});
cc.white = function() {
  return new cc.Color3B(255, 255, 255)
};
cc.yellow = function() {
  return new cc.Color3B(255, 255, 0)
};
cc.blue = function() {
  return new cc.Color3B(0, 0, 255)
};
cc.green = function() {
  return new cc.Color3B(0, 255, 0)
};
cc.red = function() {
  return new cc.Color3B(255, 0, 0)
};
cc.magenta = function() {
  return new cc.Color3B(255, 0, 255)
};
cc.black = function() {
  return new cc.Color3B(0, 0, 0)
};
cc.orange = function() {
  return new cc.Color3B(255, 127, 0)
};
cc.gray = function() {
  return new cc.Color3B(166, 166, 166)
};
cc.Color4B = function(r1, g1, b1, a1) {
  this.r = 0 | r1;
  this.g = 0 | g1;
  this.b = 0 | b1;
  this.a = 0 | a1
};
cc.c4b = function(r, g, b, a) {
  return new cc.Color4B(r, g, b, a)
};
cc.c4 = cc.c4b;
cc.Color4F = function(r1, g1, b1, a1) {
  this.r = r1;
  this.g = g1;
  this.b = b1;
  this.a = a1
};
cc.c4f = function(r, g, b, a) {
  return new cc.Color4F(r, g, b, a)
};
cc.c4FFromccc3B = function(c) {
  return new cc.Color4F(c.r / 255, c.g / 255, c.b / 255, 1)
};
cc.c4FFromccc4B = function(c) {
  return new cc.Color4F(c.r / 255, c.g / 255, c.b / 255, c.a / 255)
};
cc.c4BFromccc4F = function(c) {
  return new cc.Color4B(0 | c.r * 255, 0 | c.g * 255, 0 | c.b * 255, 0 | c.a * 255)
};
cc.c4FEqual = function(a, b) {
  return a.r == b.r && a.g == b.g && a.b == b.b && a.a == b.a
};
cc.Vertex2F = function(x1, y1) {
  this.x = x1 || 0;
  this.y = y1 || 0
};
cc.Vertex2 = function(x, y) {
  return new cc.Vertex2F(x, y)
};
cc.Vertex3F = function(x1, y1, z1) {
  this.x = x1 || 0;
  this.y = y1 || 0;
  this.z = z1 || 0
};
cc.vertex3 = function(x, y, z) {
  return new cc.Vertex3F(x, y, z)
};
cc.Tex2F = function(u1, v1) {
  this.u = u1 || 0;
  this.v = v1 || 0
};
cc.tex2 = function(u, v) {
  return new cc.Tex2F(u, v)
};
cc.PointSprite = function(pos1, color1, size1) {
  this.pos = pos1 || new cc.Vertex2F(0, 0);
  this.color = color1 || new cc.Color4B(0, 0, 0, 0);
  this.size = size1 || 0
};
cc.Quad2 = function(tl1, tr1, bl1, br1) {
  this.tl = tl1 || new cc.Vertex2F(0, 0);
  this.tr = tr1 || new cc.Vertex2F(0, 0);
  this.bl = bl1 || new cc.Vertex2F(0, 0);
  this.br = br1 || new cc.Vertex2F(0, 0)
};
cc.Quad3 = function(bl1, br1, tl1, tr1) {
  this.bl = bl1 || new cc.Vertex3F(0, 0, 0);
  this.br = br1 || new cc.Vertex3F(0, 0, 0);
  this.tl = tl1 || new cc.Vertex3F(0, 0, 0);
  this.tr = tr1 || new cc.Vertex3F(0, 0, 0)
};
cc.GridSize = function(x1, y1) {
  this.x = x1;
  this.y = y1
};
cc.g = function(x, y) {
  return new cc.GridSize(x, y)
};
cc.V2F_C4B_T2F = function(vertices1, colors1, texCoords1) {
  this.vertices = vertices1 || new cc.Vertex2F(0, 0);
  this.colors = colors1 || new cc.Color4B(0, 0, 0, 0);
  this.texCoords = texCoords1 || new cc.Tex2F(0, 0)
};
cc.V2F_C4F_T2F = function(vertices1, colors1, texCoords1) {
  this.vertices = vertices1 || new cc.Vertex2F(0, 0);
  this.colors = colors1 || new cc.Color4F(0, 0, 0, 0);
  this.texCoords = texCoords1 || new cc.Tex2F(0, 0)
};
cc.V3F_C4B_T2F = function(vertices1, colors1, texCoords1) {
  this.vertices = vertices1 || new cc.Vertex3F(0, 0, 0);
  this.colors = colors1 || new cc.Color4B(0, 0, 0, 0);
  this.texCoords = texCoords1 || new cc.Tex2F(0, 0)
};
cc.V2F_C4B_T2F_Triangle = function(a, b, c) {
  this.a = a || new cc.V2F_C4B_T2F;
  this.b = b || new cc.V2F_C4B_T2F;
  this.c = c || new cc.V2F_C4B_T2F
};
cc.V2F_C4B_T2F_Quad = function(bl1, br1, tl1, tr1) {
  this.bl = bl1 || new cc.V2F_C4B_T2F;
  this.br = br1 || new cc.V2F_C4B_T2F;
  this.tl = tl1 || new cc.V2F_C4B_T2F;
  this.tr = tr1 || new cc.V2F_C4B_T2F
};
cc.V2F_C4B_T2F_QuadZero = function() {
  return new cc.V2F_C4B_T2F_Quad(new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)), new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)), new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)), new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)))
};
cc.V3F_C4B_T2F_Quad = function(tl1, bl1, tr1, br1) {
  this.tl = tl1 || new cc.V3F_C4B_T2F;
  this.bl = bl1 || new cc.V3F_C4B_T2F;
  this.tr = tr1 || new cc.V3F_C4B_T2F;
  this.br = br1 || new cc.V3F_C4B_T2F
};
cc.V3F_C4B_T2F_QuadZero = function() {
  return new cc.V3F_C4B_T2F_Quad(new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)), new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)), new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)), new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)))
};
cc.V3F_C4B_T2F_QuadCopy = function(sourceQuad) {
  if(!sourceQuad) {
    return cc.V3F_C4B_T2F_QuadZero()
  }
  return new cc.V3F_C4B_T2F_Quad(new cc.V3F_C4B_T2F(new cc.Vertex3F(sourceQuad.tl.vertices.x, sourceQuad.tl.vertices.y, sourceQuad.tl.vertices.z), new cc.Color4B(sourceQuad.tl.colors.r, sourceQuad.tl.colors.g, sourceQuad.tl.colors.b, sourceQuad.tl.colors.a), new cc.Tex2F(sourceQuad.tl.texCoords.u, sourceQuad.tl.texCoords.v)), new cc.V3F_C4B_T2F(new cc.Vertex3F(sourceQuad.bl.vertices.x, sourceQuad.bl.vertices.y, sourceQuad.bl.vertices.z), new cc.Color4B(sourceQuad.bl.colors.r, sourceQuad.bl.colors.g, 
  sourceQuad.bl.colors.b, sourceQuad.bl.colors.a), new cc.Tex2F(sourceQuad.bl.texCoords.u, sourceQuad.bl.texCoords.v)), new cc.V3F_C4B_T2F(new cc.Vertex3F(sourceQuad.tr.vertices.x, sourceQuad.tr.vertices.y, sourceQuad.tr.vertices.z), new cc.Color4B(sourceQuad.tr.colors.r, sourceQuad.tr.colors.g, sourceQuad.tr.colors.b, sourceQuad.tr.colors.a), new cc.Tex2F(sourceQuad.tr.texCoords.u, sourceQuad.tr.texCoords.v)), new cc.V3F_C4B_T2F(new cc.Vertex3F(sourceQuad.br.vertices.x, sourceQuad.br.vertices.y, 
  sourceQuad.br.vertices.z), new cc.Color4B(sourceQuad.br.colors.r, sourceQuad.br.colors.g, sourceQuad.br.colors.b, sourceQuad.br.colors.a), new cc.Tex2F(sourceQuad.br.texCoords.u, sourceQuad.br.texCoords.v)))
};
cc.V3F_C4B_T2F_QuadsCopy = function(sourceQuads) {
  if(!sourceQuads) {
    return[]
  }
  var retArr = [];
  for(var i = 0;i < sourceQuads.length;i++) {
    retArr.push(cc.V3F_C4B_T2F_QuadCopy(sourceQuads[i]))
  }
  return retArr
};
cc.V2F_C4F_T2F_Quad = function(bl1, br1, tl1, tr1) {
  this.bl = bl1 || new cc.V2F_C4F_T2F;
  this.br = br1 || new cc.V2F_C4F_T2F;
  this.tl = tl1 || new cc.V2F_C4F_T2F;
  this.tr = tr1 || new cc.V2F_C4F_T2F
};
cc.BlendFunc = function(src1, dst1) {
  this.src = src1;
  this.dst = dst1
};
cc.BlendFuncDisable = function() {
  return new cc.BlendFunc(gl.ONE, gl.ZERO)
};
cc.convertColor3BtoHexString = function(clr) {
  var hR = clr.r.toString(16);
  var hG = clr.g.toString(16);
  var hB = clr.b.toString(16);
  var stClr = "#" + (clr.r < 16 ? "0" + hR : hR) + (clr.g < 16 ? "0" + hG : hG) + (clr.b < 16 ? "0" + hB : hB);
  return stClr
};
if(cc.Browser.supportWebGL) {
  cc.Color4B = function(r, g, b, a, arrayBuffer, offset) {
    this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Color4B.BYTES_PER_ELEMENT);
    this._offset = offset || 0;
    this._rU8 = new Uint8Array(this._arrayBuffer, this._offset, 1);
    this._gU8 = new Uint8Array(this._arrayBuffer, this._offset + Uint8Array.BYTES_PER_ELEMENT, 1);
    this._bU8 = new Uint8Array(this._arrayBuffer, this._offset + Uint8Array.BYTES_PER_ELEMENT * 2, 1);
    this._aU8 = new Uint8Array(this._arrayBuffer, this._offset + Uint8Array.BYTES_PER_ELEMENT * 3, 1);
    this._rU8[0] = r || 0;
    this._gU8[0] = g || 0;
    this._bU8[0] = b || 0;
    this._aU8[0] = a || 0
  };
  cc.Color4B.BYTES_PER_ELEMENT = 4;
  Object.defineProperties(cc.Color4B.prototype, {r:{get:function() {
    return this._rU8[0]
  }, set:function(xValue) {
    this._rU8[0] = xValue
  }, enumerable:true}, g:{get:function() {
    return this._gU8[0]
  }, set:function(yValue) {
    this._gU8[0] = yValue
  }, enumerable:true}, b:{get:function() {
    return this._bU8[0]
  }, set:function(xValue) {
    this._bU8[0] = xValue
  }, enumerable:true}, a:{get:function() {
    return this._aU8[0]
  }, set:function(yValue) {
    this._aU8[0] = yValue
  }, enumerable:true}});
  cc.Color4F = function(r, g, b, a, arrayBuffer, offset) {
    this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Color4F.BYTES_PER_ELEMENT);
    this._offset = offset || 0;
    this._rF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
    this._rF32[0] = r || 0;
    this._gF32 = new Float32Array(this._arrayBuffer, this._offset + Float32Array.BYTES_PER_ELEMENT, 1);
    this._gF32[0] = g || 0;
    this._bF32 = new Float32Array(this._arrayBuffer, this._offset + Float32Array.BYTES_PER_ELEMENT * 2, 1);
    this._bF32[0] = b || 0;
    this._aF32 = new Float32Array(this._arrayBuffer, this._offset + Float32Array.BYTES_PER_ELEMENT * 3, 1);
    this._aF32[0] = a || 0
  };
  cc.Color4F.BYTES_PER_ELEMENT = 16;
  Object.defineProperties(cc.Color4F.prototype, {r:{get:function() {
    return this._rF32[0]
  }, set:function(rValue) {
    this._rF32[0] = rValue
  }, enumerable:true}, g:{get:function() {
    return this._gF32[0]
  }, set:function(rValue) {
    this._gF32[0] = rValue
  }, enumerable:true}, b:{get:function() {
    return this._bF32[0]
  }, set:function(rValue) {
    this._bF32[0] = rValue
  }, enumerable:true}, a:{get:function() {
    return this._aF32[0]
  }, set:function(rValue) {
    this._aF32[0] = rValue
  }, enumerable:true}});
  cc.Vertex2F = function(x, y, arrayBuffer, offset) {
    this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
    this._offset = offset || 0;
    this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
    this._yF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
    this._xF32[0] = x || 0;
    this._yF32[0] = y || 0
  };
  cc.Vertex2F.BYTES_PER_ELEMENT = 8;
  Object.defineProperties(cc.Vertex2F.prototype, {x:{get:function() {
    return this._xF32[0]
  }, set:function(xValue) {
    this._xF32[0] = xValue
  }, enumerable:true}, y:{get:function() {
    return this._yF32[0]
  }, set:function(yValue) {
    this._yF32[0] = yValue
  }, enumerable:true}});
  cc.Vertex3F = function(x, y, z, arrayBuffer, offset) {
    this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
    this._offset = offset || 0;
    this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
    this._xF32[0] = x || 0;
    this._yF32 = new Float32Array(this._arrayBuffer, this._offset + Float32Array.BYTES_PER_ELEMENT, 1);
    this._yF32[0] = y || 0;
    this._zF32 = new Float32Array(this._arrayBuffer, this._offset + Float32Array.BYTES_PER_ELEMENT * 2, 1);
    this._zF32[0] = z || 0
  };
  cc.Vertex3F.BYTES_PER_ELEMENT = 12;
  Object.defineProperties(cc.Vertex3F.prototype, {x:{get:function() {
    return this._xF32[0]
  }, set:function(xValue) {
    this._xF32[0] = xValue
  }, enumerable:true}, y:{get:function() {
    return this._yF32[0]
  }, set:function(yValue) {
    this._yF32[0] = yValue
  }, enumerable:true}, z:{get:function() {
    return this._zF32[0]
  }, set:function(zValue) {
    this._zF32[0] = zValue
  }, enumerable:true}});
  cc.Tex2F = function(u, v, arrayBuffer, offset) {
    this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
    this._offset = offset || 0;
    this._uF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
    this._vF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
    this._uF32[0] = u || 0;
    this._vF32[0] = v || 0
  };
  cc.Tex2F.BYTES_PER_ELEMENT = 8;
  Object.defineProperties(cc.Tex2F.prototype, {u:{get:function() {
    return this._uF32[0]
  }, set:function(xValue) {
    this._uF32[0] = xValue
  }, enumerable:true}, v:{get:function() {
    return this._vF32[0]
  }, set:function(yValue) {
    this._vF32[0] = yValue
  }, enumerable:true}});
  cc.Quad2 = function(tl, tr, bl, br, arrayBuffer, offset) {
    this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
    this._offset = offset || 0;
    this._tl = tl ? new cc.Vertex2F(tl.x, tl.y, this._arrayBuffer, 0) : new cc.Vertex2F(0, 0, this._arrayBuffer, 0);
    this._tr = tr ? new cc.Vertex2F(tr.x, tr.y, this._arrayBuffer, cc.Vertex2F.BYTES_PER_ELEMENT) : new cc.Vertex2F(0, 0, this._arrayBuffer, cc.Vertex2F.BYTES_PER_ELEMENT);
    this._bl = bl ? new cc.Vertex2F(bl.x, bl.y, this._arrayBuffer, cc.Vertex2F.BYTES_PER_ELEMENT * 2) : new cc.Vertex2F(0, 0, this._arrayBuffer, cc.Vertex2F.BYTES_PER_ELEMENT * 2);
    this._br = br ? new cc.Vertex2F(br.x, br.y, this._arrayBuffer, cc.Vertex2F.BYTES_PER_ELEMENT * 3) : new cc.Vertex2F(0, 0, this._arrayBuffer, cc.Vertex2F.BYTES_PER_ELEMENT * 3)
  };
  cc.Quad2.BYTES_PER_ELEMENT = 32;
  Object.defineProperties(cc.Quad2.prototype, {tl:{get:function() {
    return this._tl
  }, set:function(tlValue) {
    this._tl.x = tlValue.x;
    this._tl.y = tlValue.y
  }, enumerable:true}, tr:{get:function() {
    return this._tr
  }, set:function(trValue) {
    this._tr.x = trValue.x;
    this._tr.y = trValue.y
  }, enumerable:true}, bl:{get:function() {
    return this._bl
  }, set:function(blValue) {
    this._bl.x = blValue.x;
    this._bl.y = blValue.y
  }, enumerable:true}, br:{get:function() {
    return this._br
  }, set:function(brValue) {
    this._br.x = brValue.x;
    this._br.y = brValue.y
  }, enumerable:true}});
  cc.V3F_C4B_T2F = function(vertices, colors, texCoords, arrayBuffer, offset) {
    this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
    this._offset = offset || 0;
    this._vertices = vertices ? new cc.Vertex3F(vertices.x, vertices.y, vertices.z, this._arrayBuffer, this._offset) : new cc.Vertex3F(0, 0, 0, this._arrayBuffer, this._offset);
    this._colors = colors ? new cc.Color4B(colors.r, colors.g, colors.b, colors.a, this._arrayBuffer, this._offset + cc.Vertex3F.BYTES_PER_ELEMENT) : new cc.Color4B(0, 0, 0, 0, this._arrayBuffer, this._offset + cc.Vertex3F.BYTES_PER_ELEMENT);
    this._texCoords = texCoords ? new cc.Tex2F(texCoords.u, texCoords.v, this._arrayBuffer, this._offset + cc.Vertex3F.BYTES_PER_ELEMENT + cc.Color4B.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, this._arrayBuffer, this._offset + cc.Vertex3F.BYTES_PER_ELEMENT + cc.Color4B.BYTES_PER_ELEMENT)
  };
  cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24;
  Object.defineProperties(cc.V3F_C4B_T2F.prototype, {vertices:{get:function() {
    return this._vertices
  }, set:function(verticesValue) {
    this._vertices.x = verticesValue.x;
    this._vertices.y = verticesValue.y;
    this._vertices.z = verticesValue.z
  }, enumerable:true}, colors:{get:function() {
    return this._colors
  }, set:function(colorValue) {
    this._colors.r = colorValue.r;
    this._colors.g = colorValue.g;
    this._colors.b = colorValue.b;
    this._colors.a = colorValue.a
  }, enumerable:true}, texCoords:{get:function() {
    return this._texCoords
  }, set:function(texValue) {
    this._texCoords.u = texValue.u;
    this._texCoords.v = texValue.v
  }, enumerable:true}});
  cc.V3F_C4B_T2F_Quad = function(tl, bl, tr, br, arrayBuffer, offset) {
    this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
    this._offset = offset || 0;
    this._tl = tl ? new cc.V3F_C4B_T2F(tl.vertices, tl.colors, tl.texCoords, this._arrayBuffer, this._offset) : new cc.V3F_C4B_T2F(null, null, null, this._arrayBuffer, this._offset);
    this._bl = bl ? new cc.V3F_C4B_T2F(bl.vertices, bl.colors, bl.texCoords, this._arrayBuffer, this._offset + cc.V3F_C4B_T2F.BYTES_PER_ELEMENT) : new cc.V3F_C4B_T2F(null, null, null, this._arrayBuffer, this._offset + cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
    this._tr = tr ? new cc.V3F_C4B_T2F(tr.vertices, tr.colors, tr.texCoords, this._arrayBuffer, this._offset + cc.V3F_C4B_T2F.BYTES_PER_ELEMENT * 2) : new cc.V3F_C4B_T2F(null, null, null, this._arrayBuffer, this._offset + cc.V3F_C4B_T2F.BYTES_PER_ELEMENT * 2);
    this._br = br ? new cc.V3F_C4B_T2F(br.vertices, br.colors, br.texCoords, this._arrayBuffer, this._offset + cc.V3F_C4B_T2F.BYTES_PER_ELEMENT * 3) : new cc.V3F_C4B_T2F(null, null, null, this._arrayBuffer, this._offset + cc.V3F_C4B_T2F.BYTES_PER_ELEMENT * 3)
  };
  cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96;
  Object.defineProperties(cc.V3F_C4B_T2F_Quad.prototype, {tl:{get:function() {
    return this._tl
  }, set:function(tlValue) {
    this._tl.vertices = tlValue.vertices;
    this._tl.colors = tlValue.colors;
    this._tl.texCoords = tlValue.texCoords
  }, enumerable:true}, bl:{get:function() {
    return this._bl
  }, set:function(blValue) {
    this._bl.vertices = blValue.vertices;
    this._bl.colors = blValue.colors;
    this._bl.texCoords = blValue.texCoords
  }, enumerable:true}, tr:{get:function() {
    return this._tr
  }, set:function(trValue) {
    this._tr.vertices = trValue.vertices;
    this._tr.colors = trValue.colors;
    this._tr.texCoords = trValue.texCoords
  }, enumerable:true}, br:{get:function() {
    return this._br
  }, set:function(brValue) {
    this._br.vertices = brValue.vertices;
    this._br.colors = brValue.colors;
    this._br.texCoords = brValue.texCoords
  }, enumerable:true}, arrayBuffer:{get:function() {
    return this._arrayBuffer
  }, enumerable:true}});
  cc.V3F_C4B_T2F_QuadZero = function() {
    return new cc.V3F_C4B_T2F_Quad
  };
  cc.V2F_C4B_T2F = function(vertices, colors, texCoords, arrayBuffer, offset) {
    this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
    this._offset = offset || 0;
    this._vertices = vertices ? new cc.Vertex2F(vertices.x, vertices.y, this._arrayBuffer, this._offset) : new cc.Vertex2F(0, 0, this._arrayBuffer, this._offset);
    this._colors = colors ? new cc.Color4B(colors.r, colors.g, colors.b, colors.a, this._arrayBuffer, this._offset + cc.Vertex2F.BYTES_PER_ELEMENT) : new cc.Color4B(0, 0, 0, 0, this._arrayBuffer, this._offset + cc.Vertex2F.BYTES_PER_ELEMENT);
    this._texCoords = texCoords ? new cc.Tex2F(texCoords.u, texCoords.v, this._arrayBuffer, this._offset + cc.Vertex2F.BYTES_PER_ELEMENT + cc.Color4B.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, this._arrayBuffer, this._offset + cc.Vertex2F.BYTES_PER_ELEMENT + cc.Color4B.BYTES_PER_ELEMENT)
  };
  cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20;
  Object.defineProperties(cc.V2F_C4B_T2F.prototype, {vertices:{get:function() {
    return this._vertices
  }, set:function(verticesValue) {
    this._vertices.x = verticesValue.x;
    this._vertices.y = verticesValue.y
  }, enumerable:true}, colors:{get:function() {
    return this._colors
  }, set:function(colorValue) {
    this._colors.r = colorValue.r;
    this._colors.g = colorValue.g;
    this._colors.b = colorValue.b;
    this._colors.a = colorValue.a
  }, enumerable:true}, texCoords:{get:function() {
    return this._texCoords
  }, set:function(texValue) {
    this._texCoords.u = texValue.u;
    this._texCoords.v = texValue.v
  }, enumerable:true}});
  cc.V2F_C4B_T2F_Triangle = function(a, b, c, arrayBuffer, offset) {
    this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
    this._offset = offset || 0;
    this._a = a ? new cc.V2F_C4B_T2F(a.vertices, a.colors, a.texCoords, this._arrayBuffer, this._offset) : new cc.V2F_C4B_T2F(null, null, null, this._arrayBuffer, this._offset);
    this._b = b ? new cc.V2F_C4B_T2F(b.vertices, b.colors, b.texCoords, this._arrayBuffer, this._offset + cc.V2F_C4B_T2F.BYTES_PER_ELEMENT) : new cc.V2F_C4B_T2F(null, null, null, this._arrayBuffer, this._offset + cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
    this._c = c ? new cc.V2F_C4B_T2F(c.vertices, c.colors, c.texCoords, this._arrayBuffer, this._offset + cc.V2F_C4B_T2F.BYTES_PER_ELEMENT * 2) : new cc.V2F_C4B_T2F(null, null, null, this._arrayBuffer, this._offset + cc.V2F_C4B_T2F.BYTES_PER_ELEMENT * 2)
  };
  cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60;
  Object.defineProperties(cc.V2F_C4B_T2F_Triangle.prototype, {a:{get:function() {
    return this._a
  }, set:function(aValue) {
    this._a.vertices = aValue.vertices;
    this._a.colors = aValue.colors;
    this._a.texCoords = aValue.texCoords
  }, enumerable:true}, b:{get:function() {
    return this._b
  }, set:function(bValue) {
    this._b.vertices = bValue.vertices;
    this._b.colors = bValue.colors;
    this._b.texCoords = bValue.texCoords
  }, enumerable:true}, c:{get:function() {
    return this._c
  }, set:function(cValue) {
    this._c.vertices = cValue.vertices;
    this._c.colors = cValue.colors;
    this._c.texCoords = cValue.texCoords
  }, enumerable:true}})
}
cc.convertHexNumToColor3B = function(clrSt) {
  var nAr = clrSt.substr(1).split("");
  var r = parseInt("0x" + nAr[0] + nAr[1]);
  var g = parseInt("0x" + nAr[2] + nAr[3]);
  var b = parseInt("0x" + nAr[4] + nAr[5]);
  return new cc.Color3B(r, g, b)
};
cc.TEXT_ALIGNMENT_LEFT = 0;
cc.TEXT_ALIGNMENT_CENTER = 1;
cc.TEXT_ALIGNMENT_RIGHT = 2;
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
cc._Dictionary = cc.Class.extend({_keyMapTb:null, _valueMapTb:null, __currId:0, ctor:function() {
  this._keyMapTb = {};
  this._valueMapTb = {};
  this.__currId = 2 << (0 | Math.random() * 10)
}, __getKey:function() {
  this.__currId++;
  return"key_" + this.__currId
}, setObject:function(value, key) {
  if(key == null) {
    return
  }
  var keyId = this.__getKey();
  this._keyMapTb[keyId] = key;
  this._valueMapTb[keyId] = value
}, objectForKey:function(key) {
  if(key == null) {
    return null
  }
  for(var keyId in this._keyMapTb) {
    if(this._keyMapTb[keyId] === key) {
      return this._valueMapTb[keyId]
    }
  }
  return null
}, valueForKey:function(key) {
  return this.objectForKey(key)
}, removeObjectForKey:function(key) {
  if(key == null) {
    return
  }
  for(var keyId in this._keyMapTb) {
    if(this._keyMapTb[keyId] === key) {
      delete this._valueMapTb[keyId];
      delete this._keyMapTb[keyId];
      return
    }
  }
}, removeObjectsForKeys:function(keys) {
  if(keys == null) {
    return
  }
  for(var i = 0;i < keys.length;i++) {
    this.removeObjectForKey(keys[i])
  }
}, allKeys:function() {
  var keyArr = [];
  for(var key in this._keyMapTb) {
    keyArr.push(this._keyMapTb[key])
  }
  return keyArr
}, removeAllObjects:function() {
  this._keyMapTb = {};
  this._valueMapTb = {}
}, count:function() {
  return this.allKeys().length
}});
cc.UIInterfaceOrientationLandscapeLeft = -90;
cc.UIInterfaceOrientationLandscapeRight = 90;
cc.UIInterfaceOrientationPortraitUpsideDown = 180;
cc.UIInterfaceOrientationPortrait = 0;
cc.Acceleration = function(x, y, z, timestamp) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.timestamp = timestamp || 0
};
cc.Accelerometer = cc.Class.extend({setDelegate:function(delegate) {
  cc.AccelerometerDispatcher.getInstance().addDelegate(delegate)
}, setAccelerometerInterval:function(interval) {
  cc.AccelerometerDispatcher.getInstance().setAccelerometerInterval(interval)
}});
cc.AccelerometerDispatcher = cc.Class.extend({_delegate:null, _acceleration:null, _deviceEvent:null, _interval:0.1, _minus:1, init:function() {
  this._acceleration = new cc.Acceleration;
  this._deviceEvent = window.DeviceMotionEvent || window.DeviceOrientationEvent;
  var ua = navigator.userAgent;
  if(/Android/.test(ua)) {
    this._minus = -1
  }
  return true
}, getDelegate:function() {
  return this._delegate
}, addDelegate:function(delegate) {
  this._delegate = delegate;
  var acc = this.didAccelerate.bind(this);
  if(this._delegate) {
    if(this._deviceEvent == window.DeviceMotionEvent) {
      window.addEventListener("devicemotion", acc, false)
    }else {
      window.addEventListener("deviceorientation", acc, false)
    }
  }else {
    if(this._deviceEvent == window.DeviceMotionEvent) {
      window.removeEventListener("devicemotion", acc)
    }else {
      window.removeEventListener("deviceorientation", acc)
    }
  }
}, setAccelerometerInterval:function(interval) {
  if(this._interval !== interval) {
    this._interval = interval
  }
}, didAccelerate:function(eventData) {
  if(!this._delegate) {
    return
  }
  if(this._deviceEvent == window.DeviceMotionEvent) {
    var acceleration = eventData.accelerationIncludingGravity;
    this._acceleration.x = this._minus * acceleration.x * 0.1;
    this._acceleration.y = this._minus * acceleration.y * 0.1;
    this._acceleration.z = acceleration.z * 0.1
  }else {
    this._acceleration.x = eventData.gamma / 90 * 0.981;
    this._acceleration.y = -(eventData.beta / 90) * 0.981;
    this._acceleration.z = eventData.alpha / 90 * 0.981
  }
  this._acceleration.timestamp = (new Date).getTime();
  var tmp = this._acceleration.x;
  switch(window.orientation) {
    case cc.UIInterfaceOrientationLandscapeRight:
      this._acceleration.x = -this._acceleration.y;
      this._acceleration.y = tmp;
      break;
    case cc.UIInterfaceOrientationLandscapeLeft:
      this._acceleration.x = this._acceleration.y;
      this._acceleration.y = -tmp;
      break;
    case cc.UIInterfaceOrientationPortraitUpsideDown:
      this._acceleration.x = -this._acceleration.x;
      this._acceleration.y = -this._acceleration.y;
      break;
    case cc.UIInterfaceOrientationPortrait:
      break
  }
  this._delegate.onAccelerometer(this._acceleration)
}});
cc.AccelerometerDispatcher.getInstance = function() {
  if(!this._instance) {
    this._instance = new cc.AccelerometerDispatcher;
    this._instance.init()
  }
  return this._instance
};
/*
 zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function() {
  function i(a) {
    throw a;
  }
  var r = void 0, v = !0, aa = this;
  function y(a, c) {
    var b = a.split("."), e = aa;
    !(b[0] in e) && e.execScript && e.execScript("var " + b[0]);
    for(var f;b.length && (f = b.shift());) {
      !b.length && c !== r ? e[f] = c : e = e[f] ? e[f] : e[f] = {}
    }
  }
  var H = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
  function ba(a) {
    if("string" === typeof a) {
      var c = a.split(""), b, e;
      b = 0;
      for(e = c.length;b < e;b++) {
        c[b] = (c[b].charCodeAt(0) & 255) >>> 0
      }
      a = c
    }
    for(var f = 1, d = 0, g = a.length, h, m = 0;0 < g;) {
      h = 1024 < g ? 1024 : g;
      g -= h;
      do {
        f += a[m++], d += f
      }while(--h);
      f %= 65521;
      d %= 65521
    }
    return(d << 16 | f) >>> 0
  }
  function J(a, c) {
    this.index = "number" === typeof c ? c : 0;
    this.i = 0;
    this.buffer = a instanceof (H ? Uint8Array : Array) ? a : new (H ? Uint8Array : Array)(32768);
    2 * this.buffer.length <= this.index && i(Error("invalid index"));
    this.buffer.length <= this.index && this.f()
  }
  J.prototype.f = function() {
    var a = this.buffer, c, b = a.length, e = new (H ? Uint8Array : Array)(b << 1);
    if(H) {
      e.set(a)
    }else {
      for(c = 0;c < b;++c) {
        e[c] = a[c]
      }
    }
    return this.buffer = e
  };
  J.prototype.d = function(a, c, b) {
    var e = this.buffer, f = this.index, d = this.i, g = e[f], h;
    b && 1 < c && (a = 8 < c ? (N[a & 255] << 24 | N[a >>> 8 & 255] << 16 | N[a >>> 16 & 255] << 8 | N[a >>> 24 & 255]) >> 32 - c : N[a] >> 8 - c);
    if(8 > c + d) {
      g = g << c | a, d += c
    }else {
      for(h = 0;h < c;++h) {
        g = g << 1 | a >> c - h - 1 & 1, 8 === ++d && (d = 0, e[f++] = N[g], g = 0, f === e.length && (e = this.f()))
      }
    }
    e[f] = g;
    this.buffer = e;
    this.i = d;
    this.index = f
  };
  J.prototype.finish = function() {
    var a = this.buffer, c = this.index, b;
    0 < this.i && (a[c] <<= 8 - this.i, a[c] = N[a[c]], c++);
    H ? b = a.subarray(0, c) : (a.length = c, b = a);
    return b
  };
  var ca = new (H ? Uint8Array : Array)(256), ha;
  for(ha = 0;256 > ha;++ha) {
    for(var R = ha, ia = R, ja = 7, R = R >>> 1;R;R >>>= 1) {
      ia <<= 1, ia |= R & 1, --ja
    }
    ca[ha] = (ia << ja & 255) >>> 0
  }
  var N = ca;
  var ka = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 
  2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 
  2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 
  2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 
  3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 
  414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
  H && new Uint32Array(ka);
  function la(a) {
    this.buffer = new (H ? Uint16Array : Array)(2 * a);
    this.length = 0
  }
  la.prototype.getParent = function(a) {
    return 2 * ((a - 2) / 4 | 0)
  };
  la.prototype.push = function(a, c) {
    var b, e, f = this.buffer, d;
    b = this.length;
    f[this.length++] = c;
    for(f[this.length++] = a;0 < b;) {
      if(e = this.getParent(b), f[b] > f[e]) {
        d = f[b], f[b] = f[e], f[e] = d, d = f[b + 1], f[b + 1] = f[e + 1], f[e + 1] = d, b = e
      }else {
        break
      }
    }
    return this.length
  };
  la.prototype.pop = function() {
    var a, c, b = this.buffer, e, f, d;
    c = b[0];
    a = b[1];
    this.length -= 2;
    b[0] = b[this.length];
    b[1] = b[this.length + 1];
    for(d = 0;;) {
      f = 2 * d + 2;
      if(f >= this.length) {
        break
      }
      f + 2 < this.length && b[f + 2] > b[f] && (f += 2);
      if(b[f] > b[d]) {
        e = b[d], b[d] = b[f], b[f] = e, e = b[d + 1], b[d + 1] = b[f + 1], b[f + 1] = e
      }else {
        break
      }
      d = f
    }
    return{index:a, value:c, length:this.length}
  };
  function S(a) {
    var c = a.length, b = 0, e = Number.POSITIVE_INFINITY, f, d, g, h, m, j, s, n, l;
    for(n = 0;n < c;++n) {
      a[n] > b && (b = a[n]), a[n] < e && (e = a[n])
    }
    f = 1 << b;
    d = new (H ? Uint32Array : Array)(f);
    g = 1;
    h = 0;
    for(m = 2;g <= b;) {
      for(n = 0;n < c;++n) {
        if(a[n] === g) {
          j = 0;
          s = h;
          for(l = 0;l < g;++l) {
            j = j << 1 | s & 1, s >>= 1
          }
          for(l = j;l < f;l += m) {
            d[l] = g << 16 | n
          }
          ++h
        }
      }
      ++g;
      h <<= 1;
      m <<= 1
    }
    return[d, b, e]
  }
  function ma(a, c) {
    this.h = pa;
    this.w = 0;
    this.input = a;
    this.b = 0;
    c && (c.lazy && (this.w = c.lazy), "number" === typeof c.compressionType && (this.h = c.compressionType), c.outputBuffer && (this.a = H && c.outputBuffer instanceof Array ? new Uint8Array(c.outputBuffer) : c.outputBuffer), "number" === typeof c.outputIndex && (this.b = c.outputIndex));
    this.a || (this.a = new (H ? Uint8Array : Array)(32768))
  }
  var pa = 2, qa = {NONE:0, r:1, j:pa, N:3}, ra = [], T;
  for(T = 0;288 > T;T++) {
    switch(v) {
      case 143 >= T:
        ra.push([T + 48, 8]);
        break;
      case 255 >= T:
        ra.push([T - 144 + 400, 9]);
        break;
      case 279 >= T:
        ra.push([T - 256 + 0, 7]);
        break;
      case 287 >= T:
        ra.push([T - 280 + 192, 8]);
        break;
      default:
        i("invalid literal: " + T)
    }
  }
  ma.prototype.n = function() {
    var a, c, b, e, f = this.input;
    switch(this.h) {
      case 0:
        b = 0;
        for(e = f.length;b < e;) {
          c = H ? f.subarray(b, b + 65535) : f.slice(b, b + 65535);
          b += c.length;
          var d = c, g = b === e, h = r, m = r, j = r, s = r, n = r, l = this.a, q = this.b;
          if(H) {
            for(l = new Uint8Array(this.a.buffer);l.length <= q + d.length + 5;) {
              l = new Uint8Array(l.length << 1)
            }
            l.set(this.a)
          }
          h = g ? 1 : 0;
          l[q++] = h | 0;
          m = d.length;
          j = ~m + 65536 & 65535;
          l[q++] = m & 255;
          l[q++] = m >>> 8 & 255;
          l[q++] = j & 255;
          l[q++] = j >>> 8 & 255;
          if(H) {
            l.set(d, q), q += d.length, l = l.subarray(0, q)
          }else {
            s = 0;
            for(n = d.length;s < n;++s) {
              l[q++] = d[s]
            }
            l.length = q
          }
          this.b = q;
          this.a = l
        }
        break;
      case 1:
        var E = new J(new Uint8Array(this.a.buffer), this.b);
        E.d(1, 1, v);
        E.d(1, 2, v);
        var t = sa(this, f), z, K, A;
        z = 0;
        for(K = t.length;z < K;z++) {
          if(A = t[z], J.prototype.d.apply(E, ra[A]), 256 < A) {
            E.d(t[++z], t[++z], v), E.d(t[++z], 5), E.d(t[++z], t[++z], v)
          }else {
            if(256 === A) {
              break
            }
          }
        }
        this.a = E.finish();
        this.b = this.a.length;
        break;
      case pa:
        var x = new J(new Uint8Array(this.a), this.b), B, k, p, D, C, da = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], W, Ma, ea, Na, na, va = Array(19), Oa, $, oa, F, Pa;
        B = pa;
        x.d(1, 1, v);
        x.d(B, 2, v);
        k = sa(this, f);
        W = ta(this.L, 15);
        Ma = ua(W);
        ea = ta(this.K, 7);
        Na = ua(ea);
        for(p = 286;257 < p && 0 === W[p - 1];p--) {
        }
        for(D = 30;1 < D && 0 === ea[D - 1];D--) {
        }
        var Qa = p, Ra = D, M = new (H ? Uint32Array : Array)(Qa + Ra), u, O, w, fa, L = new (H ? Uint32Array : Array)(316), I, G, P = new (H ? Uint8Array : Array)(19);
        for(u = O = 0;u < Qa;u++) {
          M[O++] = W[u]
        }
        for(u = 0;u < Ra;u++) {
          M[O++] = ea[u]
        }
        if(!H) {
          u = 0;
          for(fa = P.length;u < fa;++u) {
            P[u] = 0
          }
        }
        u = I = 0;
        for(fa = M.length;u < fa;u += O) {
          for(O = 1;u + O < fa && M[u + O] === M[u];++O) {
          }
          w = O;
          if(0 === M[u]) {
            if(3 > w) {
              for(;0 < w--;) {
                L[I++] = 0, P[0]++
              }
            }else {
              for(;0 < w;) {
                G = 138 > w ? w : 138, G > w - 3 && G < w && (G = w - 3), 10 >= G ? (L[I++] = 17, L[I++] = G - 3, P[17]++) : (L[I++] = 18, L[I++] = G - 11, P[18]++), w -= G
              }
            }
          }else {
            if(L[I++] = M[u], P[M[u]]++, w--, 3 > w) {
              for(;0 < w--;) {
                L[I++] = M[u], P[M[u]]++
              }
            }else {
              for(;0 < w;) {
                G = 6 > w ? w : 6, G > w - 3 && G < w && (G = w - 3), L[I++] = 16, L[I++] = G - 3, P[16]++, w -= G
              }
            }
          }
        }
        a = H ? L.subarray(0, I) : L.slice(0, I);
        na = ta(P, 7);
        for(F = 0;19 > F;F++) {
          va[F] = na[da[F]]
        }
        for(C = 19;4 < C && 0 === va[C - 1];C--) {
        }
        Oa = ua(na);
        x.d(p - 257, 5, v);
        x.d(D - 1, 5, v);
        x.d(C - 4, 4, v);
        for(F = 0;F < C;F++) {
          x.d(va[F], 3, v)
        }
        F = 0;
        for(Pa = a.length;F < Pa;F++) {
          if($ = a[F], x.d(Oa[$], na[$], v), 16 <= $) {
            F++;
            switch($) {
              case 16:
                oa = 2;
                break;
              case 17:
                oa = 3;
                break;
              case 18:
                oa = 7;
                break;
              default:
                i("invalid code: " + $)
            }
            x.d(a[F], oa, v)
          }
        }
        var Sa = [Ma, W], Ta = [Na, ea], Q, Ua, ga, ya, Va, Wa, Xa, Ya;
        Va = Sa[0];
        Wa = Sa[1];
        Xa = Ta[0];
        Ya = Ta[1];
        Q = 0;
        for(Ua = k.length;Q < Ua;++Q) {
          if(ga = k[Q], x.d(Va[ga], Wa[ga], v), 256 < ga) {
            x.d(k[++Q], k[++Q], v), ya = k[++Q], x.d(Xa[ya], Ya[ya], v), x.d(k[++Q], k[++Q], v)
          }else {
            if(256 === ga) {
              break
            }
          }
        }
        this.a = x.finish();
        this.b = this.a.length;
        break;
      default:
        i("invalid compression type")
    }
    return this.a
  };
  function wa(a, c) {
    this.length = a;
    this.G = c
  }
  function xa() {
    var a = za;
    switch(v) {
      case 3 === a:
        return[257, a - 3, 0];
      case 4 === a:
        return[258, a - 4, 0];
      case 5 === a:
        return[259, a - 5, 0];
      case 6 === a:
        return[260, a - 6, 0];
      case 7 === a:
        return[261, a - 7, 0];
      case 8 === a:
        return[262, a - 8, 0];
      case 9 === a:
        return[263, a - 9, 0];
      case 10 === a:
        return[264, a - 10, 0];
      case 12 >= a:
        return[265, a - 11, 1];
      case 14 >= a:
        return[266, a - 13, 1];
      case 16 >= a:
        return[267, a - 15, 1];
      case 18 >= a:
        return[268, a - 17, 1];
      case 22 >= a:
        return[269, a - 19, 2];
      case 26 >= a:
        return[270, a - 23, 2];
      case 30 >= a:
        return[271, a - 27, 2];
      case 34 >= a:
        return[272, a - 31, 2];
      case 42 >= a:
        return[273, a - 35, 3];
      case 50 >= a:
        return[274, a - 43, 3];
      case 58 >= a:
        return[275, a - 51, 3];
      case 66 >= a:
        return[276, a - 59, 3];
      case 82 >= a:
        return[277, a - 67, 4];
      case 98 >= a:
        return[278, a - 83, 4];
      case 114 >= a:
        return[279, a - 99, 4];
      case 130 >= a:
        return[280, a - 115, 4];
      case 162 >= a:
        return[281, a - 131, 5];
      case 194 >= a:
        return[282, a - 163, 5];
      case 226 >= a:
        return[283, a - 195, 5];
      case 257 >= a:
        return[284, a - 227, 5];
      case 258 === a:
        return[285, a - 258, 0];
      default:
        i("invalid length: " + a)
    }
  }
  var Aa = [], za, Ba;
  for(za = 3;258 >= za;za++) {
    Ba = xa(), Aa[za] = Ba[2] << 24 | Ba[1] << 16 | Ba[0]
  }
  var Ca = H ? new Uint32Array(Aa) : Aa;
  function sa(a, c) {
    function b(a, c) {
      var b = a.G, d = [], e = 0, f;
      f = Ca[a.length];
      d[e++] = f & 65535;
      d[e++] = f >> 16 & 255;
      d[e++] = f >> 24;
      var g;
      switch(v) {
        case 1 === b:
          g = [0, b - 1, 0];
          break;
        case 2 === b:
          g = [1, b - 2, 0];
          break;
        case 3 === b:
          g = [2, b - 3, 0];
          break;
        case 4 === b:
          g = [3, b - 4, 0];
          break;
        case 6 >= b:
          g = [4, b - 5, 1];
          break;
        case 8 >= b:
          g = [5, b - 7, 1];
          break;
        case 12 >= b:
          g = [6, b - 9, 2];
          break;
        case 16 >= b:
          g = [7, b - 13, 2];
          break;
        case 24 >= b:
          g = [8, b - 17, 3];
          break;
        case 32 >= b:
          g = [9, b - 25, 3];
          break;
        case 48 >= b:
          g = [10, b - 33, 4];
          break;
        case 64 >= b:
          g = [11, b - 49, 4];
          break;
        case 96 >= b:
          g = [12, b - 65, 5];
          break;
        case 128 >= b:
          g = [13, b - 97, 5];
          break;
        case 192 >= b:
          g = [14, b - 129, 6];
          break;
        case 256 >= b:
          g = [15, b - 193, 6];
          break;
        case 384 >= b:
          g = [16, b - 257, 7];
          break;
        case 512 >= b:
          g = [17, b - 385, 7];
          break;
        case 768 >= b:
          g = [18, b - 513, 8];
          break;
        case 1024 >= b:
          g = [19, b - 769, 8];
          break;
        case 1536 >= b:
          g = [20, b - 1025, 9];
          break;
        case 2048 >= b:
          g = [21, b - 1537, 9];
          break;
        case 3072 >= b:
          g = [22, b - 2049, 10];
          break;
        case 4096 >= b:
          g = [23, b - 3073, 10];
          break;
        case 6144 >= b:
          g = [24, b - 4097, 11];
          break;
        case 8192 >= b:
          g = [25, b - 6145, 11];
          break;
        case 12288 >= b:
          g = [26, b - 8193, 12];
          break;
        case 16384 >= b:
          g = [27, b - 12289, 12];
          break;
        case 24576 >= b:
          g = [28, b - 16385, 13];
          break;
        case 32768 >= b:
          g = [29, b - 24577, 13];
          break;
        default:
          i("invalid distance")
      }
      f = g;
      d[e++] = f[0];
      d[e++] = f[1];
      d[e++] = f[2];
      var h, j;
      h = 0;
      for(j = d.length;h < j;++h) {
        l[q++] = d[h]
      }
      t[d[0]]++;
      z[d[3]]++;
      E = a.length + c - 1;
      n = null
    }
    var e, f, d, g, h, m = {}, j, s, n, l = H ? new Uint16Array(2 * c.length) : [], q = 0, E = 0, t = new (H ? Uint32Array : Array)(286), z = new (H ? Uint32Array : Array)(30), K = a.w, A;
    if(!H) {
      for(d = 0;285 >= d;) {
        t[d++] = 0
      }
      for(d = 0;29 >= d;) {
        z[d++] = 0
      }
    }
    t[256] = 1;
    e = 0;
    for(f = c.length;e < f;++e) {
      d = h = 0;
      for(g = 3;d < g && e + d !== f;++d) {
        h = h << 8 | c[e + d]
      }
      m[h] === r && (m[h] = []);
      j = m[h];
      if(!(0 < E--)) {
        for(;0 < j.length && 32768 < e - j[0];) {
          j.shift()
        }
        if(e + 3 >= f) {
          n && b(n, -1);
          d = 0;
          for(g = f - e;d < g;++d) {
            A = c[e + d], l[q++] = A, ++t[A]
          }
          break
        }
        if(0 < j.length) {
          var x = r, B = r, k = 0, p = r, D = r, C = r, da = r, W = c.length, D = 0, da = j.length;
          a:for(;D < da;D++) {
            x = j[da - D - 1];
            p = 3;
            if(3 < k) {
              for(C = k;3 < C;C--) {
                if(c[x + C - 1] !== c[e + C - 1]) {
                  continue a
                }
              }
              p = k
            }
            for(;258 > p && e + p < W && c[x + p] === c[e + p];) {
              ++p
            }
            p > k && (B = x, k = p);
            if(258 === p) {
              break
            }
          }
          s = new wa(k, e - B);
          n ? n.length < s.length ? (A = c[e - 1], l[q++] = A, ++t[A], b(s, 0)) : b(n, -1) : s.length < K ? n = s : b(s, 0)
        }else {
          n ? b(n, -1) : (A = c[e], l[q++] = A, ++t[A])
        }
      }
      j.push(e)
    }
    l[q++] = 256;
    t[256]++;
    a.L = t;
    a.K = z;
    return H ? l.subarray(0, q) : l
  }
  function ta(a, c) {
    function b(a) {
      var c = z[a][K[a]];
      c === n ? (b(a + 1), b(a + 1)) : --E[c];
      ++K[a]
    }
    var e = a.length, f = new la(572), d = new (H ? Uint8Array : Array)(e), g, h, m, j, s;
    if(!H) {
      for(j = 0;j < e;j++) {
        d[j] = 0
      }
    }
    for(j = 0;j < e;++j) {
      0 < a[j] && f.push(j, a[j])
    }
    g = Array(f.length / 2);
    h = new (H ? Uint32Array : Array)(f.length / 2);
    if(1 === g.length) {
      return d[f.pop().index] = 1, d
    }
    j = 0;
    for(s = f.length / 2;j < s;++j) {
      g[j] = f.pop(), h[j] = g[j].value
    }
    var n = h.length, l = new (H ? Uint16Array : Array)(c), q = new (H ? Uint8Array : Array)(c), E = new (H ? Uint8Array : Array)(n), t = Array(c), z = Array(c), K = Array(c), A = (1 << c) - n, x = 1 << c - 1, B, k, p, D, C;
    l[c - 1] = n;
    for(k = 0;k < c;++k) {
      A < x ? q[k] = 0 : (q[k] = 1, A -= x), A <<= 1, l[c - 2 - k] = (l[c - 1 - k] / 2 | 0) + n
    }
    l[0] = q[0];
    t[0] = Array(l[0]);
    z[0] = Array(l[0]);
    for(k = 1;k < c;++k) {
      l[k] > 2 * l[k - 1] + q[k] && (l[k] = 2 * l[k - 1] + q[k]), t[k] = Array(l[k]), z[k] = Array(l[k])
    }
    for(B = 0;B < n;++B) {
      E[B] = c
    }
    for(p = 0;p < l[c - 1];++p) {
      t[c - 1][p] = h[p], z[c - 1][p] = p
    }
    for(B = 0;B < c;++B) {
      K[B] = 0
    }
    1 === q[c - 1] && (--E[0], ++K[c - 1]);
    for(k = c - 2;0 <= k;--k) {
      D = B = 0;
      C = K[k + 1];
      for(p = 0;p < l[k];p++) {
        D = t[k + 1][C] + t[k + 1][C + 1], D > h[B] ? (t[k][p] = D, z[k][p] = n, C += 2) : (t[k][p] = h[B], z[k][p] = B, ++B)
      }
      K[k] = 0;
      1 === q[k] && b(k)
    }
    m = E;
    j = 0;
    for(s = g.length;j < s;++j) {
      d[g[j].index] = m[j]
    }
    return d
  }
  function ua(a) {
    var c = new (H ? Uint16Array : Array)(a.length), b = [], e = [], f = 0, d, g, h, m;
    d = 0;
    for(g = a.length;d < g;d++) {
      b[a[d]] = (b[a[d]] | 0) + 1
    }
    d = 1;
    for(g = 16;d <= g;d++) {
      e[d] = f, f += b[d] | 0, f > 1 << d && i("overcommitted"), f <<= 1
    }
    65536 > f && i("undercommitted");
    d = 0;
    for(g = a.length;d < g;d++) {
      f = e[a[d]];
      e[a[d]] += 1;
      h = c[d] = 0;
      for(m = a[d];h < m;h++) {
        c[d] = c[d] << 1 | f & 1, f >>>= 1
      }
    }
    return c
  }
  function Da(a, c) {
    this.input = a;
    this.a = new (H ? Uint8Array : Array)(32768);
    this.h = U.j;
    var b = {}, e;
    if((c || !(c = {})) && "number" === typeof c.compressionType) {
      this.h = c.compressionType
    }
    for(e in c) {
      b[e] = c[e]
    }
    b.outputBuffer = this.a;
    this.z = new ma(this.input, b)
  }
  var U = qa;
  Da.prototype.n = function() {
    var a, c, b, e, f, d, g, h = 0;
    g = this.a;
    a = Ea;
    switch(a) {
      case Ea:
        c = Math.LOG2E * Math.log(32768) - 8;
        break;
      default:
        i(Error("invalid compression method"))
    }
    b = c << 4 | a;
    g[h++] = b;
    switch(a) {
      case Ea:
        switch(this.h) {
          case U.NONE:
            f = 0;
            break;
          case U.r:
            f = 1;
            break;
          case U.j:
            f = 2;
            break;
          default:
            i(Error("unsupported compression type"))
        }
        break;
      default:
        i(Error("invalid compression method"))
    }
    e = f << 6 | 0;
    g[h++] = e | 31 - (256 * b + e) % 31;
    d = ba(this.input);
    this.z.b = h;
    g = this.z.n();
    h = g.length;
    H && (g = new Uint8Array(g.buffer), g.length <= h + 4 && (this.a = new Uint8Array(g.length + 4), this.a.set(g), g = this.a), g = g.subarray(0, h + 4));
    g[h++] = d >> 24 & 255;
    g[h++] = d >> 16 & 255;
    g[h++] = d >> 8 & 255;
    g[h++] = d & 255;
    return g
  };
  y("Zlib.Deflate", Da);
  y("Zlib.Deflate.compress", function(a, c) {
    return(new Da(a, c)).n()
  });
  y("Zlib.Deflate.CompressionType", U);
  y("Zlib.Deflate.CompressionType.NONE", U.NONE);
  y("Zlib.Deflate.CompressionType.FIXED", U.r);
  y("Zlib.Deflate.CompressionType.DYNAMIC", U.j);
  function V(a, c) {
    this.k = [];
    this.l = 32768;
    this.e = this.g = this.c = this.q = 0;
    this.input = H ? new Uint8Array(a) : a;
    this.s = !1;
    this.m = Fa;
    this.B = !1;
    if(c || !(c = {})) {
      c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), c.bufferType && (this.m = c.bufferType), c.resize && (this.B = c.resize)
    }
    switch(this.m) {
      case Ga:
        this.b = 32768;
        this.a = new (H ? Uint8Array : Array)(32768 + this.l + 258);
        break;
      case Fa:
        this.b = 0;
        this.a = new (H ? Uint8Array : Array)(this.l);
        this.f = this.J;
        this.t = this.H;
        this.o = this.I;
        break;
      default:
        i(Error("invalid inflate mode"))
    }
  }
  var Ga = 0, Fa = 1, Ha = {D:Ga, C:Fa};
  V.prototype.p = function() {
    for(;!this.s;) {
      var a = X(this, 3);
      a & 1 && (this.s = v);
      a >>>= 1;
      switch(a) {
        case 0:
          var c = this.input, b = this.c, e = this.a, f = this.b, d = r, g = r, h = r, m = e.length, j = r;
          this.e = this.g = 0;
          d = c[b++];
          d === r && i(Error("invalid uncompressed block header: LEN (first byte)"));
          g = d;
          d = c[b++];
          d === r && i(Error("invalid uncompressed block header: LEN (second byte)"));
          g |= d << 8;
          d = c[b++];
          d === r && i(Error("invalid uncompressed block header: NLEN (first byte)"));
          h = d;
          d = c[b++];
          d === r && i(Error("invalid uncompressed block header: NLEN (second byte)"));
          h |= d << 8;
          g === ~h && i(Error("invalid uncompressed block header: length verify"));
          b + g > c.length && i(Error("input buffer is broken"));
          switch(this.m) {
            case Ga:
              for(;f + g > e.length;) {
                j = m - f;
                g -= j;
                if(H) {
                  e.set(c.subarray(b, b + j), f), f += j, b += j
                }else {
                  for(;j--;) {
                    e[f++] = c[b++]
                  }
                }
                this.b = f;
                e = this.f();
                f = this.b
              }
              break;
            case Fa:
              for(;f + g > e.length;) {
                e = this.f({v:2})
              }
              break;
            default:
              i(Error("invalid inflate mode"))
          }
          if(H) {
            e.set(c.subarray(b, b + g), f), f += g, b += g
          }else {
            for(;g--;) {
              e[f++] = c[b++]
            }
          }
          this.c = b;
          this.b = f;
          this.a = e;
          break;
        case 1:
          this.o(Ia, Ja);
          break;
        case 2:
          Ka(this);
          break;
        default:
          i(Error("unknown BTYPE: " + a))
      }
    }
    return this.t()
  };
  var La = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], Za = H ? new Uint16Array(La) : La, $a = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258], ab = H ? new Uint16Array($a) : $a, bb = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0], cb = H ? new Uint8Array(bb) : bb, db = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 
  1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], eb = H ? new Uint16Array(db) : db, fb = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], gb = H ? new Uint8Array(fb) : fb, hb = new (H ? Uint8Array : Array)(288), Y, ib;
  Y = 0;
  for(ib = hb.length;Y < ib;++Y) {
    hb[Y] = 143 >= Y ? 8 : 255 >= Y ? 9 : 279 >= Y ? 7 : 8
  }
  var Ia = S(hb), jb = new (H ? Uint8Array : Array)(30), kb, lb;
  kb = 0;
  for(lb = jb.length;kb < lb;++kb) {
    jb[kb] = 5
  }
  var Ja = S(jb);
  function X(a, c) {
    for(var b = a.g, e = a.e, f = a.input, d = a.c, g;e < c;) {
      g = f[d++], g === r && i(Error("input buffer is broken")), b |= g << e, e += 8
    }
    g = b & (1 << c) - 1;
    a.g = b >>> c;
    a.e = e - c;
    a.c = d;
    return g
  }
  function mb(a, c) {
    for(var b = a.g, e = a.e, f = a.input, d = a.c, g = c[0], h = c[1], m, j, s;e < h;) {
      m = f[d++], m === r && i(Error("input buffer is broken")), b |= m << e, e += 8
    }
    j = g[b & (1 << h) - 1];
    s = j >>> 16;
    a.g = b >> s;
    a.e = e - s;
    a.c = d;
    return j & 65535
  }
  function Ka(a) {
    function c(a, b, c) {
      var d, e, f, g;
      for(g = 0;g < a;) {
        switch(d = mb(this, b), d) {
          case 16:
            for(f = 3 + X(this, 2);f--;) {
              c[g++] = e
            }
            break;
          case 17:
            for(f = 3 + X(this, 3);f--;) {
              c[g++] = 0
            }
            e = 0;
            break;
          case 18:
            for(f = 11 + X(this, 7);f--;) {
              c[g++] = 0
            }
            e = 0;
            break;
          default:
            e = c[g++] = d
        }
      }
      return c
    }
    var b = X(a, 5) + 257, e = X(a, 5) + 1, f = X(a, 4) + 4, d = new (H ? Uint8Array : Array)(Za.length), g, h, m, j;
    for(j = 0;j < f;++j) {
      d[Za[j]] = X(a, 3)
    }
    g = S(d);
    h = new (H ? Uint8Array : Array)(b);
    m = new (H ? Uint8Array : Array)(e);
    a.o(S(c.call(a, b, g, h)), S(c.call(a, e, g, m)))
  }
  V.prototype.o = function(a, c) {
    var b = this.a, e = this.b;
    this.u = a;
    for(var f = b.length - 258, d, g, h, m;256 !== (d = mb(this, a));) {
      if(256 > d) {
        e >= f && (this.b = e, b = this.f(), e = this.b), b[e++] = d
      }else {
        g = d - 257;
        m = ab[g];
        0 < cb[g] && (m += X(this, cb[g]));
        d = mb(this, c);
        h = eb[d];
        0 < gb[d] && (h += X(this, gb[d]));
        e >= f && (this.b = e, b = this.f(), e = this.b);
        for(;m--;) {
          b[e] = b[e++ - h]
        }
      }
    }
    for(;8 <= this.e;) {
      this.e -= 8, this.c--
    }
    this.b = e
  };
  V.prototype.I = function(a, c) {
    var b = this.a, e = this.b;
    this.u = a;
    for(var f = b.length, d, g, h, m;256 !== (d = mb(this, a));) {
      if(256 > d) {
        e >= f && (b = this.f(), f = b.length), b[e++] = d
      }else {
        g = d - 257;
        m = ab[g];
        0 < cb[g] && (m += X(this, cb[g]));
        d = mb(this, c);
        h = eb[d];
        0 < gb[d] && (h += X(this, gb[d]));
        e + m > f && (b = this.f(), f = b.length);
        for(;m--;) {
          b[e] = b[e++ - h]
        }
      }
    }
    for(;8 <= this.e;) {
      this.e -= 8, this.c--
    }
    this.b = e
  };
  V.prototype.f = function() {
    var a = new (H ? Uint8Array : Array)(this.b - 32768), c = this.b - 32768, b, e, f = this.a;
    if(H) {
      a.set(f.subarray(32768, a.length))
    }else {
      b = 0;
      for(e = a.length;b < e;++b) {
        a[b] = f[b + 32768]
      }
    }
    this.k.push(a);
    this.q += a.length;
    if(H) {
      f.set(f.subarray(c, c + 32768))
    }else {
      for(b = 0;32768 > b;++b) {
        f[b] = f[c + b]
      }
    }
    this.b = 32768;
    return f
  };
  V.prototype.J = function(a) {
    var c, b = this.input.length / this.c + 1 | 0, e, f, d, g = this.input, h = this.a;
    a && ("number" === typeof a.v && (b = a.v), "number" === typeof a.F && (b += a.F));
    2 > b ? (e = (g.length - this.c) / this.u[2], d = 258 * (e / 2) | 0, f = d < h.length ? h.length + d : h.length << 1) : f = h.length * b;
    H ? (c = new Uint8Array(f), c.set(h)) : c = h;
    return this.a = c
  };
  V.prototype.t = function() {
    var a = 0, c = this.a, b = this.k, e, f = new (H ? Uint8Array : Array)(this.q + (this.b - 32768)), d, g, h, m;
    if(0 === b.length) {
      return H ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b)
    }
    d = 0;
    for(g = b.length;d < g;++d) {
      e = b[d];
      h = 0;
      for(m = e.length;h < m;++h) {
        f[a++] = e[h]
      }
    }
    d = 32768;
    for(g = this.b;d < g;++d) {
      f[a++] = c[d]
    }
    this.k = [];
    return this.buffer = f
  };
  V.prototype.H = function() {
    var a, c = this.b;
    H ? this.B ? (a = new Uint8Array(c), a.set(this.a.subarray(0, c))) : a = this.a.subarray(0, c) : (this.a.length > c && (this.a.length = c), a = this.a);
    return this.buffer = a
  };
  function nb(a, c) {
    var b, e;
    this.input = a;
    this.c = 0;
    if(c || !(c = {})) {
      c.index && (this.c = c.index), c.verify && (this.M = c.verify)
    }
    b = a[this.c++];
    e = a[this.c++];
    switch(b & 15) {
      case Ea:
        this.method = Ea;
        break;
      default:
        i(Error("unsupported compression method"))
    }
    0 !== ((b << 8) + e) % 31 && i(Error("invalid fcheck flag:" + ((b << 8) + e) % 31));
    e & 32 && i(Error("fdict flag is not supported"));
    this.A = new V(a, {index:this.c, bufferSize:c.bufferSize, bufferType:c.bufferType, resize:c.resize})
  }
  nb.prototype.p = function() {
    var a = this.input, c, b;
    c = this.A.p();
    this.c = this.A.c;
    this.M && (b = (a[this.c++] << 24 | a[this.c++] << 16 | a[this.c++] << 8 | a[this.c++]) >>> 0, b !== ba(c) && i(Error("invalid adler-32 checksum")));
    return c
  };
  y("Zlib.Inflate", nb);
  y("Zlib.Inflate.BufferType", Ha);
  Ha.ADAPTIVE = Ha.C;
  Ha.BLOCK = Ha.D;
  y("Zlib.Inflate.prototype.decompress", nb.prototype.p);
  var ob = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  H && new Uint16Array(ob);
  var pb = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
  H && new Uint16Array(pb);
  var qb = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
  H && new Uint8Array(qb);
  var rb = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
  H && new Uint16Array(rb);
  var sb = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
  H && new Uint8Array(sb);
  var tb = new (H ? Uint8Array : Array)(288), Z, ub;
  Z = 0;
  for(ub = tb.length;Z < ub;++Z) {
    tb[Z] = 143 >= Z ? 8 : 255 >= Z ? 9 : 279 >= Z ? 7 : 8
  }
  S(tb);
  var vb = new (H ? Uint8Array : Array)(30), wb, xb;
  wb = 0;
  for(xb = vb.length;wb < xb;++wb) {
    vb[wb] = 5
  }
  S(vb);
  var Ea = 8
}).call(this);
cc.RESOLUTION_POLICY = {EXACTFIT:0, NOBORDER:1, SHOW_ALL:2, UNKNOWN:3};
cc.Touches = [];
cc.TouchesIntergerDict = {};
cc.EGLView = cc.Class.extend({_delegate:null, _screenSize:null, _designResolutionSize:null, _viewPortRect:null, _viewName:"", _scaleX:1, _scaleY:1, _indexBitsUsed:0, _maxTouches:5, _resolutionPolicy:cc.RESOLUTION_POLICY.UNKNOWN, _initialize:false, _captured:false, _wnd:null, _hDC:null, _hRC:null, _accelerometerKeyHook:null, _supportTouch:false, _contentTranslateLeftTop:null, _menu:null, _wndProc:null, _frameZoomFactor:1, ctor:function() {
  this._viewName = "Cocos2dHTML5";
  this._screenSize = cc.SizeZero();
  this._designResolutionSize = cc.SizeZero();
  this._viewPortRect = cc.RectZero();
  this._delegate = cc.Director.getInstance().getTouchDispatcher();
  this._contentTranslateLeftTop = {left:0, top:0};
  this._hDC = cc.canvas;
  this._hRC = cc.renderContext
}, initialize:function() {
  this._initialize = true;
  this._adjustSize();
  var adjustSize = this._adjustSize.bind(this);
  window.addEventListener("resize", adjustSize, false)
}, _adjustSize:function() {
  var ele = cc.container.parentNode === document.body ? document.documentElement : cc.container.parentNode;
  cc.canvas.width = ele.clientWidth;
  cc.canvas.height = ele.clientHeight;
  if(!("opengl" in sys.capabilities)) {
    cc.renderContext.translate(0, cc.canvas.height)
  }
  var parent = document.querySelector("#" + document["ccConfig"]["tag"]).parentNode;
  if(parent) {
    parent.style.width = cc.canvas.width + "px";
    parent.style.height = cc.canvas.height + "px"
  }
  var body = document.body;
  if(body) {
    body.style.padding = 0 + "px";
    body.style.border = 0 + "px";
    body.style.margin = 0 + "px"
  }
  this._screenSize = cc.size(cc.canvas.width, cc.canvas.height);
  this.setDesignResolutionSize()
}, _adjustSizeKeepCanvasSize:function() {
  if(!("opengl" in sys.capabilities)) {
    cc.renderContext.translate(0, cc.canvas.height)
  }
  this._screenSize = cc.size(cc.canvas.width, cc.canvas.height);
  this.setDesignResolutionSize()
}, end:function() {
}, isOpenGLReady:function() {
  return this._hDC != null && this._hRC != null
}, setFrameZoomFactor:function(zoomFactor) {
  this._frameZoomFactor = zoomFactor;
  this.centerWindow();
  cc.Director.getInstance().setProjection(cc.Director.getInstance().getProjection())
}, swapBuffers:function() {
}, setIMEKeyboardState:function(isOpen) {
  if(isOpen) {
  }else {
  }
}, setContentScaleFactor:function(scaleFactor) {
  cc.Assert(this._resolutionPolicy == cc.RESOLUTION_POLICY.UNKNOWN);
  this._scaleX = this._scaleY = scaleFactor;
  return true
}, setContentTranslateLeftTop:function(offsetLeft, offsetTop) {
  this._contentTranslateLeftTop = {left:offsetLeft, top:offsetTop}
}, getContentTranslateLeftTop:function() {
  return this._contentTranslateLeftTop
}, getFrameSize:function() {
  return this._screenSize
}, setFrameSize:function(width, height) {
  this._designResolutionSize = this._screenSize = cc.size(width, height);
  this.centerWindow();
  cc.Director.getInstance().setProjection(cc.Director.getInstance().getProjection())
}, centerWindow:function() {
}, setAccelerometerKeyHook:function(accelerometerKeyHook) {
  this._accelerometerKeyHook = accelerometerKeyHook
}, getVisibleSize:function() {
  if(this._resolutionPolicy === cc.RESOLUTION_POLICY.NOBORDER) {
    return cc.size(this._screenSize.width / this._scaleX, this._screenSize.height / this._scaleY)
  }else {
    return this._designResolutionSize
  }
}, getVisibleOrigin:function() {
  if(this._resolutionPolicy === cc.RESOLUTION_POLICY.NOBORDER) {
    return cc.p((this._designResolutionSize.width - this._screenSize.width / this._scaleX) / 2, (this._designResolutionSize.height - this._screenSize.height / this._scaleY) / 2)
  }else {
    return cc.p(0, 0)
  }
}, canSetContentScaleFactor:function() {
  return true
}, setDesignResolutionSize:function(width, height, resolutionPolicy) {
  cc.Assert(resolutionPolicy !== cc.RESOLUTION_POLICY.UNKNOWN, "should set resolutionPolicy");
  if(!this._initialize) {
    this.initialize()
  }
  if(width == 0 || height == 0) {
    return
  }
  if(width != null && height != null) {
    this._designResolutionSize = cc.size(width, height)
  }
  if(resolutionPolicy != null) {
    this._resolutionPolicy = resolutionPolicy
  }
  this._scaleX = this._screenSize.width / this._designResolutionSize.width;
  this._scaleY = this._screenSize.height / this._designResolutionSize.height;
  if(this._resolutionPolicy === cc.RESOLUTION_POLICY.NOBORDER) {
    this._scaleX = this._scaleY = Math.max(this._scaleX, this._scaleY)
  }
  if(this._resolutionPolicy === cc.RESOLUTION_POLICY.SHOW_ALL) {
    this._scaleX = this._scaleY = Math.min(this._scaleX, this._scaleY)
  }
  var viewPortW = this._designResolutionSize.width * this._scaleX;
  var viewPortH = this._designResolutionSize.height * this._scaleY;
  this._viewPortRect = cc.rect((this._screenSize.width - viewPortW) / 2, (this._screenSize.height - viewPortH) / 2, viewPortW, viewPortH);
  var diretor = cc.Director.getInstance();
  diretor._winSizeInPoints = this.getDesignResolutionSize();
  if(cc.renderContextType === cc.CANVAS) {
    var width = 0, height = 0;
    if(this._resolutionPolicy === cc.RESOLUTION_POLICY.SHOW_ALL) {
      width = (this._screenSize.width - viewPortW) / 2;
      height = -(this._screenSize.height - viewPortH) / 2;
      var context = cc.renderContext;
      context.beginPath();
      context.rect(width, -viewPortH + height, viewPortW, viewPortH);
      context.clip();
      context.closePath()
    }
    cc.renderContext.translate(width, height);
    cc.renderContext.scale(this._scaleX, this._scaleY)
  }else {
    cc.Director.getInstance()._createStatsLabel();
    cc.Director.getInstance().setGLDefaultValues()
  }
}, getDesignResolutionSize:function() {
  return this._designResolutionSize
}, setTouchDelegate:function(delegate) {
  this._delegate = delegate
}, setViewPortInPoints:function(x, y, w, h) {
  cc.renderContext.viewport(x * this._scaleX * this._frameZoomFactor + this._viewPortRect.origin.x * this._frameZoomFactor, y * this._scaleY * this._frameZoomFactor + this._viewPortRect.origin.y * this._frameZoomFactor, w * this._scaleX * this._frameZoomFactor, h * this._scaleY * this._frameZoomFactor)
}, setScissorInPoints:function(x, y, w, h) {
  cc.renderContext.scissor(x * this._scaleX * this._frameZoomFactor + this._viewPortRect.origin.x * this._frameZoomFactor, y * this._scaleY * this._frameZoomFactor + this._viewPortRect.origin.y * this._frameZoomFactor, w * this._scaleX * this._frameZoomFactor, h * this._scaleY * this._frameZoomFactor)
}, setViewName:function(viewName) {
  if(viewName != null && viewName.length > 0) {
    this._viewName = viewName
  }
}, getViewName:function() {
  return this._viewName
}, getViewPortRect:function() {
  return this._viewPortRect
}, getScaleX:function() {
  return this._scaleX
}, getScaleY:function() {
  return this._scaleY
}, convertToLocationInView:function(tx, ty, relatedPos) {
  return{x:tx - relatedPos.left, y:relatedPos.top + relatedPos.height - ty}
}, handleTouchesBegin:function(num, ids, xs, ys) {
  var arr = [];
  for(var i = 0;i < num;++i) {
    var id = ids[i];
    var x = xs[i];
    var y = ys[i];
    var index = cc.TouchesIntergerDict[id];
    var unusedIndex = 0;
    if(index == null) {
      unusedIndex = this._getUnUsedIndex();
      if(unusedIndex == -1) {
        cc.log("The touches is more than MAX_TOUCHES, nUnusedIndex = " + unusedIndex);
        continue
      }
      var touch = cc.Touches[unusedIndex] = new cc.Touch;
      touch.setTouchInfo(unusedIndex, (x - this._viewPortRect.origin.x) / this._scaleX, (y - this._viewPortRect.origin.y) / this._scaleY);
      var interObj = 0 | unusedIndex;
      cc.TouchesIntergerDict[id] = interObj;
      arr.push(touch)
    }
  }
  if(arr.length == 0) {
    return
  }
  this._delegate.touchesBegan(arr, null)
}, handleTouchesMove:function(num, ids, xs, ys) {
  var arr = [];
  for(var i = 0;i < num;++i) {
    var id = ids[i];
    var x = xs[i];
    var y = ys[i];
    var index = cc.TouchesIntergerDict[id];
    if(index == null) {
      continue
    }
    var touch = cc.Touches[index];
    if(touch) {
      touch.setTouchInfo(index, (x - this._viewPortRect.origin.x) / this._scaleX, (y - this._viewPortRect.origin.y) / this._scaleY);
      arr.push(touch)
    }else {
      return
    }
  }
  if(arr.length == 0) {
    return
  }
  this._delegate.touchesMoved(arr, null)
}, handleTouchesEnd:function(num, ids, xs, ys) {
  var arr = [];
  this.getSetOfTouchesEndOrCancel(arr, num, ids, xs, ys);
  this._delegate.touchesEnded(arr, null)
}, handleTouchesCancel:function(num, ids, xs, ys) {
  var arr = [];
  this.getSetOfTouchesEndOrCancel(arr, num, ids, xs, ys);
  this._delegate.touchesCancelled(arr, null)
}, getSetOfTouchesEndOrCancel:function(arr, num, ids, xs, ys) {
  for(var i = 0;i < num;++i) {
    var id = ids[i];
    var x = xs[i];
    var y = ys[i];
    var index = cc.TouchesIntergerDict[id];
    if(index == null) {
      continue
    }
    var touch = cc.Touches[index];
    if(touch) {
      touch.setTouchInfo(index, (x - this._viewPortRect.origin.x) / this._scaleX, (y - this._viewPortRect.origin.y) / this._scaleY);
      arr.push(touch);
      cc.Touches[index] = null;
      this._removeUsedIndexBit(index);
      delete cc.TouchesIntergerDict[id]
    }else {
      return
    }
  }
}, _getUnUsedIndex:function() {
  var i;
  var temp = this._indexBitsUsed;
  for(i = 0;i < this._maxTouches;i++) {
    if(!(temp & 1)) {
      this._indexBitsUsed |= 1 << i;
      return i
    }
    temp >>= 1
  }
  return-1
}, _removeUsedIndexBit:function(index) {
  if(index < 0 || index >= this._maxTouches) {
    return
  }
  var temp = 1 << index;
  temp = ~temp;
  this._indexBitsUsed &= temp
}, touchesBegan:function(touches, event) {
  var ids = [];
  var xs = [];
  var ys = [];
  var i = 0;
  for(var j = 0;j < touches.length;j++) {
    ids[i] = j;
    xs[i] = touches[j].getLocation().x;
    ys[i] = touches[j].getLocation().y;
    ++i
  }
  this.handleTouchesBegin(i, ids, xs, ys)
}, touchesMoved:function(touches, event) {
  var ids = [];
  var xs = [];
  var ys = [];
  var i = 0;
  for(var j = 0;j < touches.length;j++) {
    ids[i] = j;
    xs[i] = touches[j].getLocation().x;
    ys[i] = touches[j].getLocation().y;
    ++i
  }
  this.handleTouchesMove(i, ids, xs, ys)
}, touchesEnded:function(touches, event) {
  var ids = [];
  var xs = [];
  var ys = [];
  var i = 0;
  for(var j = 0;j < touches.length;j++) {
    ids[i] = j;
    xs[i] = touches[j].getLocation().x;
    ys[i] = touches[j].getLocation().y;
    ++i
  }
  this.handleTouchesEnd(i, ids, xs, ys)
}, touchesCancelled:function(touches, event) {
  var ids = [];
  var xs = [];
  var ys = [];
  var i = 0;
  for(var j = 0;j < touches.length;j++) {
    ids[i] = j;
    xs[i] = touches[j].getLocation().x;
    ys[i] = touches[j].getLocation().y;
    ++i
  }
  this.handleTouchesCancel(i, ids, xs, ys)
}});
cc.EGLView.getInstance = function() {
  if(!this._instance) {
    this._instance = new cc.EGLView
  }
  return this._instance
};
cc.Point = function(_x, _y) {
  this.x = _x || 0;
  this.y = _y || 0
};
cc.PointMake = function(x, y) {
  return new cc.Point(x, y)
};
cc.p = function(x, y) {
  return{x:x, y:y}
};
cc._p = cc.p;
cc.PointZero = function() {
  return cc.p(0, 0)
};
Object.defineProperties(cc, {POINT_ZERO:{get:function() {
  return cc.p(0, 0)
}}, SIZE_ZERO:{get:function() {
  return cc.size(0, 0)
}}, RECT_ZERO:{get:function() {
  return cc.rect(0, 0, 0, 0)
}}});
cc.pointEqualToPoint = function(point1, point2) {
  if(!point1 || !point2) {
    return false
  }
  return point1.x == point2.x && point1.y == point2.y
};
cc.Point.CCPointEqualToPoint = cc.pointEqualToPoint;
cc.Size = function(_width, _height) {
  this.width = _width || 0;
  this.height = _height || 0
};
cc.SizeMake = function(width, height) {
  return cc.size(width, height)
};
cc.size = function(w, h) {
  return{width:w, height:h}
};
cc._size = cc.size;
cc.SizeZero = function() {
  return cc.size(0, 0)
};
cc.sizeEqualToSize = function(size1, size2) {
  if(!size1 || !size2) {
    return false
  }
  return size1.width == size2.width && size1.height == size2.height
};
cc.Size.CCSizeEqualToSize = cc.sizeEqualToSize;
cc.Rect = function(x1, y1, width1, height1) {
  switch(arguments.length) {
    case 0:
      this.origin = cc.p(0, 0);
      this.size = cc.size(0, 0);
      break;
    case 1:
      var oldRect = x1;
      if(!oldRect) {
        this.origin = cc.p(0, 0);
        this.size = cc.size(0, 0)
      }else {
        if(oldRect instanceof cc.Rect) {
          this.origin = cc.p(oldRect.origin.x, oldRect.origin.y);
          this.size = cc.size(oldRect.size.width, oldRect.size.height)
        }else {
          throw"unknown argument type";
        }
      }
      break;
    case 2:
      this.origin = x1 ? cc.p(x1.x, x1.y) : cc.p(0, 0);
      this.size = y1 ? cc.size(y1.width, y1.height) : cc.size(0, 0);
      break;
    case 4:
      this.origin = cc.p(x1 || 0, y1 || 0);
      this.size = cc.size(width1 || 0, height1 || 0);
      break;
    default:
      throw"unknown argument type";break
  }
};
cc.RectMake = function(x, y, width, height) {
  return cc.rect(x, y, width, height)
};
cc.rect = function(x, y, w, h) {
  return new cc.Rect(x, y, w, h)
};
cc._rect = cc.rect;
cc.RectZero = function() {
  return cc.rect(0, 0, 0, 0)
};
cc.rectEqualToRect = function(rect1, rect2) {
  if(!rect1 || !rect2) {
    return false
  }
  return cc.Point.CCPointEqualToPoint(rect1.origin, rect2.origin) && cc.Size.CCSizeEqualToSize(rect1.size, rect2.size)
};
cc.rectContainsRect = function(rect1, rect2) {
  if(!rect1 || !rect2) {
    return false
  }
  if(rect1.origin.x >= rect2.origin.x || rect1.origin.y >= rect2.origin.y || rect1.origin.x + rect1.size.width <= rect2.origin.x + rect2.size.width || rect1.origin.y + rect1.size.height <= rect2.origin.y + rect2.size.height) {
    return false
  }
  return true
};
cc.rectGetMaxX = function(rect) {
  return rect.origin.x + rect.size.width
};
cc.rectGetMidX = function(rect) {
  return rect.origin.x + rect.size.width / 2
};
cc.rectGetMinX = function(rect) {
  return rect.origin.x
};
cc.rectGetMaxY = function(rect) {
  return rect.origin.y + rect.size.height
};
cc.rectGetMidY = function(rect) {
  return rect.origin.y + rect.size.height / 2
};
cc.rectGetMinY = function(rect) {
  return rect.origin.y
};
cc.rectContainsPoint = function(rect, point) {
  var ret = false;
  if(point.x >= cc.Rect.CCRectGetMinX(rect) && point.x <= cc.Rect.CCRectGetMaxX(rect) && point.y >= cc.Rect.CCRectGetMinY(rect) && point.y <= cc.Rect.CCRectGetMaxY(rect)) {
    ret = true
  }
  return ret
};
cc.rectIntersectsRect = function(rectA, rectB) {
  return!(cc.Rect.CCRectGetMaxX(rectA) < cc.Rect.CCRectGetMinX(rectB) || cc.Rect.CCRectGetMaxX(rectB) < cc.Rect.CCRectGetMinX(rectA) || cc.Rect.CCRectGetMaxY(rectA) < cc.Rect.CCRectGetMinY(rectB) || cc.Rect.CCRectGetMaxY(rectB) < cc.Rect.CCRectGetMinY(rectA))
};
cc.rectOverlapsRect = function(rectA, rectB) {
  if(rectA.origin.x + rectA.size.width < rectB.origin.x) {
    return false
  }
  if(rectB.origin.x + rectB.size.width < rectA.origin.x) {
    return false
  }
  if(rectA.origin.y + rectA.size.height < rectB.origin.y) {
    return false
  }
  if(rectB.origin.y + rectB.size.height < rectA.origin.y) {
    return false
  }
  return true
};
cc.rectUnion = function(rectA, rectB) {
  var rect = cc.rect(0, 0, 0, 0);
  rect.origin.x = Math.min(rectA.origin.x, rectB.origin.x);
  rect.origin.y = Math.min(rectA.origin.y, rectB.origin.y);
  rect.size.width = Math.max(rectA.origin.x + rectA.size.width, rectB.origin.x + rectB.size.width) - rect.origin.x;
  rect.size.height = Math.max(rectA.origin.y + rectA.size.height, rectB.origin.y + rectB.size.height) - rect.origin.y;
  return rect
};
cc.rectIntersection = function(rectA, rectB) {
  var intersection = cc.rect(Math.max(cc.Rect.CCRectGetMinX(rectA), cc.Rect.CCRectGetMinX(rectB)), Math.max(cc.Rect.CCRectGetMinY(rectA), cc.Rect.CCRectGetMinY(rectB)), 0, 0);
  intersection.size.width = Math.min(cc.Rect.CCRectGetMaxX(rectA), cc.Rect.CCRectGetMaxX(rectB)) - cc.Rect.CCRectGetMinX(intersection);
  intersection.size.height = Math.min(cc.Rect.CCRectGetMaxY(rectA), cc.Rect.CCRectGetMaxY(rectB)) - cc.Rect.CCRectGetMinY(intersection);
  return intersection
};
cc.Rect.prototype.getX = function() {
  return this.origin.x
};
cc.Rect.prototype.setX = function(x) {
  this.origin.x = x
};
cc.Rect.prototype.getY = function() {
  return this.origin.y
};
cc.Rect.prototype.setY = function(y) {
  this.origin.y = y
};
cc.Rect.prototype.getWidth = function() {
  return this.size.width
};
cc.Rect.prototype.setWidth = function(w) {
  this.size.width = w
};
cc.Rect.prototype.getHeight = function() {
  return this.size.height
};
cc.Rect.prototype.setHeight = function(h) {
  this.size.height = h
};
Object.defineProperties(cc.Rect.prototype, {"x":{get:function() {
  return this.getX()
}, set:function(newValue) {
  this.setX(newValue)
}, enumerable:true, configurable:true}, "y":{get:function() {
  return this.getY()
}, set:function(newValue) {
  this.setY(newValue)
}, enumerable:true, configurable:true}, "width":{get:function() {
  return this.getWidth()
}, set:function(newValue) {
  this.setWidth(newValue)
}, enumerable:true, configurable:true}, "height":{get:function() {
  return this.getHeight()
}, set:function(newValue) {
  this.setHeight(newValue)
}, enumerable:true, configurable:true}});
cc.Rect.CCRectEqualToRect = cc.rectEqualToRect;
cc.Rect.CCRectContainsRect = cc.rectContainsRect;
cc.Rect.CCRectGetMaxX = cc.rectGetMaxX;
cc.Rect.CCRectGetMidX = cc.rectGetMidX;
cc.Rect.CCRectGetMinX = cc.rectGetMinX;
cc.Rect.CCRectGetMaxY = cc.rectGetMaxY;
cc.Rect.CCRectGetMidY = cc.rectGetMidY;
cc.Rect.CCRectGetMinY = cc.rectGetMinY;
cc.Rect.CCRectContainsPoint = cc.rectContainsPoint;
cc.Rect.CCRectIntersectsRect = cc.rectIntersectsRect;
cc.Rect.CCRectUnion = cc.rectUnion;
cc.Rect.CCRectIntersection = cc.rectIntersection;
var sys = sys || {};
try {
  sys.localStorage = window.localStorage
}catch(e) {
  if(e.name === "SECURITY_ERR") {
    cc.log("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option")
  }
  sys.localStorage = function() {
  }
}
Object.defineProperties(sys, {"capabilities":{get:function() {
  var capabilities = {"canvas":true};
  if(cc.Browser.supportWebGL) {
    capabilities["opengl"] = true
  }
  if("ontouchstart" in document.documentElement) {
    capabilities["touches"] = true
  }else {
    if("onmouseup" in document.documentElement) {
      capabilities["mouse"] = true
    }
  }
  if("onkeyup" in document.documentElement) {
    capabilities["keyboard"] = true
  }
  if(window.DeviceMotionEvent || window.DeviceOrientationEvent) {
    capabilities["accelerometer"] = true
  }
  return capabilities
}, enumerable:true, configurable:true}, "os":{get:function() {
  var iOS = navigator.userAgent.match(/(iPad|iPhone|iPod)/i) ? true : false;
  var isAndroid = navigator.userAgent.match(/android/i) || navigator.platform.match(/android/i) ? true : false;
  var OSName = navigator.appVersion;
  if(navigator.appVersion.indexOf("Win") != -1) {
    OSName = "Windows"
  }else {
    if(navigator.appVersion.indexOf("Mac") != -1) {
      OSName = "OS X"
    }else {
      if(navigator.appVersion.indexOf("X11") != -1) {
        OSName = "UNIX"
      }else {
        if(navigator.appVersion.indexOf("Linux") != -1) {
          OSName = "Linux"
        }else {
          if(iOS) {
            OSName = "iOS"
          }else {
            if(isAndroid) {
              OSName = "Android"
            }
          }
        }
      }
    }
  }
  return OSName
}, enumerable:true, configurable:true}, "platform":{get:function() {
  return"browser"
}, enumerable:true, configurable:true}, "version":{get:function() {
  return cc.ENGINE_VERSION
}, enumerable:true, configurable:true}});
sys.garbageCollect = function() {
};
sys.dumpRoot = function() {
};
sys.restartVM = function() {
};
cc.ENGINE_VERSION = "Cocos2d-html5-v2.1.3";
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
cc.DIRECTOR_FPS_INTERVAL = 0.5;
cc.COCOSNODE_RENDER_SUBPIXEL = 1;
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 1;
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
cc.TEXTURE_ATLAS_USE_VAO = 0;
cc.TEXTURE_NPOT_SUPPORT = 0;
cc.RETINA_DISPLAY_SUPPORT = 1;
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
cc.USE_LA88_LABELS = 1;
cc.SPRITE_DEBUG_DRAW = 0;
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
cc.LABELBMFONT_DEBUG_DRAW = 0;
cc.LABELATLAS_DEBUG_DRAW = 0;
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
cc.config = {"platform":sys.platform};
cc.dumpConfig = function() {
  for(var i in sys) {
    cc.log(i + " = " + sys[i])
  }
};
cc.ENABLE_GL_STATE_CACHE = 1;
cc.FMT_JPG = 0;
cc.FMT_PNG = 1;
cc.FMT_TIFF = 2;
cc.FMT_RAWDATA = 3;
cc.FMT_UNKNOWN = 4;
cc.ALIGN_CENTER = 51;
cc.ALIGN_TOP = 19;
cc.ALIGN_TOP_RIGHT = 18;
cc.ALIGN_RIGHT = 50;
cc.ALIGN_BOTTOM_RIGHT = 34;
cc.ALIGN_BOTTOM = 35;
cc.ALIGN_BOTTOM_LEFT = 33;
cc.ALIGN_LEFT = 49;
cc.ALIGN_TOP_LEFT = 17;
cc.RGB_PREMULTIPLY_APLHA = function(vr, vg, vb, va) {
  return vr * (va + 1) >> 8 | vg * (va + 1) >> 8 << 8 | vb * (va + 1) >> 8 << 16 | va << 24
};
cc.tImageSource = function(data, size, offset) {
  this.data = data;
  this.size = size || 0;
  this.offset = offset || 0
};
cc.pngReadCallback = function(png_ptr, data, length) {
  var isource = new cc.tImageSource;
  isource = cc.png_get_io_ptr(png_ptr);
  if(isource.offset + length <= isource.size) {
    cc.memcpy(data, isource.data + isource.offset, length);
    isource.offset += length
  }else {
    cc.png_error(png_ptr, "pngReaderCallback failed")
  }
};
cc.getImageFormatByData = function(imgData) {
  if(imgData.length > 8) {
    if(imgData[0] == 137 && imgData[1] == 80 && imgData[2] == 78 && imgData[3] == 71 && imgData[4] == 13 && imgData[5] == 10 && imgData[6] == 26 && imgData[7] == 10) {
      return cc.FMT_PNG
    }
  }
  if(imgData.length > 2) {
    if(imgData[0] == 73 && imgData[1] == 73 || imgData[0] == 77 && imgData[1] == 77 || imgData[0] == 255 && imgData[1] == 216) {
      return cc.FMT_TIFF
    }
  }
  return cc.FMT_UNKNOWN
};
cc.Image = cc.Class.extend({_width:0, _height:0, _bitsPerComponent:0, _data:0, _hasAlpha:false, _preMulti:false, initWithImageFile:function(strPath, imageType) {
  var data = cc.FileUtils.getInstance().getFileData(strPath, "rb");
  var size = data.length;
  if(data != null && data.length > 0) {
    return this.initWithImageData(data, data.length, imageType)
  }
  return false
}, initWithImageFileThreadSafe:function(fullpath, imageType) {
  return this.initWithImageFile(fullpath, imageType)
}, initWithImageData:function(data, dataLen, eFmt, width, height, bitsPerComponent) {
  bitsPerComponent = bitsPerComponent || 8;
  width = width || 0;
  height = height || 0;
  eFmt = eFmt || cc.FMT_UNKNOWN;
  if(!data || dataLen <= 0) {
    return false
  }
  if(cc.FMT_PNG == eFmt) {
    return this._initWithPngData(data, dataLen)
  }else {
    if(cc.FMT_JPG == eFmt) {
      return this._initWithJpgData(data, dataLen)
    }else {
      if(cc.FMT_TIFF == eFmt) {
        return this._initWithTiffData(data, dataLen)
      }else {
        if(cc.FMT_RAWDATA == eFmt) {
          return this._initWithRawData(data, dataLen, width, height, bitsPerComponent)
        }else {
          if(dataLen > 8) {
            if(data[0] == 137 && data[1] == 80 && data[2] == 78 && data[3] == 71 && data[4] == 13 && data[5] == 10 && data[6] == 26 && data[7] == 10) {
              return this._initWithPngData(data, dataLen)
            }
          }
          if(dataLen > 2) {
            if(data[0] == 73 && data[1] == 73 || data[0] == 77 && data[1] == 77) {
              return this._initWithTiffData(data, dataLen)
            }else {
              if(data[0] == 255 && data[1] == 216) {
                return this._initWithTiffData(data, dataLen)
              }
            }
          }
        }
      }
    }
  }
  return false
}, getData:function() {
  return this._data
}, getDataLen:function() {
  return this._width * this._height
}, hasAlpha:function() {
  return this._hasAlpha
}, isPremultipliedAlpha:function() {
  return this._preMulti
}, getWidth:function() {
  return this._width
}, getHeight:function() {
  return this._height
}, getBitsPerComponent:function() {
  return this._bitsPerComponent
}, saveToFile:function(filePath, isToRGB) {
  cc.log("doesn't support saveToFile on Cocos2d-Html5");
  return false
}, _initWithJpgData:function(data, dataLen) {
  return false
}, _initWithPngData:function(data, datalen) {
  return false
}, _initWithTiffData:function(data, dataLen) {
  return false
}, _initWithRawData:function(data, datalen, width, height, bitsPerComponent) {
  return false
}, _saveImageToPNG:function(filePath, isToRGB) {
  return false
}, _saveImageToJPG:function(filePath) {
  return false
}, initWithString:function(text, width, height, eAlignMask, fontName, size) {
  return false
}});
cc.kmScalar = Number;
cc.kmBool = Number;
cc.kmEnum = Number;
cc.KM_FALSE = 0;
cc.KM_TRUE = 1;
cc.kmPI = 3.141592;
cc.kmPIOver180 = 0.017453;
cc.kmPIUnder180 = 57.295779;
cc.kmEpsilon = 1 / 64;
cc.kmSQR = function(s) {
  return s * s
};
cc.kmDegreesToRadians = function(degrees) {
  return degrees * cc.kmPIOver180
};
cc.kmRadiansToDegrees = function(radians) {
  return radians * cc.kmPIUnder180
};
cc.kmMin = function(lhs, rhs) {
  return lhs < rhs ? lhs : rhs
};
cc.kmMax = function(lhs, rhs) {
  return lhs > rhs ? lhs : rhs
};
cc.kmAlmostEqual = function(lhs, rhs) {
  return lhs + cc.kmEpsilon > rhs && lhs - cc.kmEpsilon < rhs
};
cc.kmVec2 = function(x, y) {
  this.x = x || 0;
  this.y = y || 0
};
cc.kmVec2Fill = function(pOut, x, y) {
  pOut.x = x;
  pOut.y = y;
  return pOut
};
cc.kmVec2Length = function(pIn) {
  return Math.sqrt(cc.kmSQR(pIn.x) + cc.kmSQR(pIn.y))
};
cc.kmVec2LengthSq = function(pIn) {
  return cc.kmSQR(pIn.x) + cc.kmSQR(pIn.y)
};
cc.kmVec2Normalize = function(pOut, pIn) {
  var l = 1 / cc.kmVec2Length(pIn);
  var v = new cc.kmVec2;
  v.x = pIn.x * l;
  v.y = pIn.y * l;
  pOut.x = v.x;
  pOut.y = v.y;
  return pOut
};
cc.kmVec2Add = function(pOut, pV1, pV2) {
  pOut.x = pV1.x + pV2.x;
  pOut.y = pV1.y + pV2.y;
  return pOut
};
cc.kmVec2Dot = function(pV1, pV2) {
  return pV1.x * pV2.x + pV1.y * pV2.y
};
cc.kmVec2Subtract = function(pOut, pV1, pV2) {
  pOut.x = pV1.x - pV2.x;
  pOut.y = pV1.y - pV2.y;
  return pOut
};
cc.kmVec2Transform = function(pOut, pV, pM) {
  var v = new cc.kmVec2;
  v.x = pV.x * pM.mat[0] + pV.y * pM.mat[3] + pM.mat[6];
  v.y = pV.x * pM.mat[1] + pV.y * pM.mat[4] + pM.mat[7];
  pOut.x = v.x;
  pOut.y = v.y;
  return pOut
};
cc.kmVec2TransformCoord = function(pOut, pV, pM) {
  return null
};
cc.kmVec2Scale = function(pOut, pIn, s) {
  pOut.x = pIn.x * s;
  pOut.y = pIn.y * s;
  return pOut
};
cc.kmVec2AreEqual = function(p1, p2) {
  return p1.x < p2.x + cc.kmEpsilon && p1.x > p2.x - cc.kmEpsilon && p1.y < p2.y + cc.kmEpsilon && p1.y > p2.y - cc.kmEpsilon
};
cc.kmVec3 = function(x, y, z) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0
};
cc.kmVec3Fill = function(pOut, x, y, z) {
  if(!pOut) {
    return new cc.kmVec3(x, y, z)
  }
  pOut.x = x;
  pOut.y = y;
  pOut.z = z;
  return pOut
};
cc.kmVec3Length = function(pIn) {
  return Math.sqrt(cc.kmSQR(pIn.x) + cc.kmSQR(pIn.y) + cc.kmSQR(pIn.z))
};
cc.kmVec3LengthSq = function(pIn) {
  return cc.kmSQR(pIn.x) + cc.kmSQR(pIn.y) + cc.kmSQR(pIn.z)
};
cc.kmVec3Normalize = function(pOut, pIn) {
  var l = 1 / cc.kmVec3Length(pIn);
  pOut.x = pIn.x * l;
  pOut.y = pIn.y * l;
  pOut.z = pIn.z * l;
  return pOut
};
cc.kmVec3Cross = function(pOut, pV1, pV2) {
  pOut.x = pV1.y * pV2.z - pV1.z * pV2.y;
  pOut.y = pV1.z * pV2.x - pV1.x * pV2.z;
  pOut.z = pV1.x * pV2.y - pV1.y * pV2.x;
  return pOut
};
cc.kmVec3Dot = function(pV1, pV2) {
  return pV1.x * pV2.x + pV1.y * pV2.y + pV1.z * pV2.z
};
cc.kmVec3Add = function(pOut, pV1, pV2) {
  pOut.x = pV1.x + pV2.x;
  pOut.y = pV1.y + pV2.y;
  pOut.z = pV1.z + pV2.z;
  return pOut
};
cc.kmVec3Subtract = function(pOut, pV1, pV2) {
  pOut.x = pV1.x - pV2.x;
  pOut.y = pV1.y - pV2.y;
  pOut.z = pV1.z - pV2.z;
  return pOut
};
cc.kmVec3Transform = function(pOut, pV, pM) {
  pOut.x = pV.x * pM.mat[0] + pV.y * pM.mat[4] + pV.z * pM.mat[8] + pM.mat[12];
  pOut.y = pV.x * pM.mat[1] + pV.y * pM.mat[5] + pV.z * pM.mat[9] + pM.mat[13];
  pOut.z = pV.x * pM.mat[2] + pV.y * pM.mat[6] + pV.z * pM.mat[10] + pM.mat[14];
  return pOut
};
cc.kmVec3TransformNormal = function(pOut, pV, pM) {
  pOut.x = pV.x * pM.mat[0] + pV.y * pM.mat[4] + pV.z * pM.mat[8];
  pOut.y = pV.x * pM.mat[1] + pV.y * pM.mat[5] + pV.z * pM.mat[9];
  pOut.z = pV.x * pM.mat[2] + pV.y * pM.mat[6] + pV.z * pM.mat[10];
  return pOut
};
cc.kmVec3TransformCoord = function(pOut, pV, pM) {
  var v = new cc.kmVec4;
  var inV = new cc.kmVec4;
  cc.kmVec4Fill(inV, pV.x, pV.y, pV.z, 1);
  cc.kmVec4Transform(v, inV, pM);
  pOut.x = v.x / v.w;
  pOut.y = v.y / v.w;
  pOut.z = v.z / v.w;
  return pOut
};
cc.kmVec3Scale = function(pOut, pIn, s) {
  pOut.x = pIn.x * s;
  pOut.y = pIn.y * s;
  pOut.z = pIn.z * s;
  return pOut
};
cc.kmVec3AreEqual = function(p1, p2) {
  if(p1.x < p2.x + cc.kmEpsilon && p1.x > p2.x - cc.kmEpsilon && p1.y < p2.y + cc.kmEpsilon && p1.y > p2.y - cc.kmEpsilon && p1.z < p2.z + cc.kmEpsilon && p1.z > p2.z - cc.kmEpsilon) {
    return 1
  }
  return 0
};
cc.kmVec3InverseTransform = function(pOut, pVect, pM) {
  var v1 = new cc.kmVec3(pVect.x - pM.mat[12], pVect.y - pM.mat[13], pVect.z - pM.mat[14]);
  pOut.x = v1.x * pM.mat[0] + v1.y * pM.mat[1] + v1.z * pM.mat[2];
  pOut.y = v1.x * pM.mat[4] + v1.y * pM.mat[5] + v1.z * pM.mat[6];
  pOut.z = v1.x * pM.mat[8] + v1.y * pM.mat[9] + v1.z * pM.mat[10];
  return pOut
};
cc.kmVec3InverseTransformNormal = function(pOut, pVect, pM) {
  pOut.x = pVect.x * pM.mat[0] + pVect.y * pM.mat[1] + pVect.z * pM.mat[2];
  pOut.y = pVect.x * pM.mat[4] + pVect.y * pM.mat[5] + pVect.z * pM.mat[6];
  pOut.z = pVect.x * pM.mat[8] + pVect.y * pM.mat[9] + pVect.z * pM.mat[10];
  return pOut
};
cc.kmVec3Assign = function(pOut, pIn) {
  if(pOut == pIn) {
    return pOut
  }
  pOut.x = pIn.x;
  pOut.y = pIn.y;
  pOut.z = pIn.z;
  return pOut
};
cc.kmVec3Zero = function(pOut) {
  pOut.x = 0;
  pOut.y = 0;
  pOut.z = 0;
  return pOut
};
cc.kmVec3ToTypeArray = function(vecValue) {
  if(!vecValue) {
    return null
  }
  var tyArr = new Float32Array(3);
  tyArr[0] = vecValue.x;
  tyArr[1] = vecValue.y;
  tyArr[2] = vecValue.z;
  return tyArr
};
cc.kmVec4 = function(x, y, z, w) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = w || 0
};
cc.kmVec4Fill = function(outVec, x, y, z, w) {
  outVec.x = x;
  outVec.y = y;
  outVec.z = z;
  outVec.w = w;
  return outVec
};
cc.kmVec4Add = function(outVec, pV1, pV2) {
  outVec.x = pV1.x + pV2.x;
  outVec.y = pV1.y + pV2.y;
  outVec.z = pV1.z + pV2.z;
  outVec.w = pV1.w + pV2.w;
  return outVec
};
cc.kmVec4Dot = function(vec1, vec2) {
  return vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z + vec1.w * vec2.w
};
cc.kmVec4Length = function(inVec) {
  return Math.sqrt(cc.kmSQR(inVec.x) + cc.kmSQR(inVec.y) + cc.kmSQR(inVec.z) + cc.kmSQR(inVec.w))
};
cc.kmVec4LengthSq = function(inVec) {
  return cc.kmSQR(inVec.x) + cc.kmSQR(inVec.y) + cc.kmSQR(inVec.z) + cc.kmSQR(inVec.w)
};
cc.kmVec4Lerp = function(outVec, pV1, pV2, t) {
  return outVec
};
cc.kmVec4Normalize = function(outVec, inVec) {
  var l = 1 / cc.kmVec4Length(inVec);
  outVec.x *= l;
  outVec.y *= l;
  outVec.z *= l;
  outVec.w *= l;
  return outVec
};
cc.kmVec4Scale = function(outVec, inVec, scale) {
  cc.kmVec4Normalize(outVec, inVec);
  outVec.x *= scale;
  outVec.y *= scale;
  outVec.z *= scale;
  outVec.w *= scale;
  return outVec
};
cc.kmVec4Subtract = function(outVec, vec1, vec2) {
  outVec.x = vec1.x - vec2.x;
  outVec.y = vec1.y - vec2.y;
  outVec.z = vec1.z - vec2.z;
  outVec.w = vec1.w - vec2.w;
  return outVec
};
cc.kmVec4Transform = function(outVec, vec, mat4Obj) {
  outVec.x = vec.x * mat4Obj.mat[0] + vec.y * mat4Obj.mat[4] + vec.z * mat4Obj.mat[8] + vec.w * mat4Obj.mat[12];
  outVec.y = vec.x * mat4Obj.mat[1] + vec.y * mat4Obj.mat[5] + vec.z * mat4Obj.mat[9] + vec.w * mat4Obj.mat[13];
  outVec.z = vec.x * mat4Obj.mat[2] + vec.y * mat4Obj.mat[6] + vec.z * mat4Obj.mat[10] + vec.w * mat4Obj.mat[14];
  outVec.w = vec.x * mat4Obj.mat[3] + vec.y * mat4Obj.mat[7] + vec.z * mat4Obj.mat[11] + vec.w * mat4Obj.mat[15];
  return outVec
};
cc.kmVec4TransformArray = function(outVec, outStride, vecObj, stride, mat4Obj, count) {
  var i = 0;
  while(i < count) {
    var currIn = vecObj + i * stride;
    var out = outVec + i * outStride;
    cc.kmVec4Transform(out, currIn, mat4Obj);
    ++i
  }
  return outVec
};
cc.kmVec4AreEqual = function(vec1, vec2) {
  return vec1.x < vec2.x + cc.kmEpsilon && vec1.x > vec2.x - cc.kmEpsilon && vec1.y < vec2.y + cc.kmEpsilon && vec1.y > vec2.y - cc.kmEpsilon && vec1.z < vec2.z + cc.kmEpsilon && vec1.z > vec2.z - cc.kmEpsilon && vec1.w < vec2.w + cc.kmEpsilon && vec1.w > vec2.w - cc.kmEpsilon
};
cc.kmVec4Assign = function(destVec, srcVec) {
  cc.Assert(destVec != srcVec, "same object!");
  destVec.x = srcVec.x;
  destVec.y = srcVec.y;
  destVec.z = srcVec.z;
  destVec.w = srcVec.w;
  return destVec
};
cc.kmVec4ToTypeArray = function(vecValue) {
  if(!vecValue) {
    return null
  }
  var tyArr = new Float32Array(4);
  tyArr[0] = vecValue.x;
  tyArr[1] = vecValue.y;
  tyArr[2] = vecValue.z;
  tyArr[3] = vecValue.w;
  return tyArr
};
cc.kmRay2 = function(start, dir) {
  this.start = start || new cc.kmVec2;
  this.start = start || new cc.kmVec2
};
cc.kmRay2Fill = function(ray, px, py, vx, vy) {
  ray.start.x = px;
  ray.start.y = py;
  ray.dir.x = vx;
  ray.dir.y = vy
};
cc.kmRay2IntersectLineSegment = function(ray, p1, p2, intersection) {
  var x1 = ray.start.x;
  var y1 = ray.start.y;
  var x2 = ray.start.x + ray.dir.x;
  var y2 = ray.start.y + ray.dir.y;
  var x3 = p1.x;
  var y3 = p1.y;
  var x4 = p2.x;
  var y4 = p2.y;
  var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
  var ua, x, y;
  if(denom > -cc.kmEpsilon && denom < cc.kmEpsilon) {
    return cc.KM_FALSE
  }
  ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
  x = x1 + ua * (x2 - x1);
  y = y1 + ua * (y2 - y1);
  if(x < cc.kmMin(p1.x, p2.x) - cc.kmEpsilon || x > cc.kmMax(p1.x, p2.x) + cc.kmEpsilon || y < cc.kmMin(p1.y, p2.y) - cc.kmEpsilon || y > cc.kmMax(p1.y, p2.y) + cc.kmEpsilon) {
    return cc.KM_FALSE
  }
  if(x < cc.kmMin(x1, x2) - cc.kmEpsilon || x > cc.kmMax(x1, x2) + cc.kmEpsilon || y < cc.kmMin(y1, y2) - cc.kmEpsilon || y > cc.kmMax(y1, y2) + cc.kmEpsilon) {
    return cc.KM_FALSE
  }
  intersection.x = x;
  intersection.y = y;
  return cc.KM_TRUE
};
cc.calculate_line_normal = function(p1, p2, normal_out) {
  var tmp = new cc.kmVec2;
  cc.kmVec2Subtract(tmp, p2, p1);
  normal_out.x = -tmp.y;
  normal_out.y = tmp.x;
  cc.kmVec2Normalize(normal_out, normal_out)
};
cc.kmRay2IntersectTriangle = function(ray, p1, p2, p3, intersection, normal_out) {
  var intersect = new cc.kmVec2;
  var final_intersect = new cc.kmVec2;
  var normal = new cc.kmVec2;
  var distance = 1E4;
  var intersected = cc.KM_FALSE;
  var tmp, this_distance;
  if(cc.kmRay2IntersectLineSegment(ray, p1, p2, intersect)) {
    tmp = new cc.kmVec2;
    intersected = cc.KM_TRUE;
    this_distance = cc.kmVec2Length(cc.kmVec2Subtract(tmp, intersect, ray.start));
    if(this_distance < distance) {
      final_intersect.x = intersect.x;
      final_intersect.y = intersect.y;
      distance = this_distance;
      cc.calculate_line_normal(p1, p2, normal)
    }
  }
  if(cc.kmRay2IntersectLineSegment(ray, p2, p3, intersect)) {
    tmp = new cc.kmVec2;
    intersected = cc.KM_TRUE;
    this_distance = cc.kmVec2Length(cc.kmVec2Subtract(tmp, intersect, ray.start));
    if(this_distance < distance) {
      final_intersect.x = intersect.x;
      final_intersect.y = intersect.y;
      distance = this_distance;
      cc.calculate_line_normal(p2, p3, normal)
    }
  }
  if(cc.kmRay2IntersectLineSegment(ray, p3, p1, intersect)) {
    tmp = new cc.kmVec2;
    intersected = cc.KM_TRUE;
    this_distance = cc.kmVec2Length(cc.kmVec2Subtract(tmp, intersect, ray.start));
    if(this_distance < distance) {
      final_intersect.x = intersect.x;
      final_intersect.y = intersect.y;
      distance = this_distance;
      cc.calculate_line_normal(p3, p1, normal)
    }
  }
  if(intersected) {
    intersection.x = final_intersect.x;
    intersection.y = final_intersect.y;
    if(normal_out) {
      normal_out.x = normal.x;
      normal_out.y = normal.y
    }
  }
  return intersected
};
cc.kmRay2IntersectCircle = function(ray, centre, radius, intersection) {
  cc.Assert(0, "Not implemented");
  return 0
};
var Float32Array = Float32Array || Array;
cc.kmMat3 = function() {
  this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0])
};
cc.kmMat3Fill = function(pOut, pMat) {
  for(var i = 0;i < 9;i++) {
    pOut.mat[i] = pMat
  }
  return pOut
};
cc.kmMat3Adjugate = function(pOut, pIn) {
  pOut.mat[0] = pIn.mat[4] * pIn.mat[8] - pIn.mat[5] * pIn.mat[7];
  pOut.mat[1] = pIn.mat[2] * pIn.mat[7] - pIn.mat[1] * pIn.mat[8];
  pOut.mat[2] = pIn.mat[1] * pIn.mat[5] - pIn.mat[2] * pIn.mat[4];
  pOut.mat[3] = pIn.mat[5] * pIn.mat[6] - pIn.mat[3] * pIn.mat[8];
  pOut.mat[4] = pIn.mat[0] * pIn.mat[8] - pIn.mat[2] * pIn.mat[6];
  pOut.mat[5] = pIn.mat[2] * pIn.mat[3] - pIn.mat[0] * pIn.mat[5];
  pOut.mat[6] = pIn.mat[3] * pIn.mat[7] - pIn.mat[4] * pIn.mat[6];
  pOut.mat[8] = pIn.mat[0] * pIn.mat[4] - pIn.mat[1] * pIn.mat[3];
  return pOut
};
cc.kmMat3Identity = function(pOut) {
  pOut.mat[1] = pOut.mat[2] = pOut.mat[3] = pOut.mat[5] = pOut.mat[6] = pOut.mat[7] = 0;
  pOut.mat[0] = pOut.mat[4] = pOut.mat[8] = 1;
  return pOut
};
cc.kmMat3Inverse = function(pOut, pDeterminate, pM) {
  var detInv;
  var adjugate = new cc.kmMat3;
  if(pDeterminate === 0) {
    return null
  }
  detInv = 1 / pDeterminate;
  cc.kmMat3Adjugate(adjugate, pM);
  cc.kmMat3ScalarMultiply(pOut, adjugate, detInv);
  return pOut
};
cc.kmMat3._identity = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
cc.kmMat3IsIdentity = function(pIn) {
  for(var i = 0;i < 9;i++) {
    if(cc.kmMat3._identity[i] !== pIn.mat[i]) {
      return false
    }
  }
  return true
};
cc.kmMat3Transpose = function(pOut, pIn) {
  var z, x;
  for(z = 0;z < 3;++z) {
    for(x = 0;x < 3;++x) {
      pOut.mat[z * 3 + x] = pIn.mat[x * 3 + z]
    }
  }
  return pOut
};
cc.kmMat3Determinant = function(pIn) {
  var output;
  output = pIn.mat[0] * pIn.mat[4] * pIn.mat[8] + pIn.mat[1] * pIn.mat[5] * pIn.mat[6] + pIn.mat[2] * pIn.mat[3] * pIn.mat[7];
  output -= pIn.mat[2] * pIn.mat[4] * pIn.mat[6] + pIn.mat[0] * pIn.mat[5] * pIn.mat[7] + pIn.mat[1] * pIn.mat[3] * pIn.mat[8];
  return output
};
cc.kmMat3Multiply = function(pOut, pM1, pM2) {
  var m1 = pM1.mat, m2 = pM2.mat;
  pOut.mat[0] = m1[0] * m2[0] + m1[3] * m2[1] + m1[6] * m2[2];
  pOut.mat[1] = m1[1] * m2[0] + m1[4] * m2[1] + m1[7] * m2[2];
  pOut.mat[2] = m1[2] * m2[0] + m1[5] * m2[1] + m1[8] * m2[2];
  pOut.mat[3] = m1[0] * m2[3] + m1[3] * m2[4] + m1[6] * m2[5];
  pOut.mat[4] = m1[1] * m2[3] + m1[4] * m2[4] + m1[7] * m2[5];
  pOut.mat[5] = m1[2] * m2[3] + m1[5] * m2[4] + m1[8] * m2[5];
  pOut.mat[6] = m1[0] * m2[6] + m1[3] * m2[7] + m1[6] * m2[8];
  pOut.mat[7] = m1[1] * m2[6] + m1[4] * m2[7] + m1[7] * m2[8];
  pOut.mat[8] = m1[2] * m2[6] + m1[5] * m2[7] + m1[8] * m2[8];
  return pOut
};
cc.kmMat3ScalarMultiply = function(pOut, pM, pFactor) {
  for(var i = 0;i < 9;i++) {
    pOut.mat[i] = pM.mat[i] * pFactor
  }
  return pOut
};
cc.kmMat3RotationAxisAngle = function(pOut, axis, radians) {
  var rcos = Math.cos(radians);
  var rsin = Math.sin(radians);
  pOut.mat[0] = rcos + axis.x * axis.x * (1 - rcos);
  pOut.mat[1] = axis.z * rsin + axis.y * axis.x * (1 - rcos);
  pOut.mat[2] = -axis.y * rsin + axis.z * axis.x * (1 - rcos);
  pOut.mat[3] = -axis.z * rsin + axis.x * axis.y * (1 - rcos);
  pOut.mat[4] = rcos + axis.y * axis.y * (1 - rcos);
  pOut.mat[5] = axis.x * rsin + axis.z * axis.y * (1 - rcos);
  pOut.mat[6] = axis.y * rsin + axis.x * axis.z * (1 - rcos);
  pOut.mat[7] = -axis.x * rsin + axis.y * axis.z * (1 - rcos);
  pOut.mat[8] = rcos + axis.z * axis.z * (1 - rcos);
  return pOut
};
cc.kmMat3Assign = function(pOut, pIn) {
  cc.Assert(pOut != pIn, "Is same object");
  for(var i = 0;i < 9;i++) {
    pOut.mat[i] = pIn.mat[i]
  }
  return pOut
};
cc.kmMat3AreEqual = function(pMat1, pMat2) {
  if(pMat1 == pMat2) {
    return true
  }
  for(var i = 0;i < 9;++i) {
    if(!(pMat1.mat[i] + cc.kmEpsilon > pMat2.mat[i] && pMat1.mat[i] - cc.kmEpsilon < pMat2.mat[i])) {
      return false
    }
  }
  return true
};
cc.kmMat3RotationX = function(pOut, radians) {
  pOut.mat[0] = 1;
  pOut.mat[1] = 0;
  pOut.mat[2] = 0;
  pOut.mat[3] = 0;
  pOut.mat[4] = Math.cos(radians);
  pOut.mat[5] = Math.sin(radians);
  pOut.mat[6] = 0;
  pOut.mat[7] = -Math.sin(radians);
  pOut.mat[8] = Math.cos(radians);
  return pOut
};
cc.kmMat3RotationY = function(pOut, radians) {
  pOut.mat[0] = Math.cos(radians);
  pOut.mat[1] = 0;
  pOut.mat[2] = -Math.sin(radians);
  pOut.mat[3] = 0;
  pOut.mat[4] = 1;
  pOut.mat[5] = 0;
  pOut.mat[6] = Math.sin(radians);
  pOut.mat[7] = 0;
  pOut.mat[8] = Math.cos(radians);
  return pOut
};
cc.kmMat3RotationZ = function(pOut, radians) {
  pOut.mat[0] = Math.cos(radians);
  pOut.mat[1] = -Math.sin(radians);
  pOut.mat[2] = 0;
  pOut.mat[3] = Math.sin(radians);
  pOut.mat[4] = Math.cos(radians);
  pOut.mat[5] = 0;
  pOut.mat[6] = 0;
  pOut.mat[7] = 0;
  pOut.mat[8] = 1;
  return pOut
};
cc.kmMat3Rotation = function(pOut, radians) {
  pOut.mat[0] = Math.cos(radians);
  pOut.mat[1] = Math.sin(radians);
  pOut.mat[2] = 0;
  pOut.mat[3] = -Math.sin(radians);
  pOut.mat[4] = Math.cos(radians);
  pOut.mat[5] = 0;
  pOut.mat[6] = 0;
  pOut.mat[7] = 0;
  pOut.mat[8] = 1;
  return pOut
};
cc.kmMat3Scaling = function(pOut, x, y) {
  cc.kmMat3Identity(pOut);
  pOut.mat[0] = x;
  pOut.mat[4] = y;
  return pOut
};
cc.kmMat3Translation = function(pOut, x, y) {
  cc.kmMat3Identity(pOut);
  pOut.mat[6] = x;
  pOut.mat[7] = y;
  return pOut
};
cc.kmMat3RotationQuaternion = function(pOut, pIn) {
  if(!pIn || !pOut) {
    return null
  }
  pOut.mat[0] = 1 - 2 * (pIn.y * pIn.y + pIn.z * pIn.z);
  pOut.mat[1] = 2 * (pIn.x * pIn.y - pIn.w * pIn.z);
  pOut.mat[2] = 2 * (pIn.x * pIn.z + pIn.w * pIn.y);
  pOut.mat[3] = 2 * (pIn.x * pIn.y + pIn.w * pIn.z);
  pOut.mat[4] = 1 - 2 * (pIn.x * pIn.x + pIn.z * pIn.z);
  pOut.mat[5] = 2 * (pIn.y * pIn.z - pIn.w * pIn.x);
  pOut.mat[6] = 2 * (pIn.x * pIn.z - pIn.w * pIn.y);
  pOut.mat[7] = 2 * (pIn.y * pIn.z + pIn.w * pIn.x);
  pOut.mat[8] = 1 - 2 * (pIn.x * pIn.x + pIn.y * pIn.y);
  return pOut
};
cc.kmMat3RotationToAxisAngle = function(pAxis, radians, pIn) {
  var temp;
  cc.kmQuaternionRotationMatrix(temp, pIn);
  cc.kmQuaternionToAxisAngle(temp, pAxis, radians);
  return pAxis
};
cc.kmMat4 = function() {
  this.mat = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
};
cc.kmMat4Fill = function(pOut, pMat) {
  pOut.mat[0] = pOut.mat[1] = pOut.mat[2] = pOut.mat[3] = pOut.mat[4] = pOut.mat[5] = pOut.mat[6] = pOut.mat[7] = pOut.mat[8] = pOut.mat[9] = pOut.mat[10] = pOut.mat[11] = pOut.mat[12] = pOut.mat[13] = pOut.mat[14] = pOut.mat[15] = pMat
};
cc.kmMat4Identity = function(pOut) {
  pOut.mat[1] = pOut.mat[2] = pOut.mat[3] = pOut.mat[4] = pOut.mat[6] = pOut.mat[7] = pOut.mat[8] = pOut.mat[9] = pOut.mat[11] = pOut.mat[12] = pOut.mat[13] = pOut.mat[14] = 0;
  pOut.mat[0] = pOut.mat[5] = pOut.mat[10] = pOut.mat[15] = 1;
  return pOut
};
cc.kmMat4._get = function(pIn, row, col) {
  return pIn.mat[row + 4 * col]
};
cc.kmMat4._set = function(pIn, row, col, value) {
  pIn.mat[row + 4 * col] = value
};
cc.kmMat4._swap = function(pIn, r1, c1, r2, c2) {
  var tmp = cc.kmMat4._get(pIn, r1, c1);
  cc.kmMat4._set(pIn, r1, c1, cc.kmMat4._get(pIn, r2, c2));
  cc.kmMat4._set(pIn, r2, c2, tmp)
};
cc.kmMat4._gaussj = function(a, b) {
  var i, icol = 0, irow = 0, j, k, l, ll, n = 4, m = 4;
  var big, dum, pivinv;
  var indxc = [0, 0, 0, 0];
  var indxr = [0, 0, 0, 0];
  var ipiv = [0, 0, 0, 0];
  for(i = 0;i < n;i++) {
    big = 0;
    for(j = 0;j < n;j++) {
      if(ipiv[j] != 1) {
        for(k = 0;k < n;k++) {
          if(ipiv[k] == 0) {
            if(Math.abs(cc.kmMat4._get(a, j, k)) >= big) {
              big = Math.abs(cc.kmMat4._get(a, j, k));
              irow = j;
              icol = k
            }
          }
        }
      }
    }
    ++ipiv[icol];
    if(irow != icol) {
      for(l = 0;l < n;l++) {
        cc.kmMat4._swap(a, irow, l, icol, l)
      }
      for(l = 0;l < m;l++) {
        cc.kmMat4._swap(b, irow, l, icol, l)
      }
    }
    indxr[i] = irow;
    indxc[i] = icol;
    if(cc.kmMat4._get(a, icol, icol) == 0) {
      return cc.KM_FALSE
    }
    pivinv = 1 / cc.kmMat4._get(a, icol, icol);
    cc.kmMat4._set(a, icol, icol, 1);
    for(l = 0;l < n;l++) {
      cc.kmMat4._set(a, icol, l, cc.kmMat4._get(a, icol, l) * pivinv)
    }
    for(l = 0;l < m;l++) {
      cc.kmMat4._set(b, icol, l, cc.kmMat4._get(b, icol, l) * pivinv)
    }
    for(ll = 0;ll < n;ll++) {
      if(ll != icol) {
        dum = cc.kmMat4._get(a, ll, icol);
        cc.kmMat4._set(a, ll, icol, 0);
        for(l = 0;l < n;l++) {
          cc.kmMat4._set(a, ll, l, cc.kmMat4._get(a, ll, l) - cc.kmMat4._get(a, icol, l) * dum)
        }
        for(l = 0;l < m;l++) {
          cc.kmMat4._set(b, ll, l, cc.kmMat4._get(a, ll, l) - cc.kmMat4._get(b, icol, l) * dum)
        }
      }
    }
  }
  for(l = n - 1;l >= 0;l--) {
    if(indxr[l] != indxc[l]) {
      for(k = 0;k < n;k++) {
        cc.kmMat4._swap(a, k, indxr[l], k, indxc[l])
      }
    }
  }
  return cc.KM_TRUE
};
cc.kmMat4._identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
cc.kmMat4Inverse = function(pOut, pM) {
  var inv = new cc.kmMat4;
  var tmp = new cc.kmMat4;
  cc.kmMat4Assign(inv, pM);
  cc.kmMat4Identity(tmp);
  if(cc.kmMat4._gaussj(inv, tmp) == cc.KM_FALSE) {
    return null
  }
  cc.kmMat4Assign(pOut, inv);
  return pOut
};
cc.kmMat4IsIdentity = function(pIn) {
  for(var i = 0;i < 16;i++) {
    if(cc.kmMat4._identity[i] != pIn.mat[i]) {
      return false
    }
  }
  return true
};
cc.kmMat4Transpose = function(pOut, pIn) {
  var x, z;
  for(z = 0;z < 4;++z) {
    for(x = 0;x < 4;++x) {
      pOut.mat[z * 4 + x] = pIn.mat[x * 4 + z]
    }
  }
  return pOut
};
cc.kmMat4Multiply = function(pOut, pM1, pM2) {
  var a00 = pM1.mat[0], a01 = pM1.mat[1], a02 = pM1.mat[2], a03 = pM1.mat[3];
  var a10 = pM1.mat[4], a11 = pM1.mat[5], a12 = pM1.mat[6], a13 = pM1.mat[7];
  var a20 = pM1.mat[8], a21 = pM1.mat[9], a22 = pM1.mat[10], a23 = pM1.mat[11];
  var a30 = pM1.mat[12], a31 = pM1.mat[13], a32 = pM1.mat[14], a33 = pM1.mat[15];
  var b00 = pM2.mat[0], b01 = pM2.mat[1], b02 = pM2.mat[2], b03 = pM2.mat[3];
  var b10 = pM2.mat[4], b11 = pM2.mat[5], b12 = pM2.mat[6], b13 = pM2.mat[7];
  var b20 = pM2.mat[8], b21 = pM2.mat[9], b22 = pM2.mat[10], b23 = pM2.mat[11];
  var b30 = pM2.mat[12], b31 = pM2.mat[13], b32 = pM2.mat[14], b33 = pM2.mat[15];
  pOut.mat[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
  pOut.mat[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
  pOut.mat[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
  pOut.mat[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
  pOut.mat[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
  pOut.mat[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
  pOut.mat[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
  pOut.mat[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
  pOut.mat[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
  pOut.mat[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
  pOut.mat[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
  pOut.mat[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
  pOut.mat[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
  pOut.mat[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
  pOut.mat[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
  pOut.mat[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
  return pOut
};
cc.getMat4MultiplyValue = function(pM1, pM2) {
  var m1 = pM1.mat, m2 = pM2.mat;
  var mat = new Float32Array(16);
  mat[0] = m1[0] * m2[0] + m1[4] * m2[1] + m1[8] * m2[2] + m1[12] * m2[3];
  mat[1] = m1[1] * m2[0] + m1[5] * m2[1] + m1[9] * m2[2] + m1[13] * m2[3];
  mat[2] = m1[2] * m2[0] + m1[6] * m2[1] + m1[10] * m2[2] + m1[14] * m2[3];
  mat[3] = m1[3] * m2[0] + m1[7] * m2[1] + m1[11] * m2[2] + m1[15] * m2[3];
  mat[4] = m1[0] * m2[4] + m1[4] * m2[5] + m1[8] * m2[6] + m1[12] * m2[7];
  mat[5] = m1[1] * m2[4] + m1[5] * m2[5] + m1[9] * m2[6] + m1[13] * m2[7];
  mat[6] = m1[2] * m2[4] + m1[6] * m2[5] + m1[10] * m2[6] + m1[14] * m2[7];
  mat[7] = m1[3] * m2[4] + m1[7] * m2[5] + m1[11] * m2[6] + m1[15] * m2[7];
  mat[8] = m1[0] * m2[8] + m1[4] * m2[9] + m1[8] * m2[10] + m1[12] * m2[11];
  mat[9] = m1[1] * m2[8] + m1[5] * m2[9] + m1[9] * m2[10] + m1[13] * m2[11];
  mat[10] = m1[2] * m2[8] + m1[6] * m2[9] + m1[10] * m2[10] + m1[14] * m2[11];
  mat[11] = m1[3] * m2[8] + m1[7] * m2[9] + m1[11] * m2[10] + m1[15] * m2[11];
  mat[12] = m1[0] * m2[12] + m1[4] * m2[13] + m1[8] * m2[14] + m1[12] * m2[15];
  mat[13] = m1[1] * m2[12] + m1[5] * m2[13] + m1[9] * m2[14] + m1[13] * m2[15];
  mat[14] = m1[2] * m2[12] + m1[6] * m2[13] + m1[10] * m2[14] + m1[14] * m2[15];
  mat[15] = m1[3] * m2[12] + m1[7] * m2[13] + m1[11] * m2[14] + m1[15] * m2[15];
  return mat
};
cc.getMat4MultiplyWithMat4 = function(pM1, pM2, swapMat) {
  var m1 = pM1.mat, m2 = pM2.mat;
  var mat = swapMat.mat;
  mat[0] = m1[0] * m2[0] + m1[4] * m2[1] + m1[8] * m2[2] + m1[12] * m2[3];
  mat[1] = m1[1] * m2[0] + m1[5] * m2[1] + m1[9] * m2[2] + m1[13] * m2[3];
  mat[2] = m1[2] * m2[0] + m1[6] * m2[1] + m1[10] * m2[2] + m1[14] * m2[3];
  mat[3] = m1[3] * m2[0] + m1[7] * m2[1] + m1[11] * m2[2] + m1[15] * m2[3];
  mat[4] = m1[0] * m2[4] + m1[4] * m2[5] + m1[8] * m2[6] + m1[12] * m2[7];
  mat[5] = m1[1] * m2[4] + m1[5] * m2[5] + m1[9] * m2[6] + m1[13] * m2[7];
  mat[6] = m1[2] * m2[4] + m1[6] * m2[5] + m1[10] * m2[6] + m1[14] * m2[7];
  mat[7] = m1[3] * m2[4] + m1[7] * m2[5] + m1[11] * m2[6] + m1[15] * m2[7];
  mat[8] = m1[0] * m2[8] + m1[4] * m2[9] + m1[8] * m2[10] + m1[12] * m2[11];
  mat[9] = m1[1] * m2[8] + m1[5] * m2[9] + m1[9] * m2[10] + m1[13] * m2[11];
  mat[10] = m1[2] * m2[8] + m1[6] * m2[9] + m1[10] * m2[10] + m1[14] * m2[11];
  mat[11] = m1[3] * m2[8] + m1[7] * m2[9] + m1[11] * m2[10] + m1[15] * m2[11];
  mat[12] = m1[0] * m2[12] + m1[4] * m2[13] + m1[8] * m2[14] + m1[12] * m2[15];
  mat[13] = m1[1] * m2[12] + m1[5] * m2[13] + m1[9] * m2[14] + m1[13] * m2[15];
  mat[14] = m1[2] * m2[12] + m1[6] * m2[13] + m1[10] * m2[14] + m1[14] * m2[15];
  mat[15] = m1[3] * m2[12] + m1[7] * m2[13] + m1[11] * m2[14] + m1[15] * m2[15];
  return swapMat.mat
};
cc.kmMat4Assign = function(pOut, pIn) {
  pOut.mat[0] = pIn.mat[0];
  pOut.mat[1] = pIn.mat[1];
  pOut.mat[2] = pIn.mat[2];
  pOut.mat[3] = pIn.mat[3];
  pOut.mat[4] = pIn.mat[4];
  pOut.mat[5] = pIn.mat[5];
  pOut.mat[6] = pIn.mat[6];
  pOut.mat[7] = pIn.mat[7];
  pOut.mat[8] = pIn.mat[8];
  pOut.mat[9] = pIn.mat[9];
  pOut.mat[10] = pIn.mat[10];
  pOut.mat[11] = pIn.mat[11];
  pOut.mat[12] = pIn.mat[12];
  pOut.mat[13] = pIn.mat[13];
  pOut.mat[14] = pIn.mat[14];
  pOut.mat[15] = pIn.mat[15];
  return pOut
};
cc.kmMat4AreEqual = function(pMat1, pMat2) {
  cc.Assert(pMat1 != pMat2, "You are comparing the same thing!");
  for(var i = 0;i < 16;i++) {
    if(!(pMat1.mat[i] + cc.kmEpsilon > pMat2.mat[i] && pMat1.mat[i] - cc.kmEpsilon < pMat2.mat[i])) {
      return false
    }
  }
  return true
};
cc.kmMat4RotationX = function(pOut, radians) {
  pOut.mat[0] = 1;
  pOut.mat[1] = 0;
  pOut.mat[2] = 0;
  pOut.mat[3] = 0;
  pOut.mat[4] = 0;
  pOut.mat[5] = Math.cos(radians);
  pOut.mat[6] = Math.sin(radians);
  pOut.mat[7] = 0;
  pOut.mat[8] = 0;
  pOut.mat[9] = -Math.sin(radians);
  pOut.mat[10] = Math.cos(radians);
  pOut.mat[11] = 0;
  pOut.mat[12] = 0;
  pOut.mat[13] = 0;
  pOut.mat[14] = 0;
  pOut.mat[15] = 1;
  return pOut
};
cc.kmMat4RotationY = function(pOut, radians) {
  pOut.mat[0] = Math.cos(radians);
  pOut.mat[1] = 0;
  pOut.mat[2] = -Math.sin(radians);
  pOut.mat[3] = 0;
  pOut.mat[4] = 0;
  pOut.mat[5] = 1;
  pOut.mat[6] = 0;
  pOut.mat[7] = 0;
  pOut.mat[8] = Math.sin(radians);
  pOut.mat[9] = 0;
  pOut.mat[10] = Math.cos(radians);
  pOut.mat[11] = 0;
  pOut.mat[12] = 0;
  pOut.mat[13] = 0;
  pOut.mat[14] = 0;
  pOut.mat[15] = 1;
  return pOut
};
cc.kmMat4RotationZ = function(pOut, radians) {
  pOut.mat[0] = Math.cos(radians);
  pOut.mat[1] = Math.sin(radians);
  pOut.mat[2] = 0;
  pOut.mat[3] = 0;
  pOut.mat[4] = -Math.sin(radians);
  pOut.mat[5] = Math.cos(radians);
  pOut.mat[6] = 0;
  pOut.mat[7] = 0;
  pOut.mat[8] = 0;
  pOut.mat[9] = 0;
  pOut.mat[10] = 1;
  pOut.mat[11] = 0;
  pOut.mat[12] = 0;
  pOut.mat[13] = 0;
  pOut.mat[14] = 0;
  pOut.mat[15] = 1;
  return pOut
};
cc.kmMat4RotationPitchYawRoll = function(pOut, pitch, yaw, roll) {
  var cr = Math.cos(pitch);
  var sr = Math.sin(pitch);
  var cp = Math.cos(yaw);
  var sp = Math.sin(yaw);
  var cy = Math.cos(roll);
  var sy = Math.sin(roll);
  var srsp = sr * sp;
  var crsp = cr * sp;
  pOut.mat[0] = cp * cy;
  pOut.mat[4] = cp * sy;
  pOut.mat[8] = -sp;
  pOut.mat[1] = srsp * cy - cr * sy;
  pOut.mat[5] = srsp * sy + cr * cy;
  pOut.mat[9] = sr * cp;
  pOut.mat[2] = crsp * cy + sr * sy;
  pOut.mat[6] = crsp * sy - sr * cy;
  pOut.mat[10] = cr * cp;
  pOut.mat[3] = pOut.mat[7] = pOut.mat[11] = 0;
  pOut.mat[15] = 1;
  return pOut
};
cc.kmMat4RotationQuaternion = function(pOut, pQ) {
  pOut.mat[0] = 1 - 2 * (pQ.y * pQ.y + pQ.z * pQ.z);
  pOut.mat[1] = 2 * (pQ.x * pQ.y + pQ.z * pQ.w);
  pOut.mat[2] = 2 * (pQ.x * pQ.z - pQ.y * pQ.w);
  pOut.mat[3] = 0;
  pOut.mat[4] = 2 * (pQ.x * pQ.y - pQ.z * pQ.w);
  pOut.mat[5] = 1 - 2 * (pQ.x * pQ.x + pQ.z * pQ.z);
  pOut.mat[6] = 2 * (pQ.z * pQ.y + pQ.x * pQ.w);
  pOut.mat[7] = 0;
  pOut.mat[8] = 2 * (pQ.x * pQ.z + pQ.y * pQ.w);
  pOut.mat[9] = 2 * (pQ.y * pQ.z - pQ.x * pQ.w);
  pOut.mat[10] = 1 - 2 * (pQ.x * pQ.x + pQ.y * pQ.y);
  pOut.mat[11] = 0;
  pOut.mat[12] = 0;
  pOut.mat[13] = 0;
  pOut.mat[14] = 0;
  pOut.mat[15] = 1;
  return pOut
};
cc.kmMat4RotationTranslation = function(pOut, rotation, translation) {
  pOut.mat[0] = rotation.mat[0];
  pOut.mat[1] = rotation.mat[1];
  pOut.mat[2] = rotation.mat[2];
  pOut.mat[3] = 0;
  pOut.mat[4] = rotation.mat[3];
  pOut.mat[5] = rotation.mat[4];
  pOut.mat[6] = rotation.mat[5];
  pOut.mat[7] = 0;
  pOut.mat[8] = rotation.mat[6];
  pOut.mat[9] = rotation.mat[7];
  pOut.mat[10] = rotation.mat[8];
  pOut.mat[11] = 0;
  pOut.mat[12] = translation.x;
  pOut.mat[13] = translation.y;
  pOut.mat[14] = translation.z;
  pOut.mat[15] = 1;
  return pOut
};
cc.kmMat4Scaling = function(pOut, x, y, z) {
  pOut.mat[0] = x;
  pOut.mat[5] = y;
  pOut.mat[10] = z;
  pOut.mat[15] = 1;
  pOut.mat[1] = pOut.mat[2] = pOut.mat[3] = pOut.mat[4] = pOut.mat[6] = pOut.mat[7] = pOut.mat[8] = pOut.mat[9] = pOut.mat[11] = pOut.mat[12] = pOut.mat[13] = pOut.mat[14] = 0;
  return pOut
};
cc.kmMat4Translation = function(pOut, x, y, z) {
  pOut.mat[0] = pOut.mat[5] = pOut.mat[10] = pOut.mat[15] = 1;
  pOut.mat[1] = pOut.mat[2] = pOut.mat[3] = pOut.mat[4] = pOut.mat[6] = pOut.mat[7] = pOut.mat[8] = pOut.mat[9] = pOut.mat[11] = 0;
  pOut.mat[12] = x;
  pOut.mat[13] = y;
  pOut.mat[14] = z;
  return pOut
};
cc.kmMat4GetUpVec3 = function(pOut, pIn) {
  pOut.x = pIn.mat[4];
  pOut.y = pIn.mat[5];
  pOut.z = pIn.mat[6];
  cc.kmVec3Normalize(pOut, pOut);
  return pOut
};
cc.kmMat4GetRightVec3 = function(pOut, pIn) {
  pOut.x = pIn.mat[0];
  pOut.y = pIn.mat[1];
  pOut.z = pIn.mat[2];
  cc.kmVec3Normalize(pOut, pOut);
  return pOut
};
cc.kmMat4GetForwardVec3 = function(pOut, pIn) {
  pOut.x = pIn.mat[8];
  pOut.y = pIn.mat[9];
  pOut.z = pIn.mat[10];
  cc.kmVec3Normalize(pOut, pOut);
  return pOut
};
cc.kmMat4PerspectiveProjection = function(pOut, fovY, aspect, zNear, zFar) {
  var r = cc.kmDegreesToRadians(fovY / 2);
  var deltaZ = zFar - zNear;
  var s = Math.sin(r);
  if(deltaZ == 0 || s == 0 || aspect == 0) {
    return null
  }
  var cotangent = Math.cos(r) / s;
  cc.kmMat4Identity(pOut);
  pOut.mat[0] = cotangent / aspect;
  pOut.mat[5] = cotangent;
  pOut.mat[10] = -(zFar + zNear) / deltaZ;
  pOut.mat[11] = -1;
  pOut.mat[14] = -2 * zNear * zFar / deltaZ;
  pOut.mat[15] = 0;
  return pOut
};
cc.kmMat4OrthographicProjection = function(pOut, left, right, bottom, top, nearVal, farVal) {
  cc.kmMat4Identity(pOut);
  pOut.mat[0] = 2 / (right - left);
  pOut.mat[5] = 2 / (top - bottom);
  pOut.mat[10] = -2 / (farVal - nearVal);
  pOut.mat[12] = -((right + left) / (right - left));
  pOut.mat[13] = -((top + bottom) / (top - bottom));
  pOut.mat[14] = -((farVal + nearVal) / (farVal - nearVal));
  return pOut
};
cc.kmMat4LookAt = function(pOut, pEye, pCenter, pUp) {
  var f = new cc.kmVec3, up = new cc.kmVec3, s = new cc.kmVec3, u = new cc.kmVec3;
  var translate = new cc.kmMat4;
  cc.kmVec3Subtract(f, pCenter, pEye);
  cc.kmVec3Normalize(f, f);
  cc.kmVec3Assign(up, pUp);
  cc.kmVec3Normalize(up, up);
  cc.kmVec3Cross(s, f, up);
  cc.kmVec3Normalize(s, s);
  cc.kmVec3Cross(u, s, f);
  cc.kmVec3Normalize(s, s);
  cc.kmMat4Identity(pOut);
  pOut.mat[0] = s.x;
  pOut.mat[4] = s.y;
  pOut.mat[8] = s.z;
  pOut.mat[1] = u.x;
  pOut.mat[5] = u.y;
  pOut.mat[9] = u.z;
  pOut.mat[2] = -f.x;
  pOut.mat[6] = -f.y;
  pOut.mat[10] = -f.z;
  cc.kmMat4Translation(translate, -pEye.x, -pEye.y, -pEye.z);
  cc.kmMat4Multiply(pOut, pOut, translate);
  return pOut
};
cc.kmMat4RotationAxisAngle = function(pOut, axis, radians) {
  var rcos = Math.cos(radians);
  var rsin = Math.sin(radians);
  var normalizedAxis = new cc.kmVec3;
  cc.kmVec3Normalize(normalizedAxis, axis);
  pOut.mat[0] = rcos + normalizedAxis.x * normalizedAxis.x * (1 - rcos);
  pOut.mat[1] = normalizedAxis.z * rsin + normalizedAxis.y * normalizedAxis.x * (1 - rcos);
  pOut.mat[2] = -normalizedAxis.y * rsin + normalizedAxis.z * normalizedAxis.x * (1 - rcos);
  pOut.mat[3] = 0;
  pOut.mat[4] = -normalizedAxis.z * rsin + normalizedAxis.x * normalizedAxis.y * (1 - rcos);
  pOut.mat[5] = rcos + normalizedAxis.y * normalizedAxis.y * (1 - rcos);
  pOut.mat[6] = normalizedAxis.x * rsin + normalizedAxis.z * normalizedAxis.y * (1 - rcos);
  pOut.mat[7] = 0;
  pOut.mat[8] = normalizedAxis.y * rsin + normalizedAxis.x * normalizedAxis.z * (1 - rcos);
  pOut.mat[9] = -normalizedAxis.x * rsin + normalizedAxis.y * normalizedAxis.z * (1 - rcos);
  pOut.mat[10] = rcos + normalizedAxis.z * normalizedAxis.z * (1 - rcos);
  pOut.mat[11] = 0;
  pOut.mat[12] = 0;
  pOut.mat[13] = 0;
  pOut.mat[14] = 0;
  pOut.mat[15] = 1;
  return pOut
};
cc.kmMat4ExtractRotation = function(pOut, pIn) {
  pOut.mat[0] = pIn.mat[0];
  pOut.mat[1] = pIn.mat[1];
  pOut.mat[2] = pIn.mat[2];
  pOut.mat[3] = pIn.mat[4];
  pOut.mat[4] = pIn.mat[5];
  pOut.mat[5] = pIn.mat[6];
  pOut.mat[6] = pIn.mat[8];
  pOut.mat[7] = pIn.mat[9];
  pOut.mat[8] = pIn.mat[10];
  return pOut
};
cc.kmMat4ExtractPlane = function(pOut, pIn, plane) {
  switch(plane) {
    case cc.KM_PLANE_RIGHT:
      pOut.a = pIn.mat[3] - pIn.mat[0];
      pOut.b = pIn.mat[7] - pIn.mat[4];
      pOut.c = pIn.mat[11] - pIn.mat[8];
      pOut.d = pIn.mat[15] - pIn.mat[12];
      break;
    case cc.KM_PLANE_LEFT:
      pOut.a = pIn.mat[3] + pIn.mat[0];
      pOut.b = pIn.mat[7] + pIn.mat[4];
      pOut.c = pIn.mat[11] + pIn.mat[8];
      pOut.d = pIn.mat[15] + pIn.mat[12];
      break;
    case cc.KM_PLANE_BOTTOM:
      pOut.a = pIn.mat[3] + pIn.mat[1];
      pOut.b = pIn.mat[7] + pIn.mat[5];
      pOut.c = pIn.mat[11] + pIn.mat[9];
      pOut.d = pIn.mat[15] + pIn.mat[13];
      break;
    case cc.KM_PLANE_TOP:
      pOut.a = pIn.mat[3] - pIn.mat[1];
      pOut.b = pIn.mat[7] - pIn.mat[5];
      pOut.c = pIn.mat[11] - pIn.mat[9];
      pOut.d = pIn.mat[15] - pIn.mat[13];
      break;
    case cc.KM_PLANE_FAR:
      pOut.a = pIn.mat[3] - pIn.mat[2];
      pOut.b = pIn.mat[7] - pIn.mat[6];
      pOut.c = pIn.mat[11] - pIn.mat[10];
      pOut.d = pIn.mat[15] - pIn.mat[14];
      break;
    case cc.KM_PLANE_NEAR:
      pOut.a = pIn.mat[3] + pIn.mat[2];
      pOut.b = pIn.mat[7] + pIn.mat[6];
      pOut.c = pIn.mat[11] + pIn.mat[10];
      pOut.d = pIn.mat[15] + pIn.mat[14];
      break;
    default:
      cc.Assert(0, "Invalid plane index")
  }
  var t = Math.sqrt(pOut.a * pOut.a + pOut.b * pOut.b + pOut.c * pOut.c);
  pOut.a /= t;
  pOut.b /= t;
  pOut.c /= t;
  pOut.d /= t;
  return pOut
};
cc.kmMat4RotationToAxisAngle = function(pAxis, radians, pIn) {
  var temp = new cc.kmQuaternion;
  var rotation = new cc.kmMat3;
  cc.kmMat4ExtractRotation(rotation, pIn);
  cc.kmQuaternionRotationMatrix(temp, rotation);
  cc.kmQuaternionToAxisAngle(temp, pAxis, radians);
  return pAxis
};
cc.KM_PLANE_LEFT = 0;
cc.KM_PLANE_RIGHT = 1;
cc.KM_PLANE_BOTTOM = 2;
cc.KM_PLANE_TOP = 3;
cc.KM_PLANE_NEAR = 4;
cc.KM_PLANE_FAR = 5;
cc.kmPlane = function(a, b, c, d) {
  this.a = a || 0;
  this.b = b || 0;
  this.c = c || 0;
  this.d = d || 0
};
cc.POINT_INFRONT_OF_PLANE = 0;
cc.POINT_BEHIND_PLANE = 1;
cc.POINT_ON_PLANE = 2;
cc.kmPlaneDot = function(pP, pV) {
  return pP.a * pV.x + pP.b * pV.y + pP.c * pV.z + pP.d * pV.w
};
cc.kmPlaneDotCoord = function(pP, pV) {
  return pP.a * pV.x + pP.b * pV.y + pP.c * pV.z + pP.d
};
cc.kmPlaneDotNormal = function(pP, pV) {
  return pP.a * pV.x + pP.b * pV.y + pP.c * pV.z
};
cc.kmPlaneFromPointNormal = function(pOut, pPoint, pNormal) {
  pOut.a = pNormal.x;
  pOut.b = pNormal.y;
  pOut.c = pNormal.z;
  pOut.d = -cc.kmVec3Dot(pNormal, pPoint);
  return pOut
};
cc.kmPlaneFromPoints = function(pOut, p1, p2, p3) {
  var n = new cc.kmVec3, v1 = new cc.kmVec3, v2 = new cc.kmVec3;
  cc.kmVec3Subtract(v1, p2, p1);
  cc.kmVec3Subtract(v2, p3, p1);
  cc.kmVec3Cross(n, v1, v2);
  cc.kmVec3Normalize(n, n);
  pOut.a = n.x;
  pOut.b = n.y;
  pOut.c = n.z;
  pOut.d = cc.kmVec3Dot(cc.kmVec3Scale(n, n, -1), p1);
  return pOut
};
cc.kmPlaneIntersectLine = function(pOut, pP, pV1, pV2) {
  var d = new cc.kmVec3;
  cc.Assert(0, "Not implemented");
  cc.kmVec3Subtract(d, pV2, pV1);
  return null
};
cc.kmPlaneNormalize = function(pOut, pP) {
  var n = new cc.kmVec3;
  n.x = pP.a;
  n.y = pP.b;
  n.z = pP.c;
  var l = 1 / cc.kmVec3Length(n);
  cc.kmVec3Normalize(n, n);
  pOut.a = n.x;
  pOut.b = n.y;
  pOut.c = n.z;
  pOut.d = pP.d * l;
  return pOut
};
cc.kmPlaneScale = function(pOut, pP, s) {
  cc.Assert(0, "Not implemented");
  return null
};
cc.kmPlaneClassifyPoint = function(pIn, pP) {
  var distance = pIn.a * pP.x + pIn.b * pP.y + pIn.c * pP.z + pIn.d;
  if(distance > 0.0010) {
    return cc.POINT_INFRONT_OF_PLANE
  }
  if(distance < -0.0010) {
    return cc.POINT_BEHIND_PLANE
  }
  return cc.POINT_ON_PLANE
};
cc.kmQuaternion = function(x, y, z, w) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = w || 0
};
cc.kmQuaternionConjugate = function(pOut, pIn) {
  pOut.x = -pIn.x;
  pOut.y = -pIn.y;
  pOut.z = -pIn.z;
  pOut.w = pIn.w;
  return pOut
};
cc.kmQuaternionDot = function(q1, q2) {
  return q1.w * q2.w + q1.x * q2.x + q1.y * q2.y + q1.z * q2.z
};
cc.kmQuaternionExp = function(pOut, pIn) {
  return pOut
};
cc.kmQuaternionIdentity = function(pOut) {
  pOut.x = 0;
  pOut.y = 0;
  pOut.z = 0;
  pOut.w = 1;
  return pOut
};
cc.kmQuaternionInverse = function(pOut, pIn) {
  var l = cc.kmQuaternionLength(pIn);
  var tmp = new cc.kmQuaternion;
  if(Math.abs(l) > cc.kmEpsilon) {
    pOut.x = 0;
    pOut.y = 0;
    pOut.z = 0;
    pOut.w = 0;
    return pOut
  }
  cc.kmQuaternionScale(pOut, cc.kmQuaternionConjugate(tmp, pIn), 1 / l);
  return pOut
};
cc.kmQuaternionIsIdentity = function(pIn) {
  return pIn.x == 0 && pIn.y == 0 && pIn.z == 0 && pIn.w == 1
};
cc.kmQuaternionLength = function(pIn) {
  return Math.sqrt(cc.kmQuaternionLengthSq(pIn))
};
cc.kmQuaternionLengthSq = function(pIn) {
  return pIn.x * pIn.x + pIn.y * pIn.y + pIn.z * pIn.z + pIn.w * pIn.w
};
cc.kmQuaternionLn = function(pOut, pIn) {
  return pOut
};
cc.kmQuaternionMultiply = function(pOut, q1, q2) {
  pOut.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;
  pOut.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;
  pOut.y = q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z;
  pOut.z = q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x;
  return pOut
};
cc.kmQuaternionNormalize = function(pOut, pIn) {
  var length = cc.kmQuaternionLength(pIn);
  cc.Assert(Math.abs(length) > cc.kmEpsilon, "");
  cc.kmQuaternionScale(pOut, pIn, 1 / length);
  return pOut
};
cc.kmQuaternionRotationAxis = function(pOut, pV, angle) {
  var rad = angle * 0.5;
  var scale = Math.sin(rad);
  pOut.w = Math.cos(rad);
  pOut.x = pV.x * scale;
  pOut.y = pV.y * scale;
  pOut.z = pV.z * scale;
  return pOut
};
cc.kmQuaternionRotationMatrix = function(pOut, pIn) {
  var x, y, z, w;
  var m4x4 = [];
  var scale = 0;
  var diagonal = 0;
  if(!pIn) {
    return null
  }
  m4x4[0] = pIn.mat[0];
  m4x4[1] = pIn.mat[3];
  m4x4[2] = pIn.mat[6];
  m4x4[4] = pIn.mat[1];
  m4x4[5] = pIn.mat[4];
  m4x4[6] = pIn.mat[7];
  m4x4[8] = pIn.mat[2];
  m4x4[9] = pIn.mat[5];
  m4x4[10] = pIn.mat[8];
  m4x4[15] = 1;
  var pMatrix = m4x4[0];
  diagonal = pMatrix[0] + pMatrix[5] + pMatrix[10] + 1;
  if(diagonal > cc.kmEpsilon) {
    scale = Math.sqrt(diagonal) * 2;
    x = (pMatrix[9] - pMatrix[6]) / scale;
    y = (pMatrix[2] - pMatrix[8]) / scale;
    z = (pMatrix[4] - pMatrix[1]) / scale;
    w = 0.25 * scale
  }else {
    if(pMatrix[0] > pMatrix[5] && pMatrix[0] > pMatrix[10]) {
      scale = Math.sqrt(1 + pMatrix[0] - pMatrix[5] - pMatrix[10]) * 2;
      x = 0.25 * scale;
      y = (pMatrix[4] + pMatrix[1]) / scale;
      z = (pMatrix[2] + pMatrix[8]) / scale;
      w = (pMatrix[9] - pMatrix[6]) / scale
    }else {
      if(pMatrix[5] > pMatrix[10]) {
        scale = Math.sqrt(1 + pMatrix[5] - pMatrix[0] - pMatrix[10]) * 2;
        x = (pMatrix[4] + pMatrix[1]) / scale;
        y = 0.25 * scale;
        z = (pMatrix[9] + pMatrix[6]) / scale;
        w = (pMatrix[2] - pMatrix[8]) / scale
      }else {
        scale = Math.sqrt(1 + pMatrix[10] - pMatrix[0] - pMatrix[5]) * 2;
        x = (pMatrix[2] + pMatrix[8]) / scale;
        y = (pMatrix[9] + pMatrix[6]) / scale;
        z = 0.25 * scale;
        w = (pMatrix[4] - pMatrix[1]) / scale
      }
    }
  }
  pOut.x = x;
  pOut.y = y;
  pOut.z = z;
  pOut.w = w;
  return pOut
};
cc.kmQuaternionRotationYawPitchRoll = function(pOut, yaw, pitch, roll) {
  var ex, ey, ez;
  var cr, cp, cy, sr, sp, sy, cpcy, spsy;
  ex = cc.kmDegreesToRadians(pitch) / 2;
  ey = cc.kmDegreesToRadians(yaw) / 2;
  ez = cc.kmDegreesToRadians(roll) / 2;
  cr = Math.cos(ex);
  cp = Math.cos(ey);
  cy = Math.cos(ez);
  sr = Math.sin(ex);
  sp = Math.sin(ey);
  sy = Math.sin(ez);
  cpcy = cp * cy;
  spsy = sp * sy;
  pOut.w = cr * cpcy + sr * spsy;
  pOut.x = sr * cpcy - cr * spsy;
  pOut.y = cr * sp * cy + sr * cp * sy;
  pOut.z = cr * cp * sy - sr * sp * cy;
  cc.kmQuaternionNormalize(pOut, pOut);
  return pOut
};
cc.kmQuaternionSlerp = function(pOut, q1, q2, t) {
  if(q1.x == q2.x && q1.y == q2.y && q1.z == q2.z && q1.w == q2.w) {
    pOut.x = q1.x;
    pOut.y = q1.y;
    pOut.z = q1.z;
    pOut.w = q1.w;
    return pOut
  }
  var ct = cc.kmQuaternionDot(q1, q2);
  var theta = Math.acos(ct);
  var st = Math.sqrt(1 - cc.kmSQR(ct));
  var stt = Math.sin(t * theta) / st;
  var somt = Math.sin((1 - t) * theta) / st;
  var temp = new cc.kmQuaternion, temp2 = new cc.kmQuaternion;
  cc.kmQuaternionScale(temp, q1, somt);
  cc.kmQuaternionScale(temp2, q2, stt);
  cc.kmQuaternionAdd(pOut, temp, temp2);
  return pOut
};
cc.kmQuaternionToAxisAngle = function(pIn, pAxis, pAngle) {
  var tempAngle;
  var scale;
  tempAngle = Math.acos(pIn.w);
  scale = Math.sqrt(cc.kmSQR(pIn.x) + cc.kmSQR(pIn.y) + cc.kmSQR(pIn.z));
  if(scale > -cc.kmEpsilon && scale < cc.kmEpsilon || scale < 2 * cc.kmPI + cc.kmEpsilon && scale > 2 * cc.kmPI - cc.kmEpsilon) {
    pAngle = 0;
    pAxis.x = 0;
    pAxis.y = 0;
    pAxis.z = 1
  }else {
    pAngle = tempAngle * 2;
    pAxis.x = pIn.x / scale;
    pAxis.y = pIn.y / scale;
    pAxis.z = pIn.z / scale;
    cc.kmVec3Normalize(pAxis, pAxis)
  }
};
cc.kmQuaternionScale = function(pOut, pIn, s) {
  pOut.x = pIn.x * s;
  pOut.y = pIn.y * s;
  pOut.z = pIn.z * s;
  pOut.w = pIn.w * s;
  return pOut
};
cc.kmQuaternionAssign = function(pOut, pIn) {
  pOut.x = pIn.x;
  pOut.y = pIn.y;
  pOut.z = pIn.z;
  pOut.w = pIn.w;
  return pOut
};
cc.kmQuaternionAdd = function(pOut, pQ1, pQ2) {
  pOut.x = pQ1.x + pQ2.x;
  pOut.y = pQ1.y + pQ2.y;
  pOut.z = pQ1.z + pQ2.z;
  pOut.w = pQ1.w + pQ2.w;
  return pOut
};
cc.kmQuaternionRotationBetweenVec3 = function(pOut, vec1, vec2, fallback) {
  var v1 = new cc.kmVec3, v2 = new cc.kmVec3;
  var a;
  cc.kmVec3Assign(v1, vec1);
  cc.kmVec3Assign(v2, vec2);
  cc.kmVec3Normalize(v1, v1);
  cc.kmVec3Normalize(v2, v2);
  a = cc.kmVec3Dot(v1, v2);
  if(a >= 1) {
    cc.kmQuaternionIdentity(pOut);
    return pOut
  }
  if(a < 1E-6 - 1) {
    if(Math.abs(cc.kmVec3LengthSq(fallback)) < cc.kmEpsilon) {
      cc.kmQuaternionRotationAxis(pOut, fallback, cc.kmPI)
    }else {
      var axis = new cc.kmVec3;
      var X = new cc.kmVec3;
      X.x = 1;
      X.y = 0;
      X.z = 0;
      cc.kmVec3Cross(axis, X, vec1);
      if(Math.abs(cc.kmVec3LengthSq(axis)) < cc.kmEpsilon) {
        var Y = new cc.kmVec3;
        Y.x = 0;
        Y.y = 1;
        Y.z = 0;
        cc.kmVec3Cross(axis, Y, vec1)
      }
      cc.kmVec3Normalize(axis, axis);
      cc.kmQuaternionRotationAxis(pOut, axis, cc.kmPI)
    }
  }else {
    var s = Math.sqrt((1 + a) * 2);
    var invs = 1 / s;
    var c = new cc.kmVec3;
    cc.kmVec3Cross(c, v1, v2);
    pOut.x = c.x * invs;
    pOut.y = c.y * invs;
    pOut.z = c.z * invs;
    pOut.w = s * 0.5;
    cc.kmQuaternionNormalize(pOut, pOut)
  }
  return pOut
};
cc.kmQuaternionMultiplyVec3 = function(pOut, q, v) {
  var uv = new cc.kmVec3, uuv = new cc.kmVec3, qvec = new cc.kmVec3;
  qvec.x = q.x;
  qvec.y = q.y;
  qvec.z = q.z;
  cc.kmVec3Cross(uv, qvec, v);
  cc.kmVec3Cross(uuv, qvec, uv);
  cc.kmVec3Scale(uv, uv, 2 * q.w);
  cc.kmVec3Scale(uuv, uuv, 2);
  cc.kmVec3Add(pOut, v, uv);
  cc.kmVec3Add(pOut, pOut, uuv);
  return pOut
};
cc.kmAABB = function(min, max) {
  this.min = min || new cc.kmVec3;
  this.max = max || new cc.kmVec3
};
cc.kmAABBContainsPoint = function(pPoint, pBox) {
  if(pPoint.x >= pBox.min.x && pPoint.x <= pBox.max.x && pPoint.y >= pBox.min.y && pPoint.y <= pBox.max.y && pPoint.z >= pBox.min.z && pPoint.z <= pBox.max.z) {
    return cc.KM_TRUE
  }
  return cc.KM_FALSE
};
cc.kmAABBAssign = function(pOut, pIn) {
  cc.kmVec3Assign(pOut.min, pIn.min);
  cc.kmVec3Assign(pOut.max, pIn.max);
  return pOut
};
cc.kmAABBScale = function(pOut, pIn, s) {
  cc.Assert(0, "Not implemented");
  return 0
};
cc.km_mat4_stack = function(capacity, item_count, top, stack) {
  this.top = top;
  this.stack = stack
};
cc.km_mat4_stack.INITIAL_SIZE = 30;
cc.km_mat4_stack_initialize = function(stack) {
  stack.stack = [];
  stack.top = null
};
cc.km_mat4_stack_push = function(stack, item) {
  stack.stack.push(stack.top);
  stack.top = new cc.kmMat4;
  cc.kmMat4Assign(stack.top, item)
};
cc.km_mat4_stack_pop = function(stack, pOut) {
  stack.top = stack.stack.pop()
};
cc.km_mat4_stack_release = function(stack) {
  stack.stack = null;
  stack.top = null;
  stack = null
};
cc.KM_GL_MODELVIEW = 5888;
cc.KM_GL_PROJECTION = 5889;
cc.KM_GL_TEXTURE = 5890;
cc.modelview_matrix_stack = new cc.km_mat4_stack;
cc.projection_matrix_stack = new cc.km_mat4_stack;
cc.texture_matrix_stack = new cc.km_mat4_stack;
cc.current_stack = null;
cc.initialized = false;
cc.lazyInitialize = function() {
  if(!cc.initialized) {
    var identity = new cc.kmMat4;
    cc.km_mat4_stack_initialize(cc.modelview_matrix_stack);
    cc.km_mat4_stack_initialize(cc.projection_matrix_stack);
    cc.km_mat4_stack_initialize(cc.texture_matrix_stack);
    cc.current_stack = cc.modelview_matrix_stack;
    cc.initialized = true;
    cc.kmMat4Identity(identity);
    cc.km_mat4_stack_push(cc.modelview_matrix_stack, identity);
    cc.km_mat4_stack_push(cc.projection_matrix_stack, identity);
    cc.km_mat4_stack_push(cc.texture_matrix_stack, identity)
  }
};
cc.lazyInitialize();
cc.kmGLFreeAll = function() {
  cc.km_mat4_stack_release(cc.modelview_matrix_stack);
  cc.km_mat4_stack_release(cc.projection_matrix_stack);
  cc.km_mat4_stack_release(cc.texture_matrix_stack);
  cc.initialized = false;
  cc.current_stack = null
};
cc.kmGLPushMatrix = function() {
  cc.km_mat4_stack_push(cc.current_stack, cc.current_stack.top)
};
cc.kmGLPushMatrixWitMat4 = function(saveMat) {
  cc.current_stack.stack.push(cc.current_stack.top);
  cc.kmMat4Assign(saveMat, cc.current_stack.top);
  cc.current_stack.top = saveMat
};
cc.kmGLPopMatrix = function() {
  cc.current_stack.top = cc.current_stack.stack.pop()
};
cc.kmGLMatrixMode = function(mode) {
  switch(mode) {
    case cc.KM_GL_MODELVIEW:
      cc.current_stack = cc.modelview_matrix_stack;
      break;
    case cc.KM_GL_PROJECTION:
      cc.current_stack = cc.projection_matrix_stack;
      break;
    case cc.KM_GL_TEXTURE:
      cc.current_stack = cc.texture_matrix_stack;
      break;
    default:
      cc.Assert(0, "Invalid matrix mode specified");
      break
  }
};
cc.kmGLLoadIdentity = function() {
  cc.kmMat4Identity(cc.current_stack.top)
};
cc.kmGLLoadMatrix = function(pIn) {
  cc.kmMat4Assign(cc.current_stack.top, pIn)
};
cc.kmGLMultMatrix = function(pIn) {
  cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, pIn)
};
cc.kmGLTranslatef = function(x, y, z) {
  var translation = new cc.kmMat4;
  cc.kmMat4Translation(translation, x, y, z);
  cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, translation)
};
cc.kmGLRotatef = function(angle, x, y, z) {
  var axis = new cc.kmVec3(x, y, z);
  var rotation = new cc.kmMat4;
  cc.kmMat4RotationAxisAngle(rotation, axis, cc.kmDegreesToRadians(angle));
  cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, rotation)
};
cc.kmGLScalef = function(x, y, z) {
  var scaling = new cc.kmMat4;
  cc.kmMat4Scaling(scaling, x, y, z);
  cc.kmMat4Multiply(cc.current_stack.top, cc.current_stack.top, scaling)
};
cc.kmGLGetMatrix = function(mode, pOut) {
  switch(mode) {
    case cc.KM_GL_MODELVIEW:
      cc.kmMat4Assign(pOut, cc.modelview_matrix_stack.top);
      break;
    case cc.KM_GL_PROJECTION:
      cc.kmMat4Assign(pOut, cc.projection_matrix_stack.top);
      break;
    case cc.KM_GL_TEXTURE:
      cc.kmMat4Assign(pOut, cc.texture_matrix_stack.top);
      break;
    default:
      cc.Assert(1, "Invalid matrix mode specified");
      break
  }
};
cc.Set = cc.Class.extend({ctor:function(setObject) {
  if(setObject) {
    this._set = [].concat(setObject._set)
  }else {
    this._set = []
  }
}, copy:function() {
  return new cc.Set(this)
}, mutableCopy:function() {
  return this.copy()
}, count:function() {
  return this._set.length
}, addObject:function(obj) {
  if(cc.ArrayContainsObject(this._set, obj)) {
    return
  }
  this._set.push(obj);
  this._set.sort(function(a, b) {
    return a - b
  })
}, removeObject:function(obj) {
  var k = 0;
  for(var i = 0, n = 0;i < this._set.length;i++) {
    if(this._set[i] != obj) {
      this._set[n++] = this._set[i];
      k++
    }
  }
  this._set.length = k
}, begin:function() {
  if(this._set && this._set.length > 0) {
    return this._set[0]
  }
  return null
}, end:function() {
  if(this._set && this._set.length > 0) {
    return this._set[this._set.length - 1]
  }
  return null
}, containsObject:function(obj) {
  return cc.ArrayContainsObject(this._set, obj)
}, anyObject:function() {
  if(this._set && this._set.length > 0) {
    return this._set[0]
  }else {
    return null
  }
}, _set:null});
cc.NSMutableSet = cc.Set;
cc.splitWithForm = function(content, strs) {
  do {
    if(!content) {
      break
    }
    if(content.length == 0) {
      break
    }
    var posLeft = content.indexOf("{");
    var posRight = content.indexOf("}");
    if(posLeft == -1 || posRight == -1) {
      break
    }
    if(posLeft > posRight) {
      break
    }
    var pointStr = content.substr(posLeft + 1, posRight - posLeft - 1);
    if(pointStr.length == 0) {
      break
    }
    var nPos1 = pointStr.indexOf("{");
    var nPos2 = pointStr.indexOf("}");
    if(nPos1 != -1 || nPos2 != -1) {
      break
    }
    strs = pointStr.split(",");
    if(strs.length != 2 || strs[0] != null || strs[1] != null) {
      break
    }
  }while(0);
  return strs
};
cc.RectFromString = function(content) {
  var result = cc.RectZero();
  do {
    if(!content) {
      break
    }
    var posLeft = content.indexOf("{") + 1;
    var posRight = content.lastIndexOf("}", content.length);
    if(posLeft == -1 || posRight == -1) {
      break
    }
    content = content.substring(posLeft, posRight);
    var nPointEnd = content.indexOf("}");
    if(nPointEnd == -1) {
      break
    }
    nPointEnd = content.indexOf(",", nPointEnd);
    if(nPointEnd == -1) {
      break
    }
    var pointStr = content.substr(0, nPointEnd);
    var sizeStr = content.substr(nPointEnd + 1, content.length - nPointEnd);
    var pointInfo = cc.splitWithForm(pointStr);
    var sizeInfo = cc.splitWithForm(sizeStr);
    var x = parseFloat(pointInfo[0]);
    var y = parseFloat(pointInfo[1]);
    var width = parseFloat(sizeInfo[0]);
    var height = parseFloat(sizeInfo[1]);
    result = cc.rect(x, y, width, height)
  }while(0);
  return result
};
cc.PointFromString = function(content) {
  var ret = cc.PointZero();
  try {
    if(content == "") {
      return ret
    }
    var strs = cc.splitWithForm(content);
    var x = parseFloat(strs[0]);
    var y = parseFloat(strs[1]);
    ret = cc.p(x, y)
  }catch(e) {
  }
  return ret
};
cc.SizeFromString = function(content) {
  var ret = cc.SizeZero();
  try {
    if(content == "") {
      return ret
    }
    var strs = cc.splitWithForm(content);
    var width = parseFloat(strs[0]);
    var height = parseFloat(strs[1]);
    ret = cc.size(width, height)
  }catch(e) {
  }
  return ret
};
cc.AffineTransform = function(a, b, c, d, tx, ty) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.d = d;
  this.tx = tx;
  this.ty = ty
};
cc.__AffineTransformMake = function(a, b, c, d, tx, ty) {
  return{a:a, b:b, c:c, d:d, tx:tx, ty:ty}
};
cc.AffineTransformMake = function(a, b, c, d, tx, ty) {
  return{a:a, b:b, c:c, d:d, tx:tx, ty:ty}
};
cc.__PointApplyAffineTransform = function(point, t) {
  return{x:t.a * point.x + t.c * point.y + t.tx, y:t.b * point.x + t.d * point.y + t.ty}
};
cc.PointApplyAffineTransform = function(point, t) {
  return{x:t.a * point.x + t.c * point.y + t.tx, y:t.b * point.x + t.d * point.y + t.ty}
};
cc.__SizeApplyAffineTransform = function(size, t) {
  return{width:t.a * size.width + t.c * size.height, height:t.b * size.width + t.d * size.height}
};
cc.SizeApplyAffineTransform = function(size, t) {
  return{width:t.a * size.width + t.c * size.height, height:t.b * size.width + t.d * size.height}
};
cc.AffineTransformMakeIdentity = function() {
  return{a:1, b:0, c:0, d:1, tx:0, ty:0}
};
cc.AffineTransformIdentity = function() {
  return{a:1, b:0, c:0, d:1, tx:0, ty:0}
};
cc.RectApplyAffineTransform = function(rect, anAffineTransform) {
  var top = cc.Rect.CCRectGetMinY(rect);
  var left = cc.Rect.CCRectGetMinX(rect);
  var right = cc.Rect.CCRectGetMaxX(rect);
  var bottom = cc.Rect.CCRectGetMaxY(rect);
  var topLeft = cc.PointApplyAffineTransform(cc.p(left, top), anAffineTransform);
  var topRight = cc.PointApplyAffineTransform(cc.p(right, top), anAffineTransform);
  var bottomLeft = cc.PointApplyAffineTransform(cc.p(left, bottom), anAffineTransform);
  var bottomRight = cc.PointApplyAffineTransform(cc.p(right, bottom), anAffineTransform);
  var minX = Math.min(Math.min(topLeft.x, topRight.x), Math.min(bottomLeft.x, bottomRight.x));
  var maxX = Math.max(Math.max(topLeft.x, topRight.x), Math.max(bottomLeft.x, bottomRight.x));
  var minY = Math.min(Math.min(topLeft.y, topRight.y), Math.min(bottomLeft.y, bottomRight.y));
  var maxY = Math.max(Math.max(topLeft.y, topRight.y), Math.max(bottomLeft.y, bottomRight.y));
  return cc.rect(minX, minY, maxX - minX, maxY - minY)
};
cc.AffineTransformTranslate = function(t, tx, ty) {
  return{a:t.a, b:t.b, c:t.c, d:t.d, tx:t.tx + t.a * tx + t.c * ty, ty:t.ty + t.b * tx + t.d * ty}
};
cc.AffineTransformScale = function(t, sx, sy) {
  return{a:t.a * sx, b:t.b * sx, c:t.c * sy, d:t.d * sy, tx:t.tx, ty:t.ty}
};
cc.AffineTransformRotate = function(aTransform, anAngle) {
  var fSin = Math.sin(anAngle);
  var fCos = Math.cos(anAngle);
  return{a:aTransform.a * fCos + aTransform.c * fSin, b:aTransform.b * fCos + aTransform.d * fSin, c:aTransform.c * fCos - aTransform.a * fSin, d:aTransform.d * fCos - aTransform.b * fSin, tx:aTransform.tx, ty:aTransform.ty}
};
cc.AffineTransformConcat = function(t1, t2) {
  return{a:t1.a * t2.a + t1.b * t2.c, b:t1.a * t2.b + t1.b * t2.d, c:t1.c * t2.a + t1.d * t2.c, d:t1.c * t2.b + t1.d * t2.d, tx:t1.tx * t2.a + t1.ty * t2.c + t2.tx, ty:t1.tx * t2.b + t1.ty * t2.d + t2.ty}
};
cc.AffineTransformEqualToTransform = function(t1, t2) {
  return t1.a === t2.a && t1.b === t2.b && t1.c === t2.c && t1.d === t2.d && t1.tx === t2.tx && t1.ty === t2.ty
};
cc.AffineTransformInvert = function(t) {
  var determinant = 1 / (t.a * t.d - t.b * t.c);
  return{a:determinant * t.d, b:-determinant * t.b, c:-determinant * t.c, d:determinant * t.a, tx:determinant * (t.c * t.ty - t.d * t.tx), ty:determinant * (t.b * t.tx - t.a * t.ty)}
};
cc.POINT_EPSILON = parseFloat("1.192092896e-07F");
cc.pNeg = function(point) {
  return cc.p(-point.x, -point.y)
};
cc.pAdd = function(v1, v2) {
  return cc.p(v1.x + v2.x, v1.y + v2.y)
};
cc.pSub = function(v1, v2) {
  return cc.p(v1.x - v2.x, v1.y - v2.y)
};
cc.pMult = function(point, floatVar) {
  return cc.p(point.x * floatVar, point.y * floatVar)
};
cc.pMidpoint = function(v1, v2) {
  return cc.pMult(cc.pAdd(v1, v2), 0.5)
};
cc.pDot = function(v1, v2) {
  return v1.x * v2.x + v1.y * v2.y
};
cc.pCross = function(v1, v2) {
  return v1.x * v2.y - v1.y * v2.x
};
cc.pPerp = function(point) {
  return cc.p(-point.y, point.x)
};
cc.pRPerp = function(point) {
  return cc.p(point.y, -point.x)
};
cc.pProject = function(v1, v2) {
  return cc.pMult(v2, cc.pDot(v1, v2) / cc.pDot(v2, v2))
};
cc.pRotate = function(v1, v2) {
  return cc.p(v1.x * v2.x - v1.y * v2.y, v1.x * v2.y + v1.y * v2.x)
};
cc.pUnrotate = function(v1, v2) {
  return cc.p(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y)
};
cc.pLengthSQ = function(v) {
  return cc.pDot(v, v)
};
cc.pDistanceSQ = function(point1, point2) {
  return cc.pLengthSQ(cc.pSub(point1, point2))
};
cc.pLength = function(v) {
  return Math.sqrt(cc.pLengthSQ(v))
};
cc.pDistance = function(v1, v2) {
  return cc.pLength(cc.pSub(v1, v2))
};
cc.pNormalize = function(v) {
  return cc.pMult(v, 1 / cc.pLength(v))
};
cc.pForAngle = function(a) {
  return cc.p(Math.cos(a), Math.sin(a))
};
cc.pToAngle = function(v) {
  return Math.atan2(v.y, v.x)
};
cc.clampf = function(value, min_inclusive, max_inclusive) {
  if(min_inclusive > max_inclusive) {
    var temp = min_inclusive;
    min_inclusive = max_inclusive;
    max_inclusive = temp
  }
  return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive
};
cc.pClamp = function(p, min_inclusive, max_inclusive) {
  return cc.p(cc.clampf(p.x, min_inclusive.x, max_inclusive.x), cc.clampf(p.y, min_inclusive.y, max_inclusive.y))
};
cc.pFromSize = function(s) {
  return cc.p(s.width, s.height)
};
cc.pCompOp = function(p, opFunc) {
  return cc.p(opFunc(p.x), opFunc(p.y))
};
cc.pLerp = function(a, b, alpha) {
  return cc.pAdd(cc.pMult(a, 1 - alpha), cc.pMult(b, alpha))
};
cc.pFuzzyEqual = function(a, b, variance) {
  if(a.x - variance <= b.x && b.x <= a.x + variance) {
    if(a.y - variance <= b.y && b.y <= a.y + variance) {
      return true
    }
  }
  return false
};
cc.pCompMult = function(a, b) {
  return cc.p(a.x * b.x, a.y * b.y)
};
cc.pAngleSigned = function(a, b) {
  var a2 = cc.pNormalize(a);
  var b2 = cc.pNormalize(b);
  var angle = Math.atan2(a2.x * b2.y - a2.y * b2.x, cc.pDot(a2, b2));
  if(Math.abs(angle) < cc.POINT_EPSILON) {
    return 0
  }
  return angle
};
cc.pAngle = function(a, b) {
  var angle = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
  if(Math.abs(angle) < cc.POINT_EPSILON) {
    return 0
  }
  return angle
};
cc.pRotateByAngle = function(v, pivot, angle) {
  var r = cc.pSub(v, pivot);
  var cosa = Math.cos(angle), sina = Math.sin(angle);
  var t = r.x;
  r.x = t * cosa - r.y * sina + pivot.x;
  r.y = t * sina + r.y * cosa + pivot.y;
  return r
};
cc.pLineIntersect = function(A, B, C, D, retP) {
  if(A.x == B.x && A.y == B.y || C.x == D.x && C.y == D.y) {
    return false
  }
  var BAx = B.x - A.x;
  var BAy = B.y - A.y;
  var DCx = D.x - C.x;
  var DCy = D.y - C.y;
  var ACx = A.x - C.x;
  var ACy = A.y - C.y;
  var denom = DCy * BAx - DCx * BAy;
  retP.x = DCx * ACy - DCy * ACx;
  retP.y = BAx * ACy - BAy * ACx;
  if(denom == 0) {
    if(retP.x == 0 || retP.y == 0) {
      return true
    }
    return false
  }
  retP.x = retP.x / denom;
  retP.y = retP.y / denom;
  return true
};
cc.pSegmentIntersect = function(A, B, C, D) {
  var retP = cc.p(0, 0);
  if(cc.pLineIntersect(A, B, C, D, retP)) {
    if(retP.x >= 0 && retP.x <= 1 && retP.y >= 0 && retP.y <= 1) {
      return true
    }
  }
  return false
};
cc.pIntersectPoint = function(A, B, C, D) {
  var retP = cc.p(0, 0);
  if(cc.pLineIntersect(A, B, C, D, retP)) {
    var P = cc.p(0, 0);
    P.x = A.x + retP.x * (B.x - A.x);
    P.y = A.y + retP.x * (B.y - A.y);
    return P
  }
  return cc.PointZero()
};
cc.pSameAs = function(A, B) {
  if(A != null && B != null) {
    return A.x == B.x && A.y == B.y
  }
  return false
};
cc.UserDefault = cc.Class.extend({_db:null, init:function() {
  this._db = this._getLocalStorage();
  return true
}, _getLocalStorage:function() {
  try {
    if(!!sys.localStorage) {
      return sys.localStorage
    }
  }catch(e) {
    return undefined
  }
}, _getWebSqlDatabase:function() {
}, getBoolForKey:function(key, defaultValue) {
  var value = this._getValueForKey(key);
  var ret = defaultValue || false;
  if(value == "true") {
    return true
  }else {
    if(value == "false") {
      return false
    }else {
      if(value) {
        return Boolean(value)
      }
    }
  }
  return ret
}, getIntegerForKey:function(key, defaultValue) {
  var value = this._getValueForKey(key);
  var ret = defaultValue || 0;
  if(value) {
    return parseInt(value)
  }
  return ret
}, getFloatForKey:function(key, defaultValue) {
  var value = this._getValueForKey(key);
  var ret = defaultValue || 0;
  if(value) {
    return parseFloat(value)
  }
  return ret
}, getDoubleForKey:function(key, defaultValue) {
  return this.getFloatForKey(key, defaultValue)
}, getStringForKey:function(key, defaultValue) {
  var value = this._getValueForKey(key);
  var ret = defaultValue || "";
  if(value) {
    return String(value)
  }
  return ret
}, _getValueForKey:function(key) {
  var ret;
  if(this._db) {
    ret = this._db.getItem(key)
  }
  return ret
}, setBoolForKey:function(key, value) {
  this.setStringForKey(key, String(value))
}, setIntegerForKey:function(key, value) {
  if(!key) {
    return
  }
  this._setValueForKey(key, parseInt(value))
}, setFloatForKey:function(key, value) {
  if(!key) {
    return
  }
  this._setValueForKey(key, parseFloat(value))
}, setDoubleForKey:function(key, value) {
  return this.setFloatForKey(key, value)
}, setStringForKey:function(key, value) {
  if(!key) {
    return
  }
  this._setValueForKey(key, String(value))
}, _setValueForKey:function(key, value) {
  if(this._db) {
    this._db.setItem(key, value)
  }
}});
cc.UserDefault.getInstance = function() {
  if(!this._sUserDefault) {
    this._sUserDefault = new cc.UserDefault;
    this._sUserDefault.init()
  }
  return this._sUserDefault
};
cc.UserDefault.purgeInstanceUserDefault = function() {
  if(cc.hasOwnProperty("Browser")) {
    if(this._db) {
      this._db.clear()
    }
  }
};
cc.UserDefault._sUserDefault = null;
cc.UserDefault._isFilePathInitialized = false;
cc.vertexLineToPolygon = function(points, stroke, vertices, offset, nuPoints) {
  nuPoints += offset;
  if(nuPoints <= 1) {
    return
  }
  stroke *= 0.5;
  var idx;
  var nuPointsMinus = nuPoints - 1;
  for(var i = offset;i < nuPoints;i++) {
    idx = i * 2;
    var p1 = cc.p(points[i * 2], points[i * 2 + 1]);
    var perpVector;
    if(i === 0) {
      perpVector = cc.pPerp(cc.pNormalize(cc.pSub(p1, cc.p(points[(i + 1) * 2], points[(i + 1) * 2 + 1]))))
    }else {
      if(i === nuPointsMinus) {
        perpVector = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(points[(i - 1) * 2], points[(i - 1) * 2 + 1]), p1)))
      }else {
        var p0 = cc.p(points[(i - 1) * 2], points[(i - 1) * 2 + 1]);
        var p2 = cc.p(points[(i + 1) * 2], points[(i + 1) * 2 + 1]);
        var p2p1 = cc.pNormalize(cc.pSub(p2, p1));
        var p0p1 = cc.pNormalize(cc.pSub(p0, p1));
        var angle = Math.acos(cc.pDot(p2p1, p0p1));
        if(angle < cc.DEGREES_TO_RADIANS(70)) {
          perpVector = cc.pPerp(cc.pNormalize(cc.pMidpoint(p2p1, p0p1)))
        }else {
          if(angle < cc.DEGREES_TO_RADIANS(170)) {
            perpVector = cc.pNormalize(cc.pMidpoint(p2p1, p0p1))
          }else {
            perpVector = cc.pPerp(cc.pNormalize(cc.pSub(p2, p0)))
          }
        }
      }
    }
    perpVector = cc.pMult(perpVector, stroke);
    vertices[idx * 2] = p1.x + perpVector.x;
    vertices[idx * 2 + 1] = p1.y + perpVector.y;
    vertices[(idx + 1) * 2] = p1.x - perpVector.x;
    vertices[(idx + 1) * 2 + 1] = p1.y - perpVector.y
  }
  offset = offset == 0 ? 0 : offset - 1;
  for(i = offset;i < nuPointsMinus;i++) {
    idx = i * 2;
    var idx1 = idx + 2;
    var v1 = cc.Vertex2(vertices[idx * 2], vertices[idx * 2 + 1]);
    var v2 = cc.Vertex2(vertices[(idx + 1) * 2], vertices[(idx + 1) * 2 + 1]);
    var v3 = cc.Vertex2(vertices[idx1 * 2], vertices[idx1 * 2]);
    var v4 = cc.Vertex2(vertices[(idx1 + 1) * 2], vertices[(idx1 + 1) * 2 + 1]);
    var fixVertexResult = !cc.vertexLineIntersect(v1.x, v1.y, v4.x, v4.y, v2.x, v2.y, v3.x, v3.y);
    if(!fixVertexResult.isSuccess) {
      if(fixVertexResult.value < 0 || fixVertexResult.value > 1) {
        fixVertexResult.isSuccess = true
      }
    }
    if(fixVertexResult.isSuccess) {
      vertices[idx1 * 2] = v4.x;
      vertices[idx1 * 2 + 1] = v4.y;
      vertices[(idx1 + 1) * 2] = v3.x;
      vertices[(idx1 + 1) * 2 + 1] = v3.y
    }
  }
};
cc.vertexLineIntersect = function(Ax, Ay, Bx, By, Cx, Cy, Dx, Dy) {
  var distAB, theCos, theSin, newX;
  if(Ax == Bx && Ay == By || Cx == Dx && Cy == Dy) {
    return{isSuccess:false, value:0}
  }
  Bx -= Ax;
  By -= Ay;
  Cx -= Ax;
  Cy -= Ay;
  Dx -= Ax;
  Dy -= Ay;
  distAB = Math.sqrt(Bx * Bx + By * By);
  theCos = Bx / distAB;
  theSin = By / distAB;
  newX = Cx * theCos + Cy * theSin;
  Cy = Cy * theCos - Cx * theSin;
  Cx = newX;
  newX = Dx * theCos + Dy * theSin;
  Dy = Dy * theCos - Dx * theSin;
  Dx = newX;
  if(Cy == Dy) {
    return{isSuccess:false, value:0}
  }
  var t = (Dx + (Cx - Dx) * Dy / (Dy - Cy)) / distAB;
  return{isSuccess:true, value:t}
};
cc.CGAffineToGL = function(trans, mat) {
  mat[2] = mat[3] = mat[6] = mat[7] = mat[8] = mat[9] = mat[11] = mat[14] = 0;
  mat[10] = mat[15] = 1;
  mat[0] = trans.a;
  mat[4] = trans.c;
  mat[12] = trans.tx;
  mat[1] = trans.b;
  mat[5] = trans.d;
  mat[13] = trans.ty
};
cc.GLToCGAffine = function(mat, trans) {
  trans.a = mat[0];
  trans.c = mat[4];
  trans.tx = mat[12];
  trans.b = mat[1];
  trans.d = mat[5];
  trans.ty = mat[13]
};
cc.TGA_OK = 0;
cc.TGA_ERROR_FILE_OPEN = 1;
cc.TGA_ERROR_READING_FILE = 2;
cc.TGA_ERROR_INDEXED_COLOR = 3;
cc.TGA_ERROR_MEMORY = 4;
cc.TGA_ERROR_COMPRESSED_FILE = 5;
cc.ImageTGA = function(status, type, pixelDepth, width, height, imageData, flipped) {
  this.status = status || 0;
  this.type = type || 0;
  this.pixelDepth = pixelDepth || 0;
  this.width = width || 0;
  this.height = height || 0;
  this.imageData = imageData || [];
  this.flipped = flipped || 0
};
cc.tgaLoadHeader = function(buffer, bufSize, psInfo) {
  var step = 2;
  if(step + 1 > bufSize) {
    return false
  }
  var binaryReader = new cc.BinaryStreamReader(buffer);
  binaryReader.setOffset(step);
  psInfo.type = binaryReader.readByte();
  step += 10;
  if(step + 4 + 1 > bufSize) {
    return false
  }
  binaryReader.setOffset(step);
  psInfo.width = binaryReader.readUnsignedShort();
  psInfo.height = binaryReader.readUnsignedInteger();
  psInfo.pixelDepth = binaryReader.readByte();
  step += 5;
  if(step + 1 > bufSize) {
    return false
  }
  var garbage = binaryReader.readByte();
  psInfo.flipped = 0;
  if(garbage & 32) {
    psInfo.flipped = 1
  }
  return true
};
cc.tgaLoadImageData = function(buffer, bufSize, psInfo) {
  var mode, total, i, aux;
  var step = 18;
  mode = 0 | psInfo.pixelDepth / 2;
  total = psInfo.height * psInfo.width * mode;
  if(step + total > bufSize) {
    return false
  }
  psInfo.imageData = cc.__getSubArray(buffer, step, step + total);
  if(mode >= 3) {
    for(i = 0;i < total;i += mode) {
      aux = psInfo.imageData[i];
      psInfo.imageData[i] = psInfo.imageData[i + 2];
      psInfo.imageData[i + 2] = aux
    }
  }
  return true
};
cc.tgaLoad = function(filename) {
  var buffer = cc.FileUtils.getInstance().getFileData(filename, "rb");
  var size = buffer.length;
  if(buffer == null) {
    return null
  }
  var info = new cc.ImageTGA;
  if(!cc.tgaLoadHeader(buffer, size, info)) {
    info.status = cc.TGA_ERROR_MEMORY;
    return info
  }
  if(info.type === 1) {
    info.status = cc.TGA_ERROR_INDEXED_COLOR;
    return info
  }
  if(info.type != 2 && info.type != 3 && info.type != 10) {
    info.status = cc.TGA_ERROR_COMPRESSED_FILE;
    return info
  }
  var bLoadImage = false;
  if(info.type == 10) {
    bLoadImage = cc.tgaLoadRLEImageData(buffer, size, info)
  }else {
    bLoadImage = cc.tgaLoadImageData(buffer, size, info)
  }
  if(!bLoadImage) {
    info.status = cc.TGA_ERROR_READING_FILE;
    return info
  }
  info.status = cc.TGA_OK;
  if(info.flipped) {
    cc.tgaFlipImage(info);
    if(info.flipped) {
      info.status = cc.TGA_ERROR_MEMORY
    }
  }
  buffer = null;
  return info
};
cc.tgaRGBtogreyscale = function(psInfo) {
  var i, j;
  if(psInfo.pixelDepth === 8) {
    return
  }
  var mode = psInfo.pixelDepth / 8;
  var newImageData = new Uint8Array(psInfo.height * psInfo.width);
  if(newImageData === null) {
    return
  }
  for(i = 0, j = 0;j < psInfo.width * psInfo.height;i += mode, j++) {
    newImageData[j] = 0.3 * psInfo.imageData[i] + 0.59 * psInfo.imageData[i + 1] + 0.11 * psInfo.imageData[i + 2]
  }
  psInfo.pixelDepth = 8;
  psInfo.type = 3;
  psInfo.imageData = newImageData
};
cc.tgaDestroy = function(psInfo) {
  if(!psInfo) {
    return
  }
  psInfo.imageData = null;
  psInfo = null
};
cc.tgaLoadRLEImageData = function(buffer, bufSize, psInfo) {
  var mode, total, i, index = 0, skip = 0, flag = 0;
  var aux = [], runlength = 0;
  var step = 18;
  mode = psInfo.pixelDepth / 8;
  total = psInfo.height * psInfo.width;
  for(i = 0;i < total;i++) {
    if(runlength != 0) {
      runlength--;
      skip = flag != 0
    }else {
      if(step + 1 > bufSize) {
        break
      }
      runlength = buffer[step];
      step += 1;
      flag = runlength & 128;
      if(flag) {
        runlength -= 128
      }
      skip = 0
    }
    if(!skip) {
      if(step + mode > bufSize) {
        break
      }
      aux = cc.__getSubArray(buffer, step, step + mode);
      step += mode;
      if(mode >= 3) {
        var tmp = aux[0];
        aux[0] = aux[2];
        aux[2] = tmp
      }
    }
    for(var j = 0;j < mode;j++) {
      psInfo.imageData[index + j] = aux[j]
    }
    index += mode
  }
  return true
};
cc.tgaFlipImage = function(psInfo) {
  var mode = psInfo.pixelDepth / 8;
  var rowbytes = psInfo.width * mode;
  for(var y = 0;y < psInfo.height / 2;y++) {
    var row = cc.__getSubArray(psInfo.imageData, y * rowbytes, y * rowbytes + rowbytes);
    cc.__setDataToArray(cc.__getSubArray(psInfo.imageData, (psInfo.height - (y + 1)) * rowbytes, rowbytes), psInfo.imageData, y * rowbytes);
    cc.__setDataToArray(row, psInfo.imageData, (psInfo.height - (y + 1)) * rowbytes)
  }
  psInfo.flipped = 0
};
cc.__getSubArray = function(array, start, end) {
  if(array instanceof Array) {
    return array.slice(start, end)
  }else {
    return array.subarray(start, end)
  }
};
cc.__setDataToArray = function(sourceData, destArray, startIndex) {
  for(var i = 0;i < sourceData.length;i++) {
    destArray[startIndex + i] = sourceData[i]
  }
};
cc.BinaryStreamReader = cc.Class.extend({_binaryData:null, _offset:0, ctor:function(binaryData) {
  this._binaryData = binaryData
}, setBinaryData:function(binaryData) {
  this._binaryData = binaryData;
  this._offset = 0
}, getBinaryData:function() {
  return this._binaryData
}, _checkSize:function(neededBits) {
  if(!(this._offset + Math.ceil(neededBits / 8) < this._data.length)) {
    throw new Error("Index out of bound");
  }
}, _decodeFloat:function(precisionBits, exponentBits) {
  var length = precisionBits + exponentBits + 1;
  var size = length >> 3;
  this._checkSize(length);
  var bias = Math.pow(2, exponentBits - 1) - 1;
  var signal = this._readBits(precisionBits + exponentBits, 1, size);
  var exponent = this._readBits(precisionBits, exponentBits, size);
  var significand = 0;
  var divisor = 2;
  var curByte = 0;
  do {
    var byteValue = this._readByte(++curByte, size);
    var startBit = precisionBits % 8 || 8;
    var mask = 1 << startBit;
    while(mask >>= 1) {
      if(byteValue & mask) {
        significand += 1 / divisor
      }
      divisor *= 2
    }
  }while(precisionBits -= startBit);
  this._offset += size;
  return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand) : 0)
}, _readByte:function(i, size) {
  return this._data[this._offset + size - i - 1]
}, _decodeInt:function(bits, signed) {
  var x = this._readBits(0, bits, bits / 8), max = Math.pow(2, bits);
  var result = signed && x >= max / 2 ? x - max : x;
  this._offset += bits / 8;
  return result
}, _shl:function(a, b) {
  for(++b;--b;a = ((a %= 2147483647 + 1) & 1073741824) == 1073741824 ? a * 2 : (a - 1073741824) * 2 + 2147483647 + 1) {
  }
  return a
}, _readBits:function(start, length, size) {
  var offsetLeft = (start + length) % 8;
  var offsetRight = start % 8;
  var curByte = size - (start >> 3) - 1;
  var lastByte = size + (-(start + length) >> 3);
  var diff = curByte - lastByte;
  var sum = this._readByte(curByte, size) >> offsetRight & (1 << (diff ? 8 - offsetRight : length)) - 1;
  if(diff && offsetLeft) {
    sum += (this._readByte(lastByte++, size) & (1 << offsetLeft) - 1) << (diff-- << 3) - offsetRight
  }
  while(diff) {
    sum += this._shl(this._readByte(lastByte++, size), (diff-- << 3) - offsetRight)
  }
  return sum
}, readInteger:function() {
  return this._decodeInt(32, true)
}, readUnsignedInteger:function() {
  return this._decodeInt(32, false)
}, readSingle:function() {
  return this._decodeFloat(23, 8)
}, readShort:function() {
  return this._decodeInt(16, true)
}, readUnsignedShort:function() {
  return this._decodeInt(16, false)
}, readByte:function() {
  var readByte = this._data[this._offset];
  this._offset += 1;
  return readByte
}, readData:function(start, end) {
  if(this._binaryData instanceof Array) {
    return this._binaryData.slice(start, end)
  }else {
    return this._binaryData.subarray(start, end)
  }
}, setOffset:function(offset) {
  this._offset = offset
}, getOffset:function() {
  return this._offset
}});
cc.PNGReader = cc.Class.extend({ctor:function(data) {
  var chunkSize, colors, delayDen, delayNum, frame, i, index, key, section, ccshort, text, _i, _j, _ref;
  this.data = data;
  this.pos = 8;
  this.palette = [];
  this.imgData = [];
  this.transparency = {};
  this.animation = null;
  this.text = {};
  frame = null;
  while(true) {
    chunkSize = this.readUInt32();
    section = function() {
      var _i, _results;
      _results = [];
      for(i = _i = 0;_i < 4;i = ++_i) {
        _results.push(String.fromCharCode(this.data[this.pos++]))
      }
      return _results
    }.call(this).join("");
    switch(section) {
      case "IHDR":
        this.width = this.readUInt32();
        this.height = this.readUInt32();
        this.bits = this.data[this.pos++];
        this.colorType = this.data[this.pos++];
        this.compressionMethod = this.data[this.pos++];
        this.filterMethod = this.data[this.pos++];
        this.interlaceMethod = this.data[this.pos++];
        break;
      case "acTL":
        this.animation = {numFrames:this.readUInt32(), numPlays:this.readUInt32() || Infinity, frames:[]};
        break;
      case "PLTE":
        this.palette = this.read(chunkSize);
        break;
      case "fcTL":
        if(frame) {
          this.animation.frames.push(frame)
        }
        this.pos += 4;
        frame = {width:this.readUInt32(), height:this.readUInt32(), xOffset:this.readUInt32(), yOffset:this.readUInt32()};
        delayNum = this.readUInt16();
        delayDen = this.readUInt16() || 100;
        frame.delay = 1E3 * delayNum / delayDen;
        frame.disposeOp = this.data[this.pos++];
        frame.blendOp = this.data[this.pos++];
        frame.data = [];
        break;
      case "IDAT":
      ;
      case "fdAT":
        if(section === "fdAT") {
          this.pos += 4;
          chunkSize -= 4
        }
        data = (frame != null ? frame.data : void 0) || this.imgData;
        for(i = _i = 0;0 <= chunkSize ? _i < chunkSize : _i > chunkSize;i = 0 <= chunkSize ? ++_i : --_i) {
          data.push(this.data[this.pos++])
        }
        break;
      case "tRNS":
        this.transparency = {};
        switch(this.colorType) {
          case 3:
            this.transparency.indexed = this.read(chunkSize);
            ccshort = 255 - this.transparency.indexed.length;
            if(ccshort > 0) {
              for(i = _j = 0;0 <= ccshort ? _j < ccshort : _j > ccshort;i = 0 <= ccshort ? ++_j : --_j) {
                this.transparency.indexed.push(255)
              }
            }
            break;
          case 0:
            this.transparency.grayscale = this.read(chunkSize)[0];
            break;
          case 2:
            this.transparency.rgb = this.read(chunkSize)
        }
        break;
      case "tEXt":
        text = this.read(chunkSize);
        index = text.indexOf(0);
        key = String.fromCharCode.apply(String, text.slice(0, index));
        this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
        break;
      case "IEND":
        if(frame) {
          this.animation.frames.push(frame)
        }
        this.colors = function() {
          switch(this.colorType) {
            case 0:
            ;
            case 3:
            ;
            case 4:
              return 1;
            case 2:
            ;
            case 6:
              return 3
          }
        }.call(this);
        this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;
        colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
        this.pixelBitlength = this.bits * colors;
        this.colorSpace = function() {
          switch(this.colors) {
            case 1:
              return"DeviceGray";
            case 3:
              return"DeviceRGB"
          }
        }.call(this);
        if(Uint8Array != Array) {
          this.imgData = new Uint8Array(this.imgData)
        }
        return;
      default:
        this.pos += chunkSize
    }
    this.pos += 4;
    if(this.pos > this.data.length) {
      throw new Error("Incomplete or corrupt PNG file");
    }
  }
}, read:function(bytes) {
  var i, _i, _results;
  _results = [];
  for(i = _i = 0;0 <= bytes ? _i < bytes : _i > bytes;i = 0 <= bytes ? ++_i : --_i) {
    _results.push(this.data[this.pos++])
  }
  return _results
}, readUInt32:function() {
  var b1, b2, b3, b4;
  b1 = this.data[this.pos++] << 24;
  b2 = this.data[this.pos++] << 16;
  b3 = this.data[this.pos++] << 8;
  b4 = this.data[this.pos++];
  return b1 | b2 | b3 | b4
}, readUInt16:function() {
  var b1, b2;
  b1 = this.data[this.pos++] << 8;
  b2 = this.data[this.pos++];
  return b1 | b2
}, decodePixels:function(data) {
  var ccbyte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;
  if(data == null) {
    data = this.imgData
  }
  if(data.length === 0) {
    return new Uint8Array(0)
  }
  var inflate = new Zlib.Inflate(data, {index:0, verify:false});
  data = inflate.decompress();
  pixelBytes = this.pixelBitlength / 8;
  scanlineLength = pixelBytes * this.width;
  pixels = new Uint8Array(scanlineLength * this.height);
  length = data.length;
  row = 0;
  pos = 0;
  c = 0;
  while(pos < length) {
    switch(data[pos++]) {
      case 0:
        for(i = _i = 0;_i < scanlineLength;i = _i += 1) {
          pixels[c++] = data[pos++]
        }
        break;
      case 1:
        for(i = _j = 0;_j < scanlineLength;i = _j += 1) {
          ccbyte = data[pos++];
          left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
          pixels[c++] = (ccbyte + left) % 256
        }
        break;
      case 2:
        for(i = _k = 0;_k < scanlineLength;i = _k += 1) {
          ccbyte = data[pos++];
          col = (i - i % pixelBytes) / pixelBytes;
          upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
          pixels[c++] = (upper + ccbyte) % 256
        }
        break;
      case 3:
        for(i = _l = 0;_l < scanlineLength;i = _l += 1) {
          ccbyte = data[pos++];
          col = (i - i % pixelBytes) / pixelBytes;
          left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
          upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
          pixels[c++] = (ccbyte + Math.floor((left + upper) / 2)) % 256
        }
        break;
      case 4:
        for(i = _m = 0;_m < scanlineLength;i = _m += 1) {
          ccbyte = data[pos++];
          col = (i - i % pixelBytes) / pixelBytes;
          left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
          if(row === 0) {
            upper = upperLeft = 0
          }else {
            upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
            upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes]
          }
          p = left + upper - upperLeft;
          pa = Math.abs(p - left);
          pb = Math.abs(p - upper);
          pc = Math.abs(p - upperLeft);
          if(pa <= pb && pa <= pc) {
            paeth = left
          }else {
            if(pb <= pc) {
              paeth = upper
            }else {
              paeth = upperLeft
            }
          }
          pixels[c++] = (ccbyte + paeth) % 256
        }
        break;
      default:
        throw new Error("Invalid filter algorithm: " + data[pos - 1]);
    }
    row++
  }
  return pixels
}, copyToImageData:function(imageData, pixels) {
  var alpha, colors, data, i, input, j, k, length, palette, v, _ref;
  colors = this.colors;
  palette = null;
  alpha = this.hasAlphaChannel;
  if(this.palette.length) {
    palette = (_ref = this._decodedPalette) != null ? _ref : this._decodedPalette = this.decodePalette();
    colors = 4;
    alpha = true
  }
  data = imageData.data || imageData;
  length = data.length;
  input = palette || pixels;
  i = j = 0;
  if(colors === 1) {
    while(i < length) {
      k = palette ? pixels[i / 4] * 4 : j;
      v = input[k++];
      data[i++] = v;
      data[i++] = v;
      data[i++] = v;
      data[i++] = alpha ? input[k++] : 255;
      j = k
    }
  }else {
    while(i < length) {
      k = palette ? pixels[i / 4] * 4 : j;
      data[i++] = input[k++];
      data[i++] = input[k++];
      data[i++] = input[k++];
      data[i++] = alpha ? input[k++] : 255;
      j = k
    }
  }
}, decodePalette:function() {
  var c, i, palette, pos, ret, transparency, _i, _ref, _ref1;
  palette = this.palette;
  transparency = this.transparency.indexed || [];
  ret = new Uint8Array((transparency.length || 0) + palette.length);
  pos = 0;
  c = 0;
  for(i = _i = 0, _ref = palette.length;_i < _ref;i = _i += 3) {
    ret[pos++] = palette[i];
    ret[pos++] = palette[i + 1];
    ret[pos++] = palette[i + 2];
    ret[pos++] = (_ref1 = transparency[c++]) != null ? _ref1 : 255
  }
  return ret
}, render:function(canvas) {
  var ctx, data;
  canvas.width = this.width;
  canvas.height = this.height;
  ctx = canvas.getContext("2d");
  data = ctx.createImageData(this.width, this.height);
  this.copyToImageData(data, this.decodePixels());
  return ctx.putImageData(data, 0, 0)
}});
cc.TIFFReader = cc.Class.extend({_littleEndian:false, _tiffData:null, _fileDirectories:null, ctor:function() {
  this._fileDirectories = []
}, getUint8:function(offset) {
  return this._tiffData[offset]
}, getUint16:function(offset) {
  if(this._littleEndian) {
    return this._tiffData[offset + 1] << 8 | this._tiffData[offset]
  }else {
    return this._tiffData[offset] << 8 | this._tiffData[offset + 1]
  }
}, getUint32:function(offset) {
  var a = this._tiffData;
  if(this._littleEndian) {
    return a[offset + 3] << 24 | a[offset + 2] << 16 | a[offset + 1] << 8 | a[offset]
  }else {
    return a[offset] << 24 | a[offset + 1] << 16 | a[offset + 2] << 8 | a[offset + 3]
  }
}, checkLittleEndian:function() {
  var BOM = this.getUint16(0);
  if(BOM === 18761) {
    this.littleEndian = true
  }else {
    if(BOM === 19789) {
      this.littleEndian = false
    }else {
      console.log(BOM);
      throw TypeError("Invalid byte order value.");
    }
  }
  return this.littleEndian
}, hasTowel:function() {
  if(this.getUint16(2) !== 42) {
    throw RangeError("You forgot your towel!");return false
  }
  return true
}, getFieldTypeName:function(fieldType) {
  var typeNames = this.fieldTypeNames;
  if(fieldType in typeNames) {
    return typeNames[fieldType]
  }
  return null
}, getFieldTagName:function(fieldTag) {
  var tagNames = this.fieldTagNames;
  if(fieldTag in tagNames) {
    return tagNames[fieldTag]
  }else {
    console.log("Unknown Field Tag:", fieldTag);
    return"Tag" + fieldTag
  }
}, getFieldTypeLength:function(fieldTypeName) {
  if(["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(fieldTypeName) !== -1) {
    return 1
  }else {
    if(["SHORT", "SSHORT"].indexOf(fieldTypeName) !== -1) {
      return 2
    }else {
      if(["LONG", "SLONG", "FLOAT"].indexOf(fieldTypeName) !== -1) {
        return 4
      }else {
        if(["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(fieldTypeName) !== -1) {
          return 8
        }
      }
    }
  }
  return null
}, getFieldValues:function(fieldTagName, fieldTypeName, typeCount, valueOffset) {
  var fieldValues = [];
  var fieldTypeLength = this.getFieldTypeLength(fieldTypeName);
  var fieldValueSize = fieldTypeLength * typeCount;
  if(fieldValueSize <= 4) {
    if(this.littleEndian === false) {
      fieldValues.push(valueOffset >>> (4 - fieldTypeLength) * 8)
    }else {
      fieldValues.push(valueOffset)
    }
  }else {
    for(var i = 0;i < typeCount;i++) {
      var indexOffset = fieldTypeLength * i;
      if(fieldTypeLength >= 8) {
        if(["RATIONAL", "SRATIONAL"].indexOf(fieldTypeName) !== -1) {
          fieldValues.push(this.getUint32(valueOffset + indexOffset));
          fieldValues.push(this.getUint32(valueOffset + indexOffset + 4))
        }else {
          cc.log("Can't handle this field type or size")
        }
      }else {
        fieldValues.push(this.getBytes(fieldTypeLength, valueOffset + indexOffset))
      }
    }
  }
  if(fieldTypeName === "ASCII") {
    fieldValues.forEach(function(e, i, a) {
      a[i] = String.fromCharCode(e)
    })
  }
  return fieldValues
}, getBytes:function(numBytes, offset) {
  if(numBytes <= 0) {
    cc.log("No bytes requested")
  }else {
    if(numBytes <= 1) {
      return this.getUint8(offset)
    }else {
      if(numBytes <= 2) {
        return this.getUint16(offset)
      }else {
        if(numBytes <= 3) {
          return this.getUint32(offset) >>> 8
        }else {
          if(numBytes <= 4) {
            return this.getUint32(offset)
          }else {
            cc.log("Too many bytes requested")
          }
        }
      }
    }
  }
}, getBits:function(numBits, byteOffset, bitOffset) {
  bitOffset = bitOffset || 0;
  var extraBytes = Math.floor(bitOffset / 8);
  var newByteOffset = byteOffset + extraBytes;
  var totalBits = bitOffset + numBits;
  var shiftRight = 32 - numBits;
  var shiftLeft, rawBits;
  if(totalBits <= 0) {
    console.log("No bits requested")
  }else {
    if(totalBits <= 8) {
      shiftLeft = 24 + bitOffset;
      rawBits = this.getUint8(newByteOffset)
    }else {
      if(totalBits <= 16) {
        shiftLeft = 16 + bitOffset;
        rawBits = this.getUint16(newByteOffset)
      }else {
        if(totalBits <= 32) {
          shiftLeft = bitOffset;
          rawBits = this.getUint32(newByteOffset)
        }else {
          console.log("Too many bits requested")
        }
      }
    }
  }
  return{"bits":rawBits << shiftLeft >>> shiftRight, "byteOffset":newByteOffset + Math.floor(totalBits / 8), "bitOffset":totalBits % 8}
}, parseFileDirectory:function(byteOffset) {
  var numDirEntries = this.getUint16(byteOffset);
  var tiffFields = [];
  for(var i = byteOffset + 2, entryCount = 0;entryCount < numDirEntries;i += 12, entryCount++) {
    var fieldTag = this.getUint16(i);
    var fieldType = this.getUint16(i + 2);
    var typeCount = this.getUint32(i + 4);
    var valueOffset = this.getUint32(i + 8);
    var fieldTagName = this.getFieldTagName(fieldTag);
    var fieldTypeName = this.getFieldTypeName(fieldType);
    var fieldValues = this.getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);
    tiffFields[fieldTagName] = {type:fieldTypeName, values:fieldValues}
  }
  this.fileDirectories.push(tiffFields);
  var nextIFDByteOffset = this.getUint32(i);
  if(nextIFDByteOffset !== 0) {
    this.parseFileDirectory(nextIFDByteOffset)
  }
}, clampColorSample:function(colorSample, bitsPerSample) {
  var multiplier = Math.pow(2, 8 - bitsPerSample);
  return Math.floor(colorSample * multiplier + (multiplier - 1))
}, parseTIFF:function(tiffData, canvas) {
  canvas = canvas || document.createElement("canvas");
  this._tiffData = tiffData;
  this.canvas = canvas;
  this.checkLittleEndian();
  if(!this.hasTowel()) {
    return
  }
  var firstIFDByteOffset = this.getUint32(4);
  this.fileDirectories = [];
  this.parseFileDirectory(firstIFDByteOffset);
  var fileDirectory = this.fileDirectories[0];
  var imageWidth = fileDirectory["ImageWidth"].values[0];
  var imageLength = fileDirectory["ImageLength"].values[0];
  this.canvas.width = imageWidth;
  this.canvas.height = imageLength;
  var strips = [];
  var compression = fileDirectory["Compression"] ? fileDirectory["Compression"].values[0] : 1;
  var samplesPerPixel = fileDirectory["SamplesPerPixel"].values[0];
  var sampleProperties = [];
  var bitsPerPixel = 0;
  var hasBytesPerPixel = false;
  fileDirectory["BitsPerSample"].values.forEach(function(bitsPerSample, i, bitsPerSampleValues) {
    sampleProperties[i] = {"bitsPerSample":bitsPerSample, "hasBytesPerSample":false, "bytesPerSample":undefined};
    if(bitsPerSample % 8 === 0) {
      sampleProperties[i].hasBytesPerSample = true;
      sampleProperties[i].bytesPerSample = bitsPerSample / 8
    }
    bitsPerPixel += bitsPerSample
  }, this);
  if(bitsPerPixel % 8 === 0) {
    hasBytesPerPixel = true;
    var bytesPerPixel = bitsPerPixel / 8
  }
  var stripOffsetValues = fileDirectory["StripOffsets"].values;
  var numStripOffsetValues = stripOffsetValues.length;
  if(fileDirectory["StripByteCounts"]) {
    var stripByteCountValues = fileDirectory["StripByteCounts"].values
  }else {
    cc.log("Missing StripByteCounts!");
    if(numStripOffsetValues === 1) {
      var stripByteCountValues = [Math.ceil(imageWidth * imageLength * bitsPerPixel / 8)]
    }else {
      throw Error("Cannot recover from missing StripByteCounts");
    }
  }
  for(var i = 0;i < numStripOffsetValues;i++) {
    var stripOffset = stripOffsetValues[i];
    strips[i] = [];
    var stripByteCount = stripByteCountValues[i];
    for(var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0;byteOffset < stripByteCount;byteOffset += jIncrement) {
      switch(compression) {
        case 1:
          for(var m = 0, pixel = [];m < samplesPerPixel;m++) {
            if(sampleProperties[m].hasBytesPerSample) {
              var sampleOffset = sampleProperties[m].bytesPerSample * m;
              pixel.push(this.getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset))
            }else {
              var sampleInfo = this.getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);
              pixel.push(sampleInfo.bits);
              byteOffset = sampleInfo.byteOffset - stripOffset;
              bitOffset = sampleInfo.bitOffset;
              throw RangeError("Cannot handle sub-byte bits per sample");
            }
          }
          strips[i].push(pixel);
          if(hasBytesPerPixel) {
            jIncrement = bytesPerPixel
          }else {
            jIncrement = 0;
            throw RangeError("Cannot handle sub-byte bits per pixel");
          }
          break;
        case 2:
          break;
        case 3:
          break;
        case 4:
          break;
        case 5:
          break;
        case 6:
          break;
        case 7:
          break;
        case 32773:
          if(getHeader) {
            getHeader = false;
            var blockLength = 1;
            var iterations = 1;
            var header = this.getInt8(stripOffset + byteOffset);
            if(header >= 0 && header <= 127) {
              blockLength = header + 1
            }else {
              if(header >= -127 && header <= -1) {
                iterations = -header + 1
              }else {
                getHeader = true
              }
            }
          }else {
            var currentByte = this.getUint8(stripOffset + byteOffset);
            for(var m = 0;m < iterations;m++) {
              if(sampleProperties[sample].hasBytesPerSample) {
                currentSample = currentSample << 8 * numBytes | currentByte;
                numBytes++;
                if(numBytes === sampleProperties[sample].bytesPerSample) {
                  pixel.push(currentSample);
                  currentSample = numBytes = 0;
                  sample++
                }
              }else {
                throw RangeError("Cannot handle sub-byte bits per sample");
              }
              if(sample === samplesPerPixel) {
                strips[i].push(pixel);
                pixel = [];
                sample = 0
              }
            }
            blockLength--;
            if(blockLength === 0) {
              getHeader = true
            }
          }
          jIncrement = 1;
          break;
        default:
          break
      }
    }
  }
  if(canvas.getContext) {
    var ctx = this.canvas.getContext("2d");
    ctx.fillStyle = "rgba(255, 255, 255, 0)";
    var rowsPerStrip = fileDirectory["RowsPerStrip"] ? fileDirectory["RowsPerStrip"].values[0] : imageLength;
    var numStrips = strips.length;
    var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;
    var rowsInLastStrip = imageLengthModRowsPerStrip === 0 ? rowsPerStrip : imageLengthModRowsPerStrip;
    var numRowsInStrip = rowsPerStrip;
    var numRowsInPreviousStrip = 0;
    var photometricInterpretation = fileDirectory["PhotometricInterpretation"].values[0];
    var extraSamplesValues = [];
    var numExtraSamples = 0;
    if(fileDirectory["ExtraSamples"]) {
      extraSamplesValues = fileDirectory["ExtraSamples"].values;
      numExtraSamples = extraSamplesValues.length
    }
    if(fileDirectory["ColorMap"]) {
      var colorMapValues = fileDirectory["ColorMap"].values;
      var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample)
    }
    for(var i = 0;i < numStrips;i++) {
      if(i + 1 === numStrips) {
        numRowsInStrip = rowsInLastStrip
      }
      var numPixels = strips[i].length;
      var yPadding = numRowsInPreviousStrip * i;
      for(var y = 0, j = 0;y < numRowsInStrip, j < numPixels;y++) {
        for(var x = 0;x < imageWidth;x++, j++) {
          var pixelSamples = strips[i][j];
          var red = 0;
          var green = 0;
          var blue = 0;
          var opacity = 1;
          if(numExtraSamples > 0) {
            for(var k = 0;k < numExtraSamples;k++) {
              if(extraSamplesValues[k] === 1 || extraSamplesValues[k] === 2) {
                opacity = pixelSamples[3 + k] / 256;
                break
              }
            }
          }
          switch(photometricInterpretation) {
            case 0:
              if(sampleProperties[0].hasBytesPerSample) {
                var invertValue = Math.pow(16, sampleProperties[0].bytesPerSample * 2)
              }
              pixelSamples.forEach(function(sample, index, samples) {
                samples[index] = invertValue - sample
              });
            case 1:
              red = green = blue = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
              break;
            case 2:
              red = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
              green = this.clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);
              blue = this.clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);
              break;
            case 3:
              if(colorMapValues === undefined) {
                throw Error("Palette image missing color map");
              }
              var colorMapIndex = pixelSamples[0];
              red = this.clampColorSample(colorMapValues[colorMapIndex], 16);
              green = this.clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);
              blue = this.clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);
              break;
            default:
              throw RangeError("Unknown Photometric Interpretation:", photometricInterpretation);break
          }
          ctx.fillStyle = "rgba(" + red + ", " + green + ", " + blue + ", " + opacity + ")";
          ctx.fillRect(x, yPadding + y, 1, 1)
        }
      }
      numRowsInPreviousStrip = numRowsInStrip
    }
  }
  return this.canvas
}, fieldTagNames:{315:"Artist", 258:"BitsPerSample", 265:"CellLength", 264:"CellWidth", 320:"ColorMap", 259:"Compression", 33432:"Copyright", 306:"DateTime", 338:"ExtraSamples", 266:"FillOrder", 289:"FreeByteCounts", 288:"FreeOffsets", 291:"GrayResponseCurve", 290:"GrayResponseUnit", 316:"HostComputer", 270:"ImageDescription", 257:"ImageLength", 256:"ImageWidth", 271:"Make", 281:"MaxSampleValue", 280:"MinSampleValue", 272:"Model", 254:"NewSubfileType", 274:"Orientation", 262:"PhotometricInterpretation", 
284:"PlanarConfiguration", 296:"ResolutionUnit", 278:"RowsPerStrip", 277:"SamplesPerPixel", 305:"Software", 279:"StripByteCounts", 273:"StripOffsets", 255:"SubfileType", 263:"Threshholding", 282:"XResolution", 283:"YResolution", 326:"BadFaxLines", 327:"CleanFaxData", 343:"ClipPath", 328:"ConsecutiveBadFaxLines", 433:"Decode", 434:"DefaultImageColor", 269:"DocumentName", 336:"DotRange", 321:"HalftoneHints", 346:"Indexed", 347:"JPEGTables", 285:"PageName", 297:"PageNumber", 317:"Predictor", 319:"PrimaryChromaticities", 
532:"ReferenceBlackWhite", 339:"SampleFormat", 559:"StripRowCounts", 330:"SubIFDs", 292:"T4Options", 293:"T6Options", 325:"TileByteCounts", 323:"TileLength", 324:"TileOffsets", 322:"TileWidth", 301:"TransferFunction", 318:"WhitePoint", 344:"XClipPathUnits", 286:"XPosition", 529:"YCbCrCoefficients", 531:"YCbCrPositioning", 530:"YCbCrSubSampling", 345:"YClipPathUnits", 287:"YPosition", 37378:"ApertureValue", 40961:"ColorSpace", 36868:"DateTimeDigitized", 36867:"DateTimeOriginal", 34665:"Exif IFD", 
36864:"ExifVersion", 33434:"ExposureTime", 41728:"FileSource", 37385:"Flash", 40960:"FlashpixVersion", 33437:"FNumber", 42016:"ImageUniqueID", 37384:"LightSource", 37500:"MakerNote", 37377:"ShutterSpeedValue", 37510:"UserComment", 33723:"IPTC", 34675:"ICC Profile", 700:"XMP", 42112:"GDAL_METADATA", 42113:"GDAL_NODATA", 34377:"Photoshop"}, fieldTypeNames:{1:"BYTE", 2:"ASCII", 3:"SHORT", 4:"LONG", 5:"RATIONAL", 6:"SBYTE", 7:"UNDEFINED", 8:"SSHORT", 9:"SLONG", 10:"SRATIONAL", 11:"FLOAT", 12:"DOUBLE"}});
cc.TIFFReader.__instance = null;
cc.TIFFReader.getInstance = function() {
  if(!cc.TIFFReader.__instance) {
    cc.TIFFReader.__instance = new cc.TIFFReader
  }
  return cc.TIFFReader.__instance
};
cc.SHADER_POSITION_UCOLOR_FRAG = "                                           \n" + "precision lowp float;                    \n" + "                                         \n" + "varying vec4 v_fragmentColor;            \n" + "                                         \n" + "void main()                              \n" + "{                                        \n" + "    gl_FragColor = v_fragmentColor;      \n" + "}                                        \n";
cc.SHADER_POSITION_UCOLOR_VERT = "                                               \n" + "attribute vec4 a_position;               \n" + "uniform    vec4 u_color;                 \n" + "uniform float u_pointSize;               \n" + "                                         \n" + "varying lowp vec4 v_fragmentColor;       \n" + "                                         \n" + "void main(void)                          \n" + "{                                        \n" + "    gl_Position = CC_MVPMatrix * a_position; \n" + 
"    gl_PointSize = u_pointSize;          \n" + "    v_fragmentColor = u_color;           \n" + "}";
cc.SHADER_POSITION_COLOR_FRAG = "                                        \n" + "precision lowp float;                 \n" + "varying vec4 v_fragmentColor;         \n" + "                                      \n" + "void main()                           \n" + "{                                     \n" + "     gl_FragColor = v_fragmentColor;       \n" + "} ";
cc.SHADER_POSITION_COLOR_VERT = "                                                \n" + "attribute vec4 a_position;                \n" + "attribute vec4 a_color;                   \n" + "                                          \n" + "varying lowp vec4 v_fragmentColor;        \n" + "                                          \n" + "void main()                               \n" + "{                                         \n" + "   gl_Position = CC_MVPMatrix * a_position; \n" + "    v_fragmentColor = a_color;             \n" + 
"}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "                                               \n" + "// #extension GL_OES_standard_derivatives : enable\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n" + "\n" + "varying mediump vec4 v_color;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n" + "varying mediump vec2 v_texcoord;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    \n" + "\n" + "void main()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n" + "{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n" + 
"// #if defined GL_OES_standard_derivatives\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n" + "// gl_FragColor = v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord));\t\t\t\t\t\t\t    \n" + "// #else\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n" + "gl_FragColor = v_color * step(0.0, 1.0 - length(v_texcoord));\t\t\t\t\t\t\t\t\t\t\t\t\t\t        \n" + "// #endif\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n" + "}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t        \n" + "attribute mediump vec4 a_position;\t\t\t\t\t\t\t\t\t\n" + "attribute mediump vec2 a_texcoord;\t\t\t\t\t\t\t\t\t\n" + "attribute mediump vec4 a_color;\t\t\t\t\t\t\t\t\t\t\n" + "\n" + "varying mediump vec4 v_color;\t\t\t\t\t\t\t\t\t\t\n" + "varying mediump vec2 v_texcoord;\t\t\t\t\t\t\t\t\t    \n" + "\n" + "void main()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n" + "{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n" + "     v_color = a_color;//vec4(a_color.rgb * a_color.a, a_color.a);\t\t\t\t\n" + 
"     v_texcoord = a_texcoord;\t\t\t\t\t\t\t\t\t\t\n" + "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t        \n" + "     gl_Position = CC_MVPMatrix * a_position;\t\t\t\t\t\t\n" + "}";
cc.SHADER_POSITION_TEXTURE_FRAG = "                                             \n" + "precision lowp float;                      \n" + "                                           \n" + "varying vec2 v_texCoord;                   \n" + "uniform sampler2D CC_Texture0;             \n" + "                                           \n" + "void main()                                \n" + "{                                          \n" + "    gl_FragColor =  texture2D(CC_Texture0, v_texCoord);   \n" + 
"}";
cc.SHADER_POSITION_TEXTURE_VERT = "                                                   \n" + "attribute vec4 a_position;                   \n" + "attribute vec2 a_texCoord;                  \n" + "                                            \n" + "varying mediump vec2 v_texCoord;           \n" + "                                           \n" + "void main()                                \n" + "{                                          \n" + "    gl_Position = CC_MVPMatrix * a_position; \n" + "    v_texCoord = a_texCoord;               \n" + 
"}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "                                                \n" + "precision lowp float;                        \n" + "                                             \n" + "uniform vec4 u_color;                        \n" + "varying vec2 v_texCoord;                     \n" + "                                             \n" + "uniform sampler2D CC_Texture0;               \n" + "                                             \n" + "void main()                                  \n" + 
"{                                            \n" + "    gl_FragColor =  texture2D(CC_Texture0, v_texCoord) * u_color;    \n" + "}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "                                               \n" + "attribute vec4 a_position;                   \n" + "attribute vec2 a_texCoord;                   \n" + "                                             \n" + "varying mediump vec2 v_texCoord;             \n" + "                                             \n" + "void main()                                  \n" + "{                                            \n" + "    gl_Position = CC_MVPMatrix * a_position;  \n" + 
"    v_texCoord = a_texCoord;                 \n" + "}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "                                               \n" + "precision lowp float;                        \n" + "                                             \n" + "varying vec4 v_fragmentColor;                \n" + "varying vec2 v_texCoord;                     \n" + "uniform sampler2D CC_Texture0;                 \n" + "                                             \n" + "void main()                                  \n" + "{                                            \n" + 
"    gl_FragColor = vec4( v_fragmentColor.rgb,         \n" + "        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n" + "    );                                       \n" + "}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "                                               \n" + "attribute vec4 a_position;                   \n" + "attribute vec2 a_texCoord;                   \n" + "attribute vec4 a_color;                      \n" + "                                             \n" + "varying lowp vec4 v_fragmentColor;           \n" + "varying mediump vec2 v_texCoord;             \n" + "                                             \n" + "void main()                                  \n" + 
"{                                            \n" + "    gl_Position = CC_MVPMatrix * a_position; \n" + "    v_fragmentColor = a_color;               \n" + "    v_texCoord = a_texCoord;                 \n" + "}";
cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "                                               \n" + "precision lowp float;                        \n" + "                                             \n" + "varying vec4 v_fragmentColor;                \n" + "varying vec2 v_texCoord;                     \n" + "uniform sampler2D CC_Texture0;               \n" + "                                             \n" + "void main()                                  \n" + "{                                            \n" + 
"    gl_FragColor = v_fragmentColor * texture2D(CC_Texture0, v_texCoord);         \n" + "}";
cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "                                               \n" + "attribute vec4 a_position;                   \n" + "attribute vec2 a_texCoord;                   \n" + "attribute vec4 a_color;                      \n" + "                                             \n" + "varying lowp vec4 v_fragmentColor;           \n" + "varying mediump vec2 v_texCoord;             \n" + "                                             \n" + "void main()                                  \n" + 
"{                                            \n" + "    gl_Position = CC_MVPMatrix * a_position;  \n" + "    v_fragmentColor = a_color;               \n" + "    v_texCoord = a_texCoord;                 \n" + "}";
cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "                                                  \n" + "precision lowp float;                           \n" + "                                                \n" + "varying vec4 v_fragmentColor;                   \n" + "varying vec2 v_texCoord;                        \n" + "uniform sampler2D CC_Texture0;                  \n" + "uniform float CC_alpha_value;                   \n" + "                                                \n" + "void main()                                     \n" + 
"{                                               \n" + "    vec4 texColor = texture2D(CC_Texture0, v_texCoord);          \n" + "                                                \n" + "    // mimic: glAlphaFunc(GL_GREATER)           \n" + "    //pass if ( incoming_pixel >= CC_alpha_value ) => fail if incoming_pixel < CC_alpha_value         \n" + "                                                \n" + "    if ( texColor.a <= CC_alpha_value )          \n" + "        discard;                                \n" + 
"                                                \n" + "    gl_FragColor = texColor * v_fragmentColor;  \n" + "}";
cc.SHADEREX_SWITCHMASK_FRAG = "                                                   \n" + "precision lowp float;                            \n" + "                                                 \n" + "varying vec4 v_fragmentColor;                    \n" + "varying vec2 v_texCoord;                         \n" + "uniform sampler2D u_texture;                     \n" + "uniform sampler2D   u_mask;                      \n" + "                                                 \n" + "void main()                                      \n" + 
"{                                                \n" + "    vec4 texColor   = texture2D(u_texture, v_texCoord);          \n" + "    vec4 maskColor  = texture2D(u_mask, v_texCoord);             \n" + "    vec4 finalColor = vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n" + "    gl_FragColor    = v_fragmentColor * finalColor;              \n" + "}";
cc.SHADERTYPE_POSITION_TEXTURECOLOR = 0;
cc.SHADERTYPE_POSITION_TEXTURECOLOR_ALPHATEST = 1;
cc.SHADERTYPE_POSITION_COLOR = 2;
cc.SHADERTYPE_POSITION_TEXTURE = 3;
cc.SHADERTYPE_POSITION_TEXTURE_UCOLOR = 4;
cc.SHADERTYPE_POSITION_TEXTURE_A8COLOR = 5;
cc.SHADERTYPE_POSITION_UCOLOR = 6;
cc.SHADERTYPE_POSITION_LENGTH_TEXTURECOLOR = 7;
cc.SHADERTYPE_MAX = 8;
cc._sharedShaderCache = null;
cc.ShaderCache = cc.Class.extend({_programs:null, _init:function() {
  this.loadDefaultShaders();
  return true
}, _loadDefaultShader:function(program, type) {
  switch(type) {
    case cc.SHADERTYPE_POSITION_TEXTURECOLOR:
      program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG);
      program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
      program.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
      program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
      break;
    case cc.SHADERTYPE_POSITION_TEXTURECOLOR_ALPHATEST:
      program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
      program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
      program.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
      program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
      break;
    case cc.SHADERTYPE_POSITION_COLOR:
      program.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG);
      program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
      program.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
      break;
    case cc.SHADERTYPE_POSITION_TEXTURE:
      program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG);
      program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
      program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
      break;
    case cc.SHADERTYPE_POSITION_TEXTURE_UCOLOR:
      program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG);
      program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
      program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
      break;
    case cc.SHADERTYPE_POSITION_TEXTURE_A8COLOR:
      program.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT, cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG);
      program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
      program.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
      program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
      break;
    case cc.SHADERTYPE_POSITION_UCOLOR:
      program.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG);
      program.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
      break;
    case cc.SHADERTYPE_POSITION_LENGTH_TEXTURECOLOR:
      program.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT, cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG);
      program.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
      program.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
      program.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
      break;
    default:
      cc.log("cocos2d: cc.ShaderCache._loadDefaultShader, error shader type");
      return
  }
  program.link();
  program.updateUniforms()
}, ctor:function() {
  this._programs = {}
}, loadDefaultShaders:function() {
  var program = new cc.GLProgram;
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_TEXTURECOLOR);
  this._programs[cc.SHADER_POSITION_TEXTURECOLOR] = program;
  this._programs["ShaderPositionTextureColor"] = program;
  program = new cc.GLProgram;
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_TEXTURECOLOR_ALPHATEST);
  this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = program;
  this._programs["ShaderPositionTextureColorAlphaTest"] = program;
  program = new cc.GLProgram;
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_COLOR);
  this._programs[cc.SHADER_POSITION_COLOR] = program;
  this._programs["ShaderPositionColor"] = program;
  program = new cc.GLProgram;
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_TEXTURE);
  this._programs[cc.SHADER_POSITION_TEXTURE] = program;
  this._programs["ShaderPositionTexture"] = program;
  program = new cc.GLProgram;
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_TEXTURE_UCOLOR);
  this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = program;
  this._programs["ShaderPositionTextureUColor"] = program;
  program = new cc.GLProgram;
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_TEXTURE_A8COLOR);
  this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = program;
  this._programs["ShaderPositionTextureA8Color"] = program;
  program = new cc.GLProgram;
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_UCOLOR);
  this._programs[cc.SHADER_POSITION_UCOLOR] = program;
  this._programs["ShaderPositionUColor"] = program;
  program = new cc.GLProgram;
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_LENGTH_TEXTURECOLOR);
  this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = program;
  this._programs["ShaderPositionLengthTextureColor"] = program
}, reloadDefaultShaders:function() {
  var program = this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
  program.reset();
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_TEXTURECOLOR);
  program = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
  program.reset();
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_TEXTURECOLOR_ALPHATEST);
  program = this.programForKey(cc.SHADER_POSITION_COLOR);
  program.reset();
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_COLOR);
  program = this.programForKey(cc.SHADER_POSITION_TEXTURE);
  program.reset();
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_TEXTURE);
  program = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
  program.reset();
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_TEXTURE_UCOLOR);
  program = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR);
  program.reset();
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_TEXTURE_A8COLOR);
  program = this.programForKey(cc.SHADER_POSITION_UCOLOR);
  program.reset();
  this._loadDefaultShader(program, cc.SHADERTYPE_POSITION_UCOLOR)
}, programForKey:function(key) {
  return this._programs[key]
}, getProgram:function(shaderName) {
  return this._programs[shaderName]
}, addProgram:function(program, key) {
  this._programs[key] = program
}});
cc.ShaderCache.getInstance = function() {
  if(!cc._sharedShaderCache) {
    cc._sharedShaderCache = new cc.ShaderCache;
    cc._sharedShaderCache._init()
  }
  return cc._sharedShaderCache
};
cc.ShaderCache.purgeSharedShaderCache = function() {
  cc._sharedShaderCache = null
};
cc.VERTEX_ATTRIB_POSITION = 0;
cc.VERTEX_ATTRIB_COLOR = 1;
cc.VERTEX_ATTRIB_TEX_COORDS = 2;
cc.VERTEX_ATTRIB_MAX = 3;
cc.UNIFORM_PMATRIX = 0;
cc.UNIFORM_MVMATRIX = 1;
cc.UNIFORM_MVPMATRIX = 2;
cc.UNIFORM_TIME = 3;
cc.UNIFORM_SINTIME = 4;
cc.UNIFORM_COSTIME = 5;
cc.UNIFORM_RANDOM01 = 6;
cc.UNIFORM_SAMPLER = 7;
cc.UNIFORM_MAX = 8;
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
cc.UNIFORM_TIME_S = "CC_Time";
cc.UNIFORM_SINTIME_S = "CC_SinTime";
cc.UNIFORM_COSTIME_S = "CC_CosTime";
cc.UNIFORM_RANDOM01_S = "CC_Random01";
cc.UNIFORM_SAMPLER_S = "CC_Texture0";
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
cc.ATTRIBUTE_NAME_COLOR = "a_color";
cc.ATTRIBUTE_NAME_POSITION = "a_position";
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
cc.HashUniformEntry = function(value, location, hh) {
  this.value = value;
  this.location = location;
  this.hh = hh || {}
};
cc.GLProgram = cc.Class.extend({_glContext:null, _programObj:null, _vertShader:null, _fragShader:null, _uniforms:null, _hashForUniforms:null, _usesTime:false, _updateUniformLocation:function(location, data, bytes) {
  if(location == null) {
    return false
  }
  var updated = true;
  var element = null;
  for(var i = 0;i < this._hashForUniforms.length;i++) {
    if(this._hashForUniforms[i].location == location) {
      element = this._hashForUniforms[i]
    }
  }
  if(!element) {
    element = new cc.HashUniformEntry;
    element.location = location;
    element.value = data;
    this._hashForUniforms.push(element)
  }else {
    if(element.value == data) {
      updated = false
    }else {
      element.value = data
    }
  }
  return updated
}, _description:function() {
  return"<CCGLProgram = " + this.toString() + " | Program = " + this._programObj.toString() + ", VertexShader = " + this._vertShader.toString() + ", FragmentShader = " + this._fragShader.toString() + ">"
}, _compileShader:function(shader, type, source) {
  if(!source || !shader) {
    return false
  }
  var preStr = type == this._glContext.VERTEX_SHADER ? "precision highp float;\n" : "precision mediump float;\n";
  source = preStr + "uniform mat4 CC_PMatrix;          \n" + "uniform mat4 CC_MVMatrix;        \n" + "uniform mat4 CC_MVPMatrix;       \n" + "uniform vec4 CC_Time;            \n" + "uniform vec4 CC_SinTime;         \n" + "uniform vec4 CC_CosTime;         \n" + "uniform vec4 CC_Random01;        \n" + "//CC INCLUDES END                \n  \n" + source;
  this._glContext.shaderSource(shader, source);
  this._glContext.compileShader(shader);
  var status = this._glContext.getShaderParameter(shader, this._glContext.COMPILE_STATUS);
  if(!status) {
    cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(shader));
    if(type == this._glContext.VERTEX_SHADER) {
      cc.log("cocos2d: \n" + this.vertexShaderLog())
    }else {
      cc.log("cocos2d: \n" + this.fragmentShaderLog())
    }
  }
  return status == 1
}, ctor:function(glContext) {
  this._programObj = null;
  this._vertShader = null;
  this._fragShader = null;
  this._uniforms = [];
  this._hashForUniforms = [];
  this._glContext = glContext || cc.renderContext
}, destroyProgram:function() {
  this._vertShader = null;
  this._fragShader = null;
  this._uniforms = null;
  this._hashForUniforms = null;
  this._glContext.deleteProgram(this._programObj)
}, initWithVertexShaderByteArray:function(vertShaderStr, fragShaderStr) {
  this._programObj = cc.renderContext.createProgram();
  this._vertShader = null;
  this._fragShader = null;
  if(vertShaderStr) {
    this._vertShader = this._glContext.createShader(this._glContext.VERTEX_SHADER);
    if(!this._compileShader(this._vertShader, this._glContext.VERTEX_SHADER, vertShaderStr)) {
      cc.log("cocos2d: ERROR: Failed to compile vertex shader")
    }
  }
  if(fragShaderStr) {
    this._fragShader = this._glContext.createShader(this._glContext.FRAGMENT_SHADER);
    if(!this._compileShader(this._fragShader, this._glContext.FRAGMENT_SHADER, fragShaderStr)) {
      cc.log("cocos2d: ERROR: Failed to compile fragment shader")
    }
  }
  if(this._vertShader) {
    this._glContext.attachShader(this._programObj, this._vertShader)
  }
  cc.CHECK_GL_ERROR_DEBUG();
  if(this._fragShader) {
    this._glContext.attachShader(this._programObj, this._fragShader)
  }
  this._hashForUniforms = [];
  cc.CHECK_GL_ERROR_DEBUG();
  return true
}, initWithString:function(vertShaderStr, fragShaderStr) {
  return this.initWithVertexShaderByteArray(vertShaderStr, fragShaderStr)
}, initWithVertexShaderFilename:function(vShaderFilename, fShaderFileName) {
  var vertexSource = cc.FileUtils.getInstance().getTextFileData(vShaderFilename);
  var fragmentSource = cc.FileUtils.getInstance().getTextFileData(fShaderFileName);
  return this.initWithVertexShaderByteArray(vertexSource, fragmentSource)
}, init:function(vShaderFilename, fShaderFileName) {
  return this.initWithVertexShaderFilename(vShaderFilename, fShaderFileName)
}, addAttribute:function(attributeName, index) {
  this._glContext.bindAttribLocation(this._programObj, index, attributeName)
}, link:function() {
  cc.Assert(this._programObj != null, "Cannot link invalid program");
  this._glContext.linkProgram(this._programObj);
  if(this._vertShader) {
    this._glContext.deleteShader(this._vertShader)
  }
  if(this._fragShader) {
    this._glContext.deleteShader(this._fragShader)
  }
  this._vertShader = null;
  this._fragShader = null;
  if(cc.COCOS2D_DEBUG) {
    var status = this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS);
    if(!status) {
      cc.log("cocos2d: ERROR: Failed to link program: " + this._programObj);
      cc.glDeleteProgram(this._programObj);
      this._programObj = null;
      return false
    }
  }
  return true
}, use:function() {
  cc.glUseProgram(this._programObj)
}, updateUniforms:function() {
  this._uniforms[cc.UNIFORM_PMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S);
  this._uniforms[cc.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S);
  this._uniforms[cc.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S);
  this._uniforms[cc.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S);
  this._uniforms[cc.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S);
  this._uniforms[cc.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S);
  this._usesTime = this._uniforms[cc.UNIFORM_TIME] != null || this._uniforms[cc.UNIFORM_SINTIME] != null || this._uniforms[cc.UNIFORM_COSTIME] != null;
  this._uniforms[cc.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S);
  this._uniforms[cc.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S);
  this.use();
  this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER], 0)
}, getUniformMVPMatrix:function() {
  return this._uniforms[cc.UNIFORM_MVPMATRIX]
}, getUniformSampler:function() {
  return this._uniforms[cc.UNIFORM_SAMPLER]
}, setUniformLocationWith1i:function(location, i1) {
  var updated = this._updateUniformLocation(location, i1);
  if(updated) {
    this._glContext.uniform1i(location, i1)
  }
}, setUniformLocationI32:function(location, i1) {
  this.setUniformLocationWith1i(arguments[0], arguments[1])
}, setUniformLocationWith1f:function(location, f1) {
  var updated = this._updateUniformLocation(location, f1);
  if(updated) {
    this._glContext.uniform1f(location, f1)
  }
}, setUniformLocationWith2f:function(location, f1, f2) {
  var floats = [f1, f2];
  var updated = this._updateUniformLocation(location, floats);
  if(updated) {
    this._glContext.uniform2f(location, f1, f2)
  }
}, setUniformLocationWith3f:function(location, f1, f2, f3) {
  var floats = [f1, f2, f3];
  var updated = this._updateUniformLocation(location, floats);
  if(updated) {
    this._glContext.uniform3f(location, f1, f2, f3)
  }
}, setUniformLocationWith4f:function(location, f1, f2, f3, f4) {
  var floats = [f1, f2, f3, f4];
  var updated = this._updateUniformLocation(location, floats);
  if(updated) {
    this._glContext.uniform4f(location, f1, f2, f3, f4)
  }
}, setUniformLocationWith2fv:function(location, floatArray, numberOfArrays) {
  var updated = this._updateUniformLocation(location, floatArray);
  if(updated) {
    this._glContext.uniform2fv(location, floatArray)
  }
}, setUniformLocationWith3fv:function(location, floatArray, numberOfArrays) {
  var updated = this._updateUniformLocation(location, floatArray);
  if(updated) {
    this._glContext.uniform3fv(location, floatArray)
  }
}, setUniformLocationWith4fv:function(location, floatArray, numberOfArrays) {
  var updated = this._updateUniformLocation(location, floatArray);
  if(updated) {
    this._glContext.uniform4fv(location, floatArray)
  }
}, setUniformLocationWithMatrix4fv:function(location, matrixArray, numberOfMatrices) {
  var updated = this._updateUniformLocation(location, matrixArray);
  if(updated) {
    this._glContext.uniformMatrix4fv(location, false, matrixArray)
  }
}, setUniformLocationF32:function() {
  if(arguments.length < 2) {
    return
  }
  switch(arguments.length) {
    case 2:
      this.setUniformLocationWith1f(arguments[0], arguments[1]);
      break;
    case 3:
      this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
      break;
    case 4:
      this.setUniformLocationWith3f(arguments[0], arguments[1], arguments[2], arguments[3]);
      break;
    case 5:
      this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
      break
  }
}, setUniformsForBuiltins:function() {
  var matrixP = new cc.kmMat4;
  var matrixMV = new cc.kmMat4;
  var matrixMVP = new cc.kmMat4;
  cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, matrixP);
  cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, matrixMV);
  cc.kmMat4Multiply(matrixMVP, matrixP, matrixMV);
  this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], matrixP.mat, 1);
  this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], matrixMV.mat, 1);
  this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], matrixMVP.mat, 1);
  if(this._usesTime) {
    var director = cc.Director.getInstance();
    var time = director.getTotalFrames() * director.getAnimationInterval();
    this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], time / 10, time, time * 2, time * 4);
    this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], time / 8, time / 4, time / 2, Math.sin(time));
    this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], time / 8, time / 4, time / 2, Math.cos(time))
  }
  if(this._uniforms[cc.UNIFORM_RANDOM01] != -1) {
    this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
  }
}, setUniformForModelViewProjectionMatrix:function() {
  this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], false, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top))
}, setUniformForModelViewProjectionMatrixWithMat4:function(swapMat4) {
  cc.kmMat4Multiply(swapMat4, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top);
  this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], false, swapMat4.mat)
}, vertexShaderLog:function() {
  return this._glContext.getShaderInfoLog(this._vertShader)
}, getVertexShaderLog:function() {
  return this._glContext.getShaderInfoLog(this._vertShader)
}, getFragmentShaderLog:function() {
  return this._glContext.getShaderInfoLog(this._vertShader)
}, fragmentShaderLog:function() {
  return this._glContext.getShaderInfoLog(this._fragShader)
}, programLog:function() {
  return this._glContext.getProgramInfoLog(this._programObj)
}, getProgramLog:function() {
  return this._glContext.getProgramInfoLog(this._programObj)
}, reset:function() {
  this._vertShader = null;
  this._fragShader = null;
  this._uniforms = [];
  this._glContext.deleteProgram(this._programObj);
  this._programObj = null;
  for(var i = 0;i < this._hashForUniforms.length;i++) {
    this._hashForUniforms[i].value = null;
    this._hashForUniforms[i] = null
  }
  this._hashForUniforms = []
}, getProgram:function() {
  return this._programObj
}, retain:function() {
}, release:function() {
}});
cc.GLProgram.create = function(vShaderFileName, fShaderFileName) {
  var program = new cc.GLProgram;
  if(program.init(vShaderFileName, fShaderFileName)) {
    return program
  }
  return null
};
cc.VERTEX_ATTRIB_FLAG_NONE = 0;
cc.VERTEX_ATTRIB_FLAG_POSITION = 1 << 0;
cc.VERTEX_ATTRIB_FLAG_COLOR = 1 << 1;
cc.VERTEX_ATTRIB_FLAG_TEXCOORDS = 1 << 2;
cc.VERTEX_ATTRIB_FLAG_POSCOLORTEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEXCOORDS;
cc.GL_ALL = 0;
cc._currentProjectionMatrix = -1;
cc._vertexAttribPosition = false;
cc._vertexAttribColor = false;
cc._vertexAttribTexCoords = false;
if(cc.ENABLE_GL_STATE_CACHE) {
  cc.MAX_ACTIVETEXTURE = 16;
  cc._currentShaderProgram = -1;
  cc._currentBoundTexture = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
  cc._blendingSource = -1;
  cc._blendingDest = -1;
  cc._GLServerState = 0;
  cc._uVAO = 0
}
cc.glInvalidateStateCache = function() {
  cc.kmGLFreeAll();
  cc._currentProjectionMatrix = -1;
  cc._vertexAttribPosition = false;
  cc._vertexAttribColor = false;
  cc._vertexAttribTexCoords = false;
  if(cc.ENABLE_GL_STATE_CACHE) {
    cc._currentShaderProgram = -1;
    for(var i = 0;i < cc.MAX_ACTIVETEXTURE;i++) {
      cc._currentBoundTexture[i] = -1
    }
    cc._blendingSource = -1;
    cc._blendingDest = -1;
    cc._GLServerState = 0
  }
};
cc.glUseProgram = function(program) {
  if(program !== cc._currentShaderProgram) {
    cc._currentShaderProgram = program;
    cc.renderContext.useProgram(program)
  }
};
if(!cc.ENABLE_GL_STATE_CACHE) {
  cc.glUseProgram = function(program) {
    cc.renderContext.useProgram(program)
  }
}
cc.glDeleteProgram = function(program) {
  if(cc.ENABLE_GL_STATE_CACHE) {
    if(program === cc._currentShaderProgram) {
      cc._currentShaderProgram = -1
    }
  }
  cc.renderContext.deleteProgram(program)
};
cc.glBlendFunc = function(sfactor, dfactor) {
  if(sfactor !== cc._blendingSource || dfactor !== cc._blendingDest) {
    cc._blendingSource = sfactor;
    cc._blendingDest = dfactor;
    cc.setBlending(sfactor, dfactor)
  }
};
cc.setBlending = function(sfactor, dfactor) {
  if(sfactor === cc.renderContext.ONE && dfactor === cc.renderContext.ZERO) {
    cc.renderContext.disable(cc.renderContext.BLEND)
  }else {
    cc.renderContext.enable(cc.renderContext.BLEND);
    cc.renderContext.blendFuncSeparate(gl.SRC_ALPHA, dfactor, sfactor, dfactor)
  }
};
if(cc.ENABLE_GL_STATE_CACHE) {
  cc.glBlendFunc = cc.setBlending
}
cc.glBlendResetToCache = function() {
  cc.renderContext.blendEquation(cc.renderContext.FUNC_ADD);
  if(cc.ENABLE_GL_STATE_CACHE) {
    cc.setBlending(cc._blendingSource, cc._blendingDest)
  }else {
    cc.setBlending(cc.renderContext.BLEND_SRC, cc.renderContext.BLEND_DST)
  }
};
cc.setProjectionMatrixDirty = function() {
  cc._currentProjectionMatrix = -1
};
cc.glEnableVertexAttribs = function(flags) {
  var enablePosition = flags & cc.VERTEX_ATTRIB_FLAG_POSITION;
  if(enablePosition !== cc._vertexAttribPosition) {
    if(enablePosition) {
      cc.renderContext.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION)
    }else {
      cc.renderContext.disableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION)
    }
    cc._vertexAttribPosition = enablePosition
  }
  var enableColor = flags & cc.VERTEX_ATTRIB_FLAG_COLOR;
  if(enableColor !== cc._vertexAttribColor) {
    if(enableColor) {
      cc.renderContext.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR)
    }else {
      cc.renderContext.disableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR)
    }
    cc._vertexAttribColor = enableColor
  }
  var enableTexCoords = flags & cc.VERTEX_ATTRIB_FLAG_TEXCOORDS;
  if(enableTexCoords !== cc._vertexAttribTexCoords) {
    if(enableTexCoords) {
      cc.renderContext.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS)
    }else {
      cc.renderContext.disableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS)
    }
    cc._vertexAttribTexCoords = enableTexCoords
  }
};
cc.glBindTexture2D = function(textureId) {
  cc.glBindTexture2DN(0, textureId)
};
cc.glBindTexture2DN = function(textureUnit, textureId) {
  if(cc._currentBoundTexture[textureUnit] === textureId) {
    return
  }
  cc._currentBoundTexture[textureUnit] = textureId;
  cc.renderContext.activeTexture(cc.renderContext.TEXTURE0 + textureUnit);
  if(textureId) {
    cc.renderContext.bindTexture(cc.renderContext.TEXTURE_2D, textureId._webTextureObj)
  }else {
    cc.renderContext.bindTexture(cc.renderContext.TEXTURE_2D, null)
  }
};
if(!cc.ENABLE_GL_STATE_CACHE) {
  cc.glBindTexture2DN = function(textureUnit, textureId) {
    cc.renderContext.activeTexture(cc.renderContext.TEXTURE0 + textureUnit);
    if(textureId) {
      cc.renderContext.bindTexture(cc.renderContext.TEXTURE_2D, textureId._webTextureObj)
    }else {
      cc.renderContext.bindTexture(cc.renderContext.TEXTURE_2D, null)
    }
  }
}
cc.glDeleteTexture = function(textureId) {
  cc.glDeleteTextureN(0, textureId)
};
cc.glDeleteTextureN = function(textureUnit, textureId) {
  if(cc.ENABLE_GL_STATE_CACHE) {
    if(textureId == cc._currentBoundTexture[textureUnit]) {
      cc._currentBoundTexture[textureUnit] = -1
    }
  }
  cc.renderContext.deleteTexture(textureId)
};
cc.glBindVAO = function(vaoId) {
  if(!cc.TEXTURE_ATLAS_USE_VAO) {
    return
  }
  if(cc.ENABLE_GL_STATE_CACHE) {
    if(cc._uVAO != vaoId) {
      cc._uVAO = vaoId
    }
  }else {
  }
};
cc.glEnable = function(flags) {
  if(cc.ENABLE_GL_STATE_CACHE) {
  }else {
  }
};
cc.NODE_TAG_INVALID = -1;
cc.NODE_ON_ENTER = null;
cc.NODE_ON_EXIT = null;
cc.s_globalOrderOfArrival = 1;
cc.NodeWebGL = cc.Class.extend({_zOrder:0, _vertexZ:0, _rotationX:0, _rotationY:0, _scaleX:1, _scaleY:1, _position:null, _skewX:0, _skewY:0, _children:null, _visible:true, _anchorPoint:null, _anchorPointInPoints:null, _contentSize:null, _running:false, _parent:null, _ignoreAnchorPointForPosition:false, _tag:cc.NODE_TAG_INVALID, _userData:null, _userObject:null, _transformDirty:true, _inverseDirty:true, _cacheDirty:true, _transformGLDirty:null, _transform:null, _inverse:null, _reorderChildDirty:false, 
_shaderProgram:null, _orderOfArrival:0, _actionManager:null, _scheduler:null, _initializedNode:false, _additionalTransformDirty:false, _additionalTransform:null, _initNode:function() {
  this._anchorPoint = cc.p(0, 0);
  this._anchorPointInPoints = cc.p(0, 0);
  this._contentSize = cc.size(0, 0);
  this._position = cc.p(0, 0);
  var director = cc.Director.getInstance();
  this._actionManager = director.getActionManager();
  this.getActionManager = function() {
    return this._actionManager
  };
  this._scheduler = director.getScheduler();
  this.getScheduler = function() {
    return this._scheduler
  };
  this._initializedNode = true;
  this._additionalTransform = cc.AffineTransformMakeIdentity();
  this._additionalTransformDirty = false
}, init:function() {
  if(this._initializedNode === false) {
    this._initNode()
  }
  return true
}, _arrayMakeObjectsPerformSelector:function(array, callbackType) {
  if(!array || array.length == 0) {
    return
  }
  var i;
  switch(callbackType) {
    case cc.Node.StateCallbackType.onEnter:
      for(i = 0;i < array.length;i++) {
        if(array[i]) {
          array[i].onEnter()
        }
      }
      break;
    case cc.Node.StateCallbackType.onExit:
      for(i = 0;i < array.length;i++) {
        if(array[i]) {
          array[i].onExit()
        }
      }
      break;
    case cc.Node.StateCallbackType.onEnterTransitionDidFinish:
      for(i = 0;i < array.length;i++) {
        if(array[i]) {
          array[i].onEnterTransitionDidFinish()
        }
      }
      break;
    case cc.Node.StateCallbackType.cleanup:
      for(i = 0;i < array.length;i++) {
        if(array[i]) {
          array[i].cleanup()
        }
      }
      break;
    case cc.Node.StateCallbackType.updateTransform:
      for(i = 0;i < array.length;i++) {
        if(array[i]) {
          array[i].updateTransform()
        }
      }
      break;
    case cc.Node.StateCallbackType.onExitTransitionDidStart:
      for(i = 0;i < array.length;i++) {
        if(array[i]) {
          array[i].onExitTransitionDidStart()
        }
      }
      break;
    case cc.Node.StateCallbackType.sortAllChildren:
      for(i = 0;i < array.length;i++) {
        if(array[i]) {
          array[i].sortAllChildren()
        }
      }
      break;
    default:
      throw"Unknown callback function";break
  }
}, setNodeDirty:function() {
  this._transformDirty = this._inverseDirty = true
}, getSkewX:function() {
  return this._skewX
}, setSkewX:function(newSkewX) {
  this._skewX = newSkewX;
  this.setNodeDirty()
}, getSkewY:function() {
  return this._skewY
}, setSkewY:function(newSkewY) {
  this._skewY = newSkewY;
  this.setNodeDirty()
}, getZOrder:function() {
  return this._zOrder
}, _setZOrder:function(z) {
  this._zOrder = z
}, setZOrder:function(z) {
  this._setZOrder(z);
  if(this._parent) {
    this._parent.reorderChild(this, z)
  }
}, getVertexZ:function() {
  return this._vertexZ
}, setVertexZ:function(Var) {
  this._vertexZ = Var
}, getRotation:function() {
  cc.Assert(this._rotationX == this._rotationY, "CCNode#rotation. RotationX != RotationY. Don't know which one to return");
  return this._rotationX
}, _rotationRadiansX:0, _rotationRadiansY:0, setRotation:function(newRotation) {
  this._rotationX = this._rotationY = newRotation;
  this._rotationRadiansX = this._rotationX * (Math.PI / 180);
  this._rotationRadiansY = this._rotationY * (Math.PI / 180);
  this.setNodeDirty()
}, getRotationX:function() {
  return this._rotationX
}, setRotationX:function(rotationX) {
  this._rotationX = rotationX;
  this._rotationRadiansX = this._rotationX * (Math.PI / 180);
  this.setNodeDirty()
}, getRotationY:function() {
  return this._rotationY
}, setRotationY:function(rotationY) {
  this._rotationY = rotationY;
  this._rotationRadiansY = this._rotationY * (Math.PI / 180);
  this.setNodeDirty()
}, getScale:function() {
  cc.Assert(this._scaleX == this._scaleY, "cc.Node#scale. ScaleX != ScaleY. Don't know which one to return");
  return this._scaleX
}, setScale:function(scale, scaleY) {
  this._scaleX = scale;
  this._scaleY = scaleY || scale;
  this.setNodeDirty()
}, getScaleX:function() {
  return this._scaleX
}, setScaleX:function(newScaleX) {
  this._scaleX = newScaleX;
  this.setNodeDirty()
}, getScaleY:function() {
  return this._scaleY
}, setScaleY:function(newScaleY) {
  this._scaleY = newScaleY;
  this.setNodeDirty()
}, setPosition:function(newPosOrxValue, yValue) {
  if(arguments.length == 2) {
    this._position = new cc.Point(newPosOrxValue, yValue)
  }else {
    if(arguments.length == 1) {
      this._position = new cc.Point(newPosOrxValue.x, newPosOrxValue.y)
    }
  }
  this.setNodeDirty()
}, _setPositionByValue:function(newPosOrxValue, yValue) {
  if(arguments.length == 2) {
    this._position.x = newPosOrxValue;
    this._position.y = yValue
  }else {
    if(arguments.length == 1) {
      this._position.x = newPosOrxValue.x;
      this._position.y = newPosOrxValue.y
    }
  }
  this.setNodeDirty()
}, getPosition:function() {
  return cc.p(this._position.x, this._position.y)
}, getPositionX:function() {
  return this._position.x
}, setPositionX:function(x) {
  this._position.x = x;
  this.setNodeDirty()
}, getPositionY:function() {
  return this._position.y
}, setPositionY:function(y) {
  this._position.y = y;
  this.setNodeDirty()
}, getChildrenCount:function() {
  return this._children ? this._children.length : 0
}, getChildren:function() {
  if(!this._children) {
    this._children = []
  }
  return this._children
}, isVisible:function() {
  return this._visible
}, setVisible:function(Var) {
  this._visible = Var;
  this.setNodeDirty()
}, getAnchorPoint:function() {
  return cc.p(this._anchorPoint.x, this._anchorPoint.y)
}, setAnchorPoint:function(point) {
  if(!cc.Point.CCPointEqualToPoint(point, this._anchorPoint)) {
    this._anchorPoint = new cc.Point(point.x, point.y);
    this._anchorPointInPoints = new cc.Point(this._contentSize.width * this._anchorPoint.x, this._contentSize.height * this._anchorPoint.y);
    this.setNodeDirty()
  }
}, getAnchorPointInPoints:function() {
  return cc.p(this._anchorPointInPoints.x, this._anchorPointInPoints.y)
}, getContentSize:function() {
  return cc.size(this._contentSize.width, this._contentSize.height)
}, setContentSize:function(size) {
  if(!cc.Size.CCSizeEqualToSize(size, this._contentSize)) {
    this._contentSize = new cc.Size(size.width, size.height);
    this._anchorPointInPoints = new cc.Point(this._contentSize.width * this._anchorPoint.x, this._contentSize.height * this._anchorPoint.y);
    this.setNodeDirty()
  }
}, isRunning:function() {
  return this._running
}, getParent:function() {
  return this._parent
}, setParent:function(Var) {
  this._parent = Var
}, isIgnoreAnchorPointForPosition:function() {
  return this._ignoreAnchorPointForPosition
}, ignoreAnchorPointForPosition:function(newValue) {
  if(newValue != this._ignoreAnchorPointForPosition) {
    this._ignoreAnchorPointForPosition = newValue;
    this.setNodeDirty()
  }
}, getTag:function() {
  return this._tag
}, setTag:function(Var) {
  this._tag = Var
}, getUserData:function() {
  return this._userData
}, setUserData:function(Var) {
  this._userData = Var
}, getUserObject:function() {
  return this._userObject
}, setUserObject:function(newValue) {
  if(this._userObject != newValue) {
    this._userObject = newValue
  }
}, getOrderOfArrival:function() {
  return this._orderOfArrival
}, setOrderOfArrival:function(Var) {
  this._orderOfArrival = Var
}, getActionManager:function() {
  if(!this._actionManager) {
    this._actionManager = cc.Director.getInstance().getActionManager();
    this.getActionManager = function() {
      return this._actionManager
    }
  }
  return this._actionManager
}, setActionManager:function(actionManager) {
  if(this._actionManager != actionManager) {
    this.stopAllActions();
    this._actionManager = actionManager
  }
}, getScheduler:function() {
  if(!this._scheduler) {
    this._scheduler = cc.Director.getInstance().getScheduler();
    this.getScheduler = function() {
      return this._scheduler
    }
  }
  return this._scheduler
}, setScheduler:function(scheduler) {
  if(this._scheduler != scheduler) {
    this.unscheduleAllCallbacks();
    this._scheduler = scheduler
  }
}, getBoundingBox:function() {
  var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
  return cc.RectApplyAffineTransform(rect, this.nodeToParentTransform())
}, cleanup:function() {
  this.stopAllActions();
  this.unscheduleAllCallbacks();
  this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.cleanup)
}, description:function() {
  return"<cc.Node | Tag =" + this._tag + ">"
}, _childrenAlloc:function() {
  this._children = []
}, getChildByTag:function(aTag) {
  if(this._children != null) {
    for(var i = 0;i < this._children.length;i++) {
      var node = this._children[i];
      if(node && node._tag == aTag) {
        return node
      }
    }
  }
  return null
}, addChild:function(child, zOrder, tag) {
  if(child === this) {
    console.warn("cc.Node.addChild: An Node can't be added as a child of itself.");
    return
  }
  cc.Assert(child != null, "Argument must be non-nil");
  if(child._parent !== null) {
    cc.Assert(child._parent === null, "child already added. It can't be added again");
    return
  }
  var tempzOrder = zOrder != null ? zOrder : child.getZOrder();
  var tmptag = tag != null ? tag : child.getTag();
  child.setTag(tmptag);
  if(!this._children) {
    this._childrenAlloc()
  }
  this._insertChild(child, tempzOrder);
  child.setParent(this);
  if(this._running) {
    child.onEnter();
    child.onEnterTransitionDidFinish()
  }
}, removeFromParent:function(cleanup) {
  if(this._parent) {
    if(cleanup == null) {
      cleanup = true
    }
    this._parent.removeChild(this, cleanup)
  }
}, removeFromParentAndCleanup:function(cleanup) {
  cc.log("removeFromParentAndCleanup is deprecated. Use removeFromParent instead");
  this.removeFromParent(cleanup)
}, removeChild:function(child, cleanup) {
  if(this._children == null) {
    return
  }
  if(cleanup == null) {
    cleanup = true
  }
  if(this._children.indexOf(child) > -1) {
    this._detachChild(child, cleanup)
  }
  this.setNodeDirty()
}, removeChildByTag:function(tag, cleanup) {
  cc.Assert(tag != cc.NODE_TAG_INVALID, "Invalid tag");
  var child = this.getChildByTag(tag);
  if(child == null) {
    cc.log("cocos2d: removeChildByTag: child not found!")
  }else {
    this.removeChild(child, cleanup)
  }
}, removeAllChildrenWithCleanup:function(cleanup) {
  cc.log("removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead");
  this.removeAllChildren(cleanup)
}, removeAllChildren:function(cleanup) {
  if(this._children != null) {
    if(cleanup == null) {
      cleanup = true
    }
    for(var i = 0;i < this._children.length;i++) {
      var node = this._children[i];
      if(node) {
        if(this._running) {
          node.onExitTransitionDidStart();
          node.onExit()
        }
        if(cleanup) {
          node.cleanup()
        }
        node.setParent(null)
      }
    }
    this._children.length = 0
  }
}, _detachChild:function(child, doCleanup) {
  if(this._running) {
    child.onExitTransitionDidStart();
    child.onExit()
  }
  if(doCleanup) {
    child.cleanup()
  }
  child.setParent(null);
  cc.ArrayRemoveObject(this._children, child)
}, _insertChild:function(child, z) {
  this._reorderChildDirty = true;
  var a = this._children[this._children.length - 1];
  if(!a || a.getZOrder() <= z) {
    this._children.push(child)
  }else {
    for(var i = 0;i < this._children.length;i++) {
      var node = this._children[i];
      if(node && node.getZOrder() > z) {
        this._children = cc.ArrayAppendObjectToIndex(this._children, child, i);
        break
      }
    }
  }
  child._setZOrder(z)
}, reorderChild:function(child, zOrder) {
  cc.Assert(child != null, "Child must be non-nil");
  this._reorderChildDirty = true;
  child.setOrderOfArrival(cc.s_globalOrderOfArrival++);
  child._setZOrder(zOrder);
  this.setNodeDirty()
}, sortAllChildren:function() {
  if(this._reorderChildDirty) {
    var i, j, length = this._children.length;
    for(i = 0;i < length;i++) {
      var tempItem = this._children[i];
      j = i - 1;
      while(j >= 0 && (tempItem._zOrder < this._children[j]._zOrder || tempItem._zOrder == this._children[j]._zOrder && tempItem._orderOfArrival < this._children[j]._orderOfArrival)) {
        this._children[j + 1] = this._children[j];
        j = j - 1
      }
      this._children[j + 1] = tempItem
    }
    this._reorderChildDirty = false
  }
}, draw:function(ctx) {
}, transformAncestors:function() {
  if(this._parent != null) {
    this._parent.transformAncestors();
    this._parent.transform()
  }
}, onEnter:function() {
  this._running = true;
  this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnter);
  this.resumeSchedulerAndActions()
}, onEnterTransitionDidFinish:function() {
  this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnterTransitionDidFinish)
}, onExitTransitionDidStart:function() {
  this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExitTransitionDidStart)
}, onExit:function() {
  this._running = false;
  this.pauseSchedulerAndActions();
  this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExit)
}, runAction:function(action) {
  cc.Assert(action != null, "Argument must be non-nil");
  this.getActionManager().addAction(action, this, !this._running);
  return action
}, stopAllActions:function() {
  this.getActionManager().removeAllActionsFromTarget(this)
}, stopAction:function(action) {
  this.getActionManager().removeAction(action)
}, stopActionByTag:function(tag) {
  cc.Assert(tag != cc.ACTION_TAG_INVALID, "Invalid tag");
  this.getActionManager().removeActionByTag(tag, this)
}, getActionByTag:function(tag) {
  cc.Assert(tag != cc.ACTION_TAG_INVALID, "Invalid tag");
  return this.getActionManager().getActionByTag(tag, this)
}, numberOfRunningActions:function() {
  return this.getActionManager().numberOfRunningActionsInTarget(this)
}, scheduleUpdate:function() {
  this.scheduleUpdateWithPriority(0)
}, scheduleUpdateWithPriority:function(priority) {
  this.getScheduler().scheduleUpdateForTarget(this, priority, !this._running)
}, unscheduleUpdate:function() {
  this.getScheduler().unscheduleUpdateForTarget(this)
}, schedule:function(callback_fn, interval, repeat, delay) {
  interval = interval || 0;
  cc.Assert(callback_fn, "Argument must be non-nil");
  cc.Assert(interval >= 0, "Argument must be positive");
  repeat = repeat == null ? cc.REPEAT_FOREVER : repeat;
  delay = delay || 0;
  this.getScheduler().scheduleCallbackForTarget(this, callback_fn, interval, repeat, delay, !this._running)
}, scheduleOnce:function(callback_fn, delay) {
  this.schedule(callback_fn, 0, 0, delay)
}, unschedule:function(callback_fn) {
  if(!callback_fn) {
    return
  }
  this.getScheduler().unscheduleCallbackForTarget(this, callback_fn)
}, unscheduleAllCallbacks:function() {
  this.getScheduler().unscheduleAllCallbacksForTarget(this)
}, resumeSchedulerAndActions:function() {
  this.getScheduler().resumeTarget(this);
  this.getActionManager().resumeTarget(this)
}, pauseSchedulerAndActions:function() {
  this.getScheduler().pauseTarget(this);
  this.getActionManager().pauseTarget(this)
}, setAdditionalTransform:function(additionalTransform) {
  this._additionalTransform = additionalTransform;
  this._transformDirty = true;
  this._additionalTransformDirty = true
}, parentToNodeTransform:function() {
  if(this._inverseDirty) {
    this._inverse = cc.AffineTransformInvert(this.nodeToParentTransform());
    this._inverseDirty = false
  }
  return this._inverse
}, nodeToWorldTransform:function() {
  var t = this.nodeToParentTransform();
  for(var p = this._parent;p != null;p = p.getParent()) {
    t = cc.AffineTransformConcat(t, p.nodeToParentTransform())
  }
  return t
}, worldToNodeTransform:function() {
  return cc.AffineTransformInvert(this.nodeToWorldTransform())
}, convertToNodeSpace:function(worldPoint) {
  return cc.PointApplyAffineTransform(worldPoint, this.worldToNodeTransform())
}, convertToWorldSpace:function(nodePoint) {
  return cc.PointApplyAffineTransform(nodePoint, this.nodeToWorldTransform())
}, convertToNodeSpaceAR:function(worldPoint) {
  return cc.pSub(this.convertToNodeSpace(worldPoint), this._anchorPointInPoints)
}, convertToWorldSpaceAR:function(nodePoint) {
  var pt = cc.pAdd(nodePoint, this._anchorPointInPoints);
  return this.convertToWorldSpace(pt)
}, _convertToWindowSpace:function(nodePoint) {
  var worldPoint = this.convertToWorldSpace(nodePoint);
  return cc.Director.getInstance().convertToUI(worldPoint)
}, convertTouchToNodeSpace:function(touch) {
  var point = touch.getLocation();
  return this.convertToNodeSpace(point)
}, convertTouchToNodeSpaceAR:function(touch) {
  var point = touch.getLocation();
  point = cc.Director.getInstance().convertToGL(point);
  return this.convertToNodeSpaceAR(point)
}, update:function(dt) {
}, updateTransform:function() {
  this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform)
}, retain:function() {
}, release:function() {
}, _transform4x4:null, _mvpMatrix:null, _stackMatrix:null, _glServerState:null, _camera:null, _grid:null, ctor:function() {
  this._initNode();
  this._transform4x4 = new cc.kmMat4;
  this._glServerState = 0;
  this._mvpMatrix = new cc.kmMat4;
  this._stackMatrix = new cc.kmMat4
}, visit:function(ctx) {
  if(!this._visible) {
    return
  }
  var context = ctx || cc.renderContext, i;
  this._stackMatrix = this._stackMatrix || new cc.kmMat4;
  cc.kmGLPushMatrixWitMat4(this._stackMatrix);
  if(this._grid && this._grid._active) {
    this._grid.beforeDraw()
  }
  this.transform();
  if(this._children && this._children.length > 0) {
    this.sortAllChildren();
    for(i = 0;i < this._children.length;i++) {
      if(this._children[i] && this._children[i]._zOrder < 0) {
        this._children[i].visit(context)
      }else {
        break
      }
    }
    this.draw(context);
    for(;i < this._children.length;i++) {
      if(this._children[i]) {
        this._children[i].visit(context)
      }
    }
  }else {
    this.draw(context)
  }
  this._orderOfArrival = 0;
  if(this._grid && this._grid.isActive()) {
    this._grid.afterDraw(this)
  }
  cc.kmGLPopMatrix()
}, transform:function() {
  this._transform4x4 = this._transform4x4 || new cc.kmMat4;
  cc.CGAffineToGL(this.nodeToParentTransform(), this._transform4x4.mat);
  this._transform4x4.mat[14] = this._vertexZ;
  cc.kmGLMultMatrix(this._transform4x4);
  if(this._camera != null && !(this._grid != null && this._grid.isActive())) {
    var translate = this._anchorPointInPoints.x != 0 || this._anchorPointInPoints.y != 0;
    if(translate) {
      cc.kmGLTranslatef(cc.RENDER_IN_SUBPIXEL(this._anchorPointInPoints.x), cc.RENDER_IN_SUBPIXEL(this._anchorPointInPoints.y), 0)
    }
    this._camera.locate();
    if(translate) {
      cc.kmGLTranslatef(cc.RENDER_IN_SUBPIXEL(-this._anchorPointInPoints.x), cc.RENDER_IN_SUBPIXEL(-this._anchorPointInPoints.y), 0)
    }
  }
}, nodeToParentTransform:function() {
  if(this._transformDirty) {
    var x = this._position.x;
    var y = this._position.y;
    if(this._ignoreAnchorPointForPosition) {
      x += this._anchorPointInPoints.x;
      y += this._anchorPointInPoints.y
    }
    var cx = 1, sx = 0, cy = 1, sy = 0;
    if(this._rotationX !== 0 || this._rotationY !== 0) {
      cx = Math.cos(-this._rotationRadiansX);
      sx = Math.sin(-this._rotationRadiansX);
      cy = Math.cos(-this._rotationRadiansY);
      sy = Math.sin(-this._rotationRadiansY)
    }
    var needsSkewMatrix = this._skewX || this._skewY;
    if(!needsSkewMatrix && (this._anchorPointInPoints.x !== 0 || this._anchorPointInPoints.y !== 0)) {
      x += cy * -this._anchorPointInPoints.x * this._scaleX + -sx * -this._anchorPointInPoints.y * this._scaleY;
      y += sy * -this._anchorPointInPoints.x * this._scaleX + cx * -this._anchorPointInPoints.y * this._scaleY
    }
    this._transform = {a:cy * this._scaleX, b:sy * this._scaleX, c:-sx * this._scaleY, d:cx * this._scaleY, tx:x, ty:y};
    if(needsSkewMatrix) {
      var skewMatrix = {a:1, b:Math.tan(cc.DEGREES_TO_RADIANS(this._skewY)), c:Math.tan(cc.DEGREES_TO_RADIANS(this._skewX)), d:1, tx:0, ty:0};
      this._transform = cc.AffineTransformConcat(skewMatrix, this._transform);
      if(this._anchorPointInPoints.x !== 0 || this._anchorPointInPoints.y !== 0) {
        this._transform = cc.AffineTransformTranslate(this._transform, -this._anchorPointInPoints.x, -this._anchorPointInPoints.y)
      }
    }
    if(this._additionalTransformDirty) {
      this._transform = cc.AffineTransformConcat(this._transform, this._additionalTransform);
      this._additionalTransformDirty = false
    }
    this._transformDirty = false
  }
  return this._transform
}, setNodeDirty:function() {
  this._transformDirty = this._inverseDirty = true
}, getCamera:function() {
  if(!this._camera) {
    this._camera = new cc.Camera
  }
  return this._camera
}, getGrid:function() {
  return this._grid
}, setGrid:function(grid) {
  this._grid = grid
}, getShaderProgram:function() {
  return this._shaderProgram
}, setShaderProgram:function(newShaderProgram) {
  this._shaderProgram = newShaderProgram
}, getGLServerState:function() {
  return this._glServerState
}, setGLServerState:function(state) {
  this._glServerState = state
}});
cc.NodeWebGL.StateCallbackType = {onEnter:1, onExit:2, cleanup:3, onEnterTransitionDidFinish:4, updateTransform:5, onExitTransitionDidStart:6, sortAllChildren:7};
cc.NodeWebGL.create = function() {
  return new cc.NodeWebGL
};
cc.NodeCanvas = cc.Class.extend({_zOrder:0, _vertexZ:0, _rotationX:0, _rotationY:0, _scaleX:1, _scaleY:1, _position:null, _skewX:0, _skewY:0, _children:null, _visible:true, _anchorPoint:null, _anchorPointInPoints:null, _contentSize:null, _running:false, _parent:null, _ignoreAnchorPointForPosition:false, _tag:cc.NODE_TAG_INVALID, _userData:null, _userObject:null, _transformDirty:true, _inverseDirty:true, _cacheDirty:true, _transformGLDirty:null, _transform:null, _inverse:null, _reorderChildDirty:false, 
_shaderProgram:null, _orderOfArrival:0, _actionManager:null, _scheduler:null, _initializedNode:false, _additionalTransformDirty:false, _additionalTransform:null, _initNode:function() {
  this._anchorPoint = cc.p(0, 0);
  this._anchorPointInPoints = cc.p(0, 0);
  this._contentSize = cc.size(0, 0);
  this._position = cc.p(0, 0);
  var director = cc.Director.getInstance();
  this._actionManager = director.getActionManager();
  this.getActionManager = function() {
    return this._actionManager
  };
  this._scheduler = director.getScheduler();
  this.getScheduler = function() {
    return this._scheduler
  };
  this._initializedNode = true;
  this._additionalTransform = cc.AffineTransformMakeIdentity();
  this._additionalTransformDirty = false
}, init:function() {
  if(this._initializedNode === false) {
    this._initNode()
  }
  return true
}, _arrayMakeObjectsPerformSelector:function(array, callbackType) {
  if(!array || array.length == 0) {
    return
  }
  var i;
  switch(callbackType) {
    case cc.Node.StateCallbackType.onEnter:
      for(i = 0;i < array.length;i++) {
        if(array[i]) {
          array[i].onEnter()
        }
      }
      break;
    case cc.Node.StateCallbackType.onExit:
      for(i = 0;i < array.length;i++) {
        if(array[i]) {
          array[i].onExit()
        }
      }
      break;
    case cc.Node.StateCallbackType.onEnterTransitionDidFinish:
      for(i = 0;i < array.length;i++) {
        if(array[i]) {
          array[i].onEnterTransitionDidFinish()
        }
      }
      break;
    case cc.Node.StateCallbackType.cleanup:
      for(i = 0;i < array.length;i++) {
        if(array[i]) {
          array[i].cleanup()
        }
      }
      break;
    case cc.Node.StateCallbackType.updateTransform:
      for(i = 0;i < array.length;i++) {
        if(array[i]) {
          array[i].updateTransform()
        }
      }
      break;
    case cc.Node.StateCallbackType.onExitTransitionDidStart:
      for(i = 0;i < array.length;i++) {
        if(array[i]) {
          array[i].onExitTransitionDidStart()
        }
      }
      break;
    case cc.Node.StateCallbackType.sortAllChildren:
      for(i = 0;i < array.length;i++) {
        if(array[i]) {
          array[i].sortAllChildren()
        }
      }
      break;
    default:
      throw"Unknown callback function";break
  }
}, setNodeDirty:function() {
  this._transformDirty = this._inverseDirty = true
}, getSkewX:function() {
  return this._skewX
}, setSkewX:function(newSkewX) {
  this._skewX = newSkewX;
  this.setNodeDirty()
}, getSkewY:function() {
  return this._skewY
}, setSkewY:function(newSkewY) {
  this._skewY = newSkewY;
  this.setNodeDirty()
}, getZOrder:function() {
  return this._zOrder
}, _setZOrder:function(z) {
  this._zOrder = z
}, setZOrder:function(z) {
  this._setZOrder(z);
  if(this._parent) {
    this._parent.reorderChild(this, z)
  }
}, getVertexZ:function() {
  return this._vertexZ
}, setVertexZ:function(Var) {
  this._vertexZ = Var
}, getRotation:function() {
  cc.Assert(this._rotationX == this._rotationY, "CCNode#rotation. RotationX != RotationY. Don't know which one to return");
  return this._rotationX
}, _rotationRadiansX:0, _rotationRadiansY:0, setRotation:function(newRotation) {
  this._rotationX = this._rotationY = newRotation;
  this._rotationRadiansX = this._rotationX * 0.017453292519943295;
  this._rotationRadiansY = this._rotationY * 0.017453292519943295;
  this.setNodeDirty()
}, getRotationX:function() {
  return this._rotationX
}, setRotationX:function(rotationX) {
  this._rotationX = rotationX;
  this._rotationRadiansX = this._rotationX * 0.017453292519943295;
  this.setNodeDirty()
}, getRotationY:function() {
  return this._rotationY
}, setRotationY:function(rotationY) {
  this._rotationY = rotationY;
  this._rotationRadiansY = this._rotationY * 0.017453292519943295;
  this.setNodeDirty()
}, getScale:function() {
  cc.Assert(this._scaleX == this._scaleY, "cc.Node#scale. ScaleX != ScaleY. Don't know which one to return");
  return this._scaleX
}, setScale:function(scale, scaleY) {
  this._scaleX = scale;
  this._scaleY = scaleY || scale;
  this.setNodeDirty()
}, getScaleX:function() {
  return this._scaleX
}, setScaleX:function(newScaleX) {
  this._scaleX = newScaleX;
  this.setNodeDirty()
}, getScaleY:function() {
  return this._scaleY
}, setScaleY:function(newScaleY) {
  this._scaleY = newScaleY;
  this.setNodeDirty()
}, setPosition:function(newPosOrxValue, yValue) {
  if(arguments.length === 2) {
    this._position = new cc.Point(newPosOrxValue, yValue)
  }else {
    if(arguments.length === 1) {
      this._position = new cc.Point(newPosOrxValue.x, newPosOrxValue.y)
    }
  }
  this.setNodeDirty()
}, _setPositionByValue:function(newPosOrxValue, yValue) {
  if(arguments.length === 2) {
    this._position.x = newPosOrxValue;
    this._position.y = yValue
  }else {
    if(arguments.length === 1) {
      this._position.x = newPosOrxValue.x;
      this._position.y = newPosOrxValue.y
    }
  }
  this.setNodeDirty()
}, getPosition:function() {
  return cc.p(this._position.x, this._position.y)
}, getPositionX:function() {
  return this._position.x
}, setPositionX:function(x) {
  this._position.x = x;
  this.setNodeDirty()
}, getPositionY:function() {
  return this._position.y
}, setPositionY:function(y) {
  this._position.y = y;
  this.setNodeDirty()
}, getChildrenCount:function() {
  return this._children ? this._children.length : 0
}, getChildren:function() {
  if(!this._children) {
    this._children = []
  }
  return this._children
}, isVisible:function() {
  return this._visible
}, setVisible:function(Var) {
  this._visible = Var;
  this.setNodeDirty()
}, getAnchorPoint:function() {
  return cc.p(this._anchorPoint.x, this._anchorPoint.y)
}, setAnchorPoint:function(point) {
  if(!cc.Point.CCPointEqualToPoint(point, this._anchorPoint)) {
    this._anchorPoint = new cc.Point(point.x, point.y);
    this._anchorPointInPoints = new cc.Point(this._contentSize.width * this._anchorPoint.x, this._contentSize.height * this._anchorPoint.y);
    this.setNodeDirty()
  }
}, getAnchorPointInPoints:function() {
  return cc.p(this._anchorPointInPoints.x, this._anchorPointInPoints.y)
}, getContentSize:function() {
  return cc.size(this._contentSize.width, this._contentSize.height)
}, setContentSize:function(size) {
  if(!cc.Size.CCSizeEqualToSize(size, this._contentSize)) {
    this._contentSize = new cc.Size(size.width, size.height);
    this._anchorPointInPoints = new cc.Point(this._contentSize.width * this._anchorPoint.x, this._contentSize.height * this._anchorPoint.y);
    this.setNodeDirty()
  }
}, isRunning:function() {
  return this._running
}, getParent:function() {
  return this._parent
}, setParent:function(Var) {
  this._parent = Var
}, isIgnoreAnchorPointForPosition:function() {
  return this._ignoreAnchorPointForPosition
}, ignoreAnchorPointForPosition:function(newValue) {
  if(newValue != this._ignoreAnchorPointForPosition) {
    this._ignoreAnchorPointForPosition = newValue;
    this.setNodeDirty()
  }
}, getTag:function() {
  return this._tag
}, setTag:function(Var) {
  this._tag = Var
}, getUserData:function() {
  return this._userData
}, setUserData:function(Var) {
  this._userData = Var
}, getUserObject:function() {
  return this._userObject
}, setUserObject:function(newValue) {
  if(this._userObject != newValue) {
    this._userObject = newValue
  }
}, getOrderOfArrival:function() {
  return this._orderOfArrival
}, setOrderOfArrival:function(Var) {
  this._orderOfArrival = Var
}, getActionManager:function() {
  if(!this._actionManager) {
    this._actionManager = cc.Director.getInstance().getActionManager();
    this.getActionManager = function() {
      return this._actionManager
    }
  }
  return this._actionManager
}, setActionManager:function(actionManager) {
  if(this._actionManager != actionManager) {
    this.stopAllActions();
    this._actionManager = actionManager
  }
}, getScheduler:function() {
  if(!this._scheduler) {
    this._scheduler = cc.Director.getInstance().getScheduler();
    this.getScheduler = function() {
      return this._scheduler
    }
  }
  return this._scheduler
}, setScheduler:function(scheduler) {
  if(this._scheduler != scheduler) {
    this.unscheduleAllCallbacks();
    this._scheduler = scheduler
  }
}, getBoundingBox:function() {
  var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
  return cc.RectApplyAffineTransform(rect, this.nodeToParentTransform())
}, cleanup:function() {
  this.stopAllActions();
  this.unscheduleAllCallbacks();
  this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.cleanup)
}, description:function() {
  return"<cc.Node | Tag =" + this._tag + ">"
}, _childrenAlloc:function() {
  this._children = []
}, getChildByTag:function(aTag) {
  if(this._children != null) {
    for(var i = 0;i < this._children.length;i++) {
      var node = this._children[i];
      if(node && node._tag == aTag) {
        return node
      }
    }
  }
  return null
}, addChild:function(child, zOrder, tag) {
  if(child === this) {
    console.warn("cc.Node.addChild: An Node can't be added as a child of itself.");
    return
  }
  cc.Assert(child != null, "Argument must be non-nil");
  if(child._parent !== null) {
    cc.Assert(child._parent === null, "child already added. It can't be added again");
    return
  }
  var tempzOrder = zOrder != null ? zOrder : child.getZOrder();
  var tmptag = tag != null ? tag : child.getTag();
  child.setTag(tmptag);
  if(!this._children) {
    this._childrenAlloc()
  }
  this._insertChild(child, tempzOrder);
  child.setParent(this);
  if(this._running) {
    child.onEnter();
    child.onEnterTransitionDidFinish()
  }
}, removeFromParent:function(cleanup) {
  if(this._parent) {
    if(cleanup == null) {
      cleanup = true
    }
    this._parent.removeChild(this, cleanup)
  }
}, removeFromParentAndCleanup:function(cleanup) {
  cc.log("removeFromParentAndCleanup is deprecated. Use removeFromParent instead");
  this.removeFromParent(cleanup)
}, removeChild:function(child, cleanup) {
  if(this._children == null) {
    return
  }
  if(cleanup == null) {
    cleanup = true
  }
  if(this._children.indexOf(child) > -1) {
    this._detachChild(child, cleanup)
  }
  this.setNodeDirty()
}, removeChildByTag:function(tag, cleanup) {
  cc.Assert(tag != cc.NODE_TAG_INVALID, "Invalid tag");
  var child = this.getChildByTag(tag);
  if(child == null) {
    cc.log("cocos2d: removeChildByTag: child not found!")
  }else {
    this.removeChild(child, cleanup)
  }
}, removeAllChildrenWithCleanup:function(cleanup) {
  cc.log("removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead");
  this.removeAllChildren(cleanup)
}, removeAllChildren:function(cleanup) {
  if(this._children != null) {
    if(cleanup == null) {
      cleanup = true
    }
    for(var i = 0;i < this._children.length;i++) {
      var node = this._children[i];
      if(node) {
        if(this._running) {
          node.onExitTransitionDidStart();
          node.onExit()
        }
        if(cleanup) {
          node.cleanup()
        }
        node.setParent(null)
      }
    }
    this._children.length = 0
  }
}, _detachChild:function(child, doCleanup) {
  if(this._running) {
    child.onExitTransitionDidStart();
    child.onExit()
  }
  if(doCleanup) {
    child.cleanup()
  }
  child.setParent(null);
  cc.ArrayRemoveObject(this._children, child)
}, _insertChild:function(child, z) {
  this._reorderChildDirty = true;
  var a = this._children[this._children.length - 1];
  if(!a || a.getZOrder() <= z) {
    this._children.push(child)
  }else {
    for(var i = 0;i < this._children.length;i++) {
      var node = this._children[i];
      if(node && node.getZOrder() > z) {
        this._children = cc.ArrayAppendObjectToIndex(this._children, child, i);
        break
      }
    }
  }
  child._setZOrder(z)
}, reorderChild:function(child, zOrder) {
  cc.Assert(child != null, "Child must be non-nil");
  this._reorderChildDirty = true;
  child.setOrderOfArrival(cc.s_globalOrderOfArrival++);
  child._setZOrder(zOrder);
  this.setNodeDirty()
}, sortAllChildren:function() {
  if(this._reorderChildDirty) {
    var i, j, length = this._children.length;
    for(i = 0;i < length;i++) {
      var tempItem = this._children[i];
      j = i - 1;
      while(j >= 0 && (tempItem._zOrder < this._children[j]._zOrder || tempItem._zOrder == this._children[j]._zOrder && tempItem._orderOfArrival < this._children[j]._orderOfArrival)) {
        this._children[j + 1] = this._children[j];
        j = j - 1
      }
      this._children[j + 1] = tempItem
    }
    this._reorderChildDirty = false
  }
}, draw:function(ctx) {
}, transformAncestors:function() {
  if(this._parent != null) {
    this._parent.transformAncestors();
    this._parent.transform()
  }
}, onEnter:function() {
  this._running = true;
  this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnter);
  this.resumeSchedulerAndActions()
}, onEnterTransitionDidFinish:function() {
  this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnterTransitionDidFinish)
}, onExitTransitionDidStart:function() {
  this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExitTransitionDidStart)
}, onExit:function() {
  this._running = false;
  this.pauseSchedulerAndActions();
  this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExit)
}, runAction:function(action) {
  cc.Assert(action != null, "Argument must be non-nil");
  this.getActionManager().addAction(action, this, !this._running);
  return action
}, stopAllActions:function() {
  this.getActionManager().removeAllActionsFromTarget(this)
}, stopAction:function(action) {
  this.getActionManager().removeAction(action)
}, stopActionByTag:function(tag) {
  cc.Assert(tag != cc.ACTION_TAG_INVALID, "Invalid tag");
  this.getActionManager().removeActionByTag(tag, this)
}, getActionByTag:function(tag) {
  cc.Assert(tag != cc.ACTION_TAG_INVALID, "Invalid tag");
  return this.getActionManager().getActionByTag(tag, this)
}, numberOfRunningActions:function() {
  return this.getActionManager().numberOfRunningActionsInTarget(this)
}, scheduleUpdate:function() {
  this.scheduleUpdateWithPriority(0)
}, scheduleUpdateWithPriority:function(priority) {
  this.getScheduler().scheduleUpdateForTarget(this, priority, !this._running)
}, unscheduleUpdate:function() {
  this.getScheduler().unscheduleUpdateForTarget(this)
}, schedule:function(callback_fn, interval, repeat, delay) {
  interval = interval || 0;
  cc.Assert(callback_fn, "Argument must be non-nil");
  cc.Assert(interval >= 0, "Argument must be positive");
  repeat = repeat == null ? cc.REPEAT_FOREVER : repeat;
  delay = delay || 0;
  this.getScheduler().scheduleCallbackForTarget(this, callback_fn, interval, repeat, delay, !this._running)
}, scheduleOnce:function(callback_fn, delay) {
  this.schedule(callback_fn, 0, 0, delay)
}, unschedule:function(callback_fn) {
  if(!callback_fn) {
    return
  }
  this.getScheduler().unscheduleCallbackForTarget(this, callback_fn)
}, unscheduleAllCallbacks:function() {
  this.getScheduler().unscheduleAllCallbacksForTarget(this)
}, resumeSchedulerAndActions:function() {
  this.getScheduler().resumeTarget(this);
  this.getActionManager().resumeTarget(this)
}, pauseSchedulerAndActions:function() {
  this.getScheduler().pauseTarget(this);
  this.getActionManager().pauseTarget(this)
}, setAdditionalTransform:function(additionalTransform) {
  this._additionalTransform = additionalTransform;
  this._transformDirty = true;
  this._additionalTransformDirty = true
}, parentToNodeTransform:function() {
  if(this._inverseDirty) {
    this._inverse = cc.AffineTransformInvert(this.nodeToParentTransform());
    this._inverseDirty = false
  }
  return this._inverse
}, nodeToWorldTransform:function() {
  var t = this.nodeToParentTransform();
  for(var p = this._parent;p != null;p = p.getParent()) {
    t = cc.AffineTransformConcat(t, p.nodeToParentTransform())
  }
  return t
}, worldToNodeTransform:function() {
  return cc.AffineTransformInvert(this.nodeToWorldTransform())
}, convertToNodeSpace:function(worldPoint) {
  return cc.PointApplyAffineTransform(worldPoint, this.worldToNodeTransform())
}, convertToWorldSpace:function(nodePoint) {
  return cc.PointApplyAffineTransform(nodePoint, this.nodeToWorldTransform())
}, convertToNodeSpaceAR:function(worldPoint) {
  return cc.pSub(this.convertToNodeSpace(worldPoint), this._anchorPointInPoints)
}, convertToWorldSpaceAR:function(nodePoint) {
  var pt = cc.pAdd(nodePoint, this._anchorPointInPoints);
  return this.convertToWorldSpace(pt)
}, _convertToWindowSpace:function(nodePoint) {
  var worldPoint = this.convertToWorldSpace(nodePoint);
  return cc.Director.getInstance().convertToUI(worldPoint)
}, convertTouchToNodeSpace:function(touch) {
  var point = touch.getLocation();
  return this.convertToNodeSpace(point)
}, convertTouchToNodeSpaceAR:function(touch) {
  var point = touch.getLocation();
  point = cc.Director.getInstance().convertToGL(point);
  return this.convertToNodeSpaceAR(point)
}, update:function(dt) {
}, updateTransform:function() {
  this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform)
}, retain:function() {
}, release:function() {
}, ctor:function() {
  this._initNode()
}, visit:function(ctx) {
  if(!this._visible) {
    return
  }
  var context = ctx || cc.renderContext, i;
  context.save();
  this.transform(context);
  if(this._children && this._children.length > 0) {
    this.sortAllChildren();
    for(i = 0;i < this._children.length;i++) {
      if(this._children[i] && this._children[i]._zOrder < 0) {
        this._children[i].visit(context)
      }else {
        break
      }
    }
    this.draw(context);
    for(;i < this._children.length;i++) {
      if(this._children[i] && this._children[i]._zOrder >= 0) {
        this._children[i].visit(context)
      }
    }
  }else {
    this.draw(context)
  }
  this._orderOfArrival = 0;
  context.restore()
}, transform:function(ctx) {
  var context = ctx || cc.renderContext;
  var t = this.nodeToParentTransform();
  context.transform(t.a, t.b, t.c, t.d, t.tx, -t.ty)
}, nodeToParentTransform:function() {
  if(!this._transform) {
    this._transform = {a:1, b:0, c:0, d:1, tx:0, ty:0}
  }
  if(this._transformDirty) {
    var t = this._transform;
    t.tx = this._position.x;
    t.ty = this._position.y;
    var Cos = 1, Sin = 0;
    if(this._rotationX) {
      Cos = Math.cos(this._rotationRadiansX);
      Sin = Math.sin(this._rotationRadiansX)
    }
    t.a = t.d = Cos;
    t.c = -Sin;
    t.b = Sin;
    var sx = this._scaleX < 1E-6 && this._scaleX > -1E-6 ? 1E-6 : this._scaleX, sy = this._scaleY < 1E-6 && this._scaleY > -1E-6 ? 1E-6 : this._scaleY;
    if(this._skewX || this._skewY) {
      var skx = Math.tan(-this._skewX * Math.PI / 180);
      var sky = Math.tan(-this._skewY * Math.PI / 180);
      var xx = this._anchorPointInPoints.y * skx * sx;
      var yy = this._anchorPointInPoints.x * sky * sy;
      t.a = Cos + -Sin * sky;
      t.c = Cos * skx + -Sin;
      t.b = Sin + Cos * sky;
      t.d = Sin * skx + Cos;
      t.tx += Cos * xx + -Sin * yy;
      t.ty += Sin * xx + Cos * yy
    }
    if(this._scaleX !== 1 || this._scaleY !== 1) {
      t.a *= sx;
      t.b *= sx;
      t.c *= sy;
      t.d *= sy
    }
    t.tx += Cos * -this._anchorPointInPoints.x * sx + -Sin * this._anchorPointInPoints.y * sy;
    t.ty -= Sin * -this._anchorPointInPoints.x * sx + Cos * this._anchorPointInPoints.y * sy;
    if(this._ignoreAnchorPointForPosition) {
      t.tx += this._anchorPointInPoints.x;
      t.ty += this._anchorPointInPoints.y
    }
    if(this._additionalTransformDirty) {
      this._transform = cc.AffineTransformConcat(this._transform, this._additionalTransform);
      this._transform.b *= -1;
      this._transform.c *= -1;
      this._additionalTransformDirty = false
    }
    t.tx = t.tx | 0;
    t.ty = t.ty | 0;
    this._transformDirty = false
  }
  return this._transform
}, setNodeDirty:function() {
  this._setNodeDirtyForCache();
  this._transformDirty = this._inverseDirty = true
}, _setNodeDirtyForCache:function() {
  this._cacheDirty = true;
  if(this._parent) {
    this._parent._setNodeDirtyForCache()
  }
}, getBoundingBoxToWorld:function() {
  var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
  rect = cc.RectApplyAffineTransform(rect, this.nodeToWorldTransform());
  rect = cc.rect(0 | rect.origin.x - 4, 0 | rect.origin.y - 4, 0 | rect.size.width + 8, 0 | rect.size.height + 8);
  if(!this._children) {
    return rect
  }
  for(var i = 0;i < this._children.length;i++) {
    var child = this._children[i];
    if(child && child._visible) {
      var childRect = child.getBoundingBoxToWorld();
      if(childRect) {
        rect = cc.Rect.CCRectUnion(rect, childRect)
      }
    }
  }
  return rect
}});
cc.NodeCanvas.StateCallbackType = {onEnter:1, onExit:2, cleanup:3, onEnterTransitionDidFinish:4, updateTransform:5, onExitTransitionDidStart:6, sortAllChildren:7};
cc.NodeCanvas.create = function() {
  return new cc.NodeCanvas
};
cc.Node = cc.Browser.supportWebGL ? cc.NodeWebGL : cc.NodeCanvas;
cc.NodeRGBA = cc.Node.extend({RGBAProtocol:true, _displayedOpacity:0, _realOpacity:0, _displayedColor:null, _realColor:null, _cascadeColorEnabled:false, _cascadeOpacityEnabled:false, ctor:function() {
  this._super();
  this._displayedOpacity = 255;
  this._realOpacity = 255;
  this._displayedColor = cc.WHITE;
  this._realColor = cc.WHITE;
  this._cascadeColorEnabled = false;
  this._cascadeOpacityEnabled = false
}, init:function() {
  if(this._super()) {
    this._displayedOpacity = this._realOpacity = 255;
    this._displayedColor = cc.WHITE;
    this._realColor = cc.WHITE;
    this._cascadeOpacityEnabled = this._cascadeColorEnabled = false;
    return true
  }
  return false
}, getOpacity:function() {
  return this._realOpacity
}, getDisplayedOpacity:function() {
  return this._displayedOpacity
}, setOpacity:function(opacity) {
  this._displayedOpacity = this._realOpacity = opacity;
  if(this._cascadeOpacityEnabled) {
    var parentOpacity = 255;
    if(this._parent && this._parent.RGBAProtocol && this._parent.isCascadeOpacityEnabled()) {
      parentOpacity = this._parent.getDisplayedOpacity()
    }
    this.updateDisplayedOpacity(parentOpacity)
  }
}, updateDisplayedOpacity:function(parentOpacity) {
  this._displayedOpacity = this._realOpacity * parentOpacity / 255;
  if(this._cascadeOpacityEnabled) {
    var selChildren = this._children;
    for(var i = 0;i < selChildren.length;i++) {
      var item = selChildren[i];
      if(item && item.RGBAProtocol) {
        item.updateDisplayedOpacity(this._displayedOpacity)
      }
    }
  }
}, isCascadeOpacityEnabled:function() {
  return this._cascadeOpacityEnabled
}, setCascadeOpacityEnabled:function(cascadeOpacityEnabled) {
  this._cascadeOpacityEnabled = cascadeOpacityEnabled
}, getColor:function() {
  return this._realColor
}, getDisplayedColor:function() {
  return this._displayedColor
}, setColor:function(color) {
  this._displayedColor = this._realColor = color;
  if(this._cascadeColorEnabled) {
    var parentColor = cc.WHITE;
    if(this._parent && this._parent.RGBAProtocol && this._parent.isCascadeColorEnabled()) {
      parentColor = this._parent.getDisplayedColor()
    }
    this.updateDisplayedColor(parentColor)
  }
}, updateDisplayedColor:function(parentColor) {
  this._displayedColor.r = this._realColor.r * parentColor.r / 255;
  this._displayedColor.g = this._realColor.g * parentColor.g / 255;
  this._displayedColor.b = this._realColor.b * parentColor.b / 255;
  if(this._cascadeColorEnabled) {
    var selChildren = this._children;
    for(var i = 0;i < selChildren.length;i++) {
      var item = selChildren[i];
      if(item && item.RGBAProtocol) {
        item.updateDisplayedColor(this._displayedColor)
      }
    }
  }
}, isCascadeColorEnabled:function() {
  return this._cascadeColorEnabled
}, setCascadeColorEnabled:function(cascadeColorEnabled) {
  this._cascadeColorEnabled = cascadeColorEnabled
}, setOpacityModifyRGB:function(opacityValue) {
}, isOpacityModifyRGB:function() {
  return false
}});
cc.AtlasNodeCanvas = cc.Node.extend({RGBAProtocol:true, _itemsPerRow:0, _itemsPerColumn:0, _itemWidth:0, _itemHeight:0, _colorUnmodified:null, _textureAtlas:null, _opacityModifyRGB:false, _blendFunc:null, _opacity:0, _color:null, _quadsToDraw:0, ctor:function() {
  this._super();
  this._colorUnmodified = cc.WHITE;
  this._color = cc.white();
  this._blendFunc = {src:cc.BLEND_SRC, dst:cc.BLEND_DST};
  this._opacity = 255
}, updateAtlasValues:function() {
  cc.Assert(false, "cc.AtlasNode:Abstract updateAtlasValue not overridden")
}, getColor:function() {
  if(this._opacityModifyRGB) {
    return this._colorUnmodified
  }
  return this._color
}, getOpacity:function() {
  return this._opacity
}, setOpacityModifyRGB:function(value) {
  var oldColor = this.getColor();
  this._opacityModifyRGB = value;
  this.setColor(oldColor)
}, isOpacityModifyRGB:function() {
  return this._opacityModifyRGB
}, getBlendFunc:function() {
  return this._blendFunc
}, setBlendFunc:function(src, dst) {
  if(arguments.length == 1) {
    this._blendFunc = src
  }else {
    this._blendFunc = {src:src, dst:dst}
  }
}, setTextureAtlas:function(value) {
  this._textureAtlas = value
}, getTextureAtlas:function() {
  return this._textureAtlas
}, getQuadsToDraw:function() {
  return this._quadsToDraw
}, setQuadsToDraw:function(quadsToDraw) {
  this._quadsToDraw = quadsToDraw
}, _textureForCanvas:null, _originalTexture:null, _colorF32Array:null, initWithTileFile:function(tile, tileWidth, tileHeight, itemsToRender) {
  cc.Assert(tile != null, "title should not be null");
  this._itemWidth = tileWidth;
  this._itemHeight = tileHeight;
  this._opacityModifyRGB = true;
  this._originalTexture = cc.TextureCache.getInstance().addImage(tile);
  if(!this._originalTexture) {
    cc.log("cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.");
    return false
  }
  this._textureForCanvas = this._originalTexture;
  this._calculateMaxItems();
  this._quadsToDraw = itemsToRender;
  return true
}, setColor:function(color3) {
  if(this._color.r == color3.r && this._color.g == color3.g && this._color.b == color3.b) {
    return
  }
  this._color = this._colorUnmodified = color3;
  if(this.getTexture()) {
    var cacheTextureForColor = cc.TextureCache.getInstance().getTextureColors(this._originalTexture);
    if(cacheTextureForColor) {
      var tx = this._originalTexture;
      var textureRect = cc.rect(0, 0, tx.width, tx.height);
      var colorTexture = cc.generateTintImage(tx, cacheTextureForColor, this._color, textureRect);
      this.setTexture(colorTexture)
    }
  }
  if(this._opacityModifyRGB) {
    this._color.r = color3.r * this._opacity / 255;
    this._color.g = color3.g * this._opacity / 255;
    this._color.b = color3.b * this._opacity / 255
  }
}, setOpacity:function(opacity) {
  this._opacity = opacity;
  if(this._opacityModifyRGB) {
    this.setColor(this._colorUnmodified)
  }
}, getTexture:function() {
  return this._textureForCanvas
}, setTexture:function(texture) {
  this._textureForCanvas = texture
}, _calculateMaxItems:function() {
  var selTexture = this.getTexture();
  var size = cc.size(selTexture.width, selTexture.height);
  this._itemsPerColumn = 0 | size.height / this._itemHeight;
  this._itemsPerRow = 0 | size.width / this._itemWidth
}});
cc.AtlasNodeCanvas.create = function(tile, tileWidth, tileHeight, itemsToRender) {
  var ret = new cc.AtlasNodeCanvas;
  if(ret.initWithTileFile(tile, tileWidth, tileHeight, itemsToRender)) {
    return ret
  }
  return null
};
cc.AtlasNodeWebGL = cc.Node.extend({RGBAProtocol:true, _itemsPerRow:0, _itemsPerColumn:0, _itemWidth:0, _itemHeight:0, _colorUnmodified:null, _textureAtlas:null, _opacityModifyRGB:false, _blendFunc:null, _opacity:0, _color:null, _quadsToDraw:0, ctor:function() {
  this._super();
  this._colorUnmodified = cc.WHITE;
  this._color = cc.white();
  this._blendFunc = {src:cc.BLEND_SRC, dst:cc.BLEND_DST};
  this._opacity = 255
}, updateAtlasValues:function() {
  cc.Assert(false, "cc.AtlasNode:Abstract updateAtlasValue not overridden")
}, getColor:function() {
  if(this._opacityModifyRGB) {
    return this._colorUnmodified
  }
  return this._color
}, getOpacity:function() {
  return this._opacity
}, setOpacityModifyRGB:function(value) {
  var oldColor = this.getColor();
  this._opacityModifyRGB = value;
  this.setColor(oldColor)
}, isOpacityModifyRGB:function() {
  return this._opacityModifyRGB
}, getBlendFunc:function() {
  return this._blendFunc
}, setBlendFunc:function(src, dst) {
  if(arguments.length == 1) {
    this._blendFunc = src
  }else {
    this._blendFunc = {src:src, dst:dst}
  }
}, setTextureAtlas:function(value) {
  this._textureAtlas = value
}, getTextureAtlas:function() {
  return this._textureAtlas
}, getQuadsToDraw:function() {
  return this._quadsToDraw
}, setQuadsToDraw:function(quadsToDraw) {
  this._quadsToDraw = quadsToDraw
}, _uniformColor:null, initWithTileFile:function(tile, tileWidth, tileHeight, itemsToRender) {
  cc.Assert(tile != null, "title should not be null");
  this._itemWidth = tileWidth;
  this._itemHeight = tileHeight;
  this._opacityModifyRGB = true;
  this._colorF32Array = new Float32Array([this._color.r / 255, this._color.g / 255, this._color.b / 255, this._opacity / 255]);
  var newAtlas = new cc.TextureAtlas;
  newAtlas.initWithFile(tile, itemsToRender);
  this.setTextureAtlas(newAtlas);
  if(!this._textureAtlas) {
    cc.log("cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.");
    return false
  }
  this._updateBlendFunc();
  this._updateOpacityModifyRGB();
  this._calculateMaxItems();
  this._quadsToDraw = itemsToRender;
  this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR));
  this._uniformColor = cc.renderContext.getUniformLocation(this.getShaderProgram().getProgram(), "u_color");
  return true
}, draw:function(ctx) {
  var context = ctx || cc.renderContext;
  cc.NODE_DRAW_SETUP(this);
  cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
  context.uniform4fv(this._uniformColor, this._colorF32Array);
  this._textureAtlas.drawNumberOfQuads(this._quadsToDraw, 0)
}, setColor:function(color3) {
  if(this._color.r == color3.r && this._color.g == color3.g && this._color.b == color3.b) {
    return
  }
  this._color = this._colorUnmodified = color3;
  if(this._opacityModifyRGB) {
    this._color.r = color3.r * this._opacity / 255;
    this._color.g = color3.g * this._opacity / 255;
    this._color.b = color3.b * this._opacity / 255
  }
  this._colorF32Array = new Float32Array([this._color.r / 255, this._color.g / 255, this._color.b / 255, this._opacity / 255])
}, setOpacity:function(opacity) {
  this._opacity = opacity;
  if(this._opacityModifyRGB) {
    this.setColor(this._colorUnmodified)
  }else {
    this._colorF32Array = new Float32Array([this._color.r / 255, this._color.g / 255, this._color.b / 255, this._opacity / 255])
  }
}, getTexture:function() {
  return this._textureAtlas.getTexture()
}, setTexture:function(texture) {
  this._textureAtlas.setTexture(texture);
  this._updateBlendFunc();
  this._updateOpacityModifyRGB()
}, _calculateMaxItems:function() {
  var selTexture = this.getTexture();
  var size = selTexture.getContentSize();
  this._itemsPerColumn = 0 | size.height / this._itemHeight;
  this._itemsPerRow = 0 | size.width / this._itemWidth
}, _updateBlendFunc:function() {
  if(!this._textureAtlas.getTexture().hasPremultipliedAlpha()) {
    this._blendFunc.src = gl.SRC_ALPHA;
    this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA
  }
}, _updateOpacityModifyRGB:function() {
  this._opacityModifyRGB = this._textureAtlas.getTexture().hasPremultipliedAlpha()
}});
cc.AtlasNodeWebGL.create = function(tile, tileWidth, tileHeight, itemsToRender) {
  var ret = new cc.AtlasNodeWebGL;
  if(ret.initWithTileFile(tile, tileWidth, tileHeight, itemsToRender)) {
    return ret
  }
  return null
};
cc.AtlasNode = cc.Browser.supportWebGL ? cc.AtlasNodeWebGL : cc.AtlasNodeCanvas;
cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888 = 0;
cc.TEXTURE_2D_PIXEL_FORMAT_RGB888 = 1;
cc.TEXTURE_2D_PIXEL_FORMAT_RGB565 = 2;
cc.TEXTURE_2D_PIXEL_FORMAT_A8 = 3;
cc.TEXTURE_2D_PIXEL_FORMAT_I8 = 4;
cc.TEXTURE_2D_PIXEL_FORMAT_AI88 = 5;
cc.TEXTURE_2D_PIXEL_FORMAT_RGBA4444 = 6;
cc.TEXTURE_2D_PIXEL_FORMAT_RGB5A1 = 7;
cc.TEXTURE_2D_PIXEL_FORMAT_PVRTC4 = 8;
cc.TEXTURE_2D_PIXEL_FORMAT_PVRTC2 = 9;
cc.TEXTURE_2D_PIXEL_FORMAT_DEFAULT = cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888;
cc._defaultAlphaPixelFormat = cc.TEXTURE_2D_PIXEL_FORMAT_DEFAULT;
cc.PVRHaveAlphaPremultiplied_ = false;
cc._texParams = function(minFilter, magFilter, wrapS, wrapT) {
  this.minFilter = minFilter || 0;
  this.magFilter = magFilter || 0;
  this.wrapS = wrapS || 0;
  this.wrapT = wrapT || 0
};
cc.Texture2D = cc.Class.extend({_pVRHaveAlphaPremultiplied:null, _pixelFormat:null, _pixelsWide:null, _pixelsHigh:null, _name:null, _contentSize:null, _maxS:null, _maxT:null, _hasPremultipliedAlpha:null, _hasMipmaps:false, _shaderProgram:null, _isLoaded:false, _htmlElementObj:null, _webTextureObj:null, ctor:function() {
  this._pixelsWide = 0;
  this._pixelsWide = 0;
  this._name = "";
  this._maxS = 0;
  this._maxT = 0;
  this._hasPremultipliedAlpha = false;
  this._hasMipmaps = false;
  this._pVRHaveAlphaPremultiplied = true;
  this._pixelFormat = cc.Texture2D.defaultAlphaPixelFormat()
}, getPixelFormat:function() {
  return this._pixelFormat
}, getPixelsWide:function() {
  return this._pixelsWide
}, getPixelsHigh:function() {
  return this._pixelsHigh
}, getName:function() {
  return this._webTextureObj
}, getContentSize:function() {
  return cc.size(this._contentSize.width / cc.CONTENT_SCALE_FACTOR(), this._contentSize.height / cc.CONTENT_SCALE_FACTOR())
}, getContentSizeInPixels:function() {
  return this._contentSize
}, getMaxS:function() {
  return this._maxS
}, setMaxS:function(maxS) {
  this._maxS = maxS
}, getMaxT:function() {
  return this._maxT
}, setMaxT:function(maxT) {
  this._maxT = maxT
}, getShaderProgram:function() {
  return this._shaderProgram
}, setShaderProgram:function(shaderProgram) {
  this._shaderProgram = shaderProgram
}, hasPremultipliedAlpha:function() {
  return this._hasPremultipliedAlpha
}, hasMipmaps:function() {
  return this._hasMipmaps
}, description:function() {
  return"<cc.Texture2D | Name = " + this._name + " | Dimensions = " + this._pixelsWide + " x " + this._pixelsHigh + " | Coordinates = (" + this._maxS + ", " + this._maxT + ")>"
}, releaseData:function(data) {
  data = null
}, keepData:function(data, length) {
  return data
}, initWithData:function(data, pixelFormat, pixelsWide, pixelsHigh, contentSize) {
  var gl = cc.renderContext;
  if(pixelFormat === cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888 || cc.NextPOT(pixelsWide) == pixelsWide && cc.NextPOT(pixelsHigh) == pixelsHigh) {
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4)
  }else {
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1)
  }
  this._webTextureObj = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, this._webTextureObj);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  switch(pixelFormat) {
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888:
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixelsWide, pixelsHigh, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      break;
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGB888:
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, pixelsWide, pixelsHigh, 0, gl.RGB, gl.UNSIGNED_BYTE, data);
      break;
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGBA4444:
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixelsWide, pixelsHigh, 0, gl.RGBA, gl.UNSIGNED_SHORT_4_4_4_4, data);
      break;
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGB5A1:
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixelsWide, pixelsHigh, 0, gl.RGBA, gl.UNSIGNED_SHORT_5_5_5_1, data);
      break;
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGB565:
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, pixelsWide, pixelsHigh, 0, gl.RGB, gl.UNSIGNED_SHORT_5_6_5, data);
      break;
    case cc.TEXTURE_2D_PIXEL_FORMAT_AI88:
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE_ALPHA, pixelsWide, pixelsHigh, 0, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE, data);
      break;
    case cc.TEXTURE_2D_PIXEL_FORMAT_A8:
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, pixelsWide, pixelsHigh, 0, gl.ALPHA, gl.UNSIGNED_BYTE, data);
      break;
    case cc.TEXTURE_2D_PIXEL_FORMAT_I8:
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, pixelsWide, pixelsHigh, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, data);
      break;
    default:
      cc.Assert(0, "NSInternalInconsistencyException");
      break
  }
  this._contentSize = contentSize;
  this._pixelsWide = pixelsWide;
  this._pixelsHigh = pixelsHigh;
  this._pixelFormat = pixelFormat;
  this._maxS = contentSize.width / pixelsWide;
  this._maxT = contentSize.height / pixelsHigh;
  this._hasPremultipliedAlpha = false;
  this._hasMipmaps = false;
  this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_TEXTURE));
  this._isLoaded = true;
  return true
}, drawAtPoint:function(point) {
  var coordinates = [0, this._maxT, this._maxS, this._maxT, 0, 0, this._maxS, 0];
  var width = this._pixelsWide * this._maxS, height = this._pixelsHigh * this._maxT;
  var vertices = [point.x, point.y, 0, width + point.x, point.y, 0, point.x, height + point.y, 0, width + point.x, height + point.y, 0];
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEXCOORDS);
  this._shaderProgram.use();
  this._shaderProgram.setUniformsForBuiltins();
  cc.glBindTexture2D(this);
  var gl = cc.renderContext;
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, gl.FLOAT, false, 0, vertices);
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 0, coordinates);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
}, drawInRect:function(rect) {
  var coordinates = [0, this._maxT, this._maxS, this._maxT, 0, 0, this._maxS, 0];
  var vertices = [rect.origin.x, rect.origin.y, rect.origin.x + rect.size.width, rect.origin.y, rect.origin.x, rect.origin.y + rect.size.height, rect.origin.x + rect.size.width, rect.origin.y + rect.size.height];
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEXCOORDS);
  this._shaderProgram.use();
  this._shaderProgram.setUniformsForBuiltins();
  cc.glBindTexture2D(this);
  var gl = cc.renderContext;
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, gl.FLOAT, false, 0, vertices);
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 0, coordinates);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
}, initWithImage:function(uiImage) {
  if(uiImage == null) {
    cc.log("cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil");
    return false
  }
  var imageWidth = uiImage.getWidth();
  var imageHeight = uiImage.getHeight();
  var conf = cc.Configuration.getInstance();
  var maxTextureSize = conf.getMaxTextureSize();
  if(imageWidth > maxTextureSize || imageHeight > maxTextureSize) {
    cc.log("cocos2d: WARNING: Image (" + imageWidth + " x " + imageHeight + ") is bigger than the supported " + maxTextureSize + " x " + maxTextureSize);
    return false
  }
  this._isLoaded = true;
  return this._initPremultipliedATextureWithImage(uiImage, imageWidth, imageHeight)
}, initWithElement:function(element) {
  if(!element) {
    return
  }
  this._webTextureObj = cc.renderContext.createTexture();
  this._htmlElementObj = element
}, isLoaded:function() {
  return this._isLoaded
}, handleLoadedTexture:function() {
  this._isLoaded = true;
  var gl = cc.renderContext;
  var pixelsWide = this._htmlElementObj.width;
  var pixelsHigh = this._htmlElementObj.height;
  cc.glBindTexture2D(this);
  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._htmlElementObj);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  this._contentSize = new cc.Size(pixelsWide, pixelsHigh);
  this._pixelsWide = pixelsWide;
  this._pixelsHigh = pixelsHigh;
  this._pixelFormat = cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888;
  this._maxS = 1;
  this._maxT = 1;
  this._hasPremultipliedAlpha = false;
  this._hasMipmaps = false;
  this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_TEXTURE));
  gl.bindTexture(gl.TEXTURE_2D, null)
}, initWithString:function(text, fontName, fontSize, dimensions, hAlignment, vAlignment) {
  if(arguments.length == 3) {
    fontName = arguments[1];
    fontSize = arguments[2];
    dimensions = cc.size(0, 0);
    hAlignment = cc.TEXT_ALIGNMENT_CENTER;
    vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP
  }
  var image = new cc.Image;
  var eAlign;
  if(cc.VERTICAL_TEXT_ALIGNMENT_TOP === vAlignment) {
    eAlign = cc.TEXT_ALIGNMENT_CENTER === hAlignment ? cc.ALIGN_TOP : cc.TEXT_ALIGNMENT_LEFT === hAlignment ? cc.ALIGN_TOP_LEFT : cc.ALIGN_TOP_RIGHT
  }else {
    if(cc.VERTICAL_TEXT_ALIGNMENT_CENTER === vAlignment) {
      eAlign = cc.TEXT_ALIGNMENT_CENTER === hAlignment ? cc.ALIGN_CENTER : cc.TEXT_ALIGNMENT_LEFT === hAlignment ? cc.ALIGN_LEFT : cc.ALIGN_RIGHT
    }else {
      if(cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM === vAlignment) {
        eAlign = cc.TEXT_ALIGNMENT_CENTER === hAlignment ? cc.ALIGN_BOTTOM : cc.TEXT_ALIGNMENT_LEFT === hAlignment ? cc.ALIGN_BOTTOM_LEFT : cc.ALIGN_BOTTOM_RIGHT
      }else {
        cc.Assert(false, "Not supported alignment format!")
      }
    }
  }
  if(!image.initWithString(text, dimensions.width, dimensions.height, eAlign, fontName, fontSize)) {
    return false
  }
  return this.initWithImage(image)
}, initWithPVRFile:function(file) {
  var ret = false;
  var pvr = new cc.TexturePVR;
  ret = pvr.initWithContentsOfFile(file);
  if(ret) {
    pvr.setRetainName(true);
    this._name = pvr.getName();
    this._maxS = 1;
    this._maxT = 1;
    this._pixelsWide = pvr.getWidth();
    this._pixelsHigh = pvr.getHeight();
    this._contentSize = cc.size(this._pixelsWide, this._pixelsHigh);
    this._hasPremultipliedAlpha = cc.PVRHaveAlphaPremultiplied_;
    this._pixelFormat = pvr.getFormat();
    this.setAntiAliasTexParameters()
  }else {
    cc.log("cocos2d: Couldn't load PVR image " + file)
  }
  return ret
}, initWithPVRTCData:function(data, level, bpp, hasAlpha, length, pixelFormat) {
  if(!cc.Configuration.getInstance().supportsPVRTC()) {
    cc.log("cocos2d: WARNING: PVRTC images is not supported.");
    return false
  }
  var gl = cc.renderContext;
  this._webTextureObj = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, this._webTextureObj);
  this.setAntiAliasTexParameters();
  var format;
  var size = length * length * bpp / 8;
  if(hasAlpha) {
    format = bpp == 4 ? gl.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG : gl.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
  }else {
    format = bpp == 4 ? gl.COMPRESSED_RGB_PVRTC_4BPPV1_IMG : gl.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
  }
  if(size < 32) {
    size = 32
  }
  gl.compressedTexImage2D(gl.TEXTURE_2D, level, format, length, length, 0, size, data);
  this._contentSize = cc.size(length, length);
  this._pixelsWide = length;
  this._pixelsHigh = length;
  this._maxS = 1;
  this._maxT = 1;
  this._hasPremultipliedAlpha = cc.PVRHaveAlphaPremultiplied_;
  this._pixelFormat = pixelFormat;
  return true
}, setTexParameters:function(texParams) {
  var gl = cc.renderContext;
  cc.Assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh) || texParams.wrapS == gl.CLAMP_TO_EDGE && texParams.wrapT == gl.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures");
  cc.glBindTexture2D(this);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texParams.minFilter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texParams.magFilter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, texParams.wrapS);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, texParams.wrapT)
}, setAntiAliasTexParameters:function() {
  var gl = cc.renderContext;
  cc.glBindTexture2D(this);
  if(!this._hasMipmaps) {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
  }else {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST)
  }
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
}, setAliasTexParameters:function() {
  var gl = cc.renderContext;
  cc.glBindTexture2D(this);
  if(!this._hasMipmaps) {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
  }else {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST)
  }
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
}, generateMipmap:function() {
  cc.Assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures");
  cc.glBindTexture2D(this);
  cc.renderContext.generateMipmap(cc.renderContext.TEXTURE_2D);
  this._hasMipmaps = true
}, stringForFormat:function() {
  switch(this._pixelFormat) {
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888:
      return"RGBA8888";
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGB888:
      return"RGB888";
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGB565:
      return"RGB565";
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGBA4444:
      return"RGBA4444";
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGB5A1:
      return"RGB5A1";
    case cc.TEXTURE_2D_PIXEL_FORMAT_AI88:
      return"AI88";
    case cc.TEXTURE_2D_PIXEL_FORMAT_A8:
      return"A8";
    case cc.TEXTURE_2D_PIXEL_FORMAT_I8:
      return"I8";
    case cc.TEXTURE_2D_PIXEL_FORMAT_PVRTC4:
      return"PVRTC4";
    case cc.TEXTURE_2D_PIXEL_FORMAT_PVRTC2:
      return"PVRTC2";
    default:
      cc.Assert(false, "unrecognized pixel format");
      cc.log("stringForFormat: " + this._pixelFormat + ", cannot give useful result");
      break
  }
  return""
}, bitsPerPixelForFormat:function(format) {
  format = format || this._pixelFormat;
  switch(format) {
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888:
      return 32;
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGB888:
      return 32;
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGB565:
      return 16;
    case cc.TEXTURE_2D_PIXEL_FORMAT_A8:
      return 8;
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGBA4444:
      return 16;
    case cc.TEXTURE_2D_PIXEL_FORMAT_RGB5A1:
      return 16;
    case cc.TEXTURE_2D_PIXEL_FORMAT_PVRTC4:
      return 4;
    case cc.TEXTURE_2D_PIXEL_FORMAT_PVRTC2:
      return 2;
    case cc.TEXTURE_2D_PIXEL_FORMAT_I8:
      return 8;
    case cc.TEXTURE_2D_PIXEL_FORMAT_AI88:
      return 16;
    default:
      cc.Assert(false, "illegal pixel format");
      cc.log("bitsPerPixelForFormat: " + this._pixelFormat + ", cannot give useful result");
      return-1
  }
}, _initPremultipliedATextureWithImage:function(uiImage, width, height) {
  var tempData = uiImage.getData();
  var inPixel32 = null;
  var inPixel8 = null;
  var outPixel16 = null;
  var hasAlpha = uiImage.hasAlpha();
  var imageSize = cc.size(uiImage.getWidth(), uiImage.getHeight());
  var pixelFormat = cc.TEXTURE_2D_PIXEL_FORMAT_DEFAULT;
  var bpp = uiImage.getBitsPerComponent();
  var i;
  if(!hasAlpha) {
    if(bpp >= 8) {
      pixelFormat = cc.TEXTURE_2D_PIXEL_FORMAT_RGB888
    }else {
      cc.log("cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha");
      pixelFormat = cc.TEXTURE_2D_PIXEL_FORMAT_RGB565
    }
  }
  var length = width * height;
  if(pixelFormat == cc.TEXTURE_2D_PIXEL_FORMAT_RGB565) {
    if(hasAlpha) {
      tempData = new Uint16Array(width * height);
      inPixel32 = uiImage.getData();
      for(i = 0;i < length;++i) {
        tempData[i] = (inPixel32[i] >> 0 & 255) >> 3 << 11 | (inPixel32[i] >> 8 & 255) >> 2 << 5 | (inPixel32[i] >> 16 & 255) >> 3 << 0
      }
    }else {
      tempData = new Uint16Array(width * height);
      inPixel8 = uiImage.getData();
      for(i = 0;i < length;++i) {
        tempData[i] = (inPixel8[i] & 255) >> 3 << 11 | (inPixel8[i] & 255) >> 2 << 5 | (inPixel8[i] & 255) >> 3 << 0
      }
    }
  }else {
    if(pixelFormat == cc.TEXTURE_2D_PIXEL_FORMAT_RGBA4444) {
      tempData = new Uint16Array(width * height);
      inPixel32 = uiImage.getData();
      for(i = 0;i < length;++i) {
        tempData[i] = (inPixel32[i] >> 0 & 255) >> 4 << 12 | (inPixel32[i] >> 8 & 255) >> 4 << 8 | (inPixel32[i] >> 16 & 255) >> 4 << 4 | (inPixel32[i] >> 24 & 255) >> 4 << 0
      }
    }else {
      if(pixelFormat == cc.TEXTURE_2D_PIXEL_FORMAT_RGB5A1) {
        tempData = new Uint16Array(width * height);
        inPixel32 = uiImage.getData();
        for(i = 0;i < length;++i) {
          tempData[i] = (inPixel32[i] >> 0 & 255) >> 3 << 11 | (inPixel32[i] >> 8 & 255) >> 3 << 6 | (inPixel32[i] >> 16 & 255) >> 3 << 1 | (inPixel32[i] >> 24 & 255) >> 7 << 0
        }
      }else {
        if(pixelFormat == cc.TEXTURE_2D_PIXEL_FORMAT_A8) {
          tempData = new Uint8Array(width * height);
          inPixel32 = uiImage.getData();
          for(i = 0;i < length;++i) {
            tempData[i] = inPixel32 >> 24 & 255
          }
        }
      }
    }
  }
  if(hasAlpha && pixelFormat == cc.TEXTURE_2D_PIXEL_FORMAT_RGB888) {
    inPixel32 = uiImage.getData();
    tempData = new Uint8Array(width * height * 3);
    for(i = 0;i < length;++i) {
      tempData[i * 3] = inPixel32 >> 0 & 255;
      tempData[i * 3 + 1] = inPixel32 >> 8 & 255;
      tempData[i * 3 + 2] = inPixel32 >> 16 & 255
    }
  }
  this.initWithData(tempData, pixelFormat, width, height, imageSize);
  if(tempData != uiImage.getData()) {
    tempData = null
  }
  this._hasPremultipliedAlpha = uiImage.isPremultipliedAlpha();
  return true
}});
cc.Texture2D.setDefaultAlphaPixelFormat = function(format) {
  cc._defaultAlphaPixelFormat = format
};
cc.Texture2D.defaultAlphaPixelFormat = function() {
  return cc._defaultAlphaPixelFormat
};
cc.Texture2D.getDefaultAlphaPixelFormat = function() {
  return cc._defaultAlphaPixelFormat
};
cc.Texture2D.PVRImagesHavePremultipliedAlpha = function(haveAlphaPremultiplied) {
  cc.PVRHaveAlphaPremultiplied_ = haveAlphaPremultiplied
};
cc.g_sharedTextureCache = null;
cc.loadImage = function(imageUrl) {
  var imageType = cc.computeImageFormatType(imageUrl);
  if(imageType == cc.FMT_UNKNOWN) {
    cc.log("unsupported format:" + imageUrl);
    return
  }
  var image = new Image;
  image.src = imageUrl;
  image.onLoad = function(e) {
    cc.TextureCache.getInstance().cacheImage(imageUrl, image)
  }
};
cc.computeImageFormatType = function(filename) {
  if(filename.toLowerCase().indexOf(".jpg") > 0 || filename.toLowerCase().indexOf(".jpeg") > 0) {
    return cc.FMT_JPG
  }else {
    if(filename.toLowerCase().indexOf(".png") > 0) {
      return cc.FMT_PNG
    }
  }
  return cc.FMT_UNKNOWN
};
cc.TextureCacheCanvas = cc.Class.extend({_textures:null, _textureColorsCache:null, _textureKeySeq:1E3, ctor:function() {
  cc.Assert(cc.g_sharedTextureCache == null, "Attempted to allocate a second instance of a singleton.");
  this._textureKeySeq += 0 | Math.random() * 1E3;
  this._textures = {};
  this._textureColorsCache = {}
}, _addImageAsyncCallBack:function(target, selector) {
  if(target && typeof selector == "string") {
    target[selector]()
  }else {
    if(target && typeof selector == "function") {
      selector.call(target)
    }
  }
}, addPVRTCImage:function() {
  cc.Assert(0, "TextureCache:addPVRTCImage does not support")
}, description:function() {
  return"<TextureCache | Number of textures = " + this._textures.length + ">"
}, textureForKey:function(key) {
  if(this._textures.hasOwnProperty(key)) {
    return this._textures[key]
  }
  return null
}, getKeyByTexture:function(texture) {
  for(var key in this._textures) {
    if(this._textures[key] == texture) {
      return key
    }
  }
  return null
}, _generalTextureKey:function() {
  this._textureKeySeq++;
  return"_textureKey_" + this._textureKeySeq
}, getTextureColors:function(texture) {
  var key = this.getKeyByTexture(texture);
  if(!key) {
    if(texture instanceof HTMLImageElement) {
      key = texture.src
    }else {
      key = this._generalTextureKey()
    }
  }
  if(!this._textureColorsCache.hasOwnProperty(key)) {
    this._textureColorsCache[key] = cc.generateTextureCacheForColor(texture)
  }
  return this._textureColorsCache[key]
}, removeAllTextures:function() {
  this._textures = {}
}, removeTexture:function(texture) {
  if(!texture) {
    return
  }
  for(var key in this._textures) {
    if(this._textures[key] == texture) {
      delete this._textures[key];
      return
    }
  }
}, removeTextureForKey:function(textureKeyName) {
  if(textureKeyName == null) {
    return
  }
  if(this._textures[textureKeyName]) {
    delete this._textures[textureKeyName]
  }
}, addPVRImage:function(path) {
  cc.Assert(path != null, "TextureCache: file image MUST not be null");
  path = cc.FileUtils.getInstance().fullPathFromRelativePath(path);
  var key = path;
  if(this._textures[key] != null) {
    return this._textures[key]
  }
  var tex = new cc.Texture2D;
  if(tex.initWithPVRFile(key)) {
    this._textures[key] = tex
  }else {
    cc.log("cocos2d: Couldn't add PVRImage:" + key + " in TextureCache")
  }
  return tex
}, addImageAsync:function(path, target, selector) {
  cc.Assert(path != null, "TextureCache: path MUST not be null");
  path = cc.FileUtils.getInstance().fullPathFromRelativePath(path);
  var texture = this._textures[path];
  if(texture) {
    this._addImageAsyncCallBack(target, selector)
  }else {
    texture = new Image;
    texture.crossOrigin = "Anonymous";
    var that = this;
    texture.addEventListener("load", function() {
      that._addImageAsyncCallBack(target, selector)
    });
    texture.addEventListener("error", function() {
      cc.Loader.getInstance().onResLoadingErr(path);
      if(that._textures.hasOwnProperty(path)) {
        delete that._textures[path]
      }
    });
    texture.src = path;
    this._textures[path] = texture
  }
  return this._textures[path]
}, addImage:function(path) {
  cc.Assert(path != null, "TextureCache: path MUST not be null");
  path = cc.FileUtils.getInstance().fullPathForFilename(path);
  var texture = this._textures[path];
  if(texture) {
    cc.Loader.getInstance().onResLoaded()
  }else {
    texture = new Image;
    texture.crossOrigin = "Anonymous";
    var that = this;
    texture.addEventListener("load", function() {
      cc.Loader.getInstance().onResLoaded()
    });
    texture.addEventListener("error", function() {
      cc.Loader.getInstance().onResLoadingErr(path);
      if(that._textures.hasOwnProperty(path)) {
        delete that._textures[path]
      }
    });
    texture.src = path;
    this._textures[path] = texture
  }
  return this._textures[path]
}, cacheImage:function(path, texture) {
  this._textures[path] = texture
}, addUIImage:function(image, key) {
  cc.Assert(image != null, "TextureCache: image MUST not be nulll");
  if(key && this._textures.hasOwnProperty(key) && this._textures[key]) {
    return this._textures[key]
  }
  if(key != null && image != null) {
    this._textures[key] = image
  }else {
    cc.log("cocos2d: Couldn't add UIImage in TextureCache")
  }
  return image
}, dumpCachedTextureInfo:function() {
  var count = 0;
  var totalBytes = 0;
  for(var key in this._textures) {
    var selTexture = this._textures[key];
    count++;
    if(selTexture instanceof HTMLImageElement) {
      cc.log("cocos2d: '" + key + "' id=" + selTexture.src + " " + selTexture.width + " x " + selTexture.height)
    }else {
      cc.log("cocos2d: '" + key + "' id= HTMLCanvasElement " + selTexture.width + " x " + selTexture.height);
      totalBytes += selTexture.width * selTexture.height * 4
    }
  }
  for(key in this._textureColorsCache) {
    var selCanvas = this._textureColorsCache[key];
    count++;
    cc.log("cocos2d: '" + key + "' id= HTMLCanvasElement " + selCanvas.width + " x " + selCanvas.height);
    totalBytes += selCanvas.width * selCanvas.height * 4
  }
  cc.log("cocos2d: TextureCache dumpDebugInfo: " + count + " textures, HTMLCanvasElement for " + totalBytes / 1024 + " KB (" + (totalBytes / (1024 * 1024)).toFixed(2) + " MB)")
}});
cc.TextureCacheCanvas.getInstance = function() {
  if(!cc.g_sharedTextureCache) {
    cc.g_sharedTextureCache = new cc.TextureCacheCanvas
  }
  return cc.g_sharedTextureCache
};
cc.TextureCacheCanvas.purgeSharedTextureCache = function() {
  cc.g_sharedTextureCache = null
};
cc.TextureCacheWebGL = cc.Class.extend({_textures:null, _textureColorsCache:null, _textureKeySeq:1E3, _rendererInitialized:false, _loadedTexturesBefore:null, _loadingTexturesBefore:null, ctor:function() {
  cc.Assert(cc.g_sharedTextureCache == null, "Attempted to allocate a second instance of a singleton.");
  this._textureKeySeq += 0 | Math.random() * 1E3;
  this._textures = {};
  this._textureColorsCache = {};
  this._loadedTexturesBefore = {};
  this._loadingTexturesBefore = {}
}, _addImageAsyncCallBack:function(target, selector) {
  if(target && typeof selector == "string") {
    target[selector]()
  }else {
    if(target && typeof selector == "function") {
      selector.call(target)
    }
  }
}, _initializingRenderer:function() {
  this._rendererInitialized = true;
  var selPath;
  for(selPath in this._loadedTexturesBefore) {
    var htmlImage = this._loadedTexturesBefore[selPath];
    var texture2d = new cc.Texture2D;
    texture2d.initWithElement(htmlImage);
    texture2d.handleLoadedTexture();
    this._textures[selPath] = texture2d
  }
  this._loadedTexturesBefore = {};
  for(selPath in this._loadedTexturesBefore) {
    this.addImage(selPath)
  }
  this._loadedTexturesBefore = {}
}, addPVRTCImage:function() {
  cc.Assert(0, "TextureCache:addPVRTCImage does not support")
}, description:function() {
  return"<TextureCache | Number of textures = " + this._textures.length + ">"
}, textureForKey:function(key) {
  if(this._textures.hasOwnProperty(key)) {
    return this._textures[key]
  }
  return null
}, getKeyByTexture:function(texture) {
  for(var key in this._textures) {
    if(this._textures[key] == texture) {
      return key
    }
  }
  return null
}, _generalTextureKey:function() {
  this._textureKeySeq++;
  return"_textureKey_" + this._textureKeySeq
}, getTextureColors:function(texture) {
  var key = this.getKeyByTexture(texture);
  if(!key) {
    if(texture instanceof HTMLImageElement) {
      key = texture.src
    }else {
      key = this._generalTextureKey()
    }
  }
  if(!this._textureColorsCache.hasOwnProperty(key)) {
    this._textureColorsCache[key] = cc.generateTextureCacheForColor(texture)
  }
  return this._textureColorsCache[key]
}, removeAllTextures:function() {
  this._textures = {}
}, removeTexture:function(texture) {
  if(!texture) {
    return
  }
  for(var key in this._textures) {
    if(this._textures[key] == texture) {
      delete this._textures[key];
      return
    }
  }
}, removeTextureForKey:function(textureKeyName) {
  if(textureKeyName == null) {
    return
  }
  if(this._textures[textureKeyName]) {
    delete this._textures[textureKeyName]
  }
}, addPVRImage:function(path) {
  cc.Assert(path != null, "TextureCache: file image MUST not be null");
  path = cc.FileUtils.getInstance().fullPathFromRelativePath(path);
  var key = path;
  if(this._textures[key] != null) {
    return this._textures[key]
  }
  var tex = new cc.Texture2D;
  if(tex.initWithPVRFile(key)) {
    this._textures[key] = tex
  }else {
    cc.log("cocos2d: Couldn't add PVRImage:" + key + " in TextureCache")
  }
  return tex
}, addImageAsync:function(path, target, selector) {
  cc.Assert(path != null, "TextureCache: path MUST not be null");
  path = cc.FileUtils.getInstance().fullPathFromRelativePath(path);
  var texture = this._textures[path];
  if(texture) {
    this._addImageAsyncCallBack(target, selector)
  }else {
    texture = new Image;
    texture.crossOrigin = "Anonymous";
    var that = this;
    texture.addEventListener("load", function() {
      if(that._textures.hasOwnProperty(path)) {
        that._textures[path].handleLoadedTexture()
      }
      that._addImageAsyncCallBack(target, selector)
    });
    texture.addEventListener("error", function() {
      cc.Loader.getInstance().onResLoadingErr(path);
      if(that._textures.hasOwnProperty(path)) {
        delete that._textures[path]
      }
    });
    texture.src = path;
    var texture2d = new cc.Texture2D;
    texture2d.initWithElement(texture);
    this._textures[path] = texture2d
  }
  return this._textures[path]
}, _addImageBeforeRenderer:function(path) {
  var texture = new Image;
  texture.crossOrigin = "Anonymous";
  var that = this;
  texture.addEventListener("load", function() {
    cc.Loader.getInstance().onResLoaded();
    that._loadedTexturesBefore[path] = texture;
    delete that._loadingTexturesBefore[path]
  });
  texture.addEventListener("error", function() {
    cc.Loader.getInstance().onResLoadingErr(path);
    delete that._loadingTexturesBefore[path]
  });
  texture.src = path;
  this._loadingTexturesBefore[path] = texture
}, addImage:function(path) {
  cc.Assert(path != null, "TextureCache: path MUST not be null");
  if(!this._rendererInitialized) {
    return this._addImageBeforeRenderer(path)
  }
  path = cc.FileUtils.getInstance().fullPathForFilename(path);
  var texture = this._textures[path];
  if(texture) {
    cc.Loader.getInstance().onResLoaded()
  }else {
    texture = new Image;
    texture.crossOrigin = "Anonymous";
    var that = this;
    texture.addEventListener("load", function() {
      cc.Loader.getInstance().onResLoaded();
      if(that._textures.hasOwnProperty(path)) {
        that._textures[path].handleLoadedTexture()
      }
    });
    texture.addEventListener("error", function() {
      cc.Loader.getInstance().onResLoadingErr(path);
      if(that._textures.hasOwnProperty(path)) {
        delete that._textures[path]
      }
    });
    texture.src = path;
    var texture2d = new cc.Texture2D;
    texture2d.initWithElement(texture);
    this._textures[path] = texture2d
  }
  return this._textures[path]
}, cacheImage:function(path, texture) {
  if(texture instanceof cc.Texture2D) {
    this._textures[path] = texture;
    return
  }
  var texture2d = new cc.Texture2D;
  texture2d.initWithElement(texture);
  texture2d.handleLoadedTexture();
  this._textures[path] = texture2d
}, addUIImage:function(image, key) {
  cc.Assert(image != null, "TextureCache: image MUST not be nulll");
  if(key) {
    if(this._textures.hasOwnProperty(key) && this._textures[key]) {
      return this._textures[key]
    }
  }
  var texture = new cc.Texture2D;
  texture.initWithImage(image);
  if(key != null && texture != null) {
    this._textures[key] = texture
  }else {
    cc.log("cocos2d: Couldn't add UIImage in TextureCache")
  }
  return texture
}, dumpCachedTextureInfo:function() {
  var count = 0;
  var totalBytes = 0;
  for(var key in this._textures) {
    var tex = this._textures[key];
    var bpp = tex.bitsPerPixelForFormat();
    var bytes = tex.getPixelsWide() * tex.getPixelsHigh() * bpp / 8;
    totalBytes += bytes;
    count++;
    cc.log("cocos2d: Texture URL=" + tex._htmlElementObj.src + " " + tex.getPixelsWide() + " x " + tex.getPixelsHigh() + " @ " + bpp + " bpp => " + bytes / 1024 + " KB")
  }
  cc.log("cocos2d: TextureCache dumpDebugInfo: " + count + " textures, for " + totalBytes / 1024 + " KB (" + (totalBytes / (1024 * 1024)).toFixed(2) + " MB)")
}});
cc.TextureCacheWebGL.getInstance = function() {
  if(!cc.g_sharedTextureCache) {
    cc.g_sharedTextureCache = new cc.TextureCacheWebGL
  }
  return cc.g_sharedTextureCache
};
cc.TextureCacheWebGL.purgeSharedTextureCache = function() {
  cc.g_sharedTextureCache = null
};
cc.TextureCache = cc.Browser.supportWebGL ? cc.TextureCacheWebGL : cc.TextureCacheCanvas;
cc.TextureAtlas = cc.Class.extend({_indices:null, _buffersVBO:null, _dirty:false, _capacity:0, _texture:null, _quads:null, _quadsArrayBuffer:null, _quadsWebBuffer:null, _quadsReader:null, ctor:function() {
  this._buffersVBO = []
}, getTotalQuads:function() {
  return this._quads.length
}, getCapacity:function() {
  return this._capacity
}, getTexture:function() {
  return this._texture
}, setTexture:function(texture) {
  this._texture = texture
}, setDirty:function(dirty) {
  this._dirty = dirty
}, getDirty:function() {
  return this._dirty
}, getQuads:function() {
  return this._quads
}, setQuads:function(quads) {
  this._quads = quads;
  this._resetQuadsToTypeArray(0)
}, _resetQuadsToTypeArray:function(startIndex) {
  if(this._quads.length > this._capacity) {
    throw"out capacity";
  }
  if(startIndex > this._quads.length) {
    throw"out length";
  }
  for(var i = startIndex;i < this._quads.length;i++) {
    this._setQuadToArray(this._quads[i], i)
  }
  this._dirty = true
}, _setQuadToArray:function(quad, index) {
  if(!this._quads[index]) {
    this._quads[index] = new cc.V3F_C4B_T2F_Quad(quad.tl, quad.bl, quad.tr, quad.br, this._quadsArrayBuffer, index * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
    return
  }
  this._quads[index].bl = quad.bl;
  this._quads[index].br = quad.br;
  this._quads[index].tl = quad.tl;
  this._quads[index].tr = quad.tr
}, description:function() {
  return"<cc.TextureAtlas | totalQuads =" + this._totalQuads + ">"
}, _setupIndices:function() {
  if(this._capacity === 0) {
    return
  }
  for(var i = 0;i < this._capacity;i++) {
    if(cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP) {
      this._indices[i * 6 + 0] = i * 4 + 0;
      this._indices[i * 6 + 1] = i * 4 + 0;
      this._indices[i * 6 + 2] = i * 4 + 2;
      this._indices[i * 6 + 3] = i * 4 + 1;
      this._indices[i * 6 + 4] = i * 4 + 3;
      this._indices[i * 6 + 5] = i * 4 + 3
    }else {
      this._indices[i * 6 + 0] = i * 4 + 0;
      this._indices[i * 6 + 1] = i * 4 + 1;
      this._indices[i * 6 + 2] = i * 4 + 2;
      this._indices[i * 6 + 3] = i * 4 + 3;
      this._indices[i * 6 + 4] = i * 4 + 2;
      this._indices[i * 6 + 5] = i * 4 + 1
    }
  }
}, _setupVBO:function() {
  var gl = cc.renderContext;
  this._buffersVBO[0] = gl.createBuffer();
  this._buffersVBO[1] = gl.createBuffer();
  this._quadsWebBuffer = gl.createBuffer();
  this._mapBuffers()
}, _mapBuffers:function() {
  var gl = cc.renderContext;
  gl.bindBuffer(gl.ARRAY_BUFFER, this._quadsWebBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, this._quadsArrayBuffer, gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW)
}, initWithFile:function(file, capacity) {
  var texture = cc.TextureCache.getInstance().addImage(file);
  if(texture) {
    return this.initWithTexture(texture, capacity)
  }else {
    cc.log("cocos2d: Could not open file: " + file);
    return false
  }
}, initWithTexture:function(texture, capacity) {
  this._capacity = 0 | capacity;
  this._totalQuads = 0;
  this._texture = texture;
  cc.Assert(this._quads == null && this._indices == null, "TextureAtlas.initWithTexture():_quads and _indices should not be null");
  this._quads = [];
  this._indices = new Uint16Array(this._capacity * 6);
  this._quadsArrayBuffer = new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT * this._capacity);
  this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
  if(!(this._quads && this._indices) && this._capacity > 0) {
    return false
  }
  this._setupIndices();
  this._setupVBO();
  this._dirty = true;
  return true
}, updateQuad:function(quad, index) {
  this._totalQuads = Math.max(index + 1, this._totalQuads);
  this._setQuadToArray(quad, index);
  this._dirty = true
}, insertQuad:function(quad, index) {
  cc.Assert(index < this._capacity, "insertQuadWithTexture: Invalid index");
  this._totalQuads++;
  cc.Assert(this._totalQuads <= this._capacity, "invalid totalQuads");
  var remaining = this._totalQuads - 1 - index;
  var startOffset = index * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
  var moveLength = remaining * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
  this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
  this._quadsReader.set(this._quadsReader.subarray(startOffset, startOffset + moveLength), startOffset + cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
  this._setQuadToArray(quad, index);
  this._dirty = true
}, insertQuads:function(quads, index, amount) {
  amount = amount || quads.length;
  cc.Assert(index + amount <= this._capacity, "insertQuadWithTexture: Invalid index + amount");
  this._totalQuads += amount;
  cc.Assert(this._totalQuads <= this._capacity, "invalid totalQuads");
  var remaining = this._totalQuads - 1 - index - amount;
  var startOffset = index * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
  var moveLength = remaining * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
  var lastIndex = this._totalQuads - 1 - amount;
  var i;
  for(i = 0;i < amount;i++) {
    this._quads[lastIndex + i] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
  }
  this._quadsReader.set(this._quadsReader.subarray(startOffset, startOffset + moveLength), startOffset + cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT * amount);
  for(i = 0;i < amount;i++) {
    this._setQuadToArray(quads[i], index + i)
  }
  this._dirty = true
}, insertQuadFromIndex:function(fromIndex, newIndex) {
  cc.Assert(newIndex >= 0 && newIndex < this._totalQuads, "insertQuadFromIndex:atIndex: Invalid index");
  cc.Assert(fromIndex >= 0 && fromIndex < this._totalQuads, "insertQuadFromIndex:atIndex: Invalid index");
  if(fromIndex === newIndex) {
    return
  }
  var sourceArr = this._quadsReader.subarray(fromIndex * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
  var startOffset, moveLength;
  if(fromIndex > newIndex) {
    startOffset = newIndex * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    moveLength = (fromIndex - newIndex) * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    this._quadsReader.set(this._quadsReader.subarray(startOffset, startOffset + moveLength), startOffset + cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
    this._quadsReader.set(sourceArr, startOffset)
  }else {
    startOffset = (fromIndex + 1) * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    moveLength = (newIndex - fromIndex) * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    this._quadsReader.set(this._quadsReader.subarray(startOffset, startOffset + moveLength), startOffset - cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
    this._quadsReader.set(sourceArr, newIndex * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
  }
  this._dirty = true
}, removeQuadAtIndex:function(index) {
  cc.Assert(index < this._totalQuads, "removeQuadAtIndex: Invalid index");
  this._totalQuads--;
  this._quads.length = this._totalQuads;
  if(index !== this._totalQuads) {
    var startOffset = (index + 1) * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    var moveLength = (this._totalQuads - index) * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    this._quadsReader.set(this._quadsReader.subarray(startOffset, startOffset + moveLength), startOffset - cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
  }
  this._dirty = true
}, removeQuadsAtIndex:function(index, amount) {
  cc.Assert(index + amount <= this._totalQuads, "removeQuadAtIndex: index + amount out of bounds");
  this._totalQuads -= amount;
  if(index !== this._totalQuads) {
    var srcOffset = (index + amount) * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    var moveLength = (this._totalQuads - index) * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    var dstOffset = index * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    this._quadsReader.set(this._quadsReader.subarray(srcOffset, srcOffset + moveLength), dstOffset)
  }
  this._dirty = true
}, removeAllQuads:function() {
  this._totalQuads = 0
}, resizeCapacity:function(newCapacity) {
  if(newCapacity == this._capacity) {
    return true
  }
  var oldCapacity = this._capacity;
  this._totalQuads = Math.min(this._totalQuads, newCapacity);
  this._capacity = 0 | newCapacity;
  var i;
  if(this._quads == null) {
    this._quads = [];
    this._quadsArrayBuffer = new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT * this._capacity);
    this._quadsReader = new Uint8Array(this._quadsArrayBuffer)
  }else {
    var newQuads, newArrayBuffer;
    if(this._capacity > oldCapacity) {
      newQuads = [];
      newArrayBuffer = new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT * this._capacity);
      for(i = 0;i < this._totalQuads;i++) {
        newQuads[i] = new cc.V3F_C4B_T2F_Quad(this._quads[i].tl, this._quads[i].bl, this._quads[i].tr, this._quads[i].br, newArrayBuffer, i * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
      }
      this._quadsReader = new Uint8Array(newArrayBuffer);
      this._quads = newQuads;
      this._quadsArrayBuffer = newArrayBuffer
    }else {
      var count = Math.max(this._totalQuads, this._capacity);
      newQuads = [];
      newArrayBuffer = new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT * this._capacity);
      for(i = 0;i < count;i++) {
        newQuads[i] = new cc.V3F_C4B_T2F_Quad(this._quads[i].tl, this._quads[i].bl, this._quads[i].tr, this._quads[i].br, newArrayBuffer, i * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
      }
      this._quadsReader = new Uint8Array(newArrayBuffer);
      this._quads = newQuads;
      this._quadsArrayBuffer = newArrayBuffer
    }
  }
  if(this._indices == null) {
    this._indices = new Uint16Array(this._capacity * 6)
  }else {
    if(this._capacity > oldCapacity) {
      var tempIndices = new Uint16Array(this._capacity * 6);
      tempIndices.set(this._indices, 0);
      this._indices = tempIndices
    }else {
      this._indices = this._indices.subarray(0, this._capacity * 6)
    }
  }
  this._setupIndices();
  this._mapBuffers();
  this._dirty = true;
  return true
}, increaseTotalQuadsWith:function(amount) {
  this._totalQuads += amount
}, moveQuadsFromIndex:function(oldIndex, amount, newIndex) {
  if(arguments.length == 2) {
    newIndex = amount;
    amount = this._totalQuads - oldIndex
  }
  cc.Assert(newIndex + amount <= this._totalQuads, "moveQuadsFromIndex:newIndex: Invalid index");
  cc.Assert(oldIndex < this._totalQuads, "moveQuadsFromIndex:oldIndex: Invalid index");
  if(oldIndex == newIndex) {
    return
  }
  var srcOffset = oldIndex * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
  var srcLength = amount * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
  var sourceArr = this._quadsReader.subarray(srcOffset, srcOffset + srcLength);
  var dstOffset = newIndex * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
  var moveLength, moveStart;
  if(newIndex < oldIndex) {
    moveLength = (oldIndex - newIndex) * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    moveStart = newIndex * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    this._quadsReader.set(this._quadsReader.subarray(moveStart, moveStart + moveLength), moveStart + srcLength)
  }else {
    moveLength = (newIndex - oldIndex) * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    moveStart = (oldIndex + amount) * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    this._quadsReader.set(this._quadsReader.subarray(moveStart, moveStart + moveLength), srcOffset)
  }
  this._quadsReader.set(sourceArr, dstOffset);
  this._dirty = true
}, fillWithEmptyQuadsFromIndex:function(index, amount) {
  var count = amount * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
  var clearReader = new Uint8Array(this._quadsArrayBuffer, index * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, count);
  for(var i = 0;i < count;i++) {
    clearReader[i] = 0
  }
}, drawNumberOfQuads:function(n, start) {
  start = start || 0;
  if(0 === n || !this._texture || !this._texture.isLoaded()) {
    return
  }
  var gl = cc.renderContext;
  cc.glBindTexture2D(this._texture);
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSCOLORTEX);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._quadsWebBuffer);
  if(this._dirty) {
    gl.bufferData(gl.ARRAY_BUFFER, this._quadsArrayBuffer, gl.DYNAMIC_DRAW)
  }
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 24, 0);
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, 24, 12);
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 24, 16);
  if(this._dirty) {
    this._dirty = false
  }
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
  if(cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP) {
    gl.drawElements(gl.TRIANGLE_STRIP, n * 6, gl.UNSIGNED_SHORT, start * 6 * this._indices.BYTES_PER_ELEMENT)
  }else {
    gl.drawElements(gl.TRIANGLES, n * 6, gl.UNSIGNED_SHORT, start * 6 * this._indices.BYTES_PER_ELEMENT)
  }
  cc.g_NumberOfDraws++
}, drawQuads:function() {
  this.drawNumberOfQuads(this._totalQuads, 0)
}});
cc.TextureAtlas.create = function(file, capacity) {
  var textureAtlas = new cc.TextureAtlas;
  if(textureAtlas && textureAtlas.initWithFile(file, capacity)) {
    return textureAtlas
  }
  return null
};
cc.TextureAtlas.createWithTexture = function(texture, capacity) {
  var textureAtlas = new cc.TextureAtlas;
  if(textureAtlas && textureAtlas.initWithTexture(texture, capacity)) {
    return textureAtlas
  }
  return null
};
cc.IMAGE_FORMAT_JPEG = 0;
cc.IMAGE_FORMAT_PNG = 1;
cc.IMAGE_FORMAT_RAWDATA = 2;
cc.NextPOT = function(x) {
  x = x - 1;
  x = x | x >> 1;
  x = x | x >> 2;
  x = x | x >> 4;
  x = x | x >> 8;
  x = x | x >> 16;
  return x + 1
};
cc.RenderTexture = cc.Node.extend({canvas:null, context:null, _fBO:0, _depthRenderBuffer:0, _oldFBO:0, _texture:null, _textureCopy:null, _uITextureImage:null, _pixelFormat:cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888, _sprite:null, _clearFlags:0, _clearColor:null, _clearDepth:0, _clearStencil:0, _autoDraw:false, ctor:function() {
  this._super();
  if(cc.renderContextType === cc.CANVAS) {
    this.canvas = document.createElement("canvas");
    this.context = this.canvas.getContext("2d");
    this.setAnchorPoint(cc.p(0, 0))
  }else {
    this._clearColor = cc.c4f(0, 0, 0, 0)
  }
}, destroyRenderTexture:function() {
  if(cc.renderContextType === cc.WEBGL) {
    this._sprite = null;
    this._textureCopy = null;
    var gl = cc.renderContext;
    gl.deleteFramebuffer(this._fBO);
    if(this._depthRenderBuffer) {
      gl.deleteRenderbuffer(this._depthRenderBuffer)
    }
    this._uITextureImage = null
  }
}, getSprite:function() {
  return this._sprite
}, setSprite:function(sprite) {
  this._sprite = sprite
}, getCanvas:function() {
  return this.canvas
}, setContentSize:function(size) {
  if(!size) {
    return
  }
  this._super(size);
  if(cc.renderContextType === cc.CANVAS) {
    this.canvas.width = size.width * 1.5;
    this.canvas.height = size.height * 1.5;
    this.context.translate(0, this.canvas.height)
  }
}, initWithWidthAndHeight:function(width, height, format, depthStencilFormat) {
  if(cc.renderContextType === cc.CANVAS) {
    this.canvas.width = width || 10;
    this.canvas.height = height || 10;
    this.context.translate(0, this.canvas.height);
    this._sprite = cc.Sprite.createWithTexture(this.canvas);
    return true
  }else {
    cc.Assert(this._pixelFormat != cc.TEXTURE_2D_PIXEL_FORMAT_A8, "only RGB and RGBA formats are valid for a render texture");
    var gl = cc.renderContext;
    width = 0 | width * cc.CONTENT_SCALE_FACTOR();
    height = 0 | height * cc.CONTENT_SCALE_FACTOR();
    this._oldFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);
    var powW, powH;
    if(cc.Configuration.getInstance().supportsNPOT()) {
      powW = width;
      powH = height
    }else {
      powW = cc.NextPOT(width);
      powH = cc.NextPOT(height)
    }
    var dataLen = powW * powH * 4;
    var data = new Uint8Array(dataLen);
    for(var i = 0;i < powW * powH * 4;i++) {
      data[i] = 0
    }
    this._pixelFormat = format;
    this._texture = new cc.Texture2D;
    if(!this._texture) {
      return false
    }
    this._texture.initWithData(data, this._pixelFormat, powW, powH, cc.size(width, height));
    var oldRBO = gl.getParameter(gl.RENDERBUFFER_BINDING);
    if(cc.Configuration.getInstance().checkForGLExtension("GL_QCOM")) {
      this._textureCopy = new cc.Texture2D;
      if(!this._textureCopy) {
        return false
      }
      this._textureCopy.initWithData(data, this._pixelFormat, powW, powH, cc.size(width, height))
    }
    this._fBO = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._fBO);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._texture._webTextureObj, 0);
    if(this._depthRenderBuffer != 0) {
      this._depthRenderBuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderBuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, depthStencilFormat, powW, powH);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._depthRenderBuffer)
    }
    cc.Assert(gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE, "Could not attach texture to framebuffer");
    this._texture.setAliasTexParameters();
    this._sprite = cc.Sprite.createWithTexture(this._texture);
    this._sprite.setScaleY(-1);
    this._sprite.setBlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.bindRenderbuffer(gl.RENDERBUFFER, oldRBO);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._oldFBO);
    this._autoDraw = false;
    this.addChild(this._sprite);
    return true
  }
}, begin:function() {
  if(cc.renderContextType === cc.CANVAS) {
    return
  }
  cc.kmGLPushMatrix();
  var texSize = this._texture.getContentSizeInPixels();
  var size = cc.Director.getInstance().getWinSizeInPixels();
  var widthRatio = size.width / texSize.width;
  var heightRatio = size.height / texSize.height;
  var gl = cc.renderContext;
  gl.viewport(0, 0, texSize.width, texSize.height);
  var orthoMatrix = new cc.kmMat4;
  cc.kmMat4OrthographicProjection(orthoMatrix, -1 / widthRatio, 1 / widthRatio, -1 / heightRatio, 1 / heightRatio, -1, 1);
  cc.kmGLMultMatrix(orthoMatrix);
  this._oldFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);
  gl.bindFramebuffer(gl.FRAMEBUFFER, this._fBO);
  if(cc.Configuration.getInstance().checkForGLExtension("GL_QCOM")) {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._textureCopy._webTextureObj, 0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._texture._webTextureObj, 0)
  }
}, beginWithClear:function(r, g, b, a, depthValue, stencilValue) {
  var gl = cc.renderContext;
  depthValue = depthValue || gl.COLOR_BUFFER_BIT;
  stencilValue = stencilValue || gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT;
  this._beginWithClear(r, g, b, a, depthValue, stencilValue, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT)
}, _beginWithClear:function(r, g, b, a, depthValue, stencilValue, flags) {
  if(cc.renderContextType === cc.CANVAS) {
    return
  }
  this.begin();
  var gl = cc.renderContext;
  var clearColor = [0, 0, 0, 0];
  var depthClearValue = 0;
  var stencilClearValue = 0;
  if(flags & gl.COLOR_BUFFER_BIT) {
    clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
    gl.clearColor(r, g, b, a)
  }
  if(flags & gl.DEPTH_BUFFER_BIT) {
    depthClearValue = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
    gl.clearDepth(depthValue)
  }
  if(flags & gl.STENCIL_BUFFER_BIT) {
    stencilClearValue = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
    gl.clearStencil(stencilValue)
  }
  gl.clear(flags);
  if(flags & gl.COLOR_BUFFER_BIT) {
    gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3])
  }
  if(flags & gl.DEPTH_BUFFER_BIT) {
    gl.clearDepth(depthClearValue)
  }
  if(flags & gl.STENCIL_BUFFER_BIT) {
    gl.clearStencil(stencilClearValue)
  }
}, end:function() {
  if(cc.renderContextType === cc.CANVAS) {
    return
  }
  var gl = cc.renderContext;
  gl.bindFramebuffer(gl.FRAMEBUFFER, this._oldFBO);
  cc.kmGLPopMatrix();
  var director = cc.Director.getInstance();
  var size = director.getWinSizeInPixels();
  gl.viewport(0, 0, size.width * cc.CONTENT_SCALE_FACTOR(), size.height * cc.CONTENT_SCALE_FACTOR());
  if(director.getProjection() == cc.DIRECTOR_PROJECTION_3D && cc.CONTENT_SCALE_FACTOR() != 1) {
    gl.viewport(-size.width / 2, -size.height / 2, size.width * cc.CONTENT_SCALE_FACTOR(), size.height * cc.CONTENT_SCALE_FACTOR())
  }
  director.setProjection(director.getProjection())
}, clear:function(r, g, b, a) {
  if(cc.renderContextType === cc.CANVAS) {
    var rect = r;
    if(rect) {
      this.context.clearRect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)
    }else {
      this.context.clearRect(0, 0, this.canvas.width, -this.canvas.height)
    }
  }else {
    this.beginWithClear(r, g, b, a);
    this.end()
  }
}, clearDepth:function(depthValue) {
  if(cc.renderContextType === cc.CANVAS) {
    return
  }
  this.begin();
  var gl = cc.renderContext;
  var depthClearValue = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
  gl.clearDepth(depthValue);
  gl.clear(gl.DEPTH_BUFFER_BIT);
  gl.clearDepth(depthClearValue);
  this.end()
}, clearStencil:function(stencilValue) {
  if(cc.renderContextType === cc.CANVAS) {
    return
  }
  var gl = cc.renderContext;
  var stencilClearValue = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
  gl.clearStencil(stencilValue);
  gl.clear(gl.STENCIL_BUFFER_BIT);
  gl.clearStencil(stencilClearValue)
}, visit:function(ctx) {
  if(cc.renderContextType === cc.CANVAS) {
    this._super(ctx);
    return
  }
  if(!this._visible) {
    return
  }
  cc.kmGLPushMatrix();
  if(this._grid && this._grid.isActive()) {
    this._grid.beforeDraw();
    this.transformAncestors()
  }
  this.transform(ctx);
  this._sprite.visit();
  this.draw(ctx);
  if(this._grid && this._grid.isActive()) {
    this._grid.afterDraw(this)
  }
  cc.kmGLPopMatrix();
  this._orderOfArrival = 0
}, draw:function(ctx) {
  if(cc.renderContextType === cc.CANVAS) {
    this._super(ctx);
    return
  }
  var gl = cc.renderContext;
  if(this._autoDraw) {
    this.begin();
    if(this._clearFlags) {
      var oldClearColor = [0, 0, 0, 0];
      var oldDepthClearValue = 0;
      var oldStencilClearValue = 0;
      if(this._clearFlags & gl.COLOR_BUFFER_BIT) {
        oldClearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
        gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a)
      }
      if(this._clearFlags & gl.DEPTH_BUFFER_BIT) {
        oldDepthClearValue = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
        gl.clearDepth(this._clearDepth)
      }
      if(this._clearFlags & gl.STENCIL_BUFFER_BIT) {
        oldStencilClearValue = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
        gl.clearStencil(this._clearStencil)
      }
      gl.clear(this._clearFlags);
      if(this._clearFlags & gl.COLOR_BUFFER_BIT) {
        gl.clearColor(oldClearColor[0], oldClearColor[1], oldClearColor[2], oldClearColor[3])
      }
      if(this._clearFlags & gl.DEPTH_BUFFER_BIT) {
        gl.clearDepth(oldDepthClearValue)
      }
      if(this._clearFlags & gl.STENCIL_BUFFER_BIT) {
        gl.clearStencil(oldStencilClearValue)
      }
    }
    this.sortAllChildren();
    for(var i = 0;i < this._children.length;i++) {
      var getChild = this._children[i];
      if(getChild != this._sprite) {
        getChild.visit()
      }
    }
    this.end()
  }
}, newCCImage:function(flipImage) {
  if(flipImage === null) {
    flipImage = true
  }
  cc.Assert(this._pixelFormat == cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888, "only RGBA8888 can be saved as image");
  if(!this._texture) {
    return null
  }
  var size = this._texture.getContentSizeInPixels();
  var nSavedBufferWidth = size.width;
  var nSavedBufferHeight = size.height;
  var pImage = new cc.Image;
  var gl = cc.renderContext;
  var pBuffer = new Uint8Array(nSavedBufferWidth * nSavedBufferHeight * 4);
  if(!pBuffer) {
    return pImage
  }
  var pTempData = new Uint8Array(nSavedBufferWidth * nSavedBufferHeight * 4);
  if(!pTempData) {
    return null
  }
  this.begin();
  gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
  gl.readPixels(0, 0, nSavedBufferWidth, nSavedBufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pTempData);
  this.end();
  for(var i = 0;i < nSavedBufferHeight;++i) {
    this._memcpy(pBuffer, i * nSavedBufferWidth * 4, pTempData, (nSavedBufferHeight - i - 1) * nSavedBufferWidth * 4, nSavedBufferWidth * 4)
  }
  pImage.initWithImageData(pBuffer, nSavedBufferWidth * nSavedBufferHeight * 4, cc.FMT_RAWDATA, nSavedBufferWidth, nSavedBufferHeight, 8);
  pBuffer = null;
  pTempData = null;
  return pImage
}, _memcpy:function(destArr, destIndex, srcArr, srcIndex, size) {
  for(var i = 0;i < size;i++) {
    destArr[destIndex + i] = srcArr[srcIndex + i]
  }
}, saveToFile:function(filePath, format) {
  cc.log("saveToFile is NoSupported on Cocos2d-Html5")
}, listenToBackground:function(obj) {
  cc.log("listenToBackground is NoSupported on Cocos2d-Html5")
}, listenToForeground:function(obj) {
  cc.log("listenToForeground is NoSupported on Cocos2d-Html5")
}, getClearFlags:function() {
  return this._clearFlags
}, setClearFlags:function(clearFlags) {
  this._clearFlags = clearFlags
}, getClearColor:function() {
  return this._clearColor
}, setClearColor:function(clearColor) {
  this._clearColor = cc.c4f(clearColor.r, clearColor.g, clearColor.b, clearColor.a)
}, getClearDepth:function() {
  return this._clearDepth
}, setClearDepth:function(clearDepth) {
  this._clearDepth = clearDepth
}, getClearStencil:function() {
  return this._clearStencil
}, setClearStencil:function(clearStencil) {
  this._clearStencil = clearStencil
}, isAutoDraw:function() {
  return this._autoDraw
}, setAutoDraw:function(autoDraw) {
  this._autoDraw = autoDraw
}});
cc.RenderTexture.create = function(width, height, format, depthStencilFormat) {
  format = format || cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888;
  depthStencilFormat = depthStencilFormat || 0;
  var ret = new cc.RenderTexture;
  if(ret && ret.initWithWidthAndHeight(width, height, format, depthStencilFormat)) {
    return ret
  }
  return null
};
cc.PROGRESS_TIMER_TYPE_RADIAL = 0;
cc.PROGRESS_TIMER_TYPE_BAR = 1;
cc.PROGRESS_TEXTURE_COORDS_COUNT = 4;
cc.PROGRESS_TEXTURE_COORDS = 75;
cc.ProgressTimerCanvas = cc.Node.extend({RGBAProtocol:true, _type:null, _percentage:0, _sprite:null, _midPoint:null, _barChangeRate:null, _reverseDirection:false, ctor:function() {
  this._super();
  this._type = cc.PROGRESS_TIMER_TYPE_RADIAL;
  this._percentage = 0;
  this._midPoint = cc.p(0, 0);
  this._barChangeRate = cc.p(0, 0);
  this._reverseDirection = false
}, getMidpoint:function() {
  return this._midPoint
}, setMidpoint:function(mpoint) {
  this._midPoint = cc.pClamp(mpoint, cc.p(0, 0), cc.p(1, 1))
}, getBarChangeRate:function() {
  return this._barChangeRate
}, setBarChangeRate:function(barChangeRate) {
  this._barChangeRate = cc.pClamp(barChangeRate, cc.p(0, 0), cc.p(1, 1))
}, getType:function() {
  return this._type
}, getPercentage:function() {
  return this._percentage
}, getSprite:function() {
  return this._sprite
}, setPercentage:function(percentage) {
  if(this._percentage != percentage) {
    this._percentage = cc.clampf(percentage, 0, 100);
    this._updateProgress()
  }
}, getColor:function() {
  return this._sprite.getColor()
}, getOpacity:function() {
  return this._sprite.getOpacity()
}, setOpacityModifyRGB:function(bValue) {
}, isOpacityModifyRGB:function() {
  return false
}, isReverseDirection:function() {
  return this._reverseDirection
}, _boundaryTexCoord:function(index) {
  if(index < cc.PROGRESS_TEXTURE_COORDS_COUNT) {
    if(this._reverseDirection) {
      return cc.p(cc.PROGRESS_TEXTURE_COORDS >> 7 - (index << 1) & 1, cc.PROGRESS_TEXTURE_COORDS >> 7 - ((index << 1) + 1) & 1)
    }else {
      return cc.p(cc.PROGRESS_TEXTURE_COORDS >> (index << 1) + 1 & 1, cc.PROGRESS_TEXTURE_COORDS >> (index << 1) & 1)
    }
  }
  return cc.PointZero()
}, setReverseProgress:function(reverse) {
  if(this._reverseDirection !== reverse) {
    this._reverseDirection = reverse
  }
}, setSprite:function(sprite) {
  if(this._sprite != sprite) {
    this._sprite = sprite;
    this.setContentSize(this._sprite.getContentSize())
  }
}, setType:function(type) {
  if(type !== this._type) {
    this._type = type
  }
}, setColor:function(color) {
  this._sprite.setColor(color)
}, setOpacity:function(opacity) {
  this._sprite.setOpacity(opacity)
}, setReverseDirection:function(reverse) {
  if(this._reverseDirection !== reverse) {
    this._reverseDirection = reverse
  }
}, initWithSprite:function(sprite) {
  this.setPercentage(0);
  this.setAnchorPoint(cc.p(0.5, 0.5));
  this._type = cc.PROGRESS_TIMER_TYPE_RADIAL;
  this._reverseDirection = false;
  this.setMidpoint(cc.p(0.5, 0.5));
  this.setBarChangeRate(cc.p(1, 1));
  this.setSprite(sprite);
  return true
}, draw:function(ctx) {
  var context = ctx || cc.renderContext;
  context.globalAlpha = this._sprite._opacity / 255;
  var centerPoint, mpX = 0, mpY = 0;
  var spriteContentSize = this._sprite._contentSize;
  var spriteAnchorPoint = this._sprite._anchorPointInPoints;
  if(this._sprite._flipX) {
    centerPoint = cc.p(spriteContentSize.width * 0.5, spriteContentSize.height * 0.5);
    mpX = 0 | centerPoint.x - spriteAnchorPoint.x;
    context.translate(mpX, 0);
    context.scale(-1, 1)
  }
  if(this._sprite._flipY) {
    centerPoint = cc.p(spriteContentSize.width * 0.5, spriteContentSize.height * 0.5);
    mpY = -(0 | centerPoint.y - spriteAnchorPoint.y);
    context.translate(0, mpY);
    context.scale(1, -1)
  }
  context.translate(spriteAnchorPoint.x, -spriteAnchorPoint.y);
  var pos;
  if(this._type == cc.PROGRESS_TIMER_TYPE_BAR) {
    pos = cc.p(-spriteAnchorPoint.x + this._sprite._offsetPosition.x + this._drawPosition.x, -spriteAnchorPoint.y + this._sprite._offsetPosition.y + this._drawPosition.y);
    if(this._sprite._texture instanceof HTMLImageElement) {
      if(this._originSize.width != 0 && this._originSize.height != 0) {
        context.drawImage(this._sprite._texture, this._sprite._rect.origin.x + this._origin.x, this._sprite._rect.origin.y + this._origin.y, this._originSize.width, this._originSize.height, pos.x, -(pos.y + this._drawSize.height), this._originSize.width, this._originSize.height)
      }
    }else {
      if(this._sprite._texture instanceof HTMLCanvasElement) {
        if(this._originSize.width != 0 && this._originSize.height != 0) {
          context.drawImage(this._sprite._texture, this._origin.x, this._origin.y, this._originSize.width, this._originSize.height, pos.x, -(pos.y + this._drawSize.height), this._originSize.width, this._originSize.height)
        }
      }
    }
  }else {
    context.beginPath();
    context.arc(this._origin.x, this._origin.y, this._radius, Math.PI / 180 * this._startAngle, Math.PI / 180 * this._endAngle, false);
    context.lineTo(this._origin.x, this._origin.y);
    context.clip();
    context.closePath();
    var offsetPixels = this._sprite._offsetPosition;
    pos = cc.p(0 | -spriteAnchorPoint.x + offsetPixels.x, 0 | -spriteAnchorPoint.y + offsetPixels.y);
    if(this._sprite._texture instanceof HTMLImageElement) {
      context.drawImage(this._sprite._texture, this._sprite._rect.origin.x, this._sprite._rect.origin.y, this._sprite._rect.size.width, this._sprite._rect.size.height, pos.x, -(pos.y + this._sprite._rect.size.height), this._sprite._rect.size.width, this._sprite._rect.size.height)
    }else {
      if(this._sprite._texture instanceof HTMLCanvasElement) {
        context.drawImage(this._sprite._texture, 0, 0, this._sprite._rect.size.width, this._sprite._rect.size.height, pos.x, -(pos.y + this._sprite._rect.size.height), this._sprite._rect.size.width, this._sprite._rect.size.height)
      }
    }
  }
  cc.INCREMENT_GL_DRAWS(1)
}, _origin:cc.PointZero(), _originSize:cc.SizeZero(), _drawSize:cc.SizeZero(), _drawPosition:cc.PointZero(), _startAngle:270, _endAngle:270, _radius:0, _updateProgress:function() {
  var size = this._sprite.getContentSize();
  var textureSize = this._sprite.getTextureRect().size;
  if(this._type == cc.PROGRESS_TIMER_TYPE_RADIAL) {
    this._origin = cc.p(-(size.width * (0.5 - this._midPoint.x)), -(size.height * (0.5 - this._midPoint.y)));
    this._radius = Math.round(Math.sqrt(size.width * size.width + size.height * size.height));
    if(this._reverseDirection) {
      this._startAngle = 270 - 3.6 * this._percentage
    }else {
      this._endAngle = 270 + 3.6 * this._percentage
    }
  }else {
    this._origin = cc.p(0, 0);
    this._drawPosition = cc.p(0, 0);
    var percentageF = this._percentage / 100;
    var startPoint = cc.p(size.width * this._midPoint.x, size.height * this._midPoint.y);
    var startPointTx = cc.p(textureSize.width * this._midPoint.x, textureSize.height * this._midPoint.y);
    var drawedSize = cc.size(size.width * (1 - this._barChangeRate.x), size.height * (1 - this._barChangeRate.y));
    var drawingSize = cc.size((size.width - drawedSize.width) * percentageF, (size.height - drawedSize.height) * percentageF);
    this._drawSize = cc.size(drawedSize.width + drawingSize.width, drawedSize.height + drawingSize.height);
    var txDrawedSize = cc.size(textureSize.width * (1 - this._barChangeRate.x), textureSize.height * (1 - this._barChangeRate.y));
    var txDrawingSize = cc.size((textureSize.width - txDrawedSize.width) * percentageF, (textureSize.height - txDrawedSize.height) * percentageF);
    this._originSize = cc.size(txDrawedSize.width + txDrawingSize.width, txDrawedSize.height + txDrawingSize.height);
    var needToLeft = startPoint.x * percentageF;
    var needToLeftTx = startPointTx.x * percentageF;
    if(size.width == this._drawSize.width) {
      this._origin.x = 0;
      this._drawPosition.x = 0
    }else {
      this._origin.x = startPointTx.x - needToLeftTx;
      this._drawPosition.x = startPoint.x - needToLeft
    }
    var needToTop = (textureSize.height - startPointTx.y) * percentageF;
    if(size.height == this._drawSize.height) {
      this._origin.y = 0;
      this._drawPosition.y = 0
    }else {
      this._origin.y = textureSize.height - startPointTx.y - needToTop;
      this._drawPosition.y = startPoint.y - startPoint.y * percentageF
    }
  }
}});
cc.ProgressTimerCanvas.create = function(sprite) {
  var progressTimer = new cc.ProgressTimerCanvas;
  if(progressTimer.initWithSprite(sprite)) {
    return progressTimer
  }
  return null
};
cc.ProgressTimerWebGL = cc.Node.extend({RGBAProtocol:true, _type:null, _percentage:0, _sprite:null, _midPoint:null, _barChangeRate:null, _reverseDirection:false, ctor:function() {
  this._super();
  this._type = cc.PROGRESS_TIMER_TYPE_RADIAL;
  this._percentage = 0;
  this._midPoint = cc.p(0, 0);
  this._barChangeRate = cc.p(0, 0);
  this._reverseDirection = false
}, getMidpoint:function() {
  return this._midPoint
}, setMidpoint:function(mpoint) {
  this._midPoint = cc.pClamp(mpoint, cc.p(0, 0), cc.p(1, 1))
}, getBarChangeRate:function() {
  return this._barChangeRate
}, setBarChangeRate:function(barChangeRate) {
  this._barChangeRate = cc.pClamp(barChangeRate, cc.p(0, 0), cc.p(1, 1))
}, getType:function() {
  return this._type
}, getPercentage:function() {
  return this._percentage
}, getSprite:function() {
  return this._sprite
}, setPercentage:function(percentage) {
  if(this._percentage != percentage) {
    this._percentage = cc.clampf(percentage, 0, 100);
    this._updateProgress()
  }
}, getColor:function() {
  return this._sprite.getColor()
}, getOpacity:function() {
  return this._sprite.getOpacity()
}, setOpacityModifyRGB:function(bValue) {
}, isOpacityModifyRGB:function() {
  return false
}, isReverseDirection:function() {
  return this._reverseDirection
}, _boundaryTexCoord:function(index) {
  if(index < cc.PROGRESS_TEXTURE_COORDS_COUNT) {
    if(this._reverseDirection) {
      return cc.p(cc.PROGRESS_TEXTURE_COORDS >> 7 - (index << 1) & 1, cc.PROGRESS_TEXTURE_COORDS >> 7 - ((index << 1) + 1) & 1)
    }else {
      return cc.p(cc.PROGRESS_TEXTURE_COORDS >> (index << 1) + 1 & 1, cc.PROGRESS_TEXTURE_COORDS >> (index << 1) & 1)
    }
  }
  return cc.PointZero()
}, _vertexDataCount:0, _vertexData:null, _verticesFloat32Buffer:null, _textureCoordsFloat32Buffer:null, _colorsUint8Buffer:null, setReverseProgress:function(reverse) {
  if(this._reverseDirection !== reverse) {
    this._reverseDirection = reverse;
    this._vertexData = null;
    this._vertexDataCount = 0
  }
}, setSprite:function(sprite) {
  if(this._sprite != sprite) {
    this._sprite = sprite;
    this.setContentSize(this._sprite.getContentSize());
    if(this._vertexData) {
      this._vertexData = null;
      this._vertexDataCount = 0
    }
  }
}, setType:function(type) {
  if(type !== this._type) {
    if(this._vertexData) {
      this._vertexData = null;
      this._vertexDataCount = 0
    }
    this._type = type
  }
}, setColor:function(color) {
  this._sprite.setColor(color);
  this._updateColor()
}, setOpacity:function(opacity) {
  this._sprite.setOpacity(opacity);
  this._updateColor()
}, setReverseDirection:function(reverse) {
  if(this._reverseDirection !== reverse) {
    this._reverseDirection = reverse;
    this._vertexData = null;
    this._vertexDataCount = 0
  }
}, _textureCoordFromAlphaPoint:function(alpha) {
  if(!this._sprite) {
    return new cc.Tex2F(0, 0)
  }
  var quad = this._sprite.getQuad();
  var min = cc.p(quad.bl.texCoords.u, quad.bl.texCoords.v);
  var max = cc.p(quad.tr.texCoords.u, quad.tr.texCoords.v);
  if(this._sprite.isTextureRectRotated()) {
    var temp = alpha.x;
    alpha.x = alpha.y;
    alpha.y = temp
  }
  return new cc.Tex2F(min.x * (1 - alpha.x) + max.x * alpha.x, min.y * (1 - alpha.y) + max.y * alpha.y)
}, _vertexFromAlphaPoint:function(alpha) {
  var ret = new cc.Tex2F(0, 0);
  if(!this._sprite) {
    return ret
  }
  var quad = this._sprite.getQuad();
  var min = cc.p(quad.bl.vertices.x, quad.bl.vertices.y);
  var max = cc.p(quad.tr.vertices.x, quad.tr.vertices.y);
  ret.x = min.x * (1 - alpha.x) + max.x * alpha.x;
  ret.y = min.y * (1 - alpha.y) + max.y * alpha.y;
  return ret
}, initWithSprite:function(sprite) {
  this.setPercentage(0);
  this._vertexData = null;
  this._vertexDataCount = 0;
  this.setAnchorPoint(cc.p(0.5, 0.5));
  this._type = cc.PROGRESS_TIMER_TYPE_RADIAL;
  this._reverseDirection = false;
  this.setMidpoint(cc.p(0.5, 0.5));
  this.setBarChangeRate(cc.p(1, 1));
  this.setSprite(sprite);
  this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
  return true
}, _getProgressTimerVertexArray:function() {
  var vertexBuffer = cc.renderContext.createBuffer();
  cc.renderContext.bindBuffer(cc.renderContext.ARRAY_BUFFER, vertexBuffer);
  var vertiesArray = new Float32Array(2 * this._vertexDataCount);
  for(var i = 0;i < this._vertexDataCount;i++) {
    vertiesArray[i * 2] = this._vertexData[i].vertices.x;
    vertiesArray[i * 2 + 1] = this._vertexData[i].vertices.y
  }
  cc.renderContext.bufferData(cc.renderContext.ARRAY_BUFFER, vertiesArray, cc.renderContext.STATIC_DRAW);
  return vertexBuffer
}, _getProgressTimerColorArray:function() {
  var colorsBuffer = cc.renderContext.createBuffer();
  cc.renderContext.bindBuffer(cc.renderContext.ARRAY_BUFFER, colorsBuffer);
  var verticesArray = new Uint8Array(4 * this._vertexDataCount);
  for(var i = 0;i < this._vertexDataCount;i++) {
    verticesArray[i * 4] = this._vertexData[i].colors.r;
    verticesArray[i * 4 + 1] = this._vertexData[i].colors.g;
    verticesArray[i * 4 + 2] = this._vertexData[i].colors.b;
    verticesArray[i * 4 + 3] = this._vertexData[i].colors.a
  }
  cc.renderContext.bufferData(cc.renderContext.ARRAY_BUFFER, verticesArray, cc.renderContext.STATIC_DRAW);
  return colorsBuffer
}, _getProgressTimerTexCoodsArray:function() {
  var vertexBuffer = cc.renderContext.createBuffer();
  cc.renderContext.bindBuffer(cc.renderContext.ARRAY_BUFFER, vertexBuffer);
  var vertiesArray = new Float32Array(2 * this._vertexDataCount);
  for(var i = 0;i < this._vertexDataCount;i++) {
    vertiesArray[i * 2] = this._vertexData[i].texCoords.u;
    vertiesArray[i * 2 + 1] = this._vertexData[i].texCoords.v
  }
  cc.renderContext.bufferData(cc.renderContext.ARRAY_BUFFER, vertiesArray, cc.renderContext.STATIC_DRAW);
  return vertexBuffer
}, draw:function(ctx) {
  var context = ctx || cc.renderContext;
  if(!this._vertexData || !this._sprite) {
    return
  }
  cc.NODE_DRAW_SETUP(this);
  cc.glBlendFunc(this._sprite.getBlendFunc().src, this._sprite.getBlendFunc().dst);
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSCOLORTEX);
  if(this._sprite.getTexture()) {
    cc.glBindTexture2D(this._sprite.getTexture())
  }else {
    cc.glBindTexture2D(null)
  }
  context.bindBuffer(context.ARRAY_BUFFER, this._verticesFloat32Buffer);
  context.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, context.FLOAT, false, 0, 0);
  context.bindBuffer(context.ARRAY_BUFFER, this._textureCoordsFloat32Buffer);
  context.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, context.FLOAT, false, 0, 0);
  context.bindBuffer(context.ARRAY_BUFFER, this._colorsUint8Buffer);
  context.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, context.UNSIGNED_BYTE, true, 0, 0);
  if(this._type === cc.PROGRESS_TIMER_TYPE_RADIAL) {
    context.drawArrays(context.TRIANGLE_FAN, 0, this._vertexDataCount)
  }else {
    if(this._type == cc.PROGRESS_TIMER_TYPE_BAR) {
      if(!this._reverseDirection) {
        context.drawArrays(context.TRIANGLE_STRIP, 0, this._vertexDataCount)
      }else {
        context.drawArrays(context.TRIANGLE_STRIP, 0, this._vertexDataCount / 2);
        context.drawArrays(context.TRIANGLE_STRIP, 4, this._vertexDataCount / 2);
        cc.INCREMENT_GL_DRAWS(1)
      }
    }
  }
  cc.INCREMENT_GL_DRAWS(1)
}, _updateColor:function() {
  if(!this._sprite || !this._vertexData) {
    return
  }
  var sc = this._sprite.getQuad().tl.colors;
  for(var i = 0;i < this._vertexDataCount;++i) {
    this._vertexData[i].colors = sc
  }
  this._colorsUint8Buffer = this._getProgressTimerColorArray()
}, _updateRadial:function() {
  if(!this._sprite) {
    return
  }
  var i;
  var alpha = this._percentage / 100;
  var angle = 2 * cc.PI * (this._reverseDirection ? alpha : 1 - alpha);
  var topMid = cc.p(this._midPoint.x, 1);
  var percentagePt = cc.pRotateByAngle(topMid, this._midPoint, angle);
  var index = 0;
  var hit;
  if(alpha == 0) {
    hit = topMid;
    index = 0
  }else {
    if(alpha == 1) {
      hit = topMid;
      index = 4
    }else {
      var min_t = cc.FLT_MAX;
      for(i = 0;i <= cc.PROGRESS_TEXTURE_COORDS_COUNT;++i) {
        var pIndex = (i + (cc.PROGRESS_TEXTURE_COORDS_COUNT - 1)) % cc.PROGRESS_TEXTURE_COORDS_COUNT;
        var edgePtA = this._boundaryTexCoord(i % cc.PROGRESS_TEXTURE_COORDS_COUNT);
        var edgePtB = this._boundaryTexCoord(pIndex);
        if(i == 0) {
          edgePtB = cc.pLerp(edgePtA, edgePtB, 1 - this._midPoint.x)
        }else {
          if(i == 4) {
            edgePtA = cc.pLerp(edgePtA, edgePtB, 1 - this._midPoint.x)
          }
        }
        var retPoint = cc.p(0, 0);
        if(cc.pLineIntersect(edgePtA, edgePtB, this._midPoint, percentagePt, retPoint)) {
          if(i == 0 || i == 4) {
            if(!(0 <= retPoint.x && retPoint.x <= 1)) {
              continue
            }
          }
          if(retPoint.y >= 0) {
            if(retPoint.y < min_t) {
              min_t = retPoint.y;
              index = i
            }
          }
        }
      }
      hit = cc.pAdd(this._midPoint, cc.pMult(cc.pSub(percentagePt, this._midPoint), min_t))
    }
  }
  var sameIndexCount = true;
  if(this._vertexDataCount != index + 3) {
    sameIndexCount = false;
    this._vertexData = null;
    this._vertexDataCount = 0
  }
  if(!this._vertexData) {
    this._vertexDataCount = index + 3;
    this._vertexData = [];
    for(i = 0;i < this._vertexDataCount;i++) {
      this._vertexData[i] = new cc.V2F_C4B_T2F
    }
    cc.Assert(this._vertexData, "cc.ProgressTimer. Not enough memory")
  }
  if(!sameIndexCount) {
    this._vertexData[0].texCoords = this._textureCoordFromAlphaPoint(this._midPoint);
    this._vertexData[0].vertices = this._vertexFromAlphaPoint(this._midPoint);
    this._vertexData[1].texCoords = this._textureCoordFromAlphaPoint(topMid);
    this._vertexData[1].vertices = this._vertexFromAlphaPoint(topMid);
    for(i = 0;i < index;i++) {
      var alphaPoint = this._boundaryTexCoord(i);
      this._vertexData[i + 2].texCoords = this._textureCoordFromAlphaPoint(alphaPoint);
      this._vertexData[i + 2].vertices = this._vertexFromAlphaPoint(alphaPoint)
    }
  }
  this._vertexData[this._vertexDataCount - 1].texCoords = this._textureCoordFromAlphaPoint(hit);
  this._vertexData[this._vertexDataCount - 1].vertices = this._vertexFromAlphaPoint(hit);
  this._verticesFloat32Buffer = this._getProgressTimerVertexArray();
  this._textureCoordsFloat32Buffer = this._getProgressTimerTexCoodsArray();
  this._updateColor()
}, _updateBar:function() {
  if(!this._sprite) {
    return
  }
  var i;
  var alpha = this._percentage / 100;
  var alphaOffset = cc.pMult(cc.p(1 - this._barChangeRate.x + alpha * this._barChangeRate.x, 1 - this._barChangeRate.y + alpha * this._barChangeRate.y), 0.5);
  var min = cc.pSub(this._midPoint, alphaOffset);
  var max = cc.pAdd(this._midPoint, alphaOffset);
  if(min.x < 0) {
    max.x += -min.x;
    min.x = 0
  }
  if(max.x > 1) {
    min.x -= max.x - 1;
    max.x = 1
  }
  if(min.y < 0) {
    max.y += -min.y;
    min.y = 0
  }
  if(max.y > 1) {
    min.y -= max.y - 1;
    max.y = 1
  }
  if(!this._reverseDirection) {
    if(!this._vertexData) {
      this._vertexDataCount = 4;
      this._vertexData = [];
      for(i = 0;i < this._vertexDataCount;i++) {
        this._vertexData[i] = new cc.V2F_C4B_T2F
      }
      cc.Assert(this._vertexData, "cc.ProgressTimer. Not enough memory")
    }
    this._vertexData[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, max.y));
    this._vertexData[0].vertices = this._vertexFromAlphaPoint(cc.p(min.x, max.y));
    this._vertexData[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, min.y));
    this._vertexData[1].vertices = this._vertexFromAlphaPoint(cc.p(min.x, min.y));
    this._vertexData[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, max.y));
    this._vertexData[2].vertices = this._vertexFromAlphaPoint(cc.p(max.x, max.y));
    this._vertexData[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, min.y));
    this._vertexData[3].vertices = this._vertexFromAlphaPoint(cc.p(max.x, min.y))
  }else {
    if(!this._vertexData) {
      this._vertexData = 8;
      this._vertexData = [];
      for(i = 0;i < this._vertexDataCount;i++) {
        this._vertexData[i] = new cc.V2F_C4B_T2F
      }
      cc.Assert(this._vertexData, "cc.ProgressTimer. Not enough memory");
      this._vertexData[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 1));
      this._vertexData[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1));
      this._vertexData[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0));
      this._vertexData[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0));
      this._vertexData[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1));
      this._vertexData[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1));
      this._vertexData[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 0));
      this._vertexData[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0))
    }
    this._vertexData[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, max.y));
    this._vertexData[2].vertices = this._vertexFromAlphaPoint(cc.p(min.x, max.y));
    this._vertexData[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, min.y));
    this._vertexData[3].vertices = this._vertexFromAlphaPoint(cc.p(min.x, min.y));
    this._vertexData[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, max.y));
    this._vertexData[4].vertices = this._vertexFromAlphaPoint(cc.p(max.x, max.y));
    this._vertexData[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, min.y));
    this._vertexData[5].vertices = this._vertexFromAlphaPoint(cc.p(max.x, min.y))
  }
  this._verticesFloat32Buffer = this._getProgressTimerVertexArray();
  this._textureCoordsFloat32Buffer = this._getProgressTimerTexCoodsArray();
  this._updateColor()
}, _updateProgress:function() {
  switch(this._type) {
    case cc.PROGRESS_TIMER_TYPE_RADIAL:
      this._updateRadial();
      break;
    case cc.PROGRESS_TIMER_TYPE_BAR:
      this._updateBar();
      break;
    default:
      break
  }
}});
cc.ProgressTimerWebGL.create = function(sprite) {
  var progressTimer = new cc.ProgressTimerWebGL;
  if(progressTimer.initWithSprite(sprite)) {
    return progressTimer
  }
  return null
};
cc.ProgressTimer = cc.Browser.supportWebGL ? cc.ProgressTimerWebGL : cc.ProgressTimerCanvas;
cc.MotionStreak = cc.Node.extend({_fastMode:false, _startingPositionInitialized:false, _texture:null, _blendFunc:null, _positionR:null, _color:null, _stroke:0, _fadeDelta:0, _minSeg:0, _maxPoints:0, _nuPoints:0, _previousNuPoints:0, _pointVertexes:null, _pointState:null, _vertices:null, _colorPointer:null, _texCoords:null, _verticesBuffer:null, _colorPointerBuffer:null, _texCoordsBuffer:null, getTexture:function() {
  return this._texture
}, setTexture:function(texture) {
  if(this._texture != texture) {
    this._texture = texture
  }
}, getBlendFunc:function() {
  return this._blendFunc
}, setBlendFunc:function(src, dst) {
  if(arguments.length == 1) {
    this._blendFunc = src
  }else {
    if(arguments.length == 2) {
      this._blendFunc.src = src;
      this._blendFunc.dst = dst
    }
  }
}, setColor:function(color) {
  this._color = color
}, getColor:function() {
  return this._color
}, getOpacity:function() {
  cc.Assert(false, "Opacity no supported");
  return 0
}, setOpacity:function(opacity) {
  cc.Assert(false, "Set opacity no supported")
}, setOpacityModifyRGB:function(value) {
}, isOpacityModifyRGB:function() {
  return false
}, ctor:function() {
  this._super();
  this._positionR = cc.PointZero();
  this._color = cc.c3(0, 0, 0);
  this._blendFunc = new cc.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
}, isFastMode:function() {
  return this._fastMode
}, setFastMode:function(fastMode) {
  this._fastMode = fastMode
}, isStartingPositionInitialized:function() {
  return this._startingPositionInitialized
}, setStartingPositionInitialized:function(startingPositionInitialized) {
  this._startingPositionInitialized = startingPositionInitialized
}, initWithFade:function(fade, minSeg, stroke, color, texture) {
  cc.Assert(texture != null, "Invalid filename or texture");
  if(typeof texture === "string") {
    texture = cc.TextureCache.getInstance().addImage(texture)
  }
  cc.Node.prototype.setPosition.call(this, cc.PointZero());
  this.setAnchorPoint(cc.PointZero());
  this.ignoreAnchorPointForPosition(true);
  this._startingPositionInitialized = false;
  this._positionR = cc.PointZero();
  this._fastMode = true;
  this._minSeg = minSeg == -1 ? stroke / 5 : minSeg;
  this._minSeg *= this._minSeg;
  this._stroke = stroke;
  this._fadeDelta = 1 / fade;
  this._maxPoints = (0 | fade * 60) + 2;
  this._nuPoints = 0;
  this._pointState = new Float32Array(this._maxPoints);
  this._pointVertexes = new Float32Array(this._maxPoints * 2);
  this._vertices = new Float32Array(this._maxPoints * 4);
  this._texCoords = new Float32Array(this._maxPoints * 4);
  this._colorPointer = new Uint8Array(this._maxPoints * 8);
  var gl = cc.renderContext;
  this._verticesBuffer = gl.createBuffer();
  this._texCoordsBuffer = gl.createBuffer();
  this._colorPointerBuffer = gl.createBuffer();
  this._blendFunc.src = gl.SRC_ALPHA;
  this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA;
  this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
  this.setTexture(texture);
  this.setColor(color);
  this.scheduleUpdate();
  gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordsBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, this._texCoords, gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._colorPointerBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, this._colorPointer, gl.DYNAMIC_DRAW);
  this._isDirty = true;
  return true
}, tintWithColor:function(colors) {
  this.setColor(colors);
  for(var i = 0;i < this._nuPoints * 2;i++) {
    this._colorPointer[i * 4] = colors.r;
    this._colorPointer[i * 4 + 1] = colors.g;
    this._colorPointer[i * 4 + 2] = colors.b
  }
  this._isDirty = true
}, reset:function() {
  this._nuPoints = 0
}, setPosition:function(position) {
  this._startingPositionInitialized = true;
  this._positionR = cc.p(position.x, position.y)
}, draw:function(ctx) {
  if(this._nuPoints <= 1) {
    return
  }
  if(this._texture && this._texture.isLoaded()) {
    ctx = ctx || cc.renderContext;
    cc.NODE_DRAW_SETUP(this);
    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSCOLORTEX);
    cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
    cc.glBindTexture2D(this._texture);
    ctx.bindBuffer(ctx.ARRAY_BUFFER, this._verticesBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, this._vertices, ctx.DYNAMIC_DRAW);
    ctx.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, ctx.FLOAT, false, 0, 0);
    ctx.bindBuffer(ctx.ARRAY_BUFFER, this._texCoordsBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, this._texCoords, ctx.DYNAMIC_DRAW);
    ctx.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, ctx.FLOAT, false, 0, 0);
    ctx.bindBuffer(ctx.ARRAY_BUFFER, this._colorPointerBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, this._colorPointer, ctx.DYNAMIC_DRAW);
    ctx.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, ctx.UNSIGNED_BYTE, true, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, this._nuPoints * 2);
    cc.INCREMENT_GL_DRAWS(1)
  }
}, update:function(delta) {
  if(!this._startingPositionInitialized) {
    return
  }
  delta *= this._fadeDelta;
  var newIdx, newIdx2, i, i2;
  var mov = 0;
  for(i = 0;i < this._nuPoints;i++) {
    this._pointState[i] -= delta;
    if(this._pointState[i] <= 0) {
      mov++
    }else {
      newIdx = i - mov;
      if(mov > 0) {
        this._pointState[newIdx] = this._pointState[i];
        this._pointVertexes[newIdx * 2] = this._pointVertexes[i * 2];
        this._pointVertexes[newIdx * 2 + 1] = this._pointVertexes[i * 2 + 1];
        i2 = i * 2;
        newIdx2 = newIdx * 2;
        this._vertices[newIdx2 * 2] = this._vertices[i2 * 2];
        this._vertices[newIdx2 * 2 + 1] = this._vertices[i2 * 2 + 1];
        this._vertices[(newIdx2 + 1) * 2] = this._vertices[(i2 + 1) * 2];
        this._vertices[(newIdx2 + 1) * 2 + 1] = this._vertices[(i2 + 1) * 2 + 1];
        i2 *= 4;
        newIdx2 *= 4;
        this._colorPointer[newIdx2 + 0] = this._colorPointer[i2 + 0];
        this._colorPointer[newIdx2 + 1] = this._colorPointer[i2 + 1];
        this._colorPointer[newIdx2 + 2] = this._colorPointer[i2 + 2];
        this._colorPointer[newIdx2 + 4] = this._colorPointer[i2 + 4];
        this._colorPointer[newIdx2 + 5] = this._colorPointer[i2 + 5];
        this._colorPointer[newIdx2 + 6] = this._colorPointer[i2 + 6]
      }else {
        newIdx2 = newIdx * 8
      }
      var op = this._pointState[newIdx] * 255;
      this._colorPointer[newIdx2 + 3] = op;
      this._colorPointer[newIdx2 + 7] = op
    }
  }
  this._nuPoints -= mov;
  var appendNewPoint = true;
  if(this._nuPoints >= this._maxPoints) {
    appendNewPoint = false
  }else {
    if(this._nuPoints > 0) {
      var a1 = cc.pDistanceSQ(cc.p(this._pointVertexes[(this._nuPoints - 1) * 2], this._pointVertexes[(this._nuPoints - 1) * 2 + 1]), this._positionR) < this._minSeg;
      var a2 = this._nuPoints == 1 ? false : cc.pDistanceSQ(cc.p(this._pointVertexes[(this._nuPoints - 2) * 2], this._pointVertexes[(this._nuPoints - 2) * 2 + 1]), this._positionR) < this._minSeg * 2;
      if(a1 || a2) {
        appendNewPoint = false
      }
    }
  }
  if(appendNewPoint) {
    this._pointVertexes[this._nuPoints * 2] = this._positionR.x;
    this._pointVertexes[this._nuPoints * 2 + 1] = this._positionR.y;
    this._pointState[this._nuPoints] = 1;
    var offset = this._nuPoints * 8;
    this._colorPointer[offset] = this._color.r;
    this._colorPointer[offset + 1] = this._color.g;
    this._colorPointer[offset + 2] = this._color.b;
    this._colorPointer[offset + 4] = this._color.r;
    this._colorPointer[offset + 5] = this._color.g;
    this._colorPointer[offset + 6] = this._color.b;
    this._colorPointer[offset + 3] = 255;
    this._colorPointer[offset + 7] = 255;
    if(this._nuPoints > 0 && this._fastMode) {
      if(this._nuPoints > 1) {
        cc.vertexLineToPolygon(this._pointVertexes, this._stroke, this._vertices, this._nuPoints, 1)
      }else {
        cc.vertexLineToPolygon(this._pointVertexes, this._stroke, this._vertices, 0, 2)
      }
    }
    this._nuPoints++
  }
  if(!this._fastMode) {
    cc.vertexLineToPolygon(this._pointVertexes, this._stroke, this._vertices, 0, this._nuPoints)
  }
  if(this._nuPoints && this._previousNuPoints != this._nuPoints) {
    var texDelta = 1 / this._nuPoints;
    for(i = 0;i < this._nuPoints;i++) {
      this._texCoords[i * 4] = 0;
      this._texCoords[i * 4 + 1] = texDelta * i;
      this._texCoords[(i * 2 + 1) * 2] = 1;
      this._texCoords[(i * 2 + 1) * 2 + 1] = texDelta * i
    }
    this._previousNuPoints = this._nuPoints
  }
}});
cc.MotionStreak.create = function(fade, minSeg, stroke, color, texture) {
  var ret = new cc.MotionStreak;
  if(ret && ret.initWithFade(fade, minSeg, stroke, color, texture)) {
    return ret
  }
  return null
};
cc.stencilBits = -1;
cc.setProgram = function(node, program) {
  node.setShaderProgram(program);
  var children = node.getChildren();
  if(!children) {
    return
  }
  for(var i = 0;i < children.length;i++) {
    cc.setProgram(children[i], program)
  }
};
cc.ClippingNode = cc.Node.extend({_stencil:null, _alphaThreshold:0, _inverted:false, init:function(stencil) {
  this._stencil = stencil;
  this._alphaThreshold = 1;
  this._inverted = false;
  cc.ClippingNode._init_once = true;
  if(cc.ClippingNode._init_once) {
    cc.stencilBits = cc.renderContext.getParameter(cc.renderContext.STENCIL_BITS);
    if(cc.stencilBits <= 0) {
      cc.log("Stencil buffer is not enabled.")
    }
    cc.ClippingNode._init_once = false
  }
  return true
}, onEnter:function() {
  this._super();
  this._stencil.onEnter()
}, onEnterTransitionDidFinish:function() {
  this._super();
  this._stencil.onEnterTransitionDidFinish()
}, onExitTransitionDidStart:function() {
  this._stencil.onExitTransitionDidStart();
  this._super()
}, onExit:function() {
  this._stencil.onExit();
  this._super()
}, visit:function(ctx) {
  var gl = ctx || cc.renderContext;
  if(cc.stencilBits < 1) {
    this._super(ctx);
    return
  }
  if(!this._stencil || !this._stencil.isVisible()) {
    if(this._inverted) {
      this._super(ctx)
    }
    return
  }
  cc.ClippingNode._layer = -1;
  if(cc.ClippingNode._layer + 1 == cc.stencilBits) {
    cc.ClippingNode._visit_once = true;
    if(cc.ClippingNode._visit_once) {
      cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs.");
      cc.ClippingNode._visit_once = false
    }
    this._super();
    return
  }
  cc.ClippingNode._layer++;
  var mask_layer = 1 << cc.ClippingNode._layer;
  var mask_layer_l = mask_layer - 1;
  var mask_layer_le = mask_layer | mask_layer_l;
  var currentStencilEnabled = gl.isEnabled(gl.STENCIL_TEST);
  var currentStencilWriteMask = gl.getParameter(gl.STENCIL_WRITEMASK);
  var currentStencilFunc = gl.getParameter(gl.STENCIL_FUNC);
  var currentStencilRef = gl.getParameter(gl.STENCIL_REF);
  var currentStencilValueMask = gl.getParameter(gl.STENCIL_VALUE_MASK);
  var currentStencilFail = gl.getParameter(gl.STENCIL_FAIL);
  var currentStencilPassDepthFail = gl.getParameter(gl.STENCIL_PASS_DEPTH_FAIL);
  var currentStencilPassDepthPass = gl.getParameter(gl.STENCIL_PASS_DEPTH_PASS);
  gl.enable(gl.STENCIL_TEST);
  gl.stencilMask(mask_layer);
  var currentDepthWriteMask = gl.getParameter(gl.DEPTH_WRITEMASK);
  gl.depthMask(false);
  gl.stencilFunc(gl.NEVER, mask_layer, mask_layer);
  gl.stencilOp(!this._inverted ? gl.ZERO : gl.REPLACE, gl.KEEP, gl.KEEP);
  cc.drawingUtil.drawSolidRect(cc.PointZero(), cc.pFromSize(cc.Director.getInstance().getWinSize()), cc.c4f(1, 1, 1, 1));
  gl.stencilFunc(gl.NEVER, mask_layer, mask_layer);
  gl.stencilOp(!this._inverted ? gl.REPLACE : gl.ZERO, gl.KEEP, gl.KEEP);
  if(this._alphaThreshold < 1) {
    var program = cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
    var alphaValueLocation = gl.getUniformLocation(program.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S);
    cc.glUseProgram(program.getProgram());
    program.setUniformLocationWith1f(alphaValueLocation, this._alphaThreshold);
    cc.setProgram(this._stencil, program)
  }
  cc.kmGLPushMatrix();
  this.transform();
  this._stencil.visit();
  cc.kmGLPopMatrix();
  gl.depthMask(currentDepthWriteMask);
  gl.stencilFunc(gl.EQUAL, mask_layer_le, mask_layer_le);
  gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  this._super();
  gl.stencilFunc(currentStencilFunc, currentStencilRef, currentStencilValueMask);
  gl.stencilOp(currentStencilFail, currentStencilPassDepthFail, currentStencilPassDepthPass);
  gl.stencilMask(currentStencilWriteMask);
  if(!currentStencilEnabled) {
    gl.disable(gl.STENCIL_TEST)
  }
  cc.ClippingNode._layer--
}, getStencil:function() {
  return this._stencil
}, setStencil:function(stencil) {
  this._stencil = stencil
}, getAlphaThreshold:function() {
  return this._alphaThreshold
}, setAlphaThreshold:function(alphaThreshold) {
  this._alphaThreshold = alphaThreshold
}, isInverted:function() {
  return this._inverted
}, setInverted:function(inverted) {
  this._inverted = inverted
}});
cc.ClippingNode._init_once = null;
cc.ClippingNode._visit_once = null;
cc.ClippingNode._layer = null;
cc.ClippingNode.create = function(stencil) {
  var node = new cc.ClippingNode;
  node.init(stencil);
  return node
};
cc.GridBase = cc.Class.extend({_active:false, _reuseGrid:0, _gridSize:null, _texture:null, _step:null, _grabber:null, _isTextureFlipped:false, _shaderProgram:null, _directorProjection:0, _dirty:false, ctor:function() {
  this._step = cc.p(0, 0)
}, isActive:function() {
  return this._active
}, setActive:function(active) {
  this._active = active;
  if(!active) {
    var director = cc.Director.getInstance();
    var proj = director.getProjection();
    director.setProjection(proj)
  }
}, getReuseGrid:function() {
  return this._reuseGrid
}, setReuseGrid:function(reuseGrid) {
  this._reuseGrid = reuseGrid
}, getGridSize:function() {
  return this._gridSize
}, setGridSize:function(gridSize) {
  this._gridSize.width = parseInt(gridSize.width);
  this._gridSize.height = parseInt(gridSize.height)
}, getStep:function() {
  return this._step
}, setStep:function(step) {
  this._step = step
}, isTextureFlipped:function() {
  return this._isTextureFlipped
}, setTextureFlipped:function(flipped) {
  if(this._isTextureFlipped != flipped) {
    this._isTextureFlipped = flipped;
    this.calculateVertexPoints()
  }
}, initWithSize:function(gridSize, texture, flipped) {
  if(!texture) {
    var director = cc.Director.getInstance();
    var winSize = director.getWinSizeInPixels();
    var POTWide = cc.NextPOT(winSize.width);
    var POTHigh = cc.NextPOT(winSize.height);
    var data = new Uint8Array(POTWide * POTHigh * 4);
    if(!data) {
      cc.log("cocos2d: CCGrid: not enough memory.");
      return false
    }
    texture = new cc.Texture2D;
    texture.initWithData(data, cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888, POTWide, POTHigh, winSize);
    if(!texture) {
      cc.log("cocos2d: CCGrid: error creating texture");
      return false
    }
  }
  flipped = flipped || false;
  this._active = false;
  this._reuseGrid = 0;
  this._gridSize = gridSize;
  this._texture = texture;
  this._isTextureFlipped = flipped;
  var texSize = this._texture.getContentSize();
  this._step.x = texSize.width / this._gridSize.width;
  this._step.y = texSize.height / this._gridSize.height;
  this._grabber = new cc.Grabber;
  if(!this._grabber) {
    return false
  }
  this._grabber.grab(this._texture);
  this._shaderProgram = cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_TEXTURE);
  this.calculateVertexPoints();
  return true
}, beforeDraw:function() {
  this._directorProjection = cc.Director.getInstance().getProjection();
  this.set2DProjection();
  this._grabber.beforeRender(this._texture)
}, afterDraw:function(target) {
  this._grabber.afterRender(this._texture);
  cc.Director.getInstance().setProjection(this._directorProjection);
  if(target.getCamera().isDirty()) {
    var offset = target.getAnchorPointInPoints();
    cc.kmGLTranslatef(offset.x, offset.y, 0);
    target.getCamera().locate();
    cc.kmGLTranslatef(-offset.x, -offset.y, 0)
  }
  cc.glBindTexture2D(this._texture);
  this.blit()
}, blit:function() {
  cc.Assert(0, "")
}, reuse:function() {
  cc.Assert(0, "")
}, calculateVertexPoints:function() {
  cc.Assert(0, "")
}, set2DProjection:function() {
  var winSize = cc.Director.getInstance().getWinSizeInPixels();
  var gl = cc.renderContext;
  gl.viewport(0, 0, winSize.width * cc.CONTENT_SCALE_FACTOR(), winSize.height * cc.CONTENT_SCALE_FACTOR());
  cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
  cc.kmGLLoadIdentity();
  var orthoMatrix = new cc.kmMat4;
  cc.kmMat4OrthographicProjection(orthoMatrix, 0, winSize.width * cc.CONTENT_SCALE_FACTOR(), 0, winSize.height * cc.CONTENT_SCALE_FACTOR(), -1, 1);
  cc.kmGLMultMatrix(orthoMatrix);
  cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
  cc.kmGLLoadIdentity();
  cc.setProjectionMatrixDirty()
}});
cc.GridBase.create = function(gridSize, texture, flipped) {
  var gridBase = new cc.GridBase;
  if(gridBase && gridBase.initWithSize(gridSize, texture, flipped)) {
    return gridBase
  }
  return null
};
cc.Grid3D = cc.GridBase.extend({_texCoordinates:null, _vertices:null, _originalVertices:null, _indices:null, _texCoordinateBuffer:null, _verticesBuffer:null, _indicesBuffer:null, ctor:function() {
  this._super()
}, vertex:function(pos) {
  var index = 0 | (pos.x * (this._gridSize.height + 1) + pos.y) * 3;
  return new cc.Vertex3F(this._vertices[index], this._vertices[index + 1], this._vertices[index + 2])
}, originalVertex:function(pos) {
  var index = 0 | (pos.x * (this._gridSize.height + 1) + pos.y) * 3;
  return new cc.Vertex3F(this._originalVertices[index], this._originalVertices[index + 1], this._originalVertices[index + 2])
}, setVertex:function(pos, vertex) {
  var index = 0 | (pos.x * (this._gridSize.height + 1) + pos.y) * 3;
  var vertArray = this._vertices;
  vertArray[index] = vertex.x;
  vertArray[index + 1] = vertex.y;
  vertArray[index + 2] = vertex.z;
  this._dirty = true
}, blit:function() {
  var n = this._gridSize.width * this._gridSize.height;
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEXCOORDS);
  this._shaderProgram.use();
  this._shaderProgram.setUniformsForBuiltins();
  var gl = cc.renderContext;
  gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
  if(this._dirty) {
    gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW)
  }
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordinateBuffer);
  if(this._dirty) {
    gl.bufferData(gl.ARRAY_BUFFER, this._texCoordinates, gl.DYNAMIC_DRAW)
  }
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
  if(this._dirty) {
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW)
  }
  gl.drawElements(gl.TRIANGLES, n * 6, gl.UNSIGNED_SHORT, 0);
  if(this._dirty) {
    this._dirty = false
  }
  cc.INCREMENT_GL_DRAWS(1)
}, reuse:function() {
  if(this._reuseGrid > 0) {
    for(var i = 0;i < this._vertices.length;i++) {
      this._originalVertices[i] = this._vertices[i]
    }
    --this._reuseGrid
  }
}, calculateVertexPoints:function() {
  var gl = cc.renderContext;
  var width = this._texture.getPixelsWide();
  var height = this._texture.getPixelsHigh();
  var imageH = this._texture.getContentSizeInPixels().height;
  var numOfPoints = (this._gridSize.width + 1) * (this._gridSize.height + 1);
  this._vertices = new Float32Array(numOfPoints * 3);
  this._texCoordinates = new Float32Array(numOfPoints * 2);
  this._indices = new Uint16Array(this._gridSize.width * this._gridSize.height * 6);
  this._verticesBuffer = gl.createBuffer();
  this._texCoordinateBuffer = gl.createBuffer();
  this._indicesBuffer = gl.createBuffer();
  var x, y, i;
  for(x = 0;x < this._gridSize.width;++x) {
    for(y = 0;y < this._gridSize.height;++y) {
      var idx = y * this._gridSize.width + x;
      var x1 = x * this._step.x;
      var x2 = x1 + this._step.x;
      var y1 = y * this._step.y;
      var y2 = y1 + this._step.y;
      var a = x * (this._gridSize.height + 1) + y;
      var b = (x + 1) * (this._gridSize.height + 1) + y;
      var c = (x + 1) * (this._gridSize.height + 1) + (y + 1);
      var d = x * (this._gridSize.height + 1) + (y + 1);
      this._indices[idx * 6] = a;
      this._indices[idx * 6 + 1] = b;
      this._indices[idx * 6 + 2] = d;
      this._indices[idx * 6 + 3] = b;
      this._indices[idx * 6 + 4] = c;
      this._indices[idx * 6 + 5] = d;
      var l1 = [a * 3, b * 3, c * 3, d * 3];
      var e = new cc.Vertex3F(x1, y1, 0);
      var f = new cc.Vertex3F(x2, y1, 0);
      var g = new cc.Vertex3F(x2, y2, 0);
      var h = new cc.Vertex3F(x1, y2, 0);
      var l2 = [e, f, g, h];
      var tex1 = [a * 2, b * 2, c * 2, d * 2];
      var tex2 = [cc.p(x1, y1), cc.p(x2, y1), cc.p(x2, y2), cc.p(x1, y2)];
      for(i = 0;i < 4;++i) {
        this._vertices[l1[i]] = l2[i].x;
        this._vertices[l1[i] + 1] = l2[i].y;
        this._vertices[l1[i] + 2] = l2[i].z;
        this._texCoordinates[tex1[i]] = tex2[i].x / width;
        if(this._isTextureFlipped) {
          this._texCoordinates[tex1[i] + 1] = (imageH - tex2[i].y) / height
        }else {
          this._texCoordinates[tex1[i] + 1] = tex2[i].y / height
        }
      }
    }
  }
  this._originalVertices = new Float32Array(this._vertices);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordinateBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, this._texCoordinates, gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW);
  this._dirty = true
}});
cc.Grid3D.create = function(gridSize, texture, flipped) {
  var grid3D = new cc.Grid3D;
  if(grid3D && grid3D.initWithSize(gridSize, texture, flipped)) {
    return grid3D
  }
  return null
};
cc.TiledGrid3D = cc.GridBase.extend({_texCoordinates:null, _vertices:null, _originalVertices:null, _indices:null, _texCoordinateBuffer:null, _verticesBuffer:null, _indicesBuffer:null, ctor:function() {
  this._super()
}, tile:function(pos) {
  var idx = (this._gridSize.height * pos.x + pos.y) * 4 * 3;
  return new cc.Quad3(new cc.Vertex3F(this._vertices[idx], this._vertices[idx + 1], this._vertices[idx + 2]), new cc.Vertex3F(this._vertices[idx + 3], this._vertices[idx + 4], this._vertices[idx + 5]), new cc.Vertex3F(this._vertices[idx + 6], this._vertices[idx + 7], this._vertices[idx + 8]), new cc.Vertex3F(this._vertices[idx + 9], this._vertices[idx + 10], this._vertices[idx + 11]))
}, originalTile:function(pos) {
  var idx = (this._gridSize.height * pos.x + pos.y) * 4 * 3;
  return new cc.Quad3(new cc.Vertex3F(this._originalVertices[idx], this._originalVertices[idx + 1], this._originalVertices[idx + 2]), new cc.Vertex3F(this._originalVertices[idx + 3], this._originalVertices[idx + 4], this._originalVertices[idx + 5]), new cc.Vertex3F(this._originalVertices[idx + 6], this._originalVertices[idx + 7], this._originalVertices[idx + 8]), new cc.Vertex3F(this._originalVertices[idx + 9], this._originalVertices[idx + 10], this._originalVertices[idx + 11]))
}, setTile:function(pos, coords) {
  var idx = (this._gridSize.height * pos.x + pos.y) * 12;
  this._vertices[idx] = coords.bl.x;
  this._vertices[idx + 1] = coords.bl.y;
  this._vertices[idx + 2] = coords.bl.z;
  this._vertices[idx + 3] = coords.br.x;
  this._vertices[idx + 4] = coords.br.y;
  this._vertices[idx + 5] = coords.br.z;
  this._vertices[idx + 6] = coords.tl.x;
  this._vertices[idx + 7] = coords.tl.y;
  this._vertices[idx + 8] = coords.tl.z;
  this._vertices[idx + 9] = coords.tr.x;
  this._vertices[idx + 10] = coords.tr.y;
  this._vertices[idx + 11] = coords.tr.z;
  this._dirty = true
}, blit:function() {
  var n = this._gridSize.width * this._gridSize.height;
  this._shaderProgram.use();
  this._shaderProgram.setUniformsForBuiltins();
  var gl = cc.renderContext;
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEXCOORDS);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
  if(this._dirty) {
    gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW)
  }
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 0, this._vertices);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordinateBuffer);
  if(this._dirty) {
    gl.bufferData(gl.ARRAY_BUFFER, this._texCoordinates, gl.DYNAMIC_DRAW)
  }
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 0, this._texCoordinates);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
  if(this._dirty) {
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW)
  }
  gl.drawElements(gl.TRIANGLES, n * 6, gl.UNSIGNED_SHORT, 0);
  if(this._dirty) {
    this._dirty = false
  }
  cc.INCREMENT_GL_DRAWS(1)
}, reuse:function() {
  if(this._reuseGrid > 0) {
    for(var i = 0;i < this._vertices.length;i++) {
      this._originalVertices[i] = this._vertices[i]
    }
    --this._reuseGrid
  }
}, calculateVertexPoints:function() {
  var width = this._texture.getPixelsWide();
  var height = this._texture.getPixelsHigh();
  var imageH = this._texture.getContentSizeInPixels().height;
  var numQuads = this._gridSize.width * this._gridSize.height;
  this._vertices = new Float32Array(numQuads * 12);
  this._texCoordinates = new Float32Array(numQuads * 8);
  this._indices = new Uint16Array(numQuads * 6);
  var gl = cc.renderContext;
  this._verticesBuffer = gl.createBuffer();
  this._texCoordinateBuffer = gl.createBuffer();
  this._indicesBuffer = gl.createBuffer();
  var x, y, i = 0;
  for(x = 0;x < this._gridSize.width;x++) {
    for(y = 0;y < this._gridSize.height;y++) {
      var x1 = x * this._step.x;
      var x2 = x1 + this._step.x;
      var y1 = y * this._step.y;
      var y2 = y1 + this._step.y;
      this._vertices[i * 12] = x1;
      this._vertices[i * 12 + 1] = y1;
      this._vertices[i * 12 + 2] = 0;
      this._vertices[i * 12 + 3] = x2;
      this._vertices[i * 12 + 4] = y1;
      this._vertices[i * 12 + 5] = 0;
      this._vertices[i * 12 + 6] = x1;
      this._vertices[i * 12 + 7] = y2;
      this._vertices[i * 12 + 8] = 0;
      this._vertices[i * 12 + 9] = x2;
      this._vertices[i * 12 + 10] = y2;
      this._vertices[i * 12 + 11] = 0;
      var newY1 = y1;
      var newY2 = y2;
      if(this._isTextureFlipped) {
        newY1 = imageH - y1;
        newY2 = imageH - y2
      }
      this._texCoordinates[i * 8] = x1 / width;
      this._texCoordinates[i * 8 + 1] = newY1 / height;
      this._texCoordinates[i * 8 + 2] = x2 / width;
      this._texCoordinates[i * 8 + 3] = newY1 / height;
      this._texCoordinates[i * 8 + 4] = x1 / width;
      this._texCoordinates[i * 8 + 5] = newY2 / height;
      this._texCoordinates[i * 8 + 6] = x2 / width;
      this._texCoordinates[i * 8 + 7] = newY2 / height;
      i++
    }
  }
  for(x = 0;x < numQuads;x++) {
    this._indices[x * 6 + 0] = x * 4 + 0;
    this._indices[x * 6 + 1] = x * 4 + 1;
    this._indices[x * 6 + 2] = x * 4 + 2;
    this._indices[x * 6 + 3] = x * 4 + 1;
    this._indices[x * 6 + 4] = x * 4 + 2;
    this._indices[x * 6 + 5] = x * 4 + 3
  }
  this._originalVertices = new Float32Array(this._vertices);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordinateBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, this._texCoordinates, gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.DYNAMIC_DRAW);
  this._dirty = true
}});
cc.TiledGrid3D.create = function(gridSize, texture, flipped) {
  var ret = new cc.TiledGrid3D;
  ret.initWithSize(gridSize, texture, flipped);
  return ret
};
cc.Grabber = cc.Class.extend({_fbo:null, _oldFBO:null, _oldClearColor:null, _gl:null, ctor:function() {
  this._gl = cc.renderContext;
  this._oldClearColor = [0, 0, 0, 0];
  this._fbo = this._gl.createFramebuffer()
}, grab:function(texture) {
  this._oldFBO = this._gl.getParameter(this._gl.FRAMEBUFFER_BINDING);
  this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._fbo);
  this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, texture._webTextureObj, 0);
  var status = this._gl.checkFramebufferStatus(this._gl.FRAMEBUFFER);
  if(status != this._gl.FRAMEBUFFER_COMPLETE) {
    cc.log("Frame Grabber: could not attach texture to frmaebuffer")
  }
  this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._oldFBO)
}, beforeRender:function(texture) {
  this._oldFBO = this._gl.getParameter(this._gl.FRAMEBUFFER_BINDING);
  this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._fbo);
  this._oldClearColor = this._gl.getParameter(this._gl.COLOR_CLEAR_VALUE);
  this._gl.clearColor(0, 0, 0, 0);
  this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT)
}, afterRender:function(texture) {
  this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._oldFBO);
  this._gl.colorMask(true, true, true, true)
}, destroy:function() {
  this._gl.deleteFramebuffer(this._fbo)
}});
cc.v2fzero = function() {
  return{x:0, y:0}
};
cc.v2f = function(x, y) {
  return{x:x, y:y}
};
cc.v2fadd = function(v0, v1) {
  return cc.v2f(v0.x + v1.x, v0.y + v1.y)
};
cc.v2fsub = function(v0, v1) {
  return cc.v2f(v0.x - v1.x, v0.y - v1.y)
};
cc.v2fmult = function(v, s) {
  return cc.v2f(v.x * s, v.y * s)
};
cc.v2fperp = function(p0) {
  return cc.v2f(-p0.y, p0.x)
};
cc.v2fneg = function(p0) {
  return cc.v2f(-p0.x, -p0.y)
};
cc.v2fdot = function(p0, p1) {
  return p0.x * p1.x + p0.y * p1.y
};
cc.v2fforangle = function(_a_) {
  return cc.v2f(Math.cos(_a_), Math.sin(_a_))
};
cc.v2fnormalize = function(p) {
  var r = cc.pNormalize(cc.p(p.x, p.y));
  return cc.v2f(r.x, r.y)
};
cc.__v2f = function(v) {
  return cc.v2f(v.x, v.y)
};
cc.__t = function(v) {
  return{u:v.x, v:v.y}
};
cc.DrawNodeCanvas = cc.Node.extend({_buffer:null, _blendFunc:null, getBlendFunc:function() {
  return this._blendFunc
}, setBlendFunc:function(blendFunc) {
  this._blendFunc = blendFunc
}, ctor:function() {
  this._super();
  this._buffer = [];
  this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST)
}, draw:function(ctx) {
  var context = ctx || cc.renderContext;
  if(this._blendFunc && this._blendFunc.src == gl.SRC_ALPHA && this._blendFunc.dst == gl.ONE) {
    context.globalCompositeOperation = "lighter"
  }
  for(var i = 0;i < this._buffer.length;i++) {
    var element = this._buffer[i];
    if(element.type === cc.DRAWNODE_TYPE_DOT) {
      context.fillStyle = "rgba(" + (0 | element.color.r * 255) + "," + (0 | element.color.g * 255) + "," + (0 | element.color.b * 255) + "," + element.color.a + ")";
      cc.drawingUtil.drawPoint(element.position, element.radius)
    }
    if(element.type === cc.DRAWNODE_TYPE_SEGMENT) {
      context.strokeStyle = "rgba(" + (0 | element.color.r * 255) + "," + (0 | element.color.g * 255) + "," + (0 | element.color.b * 255) + "," + element.color.a + ")";
      context.lineWidth = element.radius * 2;
      context.lineCap = "round";
      cc.drawingUtil.drawLine(element.from, element.to)
    }
    if(element.type === cc.DRAWNODE_TYPE_POLY) {
      context.fillStyle = "rgba(" + (0 | element.fillColor.r * 255) + "," + (0 | element.fillColor.g * 255) + "," + (0 | element.fillColor.b * 255) + "," + element.fillColor.a + ")";
      cc.drawingUtil.drawPoly(element.verts, element.count, false, true);
      context.lineWidth = element.borderWidth * 2;
      context.lineCap = "round";
      context.strokeStyle = "rgba(" + (0 | element.borderColor.r * 255) + "," + (0 | element.borderColor.g * 255) + "," + (0 | element.borderColor.b * 255) + "," + element.borderColor.a + ")";
      cc.drawingUtil.drawPoly(element.verts, element.count, true, false)
    }
  }
}, drawDot:function(pos, radius, color) {
  var element = new cc._DrawNodeElement(cc.DRAWNODE_TYPE_DOT);
  element.position = pos;
  element.radius = radius;
  element.color = color;
  this._buffer.push(element)
}, drawSegment:function(from, to, radius, color) {
  var element = new cc._DrawNodeElement(cc.DRAWNODE_TYPE_SEGMENT);
  element.from = from;
  element.to = to;
  element.radius = radius;
  element.color = color;
  this._buffer.push(element)
}, drawPoly:function(verts, fillColor, borderWidth, borderColor) {
  var element = new cc._DrawNodeElement(cc.DRAWNODE_TYPE_POLY);
  element.verts = verts;
  element.count = verts.length;
  element.fillColor = fillColor;
  element.borderWidth = borderWidth;
  element.borderColor = borderColor;
  this._buffer.push(element)
}, clear:function() {
  this._buffer.length = 0
}});
cc.DrawNodeCanvas.create = function() {
  var ret = new cc.DrawNodeCanvas;
  if(ret && ret.init()) {
    return ret
  }
  return null
};
cc.DrawNodeWebGL = cc.Node.extend({_bufferCapacity:0, _buffer:null, _trianglesArrayBuffer:null, _trianglesWebBuffer:null, _trianglesReader:null, _blendFunc:null, _dirty:false, getBlendFunc:function() {
  return this._blendFunc
}, setBlendFunc:function(blendFunc) {
  this._blendFunc = blendFunc
}, ctor:function() {
  this._super();
  this._buffer = [];
  this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST)
}, init:function() {
  if(this._super()) {
    this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR));
    this._ensureCapacity(512);
    this._trianglesWebBuffer = cc.renderContext.createBuffer();
    this._dirty = true;
    return true
  }
  return false
}, _render:function() {
  var gl = cc.renderContext;
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSCOLORTEX);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._trianglesWebBuffer);
  if(this._dirty) {
    gl.bufferData(gl.ARRAY_BUFFER, this._trianglesArrayBuffer, gl.STREAM_DRAW);
    this._dirty = false
  }
  var triangleSize = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, gl.FLOAT, false, triangleSize, 0);
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, triangleSize, 8);
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, triangleSize, 12);
  gl.drawArrays(gl.TRIANGLES, 0, this._buffer.length * 3);
  cc.INCREMENT_GL_DRAWS(1)
}, _ensureCapacity:function(count) {
  if(this._buffer.length + count > this._bufferCapacity) {
    this._bufferCapacity += Math.max(this._bufferCapacity, count);
    if(this._buffer == null || this._buffer.length === 0) {
      this._buffer = [];
      this._trianglesArrayBuffer = new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT * this._bufferCapacity);
      this._trianglesReader = new Uint8Array(this._trianglesArrayBuffer)
    }else {
      var newTriangles = [];
      var newArrayBuffer = new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT * this._bufferCapacity);
      for(var i = 0;i < this._buffer.length;i++) {
        newTriangles[i] = new cc.V2F_C4B_T2F_Triangle(this._buffer[i].a, this._buffer[i].b, this._buffer[i].c, newArrayBuffer, i * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT)
      }
      this._trianglesReader = new Uint8Array(newArrayBuffer);
      this._buffer = newTriangles;
      this._trianglesArrayBuffer = newArrayBuffer
    }
  }
}, draw:function() {
  cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
  this._shaderProgram.use();
  this._shaderProgram.setUniformsForBuiltins();
  this._render()
}, drawDot:function(pos, radius, color) {
  var c4bColor = {r:0 | color.r * 255, g:0 | color.g * 255, b:0 | color.b * 255, a:0 | color.a * 255};
  var a = {vertices:{x:pos.x - radius, y:pos.y - radius}, colors:c4bColor, texCoords:{u:-1, v:-1}};
  var b = {vertices:{x:pos.x - radius, y:pos.y + radius}, colors:c4bColor, texCoords:{u:-1, v:1}};
  var c = {vertices:{x:pos.x + radius, y:pos.y + radius}, colors:c4bColor, texCoords:{u:1, v:1}};
  var d = {vertices:{x:pos.x + radius, y:pos.y - radius}, colors:c4bColor, texCoords:{u:1, v:-1}};
  this._buffer.push(new cc.V2F_C4B_T2F_Triangle(a, b, c, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
  this._buffer.push(new cc.V2F_C4B_T2F_Triangle(a, c, d, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
  this._dirty = true
}, drawSegment:function(from, to, radius, color) {
  var vertexCount = 6 * 3;
  this._ensureCapacity(vertexCount);
  var c4bColor = {r:0 | color.r * 255, g:0 | color.g * 255, b:0 | color.b * 255, a:0 | color.a * 255};
  var a = cc.__v2f(from);
  var b = cc.__v2f(to);
  var n = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(b, a)));
  var t = cc.v2fperp(n);
  var nw = cc.v2fmult(n, radius);
  var tw = cc.v2fmult(t, radius);
  var v0 = cc.v2fsub(b, cc.v2fadd(nw, tw));
  var v1 = cc.v2fadd(b, cc.v2fsub(nw, tw));
  var v2 = cc.v2fsub(b, nw);
  var v3 = cc.v2fadd(b, nw);
  var v4 = cc.v2fsub(a, nw);
  var v5 = cc.v2fadd(a, nw);
  var v6 = cc.v2fsub(a, cc.v2fsub(nw, tw));
  var v7 = cc.v2fadd(a, cc.v2fadd(nw, tw));
  this._buffer.push(new cc.V2F_C4B_T2F_Triangle({vertices:v0, colors:c4bColor, texCoords:cc.__t(cc.v2fneg(cc.v2fadd(n, t)))}, {vertices:v1, colors:c4bColor, texCoords:cc.__t(cc.v2fsub(n, t))}, {vertices:v2, colors:c4bColor, texCoords:cc.__t(cc.v2fneg(n))}, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
  this._buffer.push(new cc.V2F_C4B_T2F_Triangle({vertices:v3, colors:c4bColor, texCoords:cc.__t(n)}, {vertices:v1, colors:c4bColor, texCoords:cc.__t(cc.v2fsub(n, t))}, {vertices:v2, colors:c4bColor, texCoords:cc.__t(cc.v2fneg(n))}, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
  this._buffer.push(new cc.V2F_C4B_T2F_Triangle({vertices:v3, colors:c4bColor, texCoords:cc.__t(n)}, {vertices:v4, colors:c4bColor, texCoords:cc.__t(cc.v2fneg(n))}, {vertices:v2, colors:c4bColor, texCoords:cc.__t(cc.v2fneg(n))}, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
  this._buffer.push(new cc.V2F_C4B_T2F_Triangle({vertices:v3, colors:c4bColor, texCoords:cc.__t(n)}, {vertices:v4, colors:c4bColor, texCoords:cc.__t(cc.v2fneg(n))}, {vertices:v5, colors:c4bColor, texCoords:cc.__t(n)}, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
  this._buffer.push(new cc.V2F_C4B_T2F_Triangle({vertices:v6, colors:c4bColor, texCoords:cc.__t(cc.v2fsub(t, n))}, {vertices:v4, colors:c4bColor, texCoords:cc.__t(cc.v2fneg(n))}, {vertices:v5, colors:c4bColor, texCoords:cc.__t(n)}, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
  this._buffer.push(new cc.V2F_C4B_T2F_Triangle({vertices:v6, colors:c4bColor, texCoords:cc.__t(cc.v2fsub(t, n))}, {vertices:v7, colors:c4bColor, texCoords:cc.__t(cc.v2fadd(n, t))}, {vertices:v5, colors:c4bColor, texCoords:cc.__t(n)}, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
  this._dirty = true
}, drawPoly:function(verts, fillColor, borderWidth, borderColor) {
  var c4bFillColor = {r:0 | fillColor.r * 255, g:0 | fillColor.g * 255, b:0 | fillColor.b * 255, a:0 | fillColor.a * 255};
  var c4bBorderColor = {r:0 | borderColor.r * 255, g:0 | borderColor.g * 255, b:0 | borderColor.b * 255, a:0 | borderColor.a * 255};
  var extrude = [], i;
  var v0, v1, v2;
  var count = verts.length;
  for(i = 0;i < count;i++) {
    v0 = cc.__v2f(verts[(i - 1 + count) % count]);
    v1 = cc.__v2f(verts[i]);
    v2 = cc.__v2f(verts[(i + 1) % count]);
    var n1 = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(v1, v0)));
    var n2 = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(v2, v1)));
    var offset = cc.v2fmult(cc.v2fadd(n1, n2), 1 / (cc.v2fdot(n1, n2) + 1));
    extrude[i] = {offset:offset, n:n2}
  }
  var outline = fillColor.a > 0 && borderWidth > 0;
  var triangleCount = 3 * count - 2;
  var vertexCount = 3 * triangleCount;
  this._ensureCapacity(vertexCount);
  var inset = outline == false ? 0.5 : 0;
  for(i = 0;i < count - 2;i++) {
    v0 = cc.v2fsub(cc.__v2f(verts[0]), cc.v2fmult(extrude[0].offset, inset));
    v1 = cc.v2fsub(cc.__v2f(verts[i + 1]), cc.v2fmult(extrude[i + 1].offset, inset));
    v2 = cc.v2fsub(cc.__v2f(verts[i + 2]), cc.v2fmult(extrude[i + 2].offset, inset));
    this._buffer.push(new cc.V2F_C4B_T2F_Triangle({vertices:v0, colors:c4bFillColor, texCoords:cc.__t(cc.v2fzero())}, {vertices:v1, colors:c4bFillColor, texCoords:cc.__t(cc.v2fzero())}, {vertices:v2, colors:c4bFillColor, texCoords:cc.__t(cc.v2fzero())}, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT))
  }
  for(i = 0;i < count;i++) {
    var j = (i + 1) % count;
    v0 = cc.__v2f(verts[i]);
    v1 = cc.__v2f(verts[j]);
    var n0 = extrude[i].n;
    var offset0 = extrude[i].offset;
    var offset1 = extrude[j].offset;
    var inner0 = outline ? cc.v2fsub(v0, cc.v2fmult(offset0, borderWidth)) : cc.v2fsub(v0, cc.v2fmult(offset0, 0.5));
    var inner1 = outline ? cc.v2fsub(v1, cc.v2fmult(offset1, borderWidth)) : cc.v2fsub(v1, cc.v2fmult(offset1, 0.5));
    var outer0 = outline ? cc.v2fadd(v0, cc.v2fmult(offset0, borderWidth)) : cc.v2fadd(v0, cc.v2fmult(offset0, 0.5));
    var outer1 = outline ? cc.v2fadd(v1, cc.v2fmult(offset1, borderWidth)) : cc.v2fadd(v1, cc.v2fmult(offset1, 0.5));
    if(outline) {
      this._buffer.push(new cc.V2F_C4B_T2F_Triangle({vertices:inner0, colors:c4bBorderColor, texCoords:cc.__t(cc.v2fneg(n0))}, {vertices:inner1, colors:c4bBorderColor, texCoords:cc.__t(cc.v2fneg(n0))}, {vertices:outer1, colors:c4bBorderColor, texCoords:cc.__t(n0)}, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
      this._buffer.push(new cc.V2F_C4B_T2F_Triangle({vertices:inner0, colors:c4bBorderColor, texCoords:cc.__t(cc.v2fneg(n0))}, {vertices:outer0, colors:c4bBorderColor, texCoords:cc.__t(n0)}, {vertices:outer1, colors:c4bBorderColor, texCoords:cc.__t(n0)}, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT))
    }else {
      this._buffer.push(new cc.V2F_C4B_T2F_Triangle({vertices:inner0, colors:c4bFillColor, texCoords:cc.__t(cc.v2fzero())}, {vertices:inner1, colors:c4bFillColor, texCoords:cc.__t(cc.v2fzero())}, {vertices:outer1, colors:c4bFillColor, texCoords:cc.__t(n0)}, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
      this._buffer.push(new cc.V2F_C4B_T2F_Triangle({vertices:inner0, colors:c4bFillColor, texCoords:cc.__t(cc.v2fzero())}, {vertices:outer0, colors:c4bFillColor, texCoords:cc.__t(n0)}, {vertices:outer1, colors:c4bFillColor, texCoords:cc.__t(n0)}, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT))
    }
  }
  extrude = null;
  this._dirty = true
}, clear:function() {
  this._buffer.length = 0;
  this._dirty = true
}});
cc.DrawNodeWebGL.create = function() {
  var ret = new cc.DrawNodeWebGL;
  if(ret && ret.init()) {
    return ret
  }
  return null
};
cc.DrawNode = cc.Browser.supportWebGL ? cc.DrawNodeWebGL : cc.DrawNodeCanvas;
cc._DrawNodeElement = function(type) {
  this.type = type
};
cc.DRAWNODE_TYPE_DOT = 0;
cc.DRAWNODE_TYPE_SEGMENT = 1;
cc.DRAWNODE_TYPE_POLY = 2;
cc.ACTION_TAG_INVALID = -1;
cc.Action = cc.Class.extend({_originalTarget:null, _target:null, _tag:cc.ACTION_TAG_INVALID, description:function() {
  return"<cc.Action | Tag = " + this._tag + ">"
}, copyWithZone:function(zone) {
  return this.copy()
}, copy:function() {
  return cc.clone(this)
}, isDone:function() {
  return true
}, startWithTarget:function(target) {
  this._originalTarget = target;
  this._target = target
}, stop:function() {
  this._target = null
}, step:function(dt) {
  cc.log("[Action step]. override me")
}, update:function(time) {
  cc.log("[Action update]. override me")
}, getTarget:function() {
  return this._target
}, setTarget:function(target) {
  this._target = target
}, getOriginalTarget:function() {
  return this._originalTarget
}, setOriginalTarget:function(originalTarget) {
  this._originalTarget = originalTarget
}, getTag:function() {
  return this._tag
}, setTag:function(tag) {
  this._tag = tag
}, retain:function() {
}, release:function() {
}});
cc.Action.create = function() {
  return new cc.Action
};
cc.FiniteTimeAction = cc.Action.extend({_duration:0, getDuration:function() {
  return this._duration
}, setDuration:function(duration) {
  this._duration = duration
}, reverse:function() {
  cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
  return null
}});
cc.Speed = cc.Action.extend({_speed:0, _innerAction:null, getSpeed:function() {
  return this._speed
}, setSpeed:function(speed) {
  this._speed = speed
}, initWithAction:function(action, speed) {
  cc.Assert(action != null, "");
  this._innerAction = action;
  this._speed = speed;
  return true
}, startWithTarget:function(target) {
  cc.Action.prototype.startWithTarget.call(this, target);
  this._innerAction.startWithTarget(target)
}, stop:function() {
  this._innerAction.stop();
  cc.Action.prototype.stop.call(this)
}, step:function(dt) {
  this._innerAction.step(dt * this._speed)
}, isDone:function() {
  return this._innerAction.isDone()
}, reverse:function() {
  return cc.Speed.create(this._innerAction.reverse(), this._speed)
}, setInnerAction:function(action) {
  if(this._innerAction != action) {
    this._innerAction = action
  }
}, getInnerAction:function() {
  return this._innerAction
}});
cc.Speed.create = function(action, speed) {
  var ret = new cc.Speed;
  if(ret && ret.initWithAction(action, speed)) {
    return ret
  }
  return null
};
cc.Follow = cc.Action.extend({isBoundarySet:function() {
  return this._boundarySet
}, setBoudarySet:function(value) {
  this._boundarySet = value
}, initWithTarget:function(followedNode, rect) {
  cc.Assert(followedNode != null, "");
  rect = rect || cc.RectZero();
  this._followedNode = followedNode;
  this._boundarySet = !cc.Rect.CCRectEqualToRect(rect, cc.RectZero());
  this._boundaryFullyCovered = false;
  var winSize = cc.Director.getInstance().getWinSize();
  this._fullScreenSize = cc.p(winSize.width, winSize.height);
  this._halfScreenSize = cc.pMult(this._fullScreenSize, 0.5);
  if(this._boundarySet) {
    this.leftBoundary = -(rect.origin.x + rect.size.width - this._fullScreenSize.x);
    this.rightBoundary = -rect.origin.x;
    this.topBoundary = -rect.origin.y;
    this.bottomBoundary = -(rect.origin.y + rect.size.height - this._fullScreenSize.y);
    if(this.rightBoundary < this.leftBoundary) {
      this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2
    }
    if(this.topBoundary < this.bottomBoundary) {
      this.topBoundary = this.bottomBoundary = (this.topBoundary + this.bottomBoundary) / 2
    }
    if(this.topBoundary == this.bottomBoundary && this.leftBoundary == this.rightBoundary) {
      this._boundaryFullyCovered = true
    }
  }
  return true
}, step:function(dt) {
  if(this._boundarySet) {
    if(this._boundaryFullyCovered) {
      return
    }
    var tempPos = cc.pSub(this._halfScreenSize, this._followedNode.getPosition());
    this._target.setPosition(cc.p(cc.clampf(tempPos.x, this.leftBoundary, this.rightBoundary), cc.clampf(tempPos.y, this.bottomBoundary, this.topBoundary)))
  }else {
    this._target.setPosition(cc.pSub(this._halfScreenSize, this._followedNode.getPosition()))
  }
}, isDone:function() {
  return!this._followedNode.isRunning()
}, stop:function() {
  this._target = null;
  cc.Action.prototype.stop.call(this)
}, _followedNode:null, _boundarySet:false, _boundaryFullyCovered:false, _halfScreenSize:null, _fullScreenSize:null, leftBoundary:0, rightBoundary:0, topBoundary:0, bottomBoundary:0});
cc.Follow.create = function(followedNode, rect) {
  rect = rect || new cc.RectZero;
  var ret = new cc.Follow;
  if(rect != null && ret && ret.initWithTarget(followedNode, rect)) {
    return ret
  }else {
    if(ret && ret.initWithTarget(followedNode)) {
      return ret
    }
  }
  return null
};
cc.ActionInterval = cc.FiniteTimeAction.extend({_elapsed:0, _firstTick:false, getElapsed:function() {
  return this._elapsed
}, initWithDuration:function(d) {
  this._duration = d === 0 ? cc.FLT_EPSILON : d;
  this._elapsed = 0;
  this._firstTick = true;
  return true
}, isDone:function() {
  return this._elapsed >= this._duration
}, step:function(dt) {
  if(this._firstTick) {
    this._firstTick = false;
    this._elapsed = 0
  }else {
    this._elapsed += dt
  }
  var t = this._elapsed / (this._duration > 1.192092896E-7 ? this._duration : 1.192092896E-7);
  t = 1 > t ? t : 1;
  this.update(t > 0 ? t : 0)
}, startWithTarget:function(target) {
  cc.Action.prototype.startWithTarget.call(this, target);
  this._elapsed = 0;
  this._firstTick = true
}, reverse:function() {
  cc.Assert(false, "cc.IntervalAction: reverse not implemented.");
  return null
}, setAmplitudeRate:function(amp) {
  cc.Assert(0, "Actioninterval setAmplitudeRate")
}, getAmplitudeRate:function() {
  cc.Assert(0, "Actioninterval getAmplitudeRate");
  return 0
}});
cc.ActionInterval.create = function(d) {
  var action = new cc.ActionInterval;
  action.initWithDuration(d);
  return action
};
cc.Sequence = cc.ActionInterval.extend({_actions:null, _split:null, _last:0, ctor:function() {
  this._actions = []
}, initOneTwo:function(actionOne, actionTwo) {
  cc.Assert(actionOne != null, "Sequence.initOneTwo");
  cc.Assert(actionTwo != null, "Sequence.initOneTwo");
  var one = actionOne.getDuration();
  var two = actionTwo.getDuration();
  var d = actionOne.getDuration() + actionTwo.getDuration();
  this.initWithDuration(d);
  this._actions[0] = actionOne;
  this._actions[1] = actionTwo;
  return true
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._split = this._actions[0].getDuration() / this._duration;
  this._last = -1
}, stop:function() {
  if(this._last != -1) {
    this._actions[this._last].stop()
  }
  cc.Action.prototype.stop.call(this)
}, update:function(time) {
  var new_t, found = 0;
  if(time < this._split) {
    new_t = this._split ? time / this._split : 1
  }else {
    found = 1;
    new_t = this._split === 1 ? 1 : (time - this._split) / (1 - this._split);
    if(this._last === -1) {
      this._actions[0].startWithTarget(this._target);
      this._actions[0].update(1);
      this._actions[0].stop()
    }
    if(!this._last) {
      this._actions[0].update(1);
      this._actions[0].stop()
    }
  }
  if(this._last === found && this._actions[found].isDone()) {
    return
  }
  if(this._last != found) {
    this._actions[found].startWithTarget(this._target)
  }
  this._actions[found].update(new_t);
  this._last = found
}, reverse:function() {
  return cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse())
}, copy:function() {
  return cc.Sequence._actionOneTwo(this._actions[0].copy(), this._actions[1].copy())
}});
cc.Sequence.create = function(tempArray) {
  var paraArray = tempArray instanceof Array ? tempArray : arguments;
  var prev = paraArray[0];
  for(var i = 1;i < paraArray.length;i++) {
    if(paraArray[i]) {
      prev = cc.Sequence._actionOneTwo(prev, paraArray[i])
    }
  }
  return prev
};
cc.Sequence._actionOneTwo = function(actionOne, actionTwo) {
  var sequence = new cc.Sequence;
  sequence.initOneTwo(actionOne, actionTwo);
  return sequence
};
cc.Repeat = cc.ActionInterval.extend({_times:0, _total:0, _nextDt:0, _actionInstant:false, _innerAction:null, initWithAction:function(action, times) {
  var duration = action.getDuration() * times;
  if(this.initWithDuration(duration)) {
    this._times = times;
    this._innerAction = action;
    if(action instanceof cc.ActionInstant) {
      this._times -= 1
    }
    this._total = 0;
    return true
  }
  return false
}, startWithTarget:function(target) {
  this._total = 0;
  this._nextDt = this._innerAction.getDuration() / this._duration;
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._innerAction.startWithTarget(target)
}, stop:function() {
  this._innerAction.stop();
  cc.Action.prototype.stop.call(this)
}, update:function(time) {
  if(time >= this._nextDt) {
    while(time > this._nextDt && this._total < this._times) {
      this._innerAction.update(1);
      this._total++;
      this._innerAction.stop();
      this._innerAction.startWithTarget(this._target);
      this._nextDt += this._innerAction.getDuration() / this._duration
    }
    if(time >= 1 && this._total < this._times) {
      this._total++
    }
    if(this._actionInstant) {
      if(this._total == this._times) {
        this._innerAction.update(1);
        this._innerAction.stop()
      }else {
        this._innerAction.update(time - (this._nextDt - this._innerAction.getDuration() / this._duration))
      }
    }
  }else {
    this._innerAction.update(time * this._times % 1)
  }
}, isDone:function() {
  return this._total == this._times
}, reverse:function() {
  return cc.Repeat.create(this._innerAction.reverse(), this._times)
}, setInnerAction:function(action) {
  if(this._innerAction != action) {
    this._innerAction = action
  }
}, getInnerAction:function() {
  return this._innerAction
}});
cc.Repeat.create = function(action, times) {
  var repeat = new cc.Repeat;
  repeat.initWithAction(action, times);
  return repeat
};
cc.RepeatForever = cc.ActionInterval.extend({_innerAction:null, initWithAction:function(action) {
  cc.Assert(action != null, "");
  this._innerAction = action;
  return true
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._innerAction.startWithTarget(target)
}, step:function(dt) {
  this._innerAction.step(dt);
  if(this._innerAction.isDone()) {
    this._innerAction.startWithTarget(this._target);
    this._innerAction.step(this._innerAction.getElapsed() - this._innerAction.getDuration())
  }
}, isDone:function() {
  return false
}, reverse:function() {
  return cc.RepeatForever.create(this._innerAction.reverse())
}, setInnerAction:function(action) {
  if(this._innerAction != action) {
    this._innerAction = action
  }
}, getInnerAction:function() {
  return this._innerAction
}});
cc.RepeatForever.create = function(action) {
  var ret = new cc.RepeatForever;
  if(ret && ret.initWithAction(action)) {
    return ret
  }
  return null
};
cc.Spawn = cc.ActionInterval.extend({initOneTwo:function(action1, action2) {
  cc.Assert(action1 != null, "no action1");
  cc.Assert(action2 != null, "no action2");
  var ret = false;
  var d1 = action1.getDuration();
  var d2 = action2.getDuration();
  if(this.initWithDuration(Math.max(d1, d2))) {
    this._one = action1;
    this._two = action2;
    if(d1 > d2) {
      this._two = cc.Sequence._actionOneTwo(action2, cc.DelayTime.create(d1 - d2))
    }else {
      if(d1 < d2) {
        this._one = cc.Sequence._actionOneTwo(action1, cc.DelayTime.create(d2 - d1))
      }
    }
    ret = true
  }
  return ret
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._one.startWithTarget(target);
  this._two.startWithTarget(target)
}, stop:function() {
  this._one.stop();
  this._two.stop();
  cc.Action.prototype.stop.call(this)
}, update:function(time) {
  if(this._one) {
    this._one.update(time)
  }
  if(this._two) {
    this._two.update(time)
  }
}, reverse:function() {
  return cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse())
}, _one:null, _two:null});
cc.Spawn.create = function(tempArray) {
  var paramArray = tempArray instanceof Array ? tempArray : arguments;
  var prev = paramArray[0];
  for(var i = 1;i < paramArray.length;i++) {
    if(paramArray[i] != null) {
      prev = this._actionOneTwo(prev, paramArray[i])
    }
  }
  return prev
};
cc.Spawn._actionOneTwo = function(action1, action2) {
  var pSpawn = new cc.Spawn;
  pSpawn.initOneTwo(action1, action2);
  return pSpawn
};
cc.RotateTo = cc.ActionInterval.extend({_dstAngleX:0, _startAngleX:0, _diffAngleX:0, _dstAngleY:0, _startAngleY:0, _diffAngleY:0, initWithDuration:function(duration, deltaAngleX, deltaAngleY) {
  if(cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
    this._dstAngleX = deltaAngleX || 0;
    this._dstAngleY = deltaAngleY || this._dstAngleX;
    return true
  }
  return false
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._startAngleX = target.getRotationX();
  this._startAngleX = this._startAngleX % 360;
  this._diffAngleX = this._dstAngleX - this._startAngleX;
  if(this._diffAngleX > 180) {
    this._diffAngleX -= 360
  }
  if(this._diffAngleX < -180) {
    this._diffAngleX += 360
  }
  this._startAngleY = target.getRotationY();
  this._startAngleY = this._startAngleY % 360;
  this._diffAngleY = this._dstAngleY - this._startAngleY;
  if(this._diffAngleY > 180) {
    this._diffAngleY -= 360
  }
  if(this._diffAngleY < -180) {
    this._diffAngleY += 360
  }
}, reverse:function() {
  cc.Assert(0, "RotateTo reverse not implemented")
}, update:function(time) {
  if(this._target) {
    this._target.setRotationX(this._startAngleX + this._diffAngleX * time);
    this._target.setRotationY(this._startAngleY + this._diffAngleY * time)
  }
}});
cc.RotateTo.create = function(duration, deltaAngleX, deltaAngleY) {
  var rotateTo = new cc.RotateTo;
  rotateTo.initWithDuration(duration, deltaAngleX, deltaAngleY);
  return rotateTo
};
cc.RotateBy = cc.ActionInterval.extend({_angleX:0, _startAngleX:0, _angleY:0, _startAngleY:0, initWithDuration:function(duration, deltaAngleX, deltaAngleY) {
  if(cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
    this._angleX = deltaAngleX || 0;
    this._angleY = deltaAngleY || this._angleX;
    return true
  }
  return false
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._startAngleX = target.getRotationX();
  this._startAngleY = target.getRotationY()
}, update:function(time) {
  if(this._target) {
    this._target.setRotationX(this._startAngleX + this._angleX * time);
    this._target.setRotationY(this._startAngleY + this._angleY * time)
  }
}, reverse:function() {
  return cc.RotateBy.create(this._duration, -this._angleX, -this._angleY)
}});
cc.RotateBy.create = function(duration, deltaAngleX, deltaAngleY) {
  var rotateBy = new cc.RotateBy;
  rotateBy.initWithDuration(duration, deltaAngleX, deltaAngleY);
  return rotateBy
};
cc.MoveTo = cc.ActionInterval.extend({initWithDuration:function(duration, position) {
  if(cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
    this._endPosition = position;
    return true
  }
  return false
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._previousPosition = this._startPosition = target.getPosition();
  this._delta = cc.pSub(this._endPosition, this._startPosition)
}, update:function(time) {
  if(this._target) {
    var currentPos = this._target.getPosition();
    var diff = cc.pSub(currentPos, this._previousPosition);
    this._startPosition = cc.pAdd(this._startPosition, diff);
    var newPos = cc.p(this._startPosition.x + this._delta.x * time, this._startPosition.y + this._delta.y * time);
    this._target.setPosition(newPos);
    this._previousPosition = newPos
  }
}, reverse:function() {
  cc.Assert(0, "moveto reverse is not implemented")
}, _endPosition:cc.p(0, 0), _startPosition:cc.p(0, 0), _delta:cc.p(0, 0)});
cc.MoveTo.create = function(duration, position) {
  var moveTo = new cc.MoveTo;
  moveTo.initWithDuration(duration, position);
  return moveTo
};
cc.MoveBy = cc.MoveTo.extend({initWithDuration:function(duration, position) {
  if(cc.MoveTo.prototype.initWithDuration.call(this, duration, position)) {
    this._delta = position;
    return true
  }
  return false
}, startWithTarget:function(target) {
  var temp = this._delta;
  cc.MoveTo.prototype.startWithTarget.call(this, target);
  this._delta = temp
}, reverse:function() {
  return cc.MoveBy.create(this._duration, cc.p(-this._delta.x, -this._delta.y))
}});
cc.MoveBy.create = function(duration, position) {
  var moveBy = new cc.MoveBy;
  moveBy.initWithDuration(duration, position);
  return moveBy
};
cc.SkewTo = cc.ActionInterval.extend({initWithDuration:function(t, sx, sy) {
  var ret = false;
  if(cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
    this._endSkewX = sx;
    this._endSkewY = sy;
    ret = true
  }
  return ret
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._startSkewX = target.getSkewX();
  if(this._startSkewX > 0) {
    this._startSkewX = this._startSkewX % 180
  }else {
    this._startSkewX = this._startSkewX % -180
  }
  this._deltaX = this._endSkewX - this._startSkewX;
  if(this._deltaX > 180) {
    this._deltaX -= 360
  }
  if(this._deltaX < -180) {
    this._deltaX += 360
  }
  this._startSkewY = target.getSkewY();
  if(this._startSkewY > 0) {
    this._startSkewY = this._startSkewY % 360
  }else {
    this._startSkewY = this._startSkewY % -360
  }
  this._deltaY = this._endSkewY - this._startSkewY;
  if(this._deltaY > 180) {
    this._deltaY -= 360
  }
  if(this._deltaY < -180) {
    this._deltaY += 360
  }
}, update:function(t) {
  this._target.setSkewX(this._startSkewX + this._deltaX * t);
  this._target.setSkewY(this._startSkewY + this._deltaY * t)
}, _skewX:0, _skewY:0, _startSkewX:0, _startSkewY:0, _endSkewX:0, _endSkewY:0, _deltaX:0, _deltaY:0});
cc.SkewTo.create = function(t, sx, sy) {
  var skewTo = new cc.SkewTo;
  if(skewTo) {
    skewTo.initWithDuration(t, sx, sy)
  }
  return skewTo
};
cc.SkewBy = cc.SkewTo.extend({initWithDuration:function(t, deltaSkewX, deltaSkewY) {
  var ret = false;
  if(cc.SkewTo.prototype.initWithDuration.call(this, t, deltaSkewX, deltaSkewY)) {
    this._skewX = deltaSkewX;
    this._skewY = deltaSkewY;
    ret = true
  }
  return ret
}, startWithTarget:function(target) {
  cc.SkewTo.prototype.startWithTarget.call(this, target);
  this._deltaX = this._skewX;
  this._deltaY = this._skewY;
  this._endSkewX = this._startSkewX + this._deltaX;
  this._endSkewY = this._startSkewY + this._deltaY
}, reverse:function() {
  return cc.SkewBy.create(this._duration, -this._skewX, -this._skewY)
}});
cc.SkewBy.create = function(t, sx, sy) {
  var skewBy = new cc.SkewBy;
  if(skewBy) {
    skewBy.initWithDuration(t, sx, sy)
  }
  return skewBy
};
cc.JumpBy = cc.ActionInterval.extend({initWithDuration:function(duration, position, height, jumps) {
  if(cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
    this._delta = position;
    this._height = height;
    this._jumps = jumps;
    return true
  }
  return false
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._previousPosition = this._startPosition = target.getPosition()
}, update:function(time) {
  if(this._target) {
    var frac = time * this._jumps % 1;
    var y = this._height * 4 * frac * (1 - frac);
    y += this._delta.y * time;
    var x = this._delta.x * time;
    var currentPos = this._target.getPosition();
    var diff = cc.pSub(currentPos, this._previousPosition);
    this._startPosition = cc.pAdd(diff, this._startPosition);
    var newPos = cc.pAdd(this._startPosition, cc.p(x, y));
    this._target.setPosition(newPos);
    this._previousPosition = newPos
  }
}, reverse:function() {
  return cc.JumpBy.create(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps)
}, _startPosition:cc.p(0, 0), _delta:cc.p(0, 0), _height:0, _jumps:0});
cc.JumpBy.create = function(duration, position, height, jumps) {
  var jumpBy = new cc.JumpBy;
  jumpBy.initWithDuration(duration, position, height, jumps);
  return jumpBy
};
cc.JumpTo = cc.JumpBy.extend({startWithTarget:function(target) {
  cc.JumpBy.prototype.startWithTarget.call(this, target);
  this._delta = cc.p(this._delta.x - this._startPosition.x, this._delta.y - this._startPosition.y)
}});
cc.JumpTo.create = function(duration, position, height, jumps) {
  var jumpTo = new cc.JumpTo;
  jumpTo.initWithDuration(duration, position, height, jumps);
  return jumpTo
};
cc.bezierat = function(a, b, c, d, t) {
  return Math.pow(1 - t, 3) * a + 3 * t * Math.pow(1 - t, 2) * b + 3 * Math.pow(t, 2) * (1 - t) * c + Math.pow(t, 3) * d
};
cc.BezierBy = cc.ActionInterval.extend({initWithDuration:function(t, c) {
  if(cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
    this._config = c;
    return true
  }
  return false
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._previousPosition = this._startPosition = target.getPosition()
}, update:function(time) {
  if(this._target) {
    var xa = 0;
    var xb = this._config[0].x;
    var xc = this._config[1].x;
    var xd = this._config[2].x;
    var ya = 0;
    var yb = this._config[0].y;
    var yc = this._config[1].y;
    var yd = this._config[2].y;
    var x = cc.bezierat(xa, xb, xc, xd, time);
    var y = cc.bezierat(ya, yb, yc, yd, time);
    var currentPos = this._target.getPosition();
    var diff = cc.pSub(currentPos, this._previousPosition);
    this._startPosition = cc.pAdd(this._startPosition, diff);
    var newPos = cc.pAdd(this._startPosition, cc.p(x, y));
    this._target.setPosition(newPos);
    this._previousPosition = newPos
  }
}, reverse:function() {
  var r = [cc.pAdd(this._config[1], cc.pNeg(this._config[2])), cc.pAdd(this._config[0], cc.pNeg(this._config[2])), cc.pNeg(this._config[2])];
  return cc.BezierBy.create(this._duration, r)
}, ctor:function() {
  this._config = [];
  this._startPosition = cc.p(0, 0)
}});
cc.BezierBy.create = function(t, c) {
  var bezierBy = new cc.BezierBy;
  bezierBy.initWithDuration(t, c);
  return bezierBy
};
cc.BezierTo = cc.BezierBy.extend({_toConfig:null, initWithDuration:function(t, c) {
  if(cc.BezierBy.prototype.initWithDuration.call(this, t, c)) {
    this._toConfig = [];
    this._toConfig[0] = cc.p(c[0].x, c[0].y);
    this._toConfig[1] = cc.p(c[1].x, c[1].y);
    this._toConfig[2] = cc.p(c[2].x, c[2].y);
    return true
  }
  return false
}, startWithTarget:function(target) {
  cc.BezierBy.prototype.startWithTarget.call(this, target);
  this._config[0] = cc.pSub(this._toConfig[0], this._startPosition);
  this._config[1] = cc.pSub(this._toConfig[1], this._startPosition);
  this._config[2] = cc.pSub(this._toConfig[2], this._startPosition)
}});
cc.BezierTo.create = function(t, c) {
  var bezierTo = new cc.BezierTo;
  bezierTo.initWithDuration(t, c);
  return bezierTo
};
cc.ScaleTo = cc.ActionInterval.extend({initWithDuration:function(duration, sx, sy) {
  if(cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
    this._endScaleX = sx;
    this._endScaleY = sy != null ? sy : sx;
    return true
  }
  return false
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._startScaleX = target.getScaleX();
  this._startScaleY = target.getScaleY();
  this._deltaX = this._endScaleX - this._startScaleX;
  this._deltaY = this._endScaleY - this._startScaleY
}, update:function(time) {
  if(this._target) {
    this._target.setScale(this._startScaleX + this._deltaX * time, this._startScaleY + this._deltaY * time)
  }
}, _scaleX:1, _scaleY:1, _startScaleX:1, _startScaleY:1, _endScaleX:0, _endScaleY:0, _deltaX:0, _deltaY:0});
cc.ScaleTo.create = function(duration, sx, sy) {
  var scaleTo = new cc.ScaleTo;
  if(sy) {
    scaleTo.initWithDuration(duration, sx, sy)
  }else {
    scaleTo.initWithDuration(duration, sx)
  }
  return scaleTo
};
cc.ScaleBy = cc.ScaleTo.extend({startWithTarget:function(target) {
  cc.ScaleTo.prototype.startWithTarget.call(this, target);
  this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
  this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
}, reverse:function() {
  return cc.ScaleBy.create(this._duration, 1 / this._endScaleX, 1 / this._endScaleY)
}});
cc.ScaleBy.create = function(duration, sx, sy) {
  var scaleBy = new cc.ScaleBy;
  if(arguments.length == 3) {
    scaleBy.initWithDuration(duration, sx, sy)
  }else {
    scaleBy.initWithDuration(duration, sx)
  }
  return scaleBy
};
cc.Blink = cc.ActionInterval.extend({initWithDuration:function(duration, blinks) {
  if(cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
    this._times = blinks;
    return true
  }
  return false
}, update:function(time) {
  if(this._target && !this.isDone()) {
    var slice = 1 / this._times;
    var m = time % slice;
    this._target.setVisible(m > slice / 2 ? true : false)
  }
}, startWithTarget:function(target) {
  this._super(target);
  this._originalState = target.isVisible()
}, stop:function() {
  this._target.setVisible(this._originalState);
  this._super()
}, reverse:function() {
  return cc.Blink.create(this._duration, this._times)
}, _times:0, _originalState:false});
cc.Blink.create = function(duration, blinks) {
  var blink = new cc.Blink;
  blink.initWithDuration(duration, blinks);
  return blink
};
cc.FadeIn = cc.ActionInterval.extend({update:function(time) {
  this._target.setOpacity(255 * time)
}, reverse:function() {
  return cc.FadeOut.create(this._duration)
}});
cc.FadeIn.create = function(duration) {
  var action = new cc.FadeIn;
  action.initWithDuration(duration);
  return action
};
cc.FadeOut = cc.ActionInterval.extend({update:function(time) {
  this._target.setOpacity(255 * (1 - time))
}, reverse:function() {
  return cc.FadeIn.create(this._duration)
}});
cc.FadeOut.create = function(d) {
  var action = new cc.FadeOut;
  action.initWithDuration(d);
  return action
};
cc.FadeTo = cc.ActionInterval.extend({initWithDuration:function(duration, opacity) {
  if(cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
    this._toOpacity = opacity;
    return true
  }
  return false
}, update:function(time) {
  this._target.setOpacity(this._fromOpacity + (this._toOpacity - this._fromOpacity) * time)
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._fromOpacity = target.getOpacity()
}, _toOpacity:"", _fromOpacity:""});
cc.FadeTo.create = function(duration, opacity) {
  var fadeTo = new cc.FadeTo;
  fadeTo.initWithDuration(duration, opacity);
  return fadeTo
};
cc.TintTo = cc.ActionInterval.extend({initWithDuration:function(duration, red, green, blue) {
  if(cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
    this._to = cc.c3b(red, green, blue);
    return true
  }
  return false
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._from = this._target.getColor()
}, update:function(time) {
  this._target.setColor(cc.c3b(this._from.r + (this._to.r - this._from.r) * time, this._from.g + (this._to.g - this._from.g) * time, this._from.b + (this._to.b - this._from.b) * time))
}, _to:new cc.Color3B, _from:new cc.Color3B});
cc.TintTo.create = function(duration, red, green, blue) {
  var tintTo = new cc.TintTo;
  tintTo.initWithDuration(duration, red, green, blue);
  return tintTo
};
cc.TintBy = cc.ActionInterval.extend({initWithDuration:function(duration, deltaRed, deltaGreen, deltaBlue) {
  if(cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
    this._deltaR = deltaRed;
    this._deltaG = deltaGreen;
    this._deltaB = deltaBlue;
    return true
  }
  return false
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  if(target.RGBAProtocol) {
    var color = target.getColor();
    this._fromR = color.r;
    this._fromG = color.g;
    this._fromB = color.b
  }
}, update:function(time) {
  if(this._target.RGBAProtocol) {
    this._target.setColor(cc.c3b(this._fromR + this._deltaR * time, this._fromG + this._deltaG * time, this._fromB + this._deltaB * time))
  }
}, reverse:function() {
  return cc.TintBy.create(this._duration, -this._deltaR, -this._deltaG, -this._deltaB)
}, _deltaR:0, _deltaG:0, _deltaB:0, _fromR:0, _fromG:0, _fromB:0});
cc.TintBy.create = function(duration, deltaRed, deltaGreen, deltaBlue) {
  var tintBy = new cc.TintBy;
  tintBy.initWithDuration(duration, deltaRed, deltaGreen, deltaBlue);
  return tintBy
};
cc.DelayTime = cc.ActionInterval.extend({update:function(time) {
}, reverse:function() {
  return cc.DelayTime.create(this._duration)
}});
cc.DelayTime.create = function(d) {
  var action = new cc.DelayTime;
  action.initWithDuration(d);
  return action
};
cc.ReverseTime = cc.ActionInterval.extend({initWithAction:function(action) {
  cc.Assert(action != null, "");
  cc.Assert(action != this._other, "");
  if(cc.ActionInterval.prototype.initWithDuration.call(this, action.getDuration())) {
    this._other = action;
    return true
  }
  return false
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._other.startWithTarget(target)
}, update:function(time) {
  if(this._other) {
    this._other.update(1 - time)
  }
}, reverse:function() {
  return this._other.copy()
}, stop:function() {
  this._other.stop();
  cc.Action.prototype.stop.call(this)
}, _other:null});
cc.ReverseTime.create = function(action) {
  var reverseTime = new cc.ReverseTime;
  reverseTime.initWithAction(action);
  return reverseTime
};
cc.Animate = cc.ActionInterval.extend({_animation:null, _nextFrame:0, _origFrame:null, _executedLoops:0, _splitTimes:null, getAnimation:function() {
  return this._animation
}, setAnimation:function(animation) {
  this._animation = animation
}, initWithAnimation:function(animation) {
  cc.Assert(animation != null, "Animate: argument Animation must be non-NULL");
  var singleDuration = animation.getDuration();
  if(this.initWithDuration(singleDuration * animation.getLoops())) {
    this._nextFrame = 0;
    this.setAnimation(animation);
    this._origFrame = null;
    this._executedLoops = 0;
    this._splitTimes = [];
    var accumUnitsOfTime = 0;
    var newUnitOfTimeValue = singleDuration / animation.getTotalDelayUnits();
    var frames = animation.getFrames();
    cc.ArrayVerifyType(frames, cc.AnimationFrame);
    for(var i = 0;i < frames.length;i++) {
      var frame = frames[i];
      var value = accumUnitsOfTime * newUnitOfTimeValue / singleDuration;
      accumUnitsOfTime += frame.getDelayUnits();
      this._splitTimes.push(value)
    }
    return true
  }
  return false
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  if(this._animation.getRestoreOriginalFrame()) {
    this._origFrame = target.displayFrame()
  }
  this._nextFrame = 0;
  this._executedLoops = 0
}, update:function(time) {
  if(time < 1) {
    time *= this._animation.getLoops();
    var loopNumber = 0 | time;
    if(loopNumber > this._executedLoops) {
      this._nextFrame = 0;
      this._executedLoops++
    }
    time = time % 1
  }
  var frames = this._animation.getFrames();
  var numberOfFrames = frames.length;
  for(var i = this._nextFrame;i < numberOfFrames;i++) {
    if(this._splitTimes[i] <= time) {
      this._target.setDisplayFrame(frames[i].getSpriteFrame());
      this._nextFrame = i + 1;
      break
    }
  }
}, reverse:function() {
  var oldArray = this._animation.getFrames();
  var newArray = [];
  cc.ArrayVerifyType(oldArray, cc.AnimationFrame);
  if(oldArray.length > 0) {
    for(var i = oldArray.length - 1;i >= 0;i--) {
      var element = oldArray[i];
      if(!element) {
        break
      }
      newArray.push(element.copy())
    }
  }
  var newAnim = cc.Animation.createWithAnimationFrames(newArray, this._animation.getDelayPerUnit(), this._animation.getLoops());
  newAnim.setRestoreOriginalFrame(this._animation.getRestoreOriginalFrame());
  return cc.Animate.create(newAnim)
}, copy:function() {
  return cc.Animate.create(this._animation.copy())
}, stop:function() {
  if(this._animation.getRestoreOriginalFrame() && this._target) {
    this._target.setDisplayFrame(this._origFrame)
  }
  cc.Action.prototype.stop.call(this)
}});
cc.Animate.create = function(animation) {
  var animate = new cc.Animate;
  animate.initWithAnimation(animation);
  return animate
};
cc.TargetedAction = cc.ActionInterval.extend({_action:null, _forcedTarget:null, initWithTarget:function(target, action) {
  if(this.initWithDuration(action.getDuration())) {
    this._forcedTarget = target;
    this._action = action;
    return true
  }
  return false
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, this._forcedTarget);
  this._action.startWithTarget(this._forcedTarget)
}, stop:function() {
  this._action.stop()
}, update:function(time) {
  this._action.update(time)
}, getForcedTarget:function() {
  return this._forcedTarget
}, setForcedTarget:function(forcedTarget) {
  if(this._forcedTarget != forcedTarget) {
    this._forcedTarget = forcedTarget
  }
}});
cc.TargetedAction.create = function(target, action) {
  var retObj = new cc.TargetedAction;
  retObj.initWithTarget(target, action);
  return retObj
};
cc.ActionInstant = cc.FiniteTimeAction.extend({isDone:function() {
  return true
}, step:function(dt) {
  this.update(1)
}, update:function(time) {
}});
cc.Show = cc.ActionInstant.extend({update:function(target) {
  this._target.setVisible(true)
}, reverse:function() {
  return cc.Hide.create.call(this)
}});
cc.Show.create = function() {
  return new cc.Show
};
cc.Hide = cc.ActionInstant.extend({update:function(time) {
  this._target.setVisible(false)
}, reverse:function() {
  return cc.Show.create.call(this)
}});
cc.Hide.create = function() {
  return new cc.Hide
};
cc.ToggleVisibility = cc.ActionInstant.extend({update:function(time) {
  this._target.setVisible(!this._target.isVisible())
}, reverse:function() {
  return new cc.ToggleVisibility
}});
cc.ToggleVisibility.create = function() {
  return new cc.ToggleVisibility
};
cc.FlipX = cc.ActionInstant.extend({initWithFlipX:function(x) {
  this._flipX = x;
  return true
}, update:function(time) {
  this._target.setFlipX(this._flipX)
}, reverse:function() {
  return cc.FlipX.create(!this._flipX)
}, _flipX:false});
cc.FlipX.create = function(x) {
  var ret = new cc.FlipX;
  if(ret.initWithFlipX(x)) {
    return ret
  }
  return null
};
cc.FlipY = cc.ActionInstant.extend({initWithFlipY:function(Y) {
  this._flipY = Y;
  return true
}, update:function(time) {
  this._target.setFlipY(this._flipY)
}, reverse:function() {
  return cc.FlipY.create(!this._flipY)
}, _flipY:false});
cc.FlipY.create = function(y) {
  var ret = new cc.FlipY;
  if(ret.initWithFlipY(y)) {
    return ret
  }
  return null
};
cc.Place = cc.ActionInstant.extend({initWithPosition:function(pos) {
  this._position = pos;
  return true
}, update:function(time) {
  this._target.setPosition(this._position)
}});
cc.Place.create = function(pos) {
  var ret = new cc.Place;
  ret.initWithPosition(pos);
  return ret
};
cc.CallFunc = cc.ActionInstant.extend({initWithTarget:function(selector, selectorTarget, data) {
  this._data = data;
  this._callFunc = selector;
  this._selectorTarget = selectorTarget;
  return true
}, execute:function() {
  if(this._callFunc != null) {
    this._callFunc.call(this._selectorTarget, this._target, this._data)
  }
}, update:function(time) {
  this.execute()
}, getTargetCallback:function() {
  return this._selectorTarget
}, setTargetCallback:function(sel) {
  if(sel != this._selectorTarget) {
    if(this._selectorTarget) {
      this._selectorTarget = null
    }
    this._selectorTarget = sel
  }
}, copy:function() {
  var n = new cc.CallFunc;
  n.initWithTarget(this._callFunc, this._selectorTarget, this._data);
  return n
}, _selectorTarget:null, _callFunc:null});
cc.CallFunc.create = function(selector, selectorTarget, data) {
  var ret = new cc.CallFunc;
  if(ret && ret.initWithTarget(selector, selectorTarget, data)) {
    ret._callFunc = selector;
    return ret
  }
  return null
};
cc.HashElement = cc.Class.extend({actions:null, target:null, actionIndex:0, currentAction:null, currentActionSalvaged:false, paused:false, hh:null, ctor:function() {
  this.actions = []
}});
cc.ActionManager = cc.Class.extend({_targets:null, _currentTarget:null, _currentTargetSalvaged:false, _searchElementByTarget:function(arr, target) {
  for(var k = 0;k < arr.length;k++) {
    if(target == arr[k].target) {
      return arr[k]
    }
  }
  return null
}, ctor:function() {
  this._targets = []
}, addAction:function(action, target, paused) {
  cc.Assert(action != null, "no action");
  cc.Assert(target != null, "");
  var element = this._searchElementByTarget(this._targets, target);
  if(!element) {
    element = new cc.HashElement;
    element.paused = paused;
    element.target = target;
    this._targets.push(element)
  }
  this._actionAllocWithHashElement(element);
  element.actions.push(action);
  action.startWithTarget(target)
}, removeAllActions:function() {
  for(var i = 0;i < this._targets.length;i++) {
    var element = this._targets[i];
    if(element) {
      this.removeAllActionsFromTarget(element.target)
    }
  }
}, removeAllActionsFromTarget:function(target) {
  if(target == null) {
    return
  }
  var element = this._searchElementByTarget(this._targets, target);
  if(element) {
    if(element.currentAction in element.actions && !element.currentActionSalvaged) {
      element.currentActionSalvaged = true
    }
    element.actions = [];
    if(this._currentTarget == element) {
      this._currentTargetSalvaged = true
    }else {
      this._deleteHashElement(element)
    }
  }else {
  }
}, removeAction:function(action) {
  if(action == null) {
    return
  }
  var target = action.getOriginalTarget();
  var element = this._searchElementByTarget(this._targets, target);
  if(element) {
    for(var i = 0;i < element.actions.length;i++) {
      if(element.actions[i] == action) {
        element.actions.splice(i, 1);
        break
      }
    }
  }else {
    cc.log("cocos2d: removeAction: Target not found")
  }
}, removeActionByTag:function(tag, target) {
  cc.Assert(tag != cc.ACTION_TAG_INVALID, "");
  cc.Assert(target != null, "");
  var element = this._searchElementByTarget(this._targets, target);
  if(element) {
    var limit = element.actions.length;
    for(var i = 0;i < limit;++i) {
      var action = element.actions[i];
      if(action) {
        if(action.getTag() == tag && action.getOriginalTarget() == target) {
          this._removeActionAtIndex(i, element);
          break
        }
      }
    }
  }
}, getActionByTag:function(tag, target) {
  cc.Assert(tag != cc.ACTION_TAG_INVALID, "");
  var element = this._searchElementByTarget(this._targets, target);
  if(element) {
    if(element.actions != null) {
      for(var i = 0;i < element.actions.length;++i) {
        var action = element.actions[i];
        if(action) {
          if(action.getTag() == tag) {
            return action
          }
        }
      }
    }
  }
  return null
}, numberOfRunningActionsInTarget:function(target) {
  var element = this._searchElementByTarget(this._targets, target);
  if(element) {
    return element.actions ? element.actions.length : 0
  }
  return 0
}, pauseTarget:function(target) {
  var element = this._searchElementByTarget(this._targets, target);
  if(element) {
    element.paused = true
  }
}, resumeTarget:function(target) {
  var element = this._searchElementByTarget(this._targets, target);
  if(element) {
    element.paused = false
  }
}, pauseAllRunningActions:function() {
  var idsWithActions = [];
  for(var i = 0;i < this._targets.length;i++) {
    var element = this._targets[i];
    if(element && !element.paused) {
      element.paused = true;
      idsWithActions.push(element.target)
    }
  }
  return idsWithActions
}, resumeTargets:function(targetsToResume) {
  if(!targetsToResume) {
    return
  }
  for(var i = 0;i < targetsToResume.length;i++) {
    if(targetsToResume[i]) {
      this.resumeTarget(targetsToResume[i])
    }
  }
}, purgeSharedManager:function() {
  cc.Director.getInstance().getScheduler().unscheduleUpdateForTarget(this)
}, _removeActionAtIndex:function(index, element) {
  var action = element.actions[index];
  if(action == element.currentAction && !element.currentActionSalvaged) {
    element.currentActionSalvaged = true
  }
  cc.ArrayRemoveObjectAtIndex(element.actions, index);
  if(element.actionIndex >= index) {
    element.actionIndex--
  }
  if(element.actions.length == 0) {
    if(this._currentTarget == element) {
      this._currentTargetSalvaged = true
    }else {
      this._deleteHashElement(element)
    }
  }
}, _deleteHashElement:function(element) {
  cc.ArrayRemoveObject(this._targets, element);
  if(element) {
    element.actions = null;
    element.target = null
  }
}, _actionAllocWithHashElement:function(element) {
  if(element.actions == null) {
    element.actions = []
  }
}, update:function(dt) {
  for(var elt = 0;elt < this._targets.length;elt++) {
    this._currentTarget = this._targets[elt];
    this._currentTargetSalvaged = false;
    if(!this._currentTarget.paused) {
      for(this._currentTarget.actionIndex = 0;this._currentTarget.actionIndex < this._currentTarget.actions.length;this._currentTarget.actionIndex++) {
        this._currentTarget.currentAction = this._currentTarget.actions[this._currentTarget.actionIndex];
        if(!this._currentTarget.currentAction) {
          continue
        }
        this._currentTarget.currentActionSalvaged = false;
        this._currentTarget.currentAction.step(dt);
        if(this._currentTarget.currentActionSalvaged) {
          this._currentTarget.currentAction = null
        }else {
          if(this._currentTarget.currentAction.isDone()) {
            this._currentTarget.currentAction.stop();
            var action = this._currentTarget.currentAction;
            this._currentTarget.currentAction = null;
            this.removeAction(action)
          }
        }
        this._currentTarget.currentAction = null
      }
    }
    if(this._currentTargetSalvaged && this._currentTarget.actions.length == 0) {
      this._deleteHashElement(this._currentTarget)
    }
  }
}});
cc.ProgressTo = cc.ActionInterval.extend({_to:0, _from:0, initWithDuration:function(duration, percent) {
  if(this._super(duration)) {
    this._to = percent;
    return true
  }
  return false
}, startWithTarget:function(target) {
  this._super(target);
  this._from = target.getPercentage();
  if(this._from == 100) {
    this._from = 0
  }
}, update:function(time) {
  if(this._target instanceof cc.ProgressTimer) {
    this._target.setPercentage(this._from + (this._to - this._from) * time)
  }
}});
cc.ProgressTo.create = function(duration, percent) {
  var progressTo = new cc.ProgressTo;
  progressTo.initWithDuration(duration, percent);
  return progressTo
};
cc.ProgressFromTo = cc.ActionInterval.extend({_to:0, _from:0, initWithDuration:function(duration, fromPercentage, toPercentage) {
  if(this._super(duration)) {
    this._to = toPercentage;
    this._from = fromPercentage;
    return true
  }
  return false
}, reverse:function() {
  return cc.ProgressFromTo.create(this._duration, this._to, this._from)
}, startWithTarget:function(target) {
  this._super(target)
}, update:function(time) {
  if(this._target instanceof cc.ProgressTimer) {
    this._target.setPercentage(this._from + (this._to - this._from) * time)
  }
}});
cc.ProgressFromTo.create = function(duration, fromPercentage, toPercentage) {
  var progressFromTo = new cc.ProgressFromTo;
  progressFromTo.initWithDuration(duration, fromPercentage, toPercentage);
  return progressFromTo
};
cc.ActionCamera = cc.ActionInterval.extend({_centerXOrig:0, _centerYOrig:0, _centerZOrig:0, _eyeXOrig:0, _eyeYOrig:0, _eyeZOrig:0, _upXOrig:0, _upYOrig:0, _upZOrig:0, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  var camera = target.getCamera();
  var centerXYZ = camera.getCenter();
  this._centerXOrig = centerXYZ.x;
  this._centerYOrig = centerXYZ.y;
  this._centerZOrig = centerXYZ.z;
  var eyeXYZ = camera.getEye();
  this._eyeXOrig = eyeXYZ.x;
  this._eyeYOrig = eyeXYZ.y;
  this._eyeZOrig = eyeXYZ.z;
  var upXYZ = camera.getUp();
  this._upXOrig = upXYZ.x;
  this._upYOrig = upXYZ.y;
  this._upZOrig = upXYZ.z
}, reverse:function() {
  return cc.ReverseTime.create(this)
}});
cc.OrbitCamera = cc.ActionCamera.extend({_radius:0, _deltaRadius:0, _angleZ:0, _deltaAngleZ:0, _angleX:0, _deltaAngleX:0, _radZ:0, _radDeltaZ:0, _radX:0, _radDeltaX:0, initWithDuration:function(t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX) {
  if(cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
    this._radius = radius;
    this._deltaRadius = deltaRadius;
    this._angleZ = angleZ;
    this._deltaAngleZ = deltaAngleZ;
    this._angleX = angleX;
    this._deltaAngleX = deltaAngleX;
    this._radDeltaZ = cc.DEGREES_TO_RADIANS(deltaAngleZ);
    this._radDeltaX = cc.DEGREES_TO_RADIANS(deltaAngleX);
    return true
  }
  return false
}, sphericalRadius:function() {
  var newRadius, zenith, azimuth;
  var camera = this._target.getCamera();
  var eyeXYZ = camera.getEye();
  var centerXYZ = camera.getCenter();
  var x = eyeXYZ.x - centerXYZ.x;
  var y = eyeXYZ.y - centerXYZ.y;
  var z = eyeXYZ.z - centerXYZ.z;
  var r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
  var s = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  if(s === 0) {
    s = cc.FLT_EPSILON
  }
  if(r === 0) {
    r = cc.FLT_EPSILON
  }
  zenith = Math.acos(z / r);
  if(x < 0) {
    azimuth = Math.PI - Math.asin(y / s)
  }else {
    azimuth = Math.asin(y / s)
  }
  newRadius = r / cc.Camera.getZEye();
  return{newRadius:newRadius, zenith:zenith, azimuth:azimuth}
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  var retValue = this.sphericalRadius();
  if(isNaN(this._radius)) {
    this._radius = retValue.newRadius
  }
  if(isNaN(this._angleZ)) {
    this._angleZ = cc.RADIANS_TO_DEGREES(retValue.zenith)
  }
  if(isNaN(this._angleX)) {
    this._angleX = cc.RADIANS_TO_DEGREES(retValue.azimuth)
  }
  this._radZ = cc.DEGREES_TO_RADIANS(this._angleZ);
  this._radX = cc.DEGREES_TO_RADIANS(this._angleX)
}, update:function(dt) {
  var r = (this._radius + this._deltaRadius * dt) * cc.Camera.getZEye();
  var za = this._radZ + this._radDeltaZ * dt;
  var xa = this._radX + this._radDeltaX * dt;
  var i = Math.sin(za) * Math.cos(xa) * r + this._centerXOrig;
  var j = Math.sin(za) * Math.sin(xa) * r + this._centerYOrig;
  var k = Math.cos(za) * r + this._centerZOrig;
  this._target.getCamera().setEye(i, j, k)
}});
cc.OrbitCamera.create = function(t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX) {
  var ret = new cc.OrbitCamera;
  if(ret.initWithDuration(t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX)) {
    return ret
  }
  return null
};
cc.ActionEase = cc.ActionInterval.extend({initWithAction:function(action) {
  cc.Assert(action != null, "");
  if(this.initWithDuration(action.getDuration())) {
    this._other = action;
    return true
  }
  return false
}, startWithTarget:function(target) {
  cc.ActionInterval.prototype.startWithTarget.call(this, target);
  this._other.startWithTarget(this._target)
}, stop:function() {
  this._other.stop();
  this._super()
}, update:function(time1) {
  this._other.update(time1)
}, reverse:function() {
  return cc.ActionEase.create(this._other.reverse())
}, _other:null});
cc.ActionEase.create = function(action) {
  var ret = new cc.ActionEase;
  if(ret) {
    ret.initWithAction(action)
  }
  return ret
};
cc.EaseRateAction = cc.ActionEase.extend({setRate:function(rate) {
  this._rate = rate
}, getRate:function() {
  return this._rate
}, initWithAction:function(action, rate) {
  if(this._super(action)) {
    this._rate = rate;
    return true
  }
  return false
}, reverse:function() {
  return cc.EaseRateAction.create(this._other.reverse(), 1 / this._rate)
}, _rate:null});
cc.EaseRateAction.create = function(action, rate) {
  var ret = new cc.EaseRateAction;
  if(ret) {
    ret.initWithAction(action, rate)
  }
  return ret
};
cc.EaseIn = cc.EaseRateAction.extend({update:function(time1) {
  this._other.update(Math.pow(time1, this._rate))
}, reverse:function() {
  return cc.EaseIn.create(this._other.reverse(), 1 / this._rate)
}});
cc.EaseIn.create = function(action, rate) {
  var ret = new cc.EaseIn;
  if(ret) {
    ret.initWithAction(action, rate)
  }
  return ret
};
cc.EaseOut = cc.EaseRateAction.extend({update:function(time1) {
  this._other.update(Math.pow(time1, 1 / this._rate))
}, reverse:function() {
  return cc.EaseOut.create(this._other.reverse(), 1 / this._rate)
}});
cc.EaseOut.create = function(action, rate) {
  var ret = new cc.EaseOut;
  if(ret) {
    ret.initWithAction(action, rate)
  }
  return ret
};
cc.EaseInOut = cc.EaseRateAction.extend({update:function(time1) {
  time1 *= 2;
  if(time1 < 1) {
    this._other.update(0.5 * Math.pow(time1, this._rate))
  }else {
    this._other.update(1 - 0.5 * Math.pow(2 - time1, this._rate))
  }
}, reverse:function() {
  return cc.EaseInOut.create(this._other.reverse(), this._rate)
}});
cc.EaseInOut.create = function(action, rate) {
  var ret = new cc.EaseInOut;
  if(ret) {
    ret.initWithAction(action, rate)
  }
  return ret
};
cc.EaseExponentialIn = cc.ActionEase.extend({update:function(time1) {
  this._other.update(time1 === 0 ? 0 : Math.pow(2, 10 * (time1 - 1)))
}, reverse:function() {
  return cc.EaseExponentialOut.create(this._other.reverse())
}});
cc.EaseExponentialIn.create = function(action) {
  var ret = new cc.EaseExponentialIn;
  if(ret) {
    ret.initWithAction(action)
  }
  return ret
};
cc.EaseExponentialOut = cc.ActionEase.extend({update:function(time1) {
  this._other.update(time1 == 1 ? 1 : -Math.pow(2, -10 * time1) + 1)
}, reverse:function() {
  return cc.EaseExponentialIn.create(this._other.reverse())
}});
cc.EaseExponentialOut.create = function(action) {
  var ret = new cc.EaseExponentialOut;
  if(ret) {
    ret.initWithAction(action)
  }
  return ret
};
cc.EaseExponentialInOut = cc.ActionEase.extend({update:function(time) {
  if(time != 1 && time !== 0) {
    time *= 2;
    if(time < 1) {
      time = 0.5 * Math.pow(2, 10 * (time - 1))
    }else {
      time = 0.5 * (-Math.pow(2, -10 * (time - 1)) + 2)
    }
  }
  this._other.update(time)
}, reverse:function() {
  return cc.EaseExponentialInOut.create(this._other.reverse())
}});
cc.EaseExponentialInOut.create = function(action) {
  var ret = new cc.EaseExponentialInOut;
  if(ret) {
    ret.initWithAction(action)
  }
  return ret
};
cc.EaseSineIn = cc.ActionEase.extend({update:function(time1) {
  time1 = time1 === 0 || time1 == 1 ? time1 : -1 * Math.cos(time1 * Math.PI / 2) + 1;
  this._other.update(time1)
}, reverse:function() {
  return cc.EaseSineOut.create(this._other.reverse())
}});
cc.EaseSineIn.create = function(action) {
  var ret = new cc.EaseSineIn;
  if(ret) {
    ret.initWithAction(action)
  }
  return ret
};
cc.EaseSineOut = cc.ActionEase.extend({update:function(time1) {
  time1 = time1 === 0 || time1 == 1 ? time1 : Math.sin(time1 * Math.PI / 2);
  this._other.update(time1)
}, reverse:function() {
  return cc.EaseSineIn.create(this._other.reverse())
}});
cc.EaseSineOut.create = function(action) {
  var ret = new cc.EaseSineOut;
  if(ret) {
    ret.initWithAction(action)
  }
  return ret
};
cc.EaseSineInOut = cc.ActionEase.extend({update:function(time1) {
  time1 = time1 === 0 || time1 == 1 ? time1 : -0.5 * (Math.cos(Math.PI * time1) - 1);
  this._other.update(time1)
}, reverse:function() {
  return cc.EaseSineInOut.create(this._other.reverse())
}});
cc.EaseSineInOut.create = function(action) {
  var ret = new cc.EaseSineInOut;
  if(ret) {
    ret.initWithAction(action)
  }
  return ret
};
cc.EaseElastic = cc.ActionEase.extend({getPeriod:function() {
  return this._period
}, setPeriod:function(period) {
  this._period = period
}, initWithAction:function(action, period) {
  this._super(action);
  this._period = period == null ? 0.3 : period;
  return true
}, reverse:function() {
  cc.Assert(0, "Override me");
  return null
}, _period:null});
cc.EaseElastic.create = function(action, period) {
  var ret = new cc.EaseElastic;
  if(ret && ret.initWithAction(action, period)) {
    return ret
  }
  return null
};
cc.EaseElasticIn = cc.EaseElastic.extend({update:function(time1) {
  var newT = 0;
  if(time1 === 0 || time1 === 1) {
    newT = time1
  }else {
    var s = this._period / 4;
    time1 = time1 - 1;
    newT = -Math.pow(2, 10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / this._period)
  }
  this._other.update(newT)
}, reverse:function() {
  return cc.EaseElasticOut.create(this._other.reverse(), this._period)
}});
cc.EaseElasticIn.create = function(action, period) {
  var ret = new cc.EaseElasticIn;
  if(ret && ret.initWithAction(action, period)) {
    return ret
  }
  return null
};
cc.EaseElasticOut = cc.EaseElastic.extend({update:function(time1) {
  var newT = 0;
  if(time1 === 0 || time1 == 1) {
    newT = time1
  }else {
    var s = this._period / 4;
    newT = Math.pow(2, -10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / this._period) + 1
  }
  this._other.update(newT)
}, reverse:function() {
  return cc.EaseElasticIn.create(this._other.reverse(), this._period)
}});
cc.EaseElasticOut.create = function(action, period) {
  var ret = new cc.EaseElasticOut;
  if(ret) {
    if(period == null) {
      ret.initWithAction(action)
    }else {
      ret.initWithAction(action, period)
    }
  }
  return ret
};
cc.EaseElasticInOut = cc.EaseElastic.extend({update:function(time1) {
  var newT = 0;
  if(time1 === 0 || time1 == 1) {
    newT = time1
  }else {
    time1 = time1 * 2;
    if(!this._period) {
      this._period = 0.3 * 1.5
    }
    var s = this._period / 4;
    time1 = time1 - 1;
    if(time1 < 0) {
      newT = -0.5 * Math.pow(2, 10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / this._period)
    }else {
      newT = Math.pow(2, -10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / this._period) * 0.5 + 1
    }
  }
  this._other.update(newT)
}, reverse:function() {
  return cc.EaseElasticInOut.create(this._other.reverse(), this._period)
}});
cc.EaseElasticInOut.create = function(action, period) {
  var ret = new cc.EaseElasticInOut;
  if(ret) {
    if(period == null) {
      ret.initWithAction(action)
    }else {
      ret.initWithAction(action, period)
    }
  }
  return ret
};
cc.EaseBounce = cc.ActionEase.extend({bounceTime:function(time1) {
  if(time1 < 1 / 2.75) {
    return 7.5625 * time1 * time1
  }else {
    if(time1 < 2 / 2.75) {
      time1 -= 1.5 / 2.75;
      return 7.5625 * time1 * time1 + 0.75
    }else {
      if(time1 < 2.5 / 2.75) {
        time1 -= 2.25 / 2.75;
        return 7.5625 * time1 * time1 + 0.9375
      }
    }
  }
  time1 -= 2.625 / 2.75;
  return 7.5625 * time1 * time1 + 0.984375
}, reverse:function() {
  return cc.EaseBounce.create(this._other.reverse())
}});
cc.EaseBounce.create = function(action) {
  var ret = new cc.EaseBounce;
  if(ret) {
    ret.initWithAction(action)
  }
  return ret
};
cc.EaseBounceIn = cc.EaseBounce.extend({update:function(time1) {
  var newT = 1 - this.bounceTime(1 - time1);
  this._other.update(newT)
}, reverse:function() {
  return cc.EaseBounceOut.create(this._other.reverse())
}});
cc.EaseBounceIn.create = function(action) {
  var ret = new cc.EaseBounceIn;
  if(ret) {
    ret.initWithAction(action)
  }
  return ret
};
cc.EaseBounceOut = cc.EaseBounce.extend({update:function(time1) {
  var newT = this.bounceTime(time1);
  this._other.update(newT)
}, reverse:function() {
  return cc.EaseBounceIn.create(this._other.reverse())
}});
cc.EaseBounceOut.create = function(action) {
  var ret = new cc.EaseBounceOut;
  if(ret) {
    ret.initWithAction(action)
  }
  return ret
};
cc.EaseBounceInOut = cc.EaseBounce.extend({update:function(time1) {
  var newT = 0;
  if(time1 < 0.5) {
    time1 = time1 * 2;
    newT = (1 - this.bounceTime(1 - time1)) * 0.5
  }else {
    newT = this.bounceTime(time1 * 2 - 1) * 0.5 + 0.5
  }
  this._other.update(newT)
}, reverse:function() {
  return cc.EaseBounceInOut.create(this._other.reverse())
}});
cc.EaseBounceInOut.create = function(action) {
  var ret = new cc.EaseBounceInOut;
  if(ret) {
    ret.initWithAction(action)
  }
  return ret
};
cc.EaseBackIn = cc.ActionEase.extend({update:function(time1) {
  var overshoot = 1.70158;
  time1 = time1 === 0 || time1 == 1 ? time1 : time1 * time1 * ((overshoot + 1) * time1 - overshoot);
  this._other.update(time1)
}, reverse:function() {
  return cc.EaseBackOut.create(this._other.reverse())
}});
cc.EaseBackIn.create = function(action) {
  var ret = new cc.EaseBackIn;
  if(ret) {
    ret.initWithAction(action)
  }
  return ret
};
cc.EaseBackOut = cc.ActionEase.extend({update:function(time1) {
  var overshoot = 1.70158;
  time1 = time1 - 1;
  this._other.update(time1 * time1 * ((overshoot + 1) * time1 + overshoot) + 1)
}, reverse:function() {
  return cc.EaseBackIn.create(this._other.reverse())
}});
cc.EaseBackOut.create = function(action) {
  var ret = new cc.EaseBackOut;
  if(ret) {
    ret.initWithAction(action)
  }
  return ret
};
cc.EaseBackInOut = cc.ActionEase.extend({update:function(time1) {
  var overshoot = 1.70158 * 1.525;
  time1 = time1 * 2;
  if(time1 < 1) {
    this._other.update(time1 * time1 * ((overshoot + 1) * time1 - overshoot) / 2)
  }else {
    time1 = time1 - 2;
    this._other.update(time1 * time1 * ((overshoot + 1) * time1 + overshoot) / 2 + 1)
  }
}, reverse:function() {
  return cc.EaseBackInOut.create(this._other.reverse())
}});
cc.EaseBackInOut.create = function(action) {
  var ret = new cc.EaseBackInOut;
  if(ret) {
    ret.initWithAction(action)
  }
  return ret
};
cc.GridAction = cc.ActionInterval.extend({_gridSize:null, startWithTarget:function(target) {
  this._super(target);
  var newGrid = this.getGrid();
  var t = this._target;
  var targetGrid = t.getGrid();
  if(targetGrid && targetGrid.getReuseGrid() > 0) {
    if(targetGrid.isActive() && targetGrid.getGridSize().width == this._gridSize.width && targetGrid.getGridSize().height == this._gridSize.height) {
      targetGrid.reuse()
    }else {
      cc.Assert(0, "")
    }
  }else {
    if(targetGrid && targetGrid.isActive()) {
      targetGrid.setActive(false)
    }
    t.setGrid(newGrid);
    t.getGrid().setActive(true)
  }
}, reverse:function() {
  return cc.ReverseTime.create(this)
}, initWithDuration:function(duration, gridSize) {
  if(this._super(duration)) {
    this._gridSize = gridSize;
    return true
  }
  return false
}, getGrid:function() {
  cc.Assert(0, "");
  return null
}});
cc.GridAction.create = function(duration, gridSize) {
  var action = new cc.GridAction;
  action.initWithDuration(duration, gridSize);
  return action
};
cc.Grid3DAction = cc.GridAction.extend({getGrid:function() {
  return cc.Grid3D.create(this._gridSize)
}, vertex:function(position) {
  return this._target.getGrid().vertex(position)
}, originalVertex:function(position) {
  return this._target.getGrid().originalVertex(position)
}, setVertex:function(position, vertex) {
  this._target.getGrid().setVertex(position, vertex)
}});
cc.Grid3DAction.create = function(duration, gridSize) {
  return new cc.Grid3DAction
};
cc.TiledGrid3DAction = cc.GridAction.extend({tile:function(position) {
  return this._target.getGrid().tile(position)
}, originalTile:function(position) {
  return this._target.getGrid().originalTile(position)
}, setTile:function(position, coords) {
  this._target.getGrid().setTile(position, coords)
}, getGrid:function() {
  return cc.TiledGrid3D.create(this._gridSize)
}});
cc.TiledGrid3DAction.create = function(duration, gridSize) {
  var ret = new cc.TiledGrid3DAction;
  ret.initWithDuration(duration, gridSize);
  return ret
};
cc.StopGrid = cc.ActionInstant.extend({startWithTarget:function(target) {
  this._super(target);
  var grid = this._target.getGrid();
  if(grid && grid.isActive()) {
    grid.setActive(false)
  }
}});
cc.StopGrid.create = function() {
  return new cc.StopGrid
};
cc.ReuseGrid = cc.ActionInstant.extend({_times:null, initWithTimes:function(times) {
  this._times = times;
  return true
}, startWithTarget:function(target) {
  cc.ActionInstant.prototype.startWithTarget.call(this, target);
  if(this._target.getGrid() && this._target.getGrid().isActive()) {
    this._target.getGrid().setReuseGrid(this._target.getGrid().getReuseGrid() + this._times)
  }
}});
cc.ReuseGrid.create = function(times) {
  return new cc.ReuseGrid
};
cc.RAND_MAX = 16777215;
cc.rand = function() {
  return Math.random() * cc.RAND_MAX
};
cc.Waves3D = cc.Grid3DAction.extend({_waves:null, _amplitude:null, _amplitudeRate:null, getAmplitude:function() {
  return this._amplitude
}, setAmplitude:function(amplitude) {
  this._amplitude = amplitude
}, getAmplitudeRate:function() {
  return this._amplitudeRate
}, setAmplitudeRate:function(amplitudeRate) {
  this._amplitudeRate = amplitudeRate
}, initWithDuration:function(duration, gridSize, waves, amplitude) {
  if(this._super(duration, gridSize)) {
    this._waves = waves;
    this._amplitude = amplitude;
    this._amplitudeRate = 1;
    return true
  }
  return false
}, update:function(time) {
  for(var i = 0;i < this._gridSize.width + 1;++i) {
    for(var j = 0;j < this._gridSize.height + 1;++j) {
      var v = this.originalVertex(cc.g(i, j));
      v.z += Math.sin(Math.PI * time * this._waves * 2 + (v.y + v.x) * 0.01) * this._amplitude * this._amplitudeRate;
      this.setVertex(cc.p(i, j), v)
    }
  }
}});
cc.Waves3D.create = function(duration, gridSize, waves, amplitude) {
  var action = new cc.Waves3D;
  action.initWithDuration(duration, gridSize, waves, amplitude);
  return action
};
cc.FlipX3D = cc.Grid3DAction.extend({initWithDuration:function(duration) {
  return this._super(duration, cc.size(1, 1))
}, initWithSize:function(gridSize, duration) {
  if(gridSize.width != 1 || gridSize.height != 1) {
    cc.Assert(0, "");
    return false
  }
  return cc.Grid3DAction.prototype.initWithDuration.call(this, duration, gridSize)
}, update:function(time) {
  var angle = Math.PI * time;
  var mz = Math.sin(angle);
  angle = angle / 2;
  var mx = Math.cos(angle);
  var diff = new cc.Vertex3F;
  var v0 = this.originalVertex(cc.p(1, 1));
  var v1 = this.originalVertex(cc.p(0, 0));
  var x0 = v0.x;
  var x1 = v1.x;
  var x;
  var a, b, c, d;
  if(x0 > x1) {
    a = cc.p(0, 0);
    b = cc.p(0, 1);
    c = cc.p(1, 0);
    d = cc.p(1, 1);
    x = x0
  }else {
    c = cc.p(0, 0);
    d = cc.p(0, 1);
    a = cc.p(1, 0);
    b = cc.p(1, 1);
    x = x1
  }
  diff.x = x - x * mx;
  diff.z = Math.abs(parseFloat(x * mz / 4));
  var v = this.originalVertex(a);
  v.x = diff.x;
  v.z += diff.z;
  this.setVertex(a, v);
  v = this.originalVertex(b);
  v.x = diff.x;
  v.z += diff.z;
  this.setVertex(b, v);
  v = this.originalVertex(c);
  v.x -= diff.x;
  v.z -= diff.z;
  this.setVertex(c, v);
  v = this.originalVertex(d);
  v.x -= diff.x;
  v.z -= diff.z;
  this.setVertex(d, v)
}});
cc.FlipX3D.create = function(duration) {
  var action = new cc.FlipX3D;
  action.initWithDuration(duration);
  return action
};
cc.FlipY3D = cc.FlipX3D.extend({update:function(time) {
  var angle = Math.PI * time;
  var mz = Math.sin(angle);
  angle = angle / 2;
  var my = Math.cos(angle);
  var diff = new cc.Vertex3F;
  var v0 = this.originalVertex(cc.p(1, 1));
  var v1 = this.originalVertex(cc.p(0, 0));
  var y0 = v0.y;
  var y1 = v1.y;
  var y;
  var a, b, c, d;
  if(y0 > y1) {
    a = cc.p(0, 0);
    b = cc.p(0, 1);
    c = cc.p(1, 0);
    d = cc.p(1, 1);
    y = y0
  }else {
    b = cc.p(0, 0);
    a = cc.p(0, 1);
    d = cc.p(1, 0);
    c = cc.p(1, 1);
    y = y1
  }
  diff.y = y - y * my;
  diff.z = Math.abs(parseFloat(y * mz) / 4);
  var v = this.originalVertex(a);
  v.y = diff.y;
  v.z += diff.z;
  this.setVertex(a, v);
  v = this.originalVertex(b);
  v.y -= diff.y;
  v.z -= diff.z;
  this.setVertex(b, v);
  v = this.originalVertex(c);
  v.y = diff.y;
  v.z += diff.z;
  this.setVertex(c, v);
  v = this.originalVertex(d);
  v.y -= diff.y;
  v.z -= diff.z;
  this.setVertex(d, v)
}});
cc.FlipY3D.create = function(duration) {
  var action = new cc.FlipY3D;
  action.initWithDuration(duration);
  return action
};
cc.Lens3D = cc.Grid3DAction.extend({_position:null, _radius:0, _lensEffect:0, _dirty:false, getLensEffect:function() {
  return this._lensEffect
}, setLensEffect:function(lensEffect) {
  this._lensEffect = lensEffect
}, getPosition:function() {
  return this._position
}, setPosition:function(position) {
  if(!cc.Point.CCPointEqualToPoint(position, this._position)) {
    this._position = position;
    this._dirty = true
  }
}, initWithDuration:function(duration, gridSize, position, radius) {
  if(this._super(duration, gridSize)) {
    this._position = cc.p(-1, -1);
    this.setPosition(position);
    this._radius = radius;
    this._lensEffect = 0.7;
    this._dirty = true;
    return true
  }
  return false
}, update:function(time) {
  if(this._dirty) {
    for(var i = 0;i < this._gridSize.width + 1;++i) {
      for(var j = 0;j < this._gridSize.height + 1;++j) {
        var v = this.originalVertex(cc.p(i, j));
        var vect = cc.pSub(this._position, cc.p(v.x, v.y));
        var r = cc.pLength(vect);
        if(r < this._radius) {
          r = this._radius - r;
          var pre_log = r / this._radius;
          if(pre_log == 0) {
            pre_log = 0.0010
          }
          var l = Math.log(pre_log) * this._lensEffect;
          var new_r = Math.exp(l) * this._radius;
          if(cc.pLength(vect) > 0) {
            vect = cc.pNormalize(vect);
            var new_vect = cc.pMult(vect, new_r);
            v.z += cc.pLength(new_vect) * this._lensEffect
          }
        }
        this.setVertex(cc.p(i, j), v)
      }
    }
    this._dirty = false
  }
}});
cc.Lens3D.create = function(duration, gridSize, position, radius) {
  var action = new cc.Lens3D;
  action.initWithDuration(duration, gridSize, position, radius);
  return action
};
cc.Ripple3D = cc.Grid3DAction.extend({_position:null, _radius:null, _waves:null, _amplitude:null, _amplitudeRate:null, getPosition:function() {
  return this._position
}, setPosition:function(position) {
  this._position = position
}, getAmplitude:function() {
  return this._amplitude
}, setAmplitude:function(amplitude) {
  this._amplitude = amplitude
}, getAmplitudeRate:function() {
  return this._amplitudeRate
}, setAmplitudeRate:function(amplitudeRate) {
  this._amplitudeRate = amplitudeRate
}, initWithDuration:function(duration, gridSize, position, radius, waves, amplitude) {
  if(this._super(duration, gridSize)) {
    this.setPosition(position);
    this._radius = radius;
    this._waves = waves;
    this._amplitude = amplitude;
    this._amplitudeRate = 1;
    return true
  }
  return false
}, update:function(time) {
  for(var i = 0;i < this._gridSize.width + 1;++i) {
    for(var j = 0;j < this._gridSize.height + 1;++j) {
      var v = this.originalVertex(cc.p(i, j));
      var vect = cc.pSub(this._position, cc.p(v.x, v.y));
      var r = cc.pLength(vect);
      if(r < this._radius) {
        r = this._radius - r;
        var rate = Math.pow(r / this._radius, 2);
        v.z += Math.sin(time * Math.PI * this._waves * 2 + r * 0.1) * this._amplitude * this._amplitudeRate * rate
      }
      this.setVertex(cc.p(i, j), v)
    }
  }
}});
cc.Ripple3D.create = function(duration, gridSize, position, radius, waves, amplitude) {
  var action = new cc.Ripple3D;
  action.initWithDuration(duration, gridSize, position, radius, waves, amplitude);
  return action
};
cc.Shaky3D = cc.Grid3DAction.extend({_randRange:null, _shakeZ:null, initWithDuration:function(duration, gridSize, range, shakeZ) {
  if(this._super(duration, gridSize)) {
    this._randRange = range;
    this._shakeZ = shakeZ;
    return true
  }
  return false
}, update:function(time) {
  for(var i = 0;i < this._gridSize.width + 1;++i) {
    for(var j = 0;j < this._gridSize.height + 1;++j) {
      var v = this.originalVertex(cc.p(i, j));
      v.x += cc.rand() % (this._randRange * 2) - this._randRange;
      v.y += cc.rand() % (this._randRange * 2) - this._randRange;
      if(this._shakeZ) {
        v.z += cc.rand() % (this._randRange * 2) - this._randRange
      }
      this.setVertex(cc.p(i, j), v)
    }
  }
}});
cc.Shaky3D.create = function(duration, gridSize, range, shakeZ) {
  var action = new cc.Shaky3D;
  action.initWithDuration(duration, gridSize, range, shakeZ);
  return action
};
cc.Liquid = cc.Grid3DAction.extend({_waves:null, _amplitude:null, _amplitudeRate:null, getAmplitude:function() {
  return this._amplitude
}, setAmplitude:function(amplitude) {
  this._amplitude = amplitude
}, getAmplitudeRate:function() {
  return this._amplitudeRate
}, setAmplitudeRate:function(amplitudeRate) {
  this._amplitudeRate = amplitudeRate
}, initWithDuration:function(duration, gridSize, waves, amplitude) {
  if(this._super(duration, gridSize)) {
    this._waves = waves;
    this._amplitude = amplitude;
    this._amplitudeRate = 1;
    return true
  }
  return false
}, update:function(time) {
  for(var i = 1;i < this._gridSize.width;++i) {
    for(var j = 1;j < this._gridSize.height;++j) {
      var v = this.originalVertex(cc.p(i, j));
      v.x = v.x + Math.sin(time * Math.PI * this._waves * 2 + v.x * 0.01) * this._amplitude * this._amplitudeRate;
      v.y = v.y + Math.sin(time * Math.PI * this._waves * 2 + v.y * 0.01) * this._amplitude * this._amplitudeRate;
      this.setVertex(cc.p(i, j), v)
    }
  }
}});
cc.Liquid.create = function(duration, gridSize, waves, amplitude) {
  var action = new cc.Liquid;
  action.initWithDuration(duration, gridSize, waves, amplitude);
  return action
};
cc.Waves = cc.Grid3DAction.extend({_waves:null, _amplitude:null, _amplitudeRate:null, _vertical:null, _horizontal:null, getAmplitude:function() {
  return this._amplitude
}, setAmplitude:function(amplitude) {
  this._amplitude = amplitude
}, getAmplitudeRate:function() {
  return this._amplitudeRate
}, setAmplitudeRate:function(amplitudeRate) {
  this._amplitudeRate = amplitudeRate
}, initWithDuration:function(duration, gridSize, waves, amplitude, horizontal, vertical) {
  if(this._super(duration, gridSize)) {
    this._waves = waves;
    this._amplitude = amplitude;
    this._amplitudeRate = 1;
    this._horizontal = horizontal;
    this._vertical = vertical;
    return true
  }
  return false
}, update:function(time) {
  for(var i = 0;i < this._gridSize.width + 1;++i) {
    for(var j = 0;j < this._gridSize.height + 1;++j) {
      var v = this.originalVertex(cc.p(i, j));
      if(this._vertical) {
        v.x = v.x + Math.sin(time * Math.PI * this._waves * 2 + v.y * 0.01) * this._amplitude * this._amplitudeRate
      }
      if(this._horizontal) {
        v.y = v.y + Math.sin(time * Math.PI * this._waves * 2 + v.x * 0.01) * this._amplitude * this._amplitudeRate
      }
      this.setVertex(cc.p(i, j), v)
    }
  }
}});
cc.Waves.create = function(duration, gridSize, waves, amplitude, horizontal, vertical) {
  var action = new cc.Waves;
  action.initWithDuration(duration, gridSize, waves, amplitude, horizontal, vertical);
  return action
};
cc.Twirl = cc.Grid3DAction.extend({_position:null, _twirls:null, _amplitude:null, _amplitudeRate:null, getPosition:function() {
  return this._position
}, setPosition:function(position) {
  this._position = position
}, getAmplitude:function() {
  return this._amplitude
}, setAmplitude:function(amplitude) {
  this._amplitude = amplitude
}, getAmplitudeRate:function() {
  return this._amplitudeRate
}, setAmplitudeRate:function(amplitudeRate) {
  this._amplitudeRate = amplitudeRate
}, initWithDuration:function(duration, gridSize, position, twirls, amplitude) {
  if(this._super(duration, gridSize)) {
    this.setPosition(position);
    this._twirls = twirls;
    this._amplitude = amplitude;
    this._amplitudeRate = 1;
    return true
  }
  return false
}, update:function(time) {
  var c = this._position;
  for(var i = 0;i < this._gridSize.width + 1;++i) {
    for(var j = 0;j < this._gridSize.height + 1;++j) {
      var v = this.originalVertex(cc.p(i, j));
      var avg = cc.p(i - this._gridSize.width / 2, j - this._gridSize.height / 2);
      var amp = 0.1 * this._amplitude * this._amplitudeRate;
      var a = cc.pLength(avg) * Math.cos(Math.PI / 2 + time * Math.PI * this._twirls * 2) * amp;
      var d = cc.p(Math.sin(a) * (v.y - c.y) + Math.cos(a) * (v.x - c.x), Math.cos(a) * (v.y - c.y) - Math.sin(a) * (v.x - c.x));
      v.x = c.x + d.x;
      v.y = c.y + d.y;
      this.setVertex(cc.p(i, j), v)
    }
  }
}});
cc.Twirl.create = function(duration, gridSize, position, twirls, amplitude) {
  var action = new cc.Twirl;
  action.initWithDuration(duration, gridSize, position, twirls, amplitude);
  return action
};
cc.ShakyTiles3D = cc.TiledGrid3DAction.extend({_randRange:0, _shakeZ:false, initWithDuration:function(duration, gridSize, range, shakeZ) {
  if(this._super(duration, gridSize)) {
    this._randRange = range;
    this._shakeZ = shakeZ;
    return true
  }
  return false
}, update:function(time) {
  for(var i = 0;i < this._gridSize.width;++i) {
    for(var j = 0;j < this._gridSize.height;++j) {
      var coords = this.originalTile(cc.p(i, j));
      coords.bl.x += cc.rand() % (this._randRange * 2) - this._randRange;
      coords.br.x += cc.rand() % (this._randRange * 2) - this._randRange;
      coords.tl.x += cc.rand() % (this._randRange * 2) - this._randRange;
      coords.tr.x += cc.rand() % (this._randRange * 2) - this._randRange;
      coords.bl.y += cc.rand() % (this._randRange * 2) - this._randRange;
      coords.br.y += cc.rand() % (this._randRange * 2) - this._randRange;
      coords.tl.y += cc.rand() % (this._randRange * 2) - this._randRange;
      coords.tr.y += cc.rand() % (this._randRange * 2) - this._randRange;
      if(this._shakeZ) {
        coords.bl.z += cc.rand() % (this._randRange * 2) - this._randRange;
        coords.br.z += cc.rand() % (this._randRange * 2) - this._randRange;
        coords.tl.z += cc.rand() % (this._randRange * 2) - this._randRange;
        coords.tr.z += cc.rand() % (this._randRange * 2) - this._randRange
      }
      this.setTile(cc.p(i, j), coords)
    }
  }
}});
cc.ShakyTiles3D.create = function(duration, gridSize, range, shakeZ) {
  var action = new cc.ShakyTiles3D;
  action.initWithDuration(duration, gridSize, range, shakeZ);
  return action
};
cc.ShatteredTiles3D = cc.TiledGrid3DAction.extend({_randRange:0, _once:false, _shatterZ:false, initWithDuration:function(duration, gridSize, range, shatterZ) {
  if(this._super(duration, gridSize)) {
    this._once = false;
    this._randRange = range;
    this._shatterZ = shatterZ;
    return true
  }
  return false
}, update:function(time) {
  if(this._once === false) {
    for(var i = 0;i < this._gridSize.width;++i) {
      for(var j = 0;j < this._gridSize.height;++j) {
        var coords = this.originalTile(cc.p(i, j));
        coords.bl.x += cc.rand() % (this._randRange * 2) - this._randRange;
        coords.br.x += cc.rand() % (this._randRange * 2) - this._randRange;
        coords.tl.x += cc.rand() % (this._randRange * 2) - this._randRange;
        coords.tr.x += cc.rand() % (this._randRange * 2) - this._randRange;
        coords.bl.y += cc.rand() % (this._randRange * 2) - this._randRange;
        coords.br.y += cc.rand() % (this._randRange * 2) - this._randRange;
        coords.tl.y += cc.rand() % (this._randRange * 2) - this._randRange;
        coords.tr.y += cc.rand() % (this._randRange * 2) - this._randRange;
        if(this._shatterZ) {
          coords.bl.z += cc.rand() % (this._randRange * 2) - this._randRange;
          coords.br.z += cc.rand() % (this._randRange * 2) - this._randRange;
          coords.tl.z += cc.rand() % (this._randRange * 2) - this._randRange;
          coords.tr.z += cc.rand() % (this._randRange * 2) - this._randRange
        }
        this.setTile(cc.p(i, j), coords)
      }
    }
    this._once = true
  }
}});
cc.ShatteredTiles3D.create = function(duration, gridSize, range, shatterZ) {
  var action = new cc.ShatteredTiles3D;
  action.initWithDuration(duration, gridSize, range, shatterZ);
  return action
};
cc.Tile = function(position, startPosition, delta) {
  this.position = position || cc.POINT_ZERO;
  this.startPosition = startPosition || cc.POINT_ZERO;
  this.delta = delta || cc.POINT_ZERO
};
cc.ShuffleTiles = cc.TiledGrid3DAction.extend({_seed:0, _tilesCount:0, _tilesOrder:null, _tiles:null, ctor:function() {
  this._tilesOrder = [];
  this._tiles = []
}, initWithDuration:function(duration, gridSize, seed) {
  if(this._super(duration, gridSize)) {
    this._seed = seed;
    this._tilesOrder = null;
    this._tiles = null;
    return true
  }
  return false
}, shuffle:function(array, len) {
  for(var i = len - 1;i >= 0;i--) {
    var j = 0 | cc.rand() % (i + 1);
    var v = array[i];
    array[i] = array[j];
    array[j] = v
  }
}, getDelta:function(pos) {
  var idx = pos.width * this._gridSize.height + pos.height;
  return cc.SizeMake(this._tilesOrder[idx] / this._gridSize.height - pos.width, this._tilesOrder[idx] % this._gridSize.height - pos.height)
}, placeTile:function(pos, tile) {
  var coords = this.originalTile(pos);
  var step = this._target.getGrid().getStep();
  coords.bl.x += tile.position.x * step.x;
  coords.bl.y += tile.position.y * step.y;
  coords.br.x += tile.position.x * step.x;
  coords.br.y += tile.position.y * step.y;
  coords.tl.x += tile.position.x * step.x;
  coords.tl.y += tile.position.y * step.y;
  coords.tr.x += tile.position.x * step.x;
  coords.tr.y += tile.position.y * step.y;
  this.setTile(pos, coords)
}, startWithTarget:function(target) {
  this._super(target);
  this._tilesCount = this._gridSize.width * this._gridSize.height;
  this._tilesOrder = [];
  for(var k = 0;k < this._tilesCount;++k) {
    this._tilesOrder[k] = k
  }
  this.shuffle(this._tilesOrder, this._tilesCount);
  this._tiles = [];
  var tileIndex = 0;
  for(var i = 0;i < this._gridSize.width;++i) {
    for(var j = 0;j < this._gridSize.height;++j) {
      this._tiles[tileIndex] = new cc.Tile;
      this._tiles[tileIndex].position = cc.p(i, j);
      this._tiles[tileIndex].startPosition = cc.p(i, j);
      this._tiles[tileIndex].delta = this.getDelta(cc.SizeMake(i, j));
      ++tileIndex
    }
  }
}, update:function(time) {
  var tileIndex = 0;
  for(var i = 0;i < this._gridSize.width;++i) {
    for(var j = 0;j < this._gridSize.height;++j) {
      var selTile = this._tiles[tileIndex];
      selTile.position = cc.pMult(cc.p(selTile.delta.width, selTile.delta.height), time);
      this.placeTile(cc.p(i, j), selTile);
      ++tileIndex
    }
  }
}});
cc.ShuffleTiles.create = function(duration, gridSize, seed) {
  var action = new cc.ShuffleTiles;
  action.initWithDuration(duration, gridSize, seed);
  return action
};
cc.FadeOutTRTiles = cc.TiledGrid3DAction.extend({testFunc:function(pos, time) {
  var n = cc.pMult(cc.p(this._gridSize.width, this._gridSize.height), time);
  if(n.x + n.y == 0) {
    return 1
  }
  return Math.pow((pos.width + pos.height) / (n.x + n.y), 6)
}, turnOnTile:function(pos) {
  this.setTile(pos, this.originalTile(pos))
}, turnOffTile:function(pos) {
  this.setTile(pos, new cc.Quad3)
}, transformTile:function(pos, distance) {
  var coords = this.originalTile(pos);
  var step = this._target.getGrid().getStep();
  coords.bl.x += step.x / 2 * (1 - distance);
  coords.bl.y += step.y / 2 * (1 - distance);
  coords.br.x -= step.x / 2 * (1 - distance);
  coords.br.y += step.y / 2 * (1 - distance);
  coords.tl.x += step.x / 2 * (1 - distance);
  coords.tl.y -= step.y / 2 * (1 - distance);
  coords.tr.x -= step.x / 2 * (1 - distance);
  coords.tr.y -= step.y / 2 * (1 - distance);
  this.setTile(pos, coords)
}, update:function(time) {
  for(var i = 0;i < this._gridSize.width;++i) {
    for(var j = 0;j < this._gridSize.height;++j) {
      var distance = this.testFunc(cc.SizeMake(i, j), time);
      if(distance == 0) {
        this.turnOffTile(cc.p(i, j))
      }else {
        if(distance < 1) {
          this.transformTile(cc.p(i, j), distance)
        }else {
          this.turnOnTile(cc.p(i, j))
        }
      }
    }
  }
}});
cc.FadeOutTRTiles.create = function(duration, gridSize) {
  var action = new cc.FadeOutTRTiles;
  action.initWithDuration(duration, gridSize);
  return action
};
cc.FadeOutBLTiles = cc.FadeOutTRTiles.extend({testFunc:function(pos, time) {
  var n = cc.pMult(cc.p(this._gridSize.width, this._gridSize.height), 1 - time);
  if(pos.width + pos.height == 0) {
    return 1
  }
  return Math.pow((n.x + n.y) / (pos.width + pos.height), 6)
}});
cc.FadeOutBLTiles.create = function(duration, gridSize) {
  var action = new cc.FadeOutBLTiles;
  action.initWithDuration(duration, gridSize);
  return action
};
cc.FadeOutUpTiles = cc.FadeOutTRTiles.extend({testFunc:function(pos, time) {
  var n = cc.pMult(cc.p(this._gridSize.width, this._gridSize.height), time);
  if(n.y == 0) {
    return 1
  }
  return Math.pow(pos.height / n.y, 6)
}, transformTile:function(pos, distance) {
  var coords = this.originalTile(pos);
  var step = this._target.getGrid().getStep();
  coords.bl.y += step.y / 2 * (1 - distance);
  coords.br.y += step.y / 2 * (1 - distance);
  coords.tl.y -= step.y / 2 * (1 - distance);
  coords.tr.y -= step.y / 2 * (1 - distance);
  this.setTile(pos, coords)
}});
cc.FadeOutUpTiles.create = function(duration, gridSize) {
  var action = new cc.FadeOutUpTiles;
  action.initWithDuration(duration, gridSize);
  return action
};
cc.FadeOutDownTiles = cc.FadeOutUpTiles.extend({testFunc:function(pos, time) {
  var n = cc.pMult(cc.p(this._gridSize.width, this._gridSize.height), 1 - time);
  if(pos.height == 0) {
    return 1
  }
  return Math.pow(n.y / pos.height, 6)
}});
cc.FadeOutDownTiles.create = function(duration, gridSize) {
  var action = new cc.FadeOutDownTiles;
  action.initWithDuration(duration, gridSize);
  return action
};
cc.TurnOffTiles = cc.TiledGrid3DAction.extend({_seed:null, _tilesCount:0, _tilesOrder:null, ctor:function() {
  this._tilesOrder = []
}, initWithDuration:function(duration, gridSize, seed) {
  if(this._super(duration, gridSize)) {
    this._seed = seed;
    this._tilesOrder = null;
    return true
  }
  return false
}, shuffle:function(array, len) {
  for(var i = len - 1;i >= 0;i--) {
    var j = 0 | cc.rand() % (i + 1);
    var v = array[i];
    array[i] = array[j];
    array[j] = v
  }
}, turnOnTile:function(pos) {
  this.setTile(pos, this.originalTile(pos))
}, turnOffTile:function(pos) {
  this.setTile(pos, new cc.Quad3)
}, startWithTarget:function(target) {
  this._super(target);
  this._tilesCount = this._gridSize.width * this._gridSize.height;
  this._tilesOrder = [];
  for(var i = 0;i < this._tilesCount;++i) {
    this._tilesOrder[i] = i
  }
  this.shuffle(this._tilesOrder, this._tilesCount)
}, update:function(time) {
  var l = 0 | time * this._tilesCount;
  for(var i = 0;i < this._tilesCount;i++) {
    var t = this._tilesOrder[i];
    var tilePos = cc.p(0 | t / this._gridSize.height, t % (0 | this._gridSize.height));
    if(i < l) {
      this.turnOffTile(tilePos)
    }else {
      this.turnOnTile(tilePos)
    }
  }
}});
cc.TurnOffTiles.create = function(duration, gridSize, seed) {
  seed = seed || 0;
  var action = new cc.TurnOffTiles;
  action.initWithDuration(duration, gridSize, seed);
  return action
};
cc.WavesTiles3D = cc.TiledGrid3DAction.extend({_waves:0, _amplitude:0, _amplitudeRate:0, getAmplitude:function() {
  return this._amplitude
}, setAmplitude:function(amplitude) {
  this._amplitude = amplitude
}, getAmplitudeRate:function() {
  return this._amplitudeRate
}, setAmplitudeRate:function(amplitudeRate) {
  this._amplitudeRate = amplitudeRate
}, initWithDuration:function(duration, gridSize, waves, amplitude) {
  if(this._super(duration, gridSize)) {
    this._waves = waves;
    this._amplitude = amplitude;
    this._amplitudeRate = 1;
    return true
  }
  return false
}, update:function(time) {
  for(var i = 0;i < this._gridSize.width;i++) {
    for(var j = 0;j < this._gridSize.height;j++) {
      var coords = this.originalTile(cc.p(i, j));
      coords.bl.z = Math.sin(time * Math.PI * this._waves * 2 + (coords.bl.y + coords.bl.x) * 0.01) * this._amplitude * this._amplitudeRate;
      coords.br.z = coords.bl.z;
      coords.tl.z = coords.bl.z;
      coords.tr.z = coords.bl.z;
      this.setTile(cc.p(i, j), coords)
    }
  }
}});
cc.WavesTiles3D.create = function(duration, gridSize, waves, amplitude) {
  var action = new cc.WavesTiles3D;
  action.initWithDuration(duration, gridSize, waves, amplitude);
  return action
};
cc.JumpTiles3D = cc.TiledGrid3DAction.extend({_jumps:0, _amplitude:0, _amplitudeRate:0, getAmplitude:function() {
  return this._amplitude
}, setAmplitude:function(amplitude) {
  this._amplitude = amplitude
}, getAmplitudeRate:function() {
  return this._amplitudeRate
}, setAmplitudeRate:function(amplitudeRate) {
  this._amplitudeRate = amplitudeRate
}, initWithDuration:function(duration, gridSize, numberOfJumps, amplitude) {
  if(this._super(duration, gridSize)) {
    this._jumps = numberOfJumps;
    this._amplitude = amplitude;
    this._amplitudeRate = 1;
    return true
  }
  return false
}, update:function(time) {
  var sinz = Math.sin(Math.PI * time * this._jumps * 2) * this._amplitude * this._amplitudeRate;
  var sinz2 = Math.sin(Math.PI * (time * this._jumps * 2 + 1)) * this._amplitude * this._amplitudeRate;
  for(var i = 0;i < this._gridSize.width;i++) {
    for(var j = 0;j < this._gridSize.height;j++) {
      var coords = this.originalTile(cc.p(i, j));
      if((i + j) % 2 == 0) {
        coords.bl.z += sinz;
        coords.br.z += sinz;
        coords.tl.z += sinz;
        coords.tr.z += sinz
      }else {
        coords.bl.z += sinz2;
        coords.br.z += sinz2;
        coords.tl.z += sinz2;
        coords.tr.z += sinz2
      }
      this.setTile(cc.p(i, j), coords)
    }
  }
}});
cc.JumpTiles3D.create = function(duration, gridSize, numberOfJumps, amplitude) {
  var action = new cc.JumpTiles3D;
  action.initWithDuration(duration, gridSize, numberOfJumps, amplitude);
  return action
};
cc.SplitRows = cc.TiledGrid3DAction.extend({_rows:0, _winSize:null, initWithDuration:function(duration, rows) {
  this._rows = rows;
  return this._super(duration, cc.SizeMake(1, this._rows))
}, update:function(time) {
  for(var j = 0;j < this._gridSize.height;++j) {
    var coords = this.originalTile(cc.p(0, j));
    var direction = 1;
    if(j % 2 == 0) {
      direction = -1
    }
    coords.bl.x += direction * this._winSize.width * time;
    coords.br.x += direction * this._winSize.width * time;
    coords.tl.x += direction * this._winSize.width * time;
    coords.tr.x += direction * this._winSize.width * time;
    this.setTile(cc.p(0, j), coords)
  }
}, startWithTarget:function(target) {
  this._super(target);
  this._winSize = cc.Director.getInstance().getWinSizeInPixels()
}});
cc.SplitRows.create = function(duration, rows) {
  var action = new cc.SplitRows;
  action.initWithDuration(duration, rows);
  return action
};
cc.SplitCols = cc.TiledGrid3DAction.extend({_cols:0, _winSize:null, initWithDuration:function(duration, cols) {
  this._cols = cols;
  return this._super(duration, cc.SizeMake(this._cols, 1))
}, update:function(time) {
  for(var i = 0;i < this._gridSize.width;++i) {
    var coords = this.originalTile(cc.p(i, 0));
    var direction = 1;
    if(i % 2 == 0) {
      direction = -1
    }
    coords.bl.y += direction * this._winSize.height * time;
    coords.br.y += direction * this._winSize.height * time;
    coords.tl.y += direction * this._winSize.height * time;
    coords.tr.y += direction * this._winSize.height * time;
    this.setTile(cc.p(i, 0), coords)
  }
}, startWithTarget:function(target) {
  this._super(target);
  this._winSize = cc.Director.getInstance().getWinSizeInPixels()
}});
cc.SplitCols.create = function(duration, cols) {
  var action = new cc.SplitCols;
  action.initWithDuration(duration, cols);
  return action
};
cc.CardinalSplineAt = function(p0, p1, p2, p3, tension, t) {
  var t2 = t * t;
  var t3 = t2 * t;
  var s = (1 - tension) / 2;
  var b1 = s * (-t3 + 2 * t2 - t);
  var b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
  var b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
  var b4 = s * (t3 - t2);
  var x = p0.x * b1 + p1.x * b2 + p2.x * b3 + p3.x * b4;
  var y = p0.y * b1 + p1.y * b2 + p2.y * b3 + p3.y * b4;
  return cc.p(x, y)
};
cc.reverseControlPoints = function(controlPoints) {
  var newArray = [];
  for(var i = controlPoints.length - 1;i >= 0;i--) {
    newArray.push(cc.p(controlPoints[i].x, controlPoints[i].y))
  }
  return newArray
};
cc.getControlPointAt = function(controlPoints, pos) {
  var p = Math.min(controlPoints.length - 1, Math.max(pos, 0));
  return controlPoints[p]
};
cc.reverseControlPointsInline = function(controlPoints) {
  var len = controlPoints.length;
  var mid = 0 | len / 2;
  for(var i = 0;i < mid;++i) {
    var temp = controlPoints[i];
    controlPoints[i] = controlPoints[len - i - 1];
    controlPoints[len - i - 1] = temp
  }
};
cc.CardinalSplineTo = cc.ActionInterval.extend({_points:null, _deltaT:0, _tension:0, ctor:function() {
  this._points = []
}, initWithDuration:function(duration, points, tension) {
  cc.Assert(points.length > 0, "Invalid configuration. It must at least have one control point");
  if(this._super(duration)) {
    this.setPoints(points);
    this._tension = tension;
    return true
  }
  return false
}, startWithTarget:function(target) {
  this._super(target);
  this._deltaT = 1 / (this._points.length - 1);
  this._previousPosition = this._target.getPosition();
  this._accumulatedDiff = cc.p(0, 0)
}, update:function(time) {
  var p, lt;
  if(time == 1) {
    p = this._points.length - 1;
    lt = 1
  }else {
    p = 0 | time / this._deltaT;
    lt = (time - this._deltaT * p) / this._deltaT
  }
  var newPos = cc.CardinalSplineAt(cc.getControlPointAt(this._points, p - 1), cc.getControlPointAt(this._points, p - 0), cc.getControlPointAt(this._points, p + 1), cc.getControlPointAt(this._points, p + 2), this._tension, lt);
  var node = this._target;
  var diff = cc.pSub(node.getPosition(), this._previousPosition);
  if(diff.x != 0 || diff.y != 0) {
    this._accumulatedDiff = cc.pAdd(this._accumulatedDiff, diff);
    newPos = cc.pAdd(newPos, this._accumulatedDiff)
  }
  this.updatePosition(newPos)
}, reverse:function() {
  var reversePoints = cc.reverseControlPoints(this._points);
  return cc.CardinalSplineTo.create(this._duration, reversePoints, this._tension)
}, updatePosition:function(newPos) {
  this._target.setPosition(newPos);
  this._previousPosition = newPos
}, getPoints:function() {
  return this._points
}, setPoints:function(points) {
  this._points = points
}});
cc.CardinalSplineTo.create = function(duration, points, tension) {
  var ret = new cc.CardinalSplineTo;
  if(ret.initWithDuration(duration, points, tension)) {
    return ret
  }
  return null
};
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({_startPosition:null, ctor:function() {
  this._startPosition = cc.p(0, 0)
}, startWithTarget:function(target) {
  this._super(target);
  this._startPosition = target.getPosition()
}, reverse:function() {
  var copyConfig = this._points.slice();
  var current;
  var p = copyConfig[0];
  for(var i = 1;i < copyConfig.length;++i) {
    current = copyConfig[i];
    var diff = cc.pSub(current, p);
    copyConfig[i] = diff;
    p = current
  }
  var reverseArray = cc.reverseControlPoints(copyConfig);
  p = reverseArray[reverseArray.length - 1];
  reverseArray.pop();
  p = cc.pNeg(p);
  reverseArray.unshift(p);
  for(i = 1;i < reverseArray.length;++i) {
    current = reverseArray[i];
    current = cc.pNeg(current);
    var abs = cc.pAdd(current, p);
    reverseArray[i] = abs;
    p = abs
  }
  return cc.CardinalSplineBy.create(this._duration, reverseArray, this._tension)
}, updatePosition:function(newPos) {
  var p = cc.pAdd(newPos, this._startPosition);
  this._target.setPosition(p);
  this._previousPosition = p
}});
cc.CardinalSplineBy.create = function(duration, points, tension) {
  var ret = new cc.CardinalSplineBy;
  if(ret.initWithDuration(duration, points, tension)) {
    return ret
  }
  return null
};
cc.CatmullRomTo = cc.CardinalSplineTo.extend({initWithDuration:function(dt, points) {
  return this._super(dt, points, 0.5)
}});
cc.CatmullRomTo.create = function(dt, points) {
  var ret = new cc.CatmullRomTo;
  if(ret.initWithDuration(dt, points)) {
    return ret
  }
  return null
};
cc.CatmullRomBy = cc.CardinalSplineBy.extend({initWithDuration:function(dt, points) {
  return this._super(dt, points, 0.5)
}});
cc.CatmullRomBy.create = function(dt, points) {
  var ret = new cc.CatmullRomBy;
  if(ret.initWithDuration(dt, points)) {
    return ret
  }
  return null
};
cc.PageTurn3D = cc.Grid3DAction.extend({update:function(time) {
  var tt = Math.max(0, time - 0.25);
  var deltaAy = tt * tt * 500;
  var ay = -100 - deltaAy;
  var deltaTheta = -Math.PI / 2 * Math.sqrt(time);
  var theta = +Math.PI / 2 + deltaTheta;
  var sinTheta = Math.sin(theta);
  var cosTheta = Math.cos(theta);
  for(var i = 0;i <= this._gridSize.width;++i) {
    for(var j = 0;j <= this._gridSize.height;++j) {
      var p = this.originalVertex(cc.p(i, j));
      var R = Math.sqrt(p.x * p.x + (p.y - ay) * (p.y - ay));
      var r = R * sinTheta;
      var alpha = Math.asin(p.x / R);
      var beta = alpha / sinTheta;
      var cosBeta = Math.cos(beta);
      if(beta <= Math.PI) {
        p.x = r * Math.sin(beta)
      }else {
        p.x = 0
      }
      p.y = R + ay - r * (1 - cosBeta) * sinTheta;
      p.z = r * (1 - cosBeta) * cosTheta / 7;
      if(p.z < 0.5) {
        p.z = 0.5
      }
      this.setVertex(cc.p(i, j), p)
    }
  }
}});
cc.PageTurn3D.create = function(duration, gridSize) {
  var action = new cc.PageTurn3D;
  action.initWithDuration(duration, gridSize);
  return action
};
cc.Scene = cc.Node.extend({ctor:function() {
  this._super();
  this._ignoreAnchorPointForPosition = true;
  this.setAnchorPoint(cc.p(0.5, 0.5));
  this.setContentSize(cc.Director.getInstance().getWinSize())
}});
cc.Scene.create = function() {
  var scene = new cc.Scene;
  scene.init();
  return scene
};
cc.TOUCH_ALL_AT_ONCE = 0;
cc.TOUCH_ONE_BY_ONE = 1;
cc.Layer = cc.Node.extend({_isTouchEnabled:false, _isAccelerometerEnabled:false, _isKeyboardEnabled:false, _touchPriority:0, _touchMode:cc.TOUCH_ALL_AT_ONCE, _isMouseEnabled:false, _mousePriority:0, _initLayer:function() {
  this.setAnchorPoint(cc.p(0.5, 0.5));
  this._ignoreAnchorPointForPosition = true;
  var director = cc.Director.getInstance();
  this.setContentSize(director.getWinSize());
  this._isTouchEnabled = false;
  this._isAccelerometerEnabled = false;
  this._isMouseEnabled = false;
  this._touchMode = cc.TOUCH_ALL_AT_ONCE;
  this._touchPriority = 0
}, init:function() {
  this._super();
  this._initLayer();
  return true
}, registerWithTouchDispatcher:function() {
  if(this._touchMode === cc.TOUCH_ALL_AT_ONCE) {
    cc.Director.getInstance().getTouchDispatcher().addStandardDelegate(this, this._touchPriority)
  }else {
    cc.Director.getInstance().getTouchDispatcher().addTargetedDelegate(this, this._touchPriority, true)
  }
}, isMouseEnabled:function() {
  return this._isMouseEnabled
}, setMouseEnabled:function(enabled) {
  if(this._isMouseEnabled != enabled) {
    this._isMouseEnabled = enabled;
    if(this._running) {
      if(enabled) {
        cc.Director.getInstance().getMouseDispatcher().addMouseDelegate(this, this._mousePriority)
      }else {
        cc.Director.getInstance().getMouseDispatcher().removeMouseDelegate(this)
      }
    }
  }
}, setMousePriority:function(priority) {
  if(this._mousePriority !== priority) {
    this._mousePriority = priority;
    if(this._isMouseEnabled) {
      this.setMouseEnabled(false);
      this.setMouseEnabled(true)
    }
  }
}, getMousePriority:function() {
  return this._mousePriority
}, isTouchEnabled:function() {
  return this._isTouchEnabled
}, setTouchEnabled:function(enabled) {
  if(this._isTouchEnabled !== enabled) {
    this._isTouchEnabled = enabled;
    if(this._running) {
      if(enabled) {
        this.registerWithTouchDispatcher()
      }else {
        cc.Director.getInstance().getTouchDispatcher().removeDelegate(this)
      }
    }
  }
}, getTouchPriority:function() {
  return this._touchPriority
}, setTouchPriority:function(priority) {
  if(this._touchPriority !== priority) {
    this._touchPriority = priority;
    if(this._isTouchEnabled) {
      this.setTouchEnabled(false);
      this.setTouchEnabled(true)
    }
  }
}, getTouchMode:function() {
  return this._touchMode
}, setTouchMode:function(mode) {
  if(this._touchMode !== mode) {
    this._touchMode = mode;
    if(this._isTouchEnabled) {
      this.setTouchEnabled(false);
      this.setTouchEnabled(true)
    }
  }
}, isAccelerometerEnabled:function() {
  return this._isAccelerometerEnabled
}, setAccelerometerEnabled:function(enabled) {
  if(enabled !== this._isAccelerometerEnabled) {
    this._isAccelerometerEnabled = enabled;
    if(this._running) {
      var director = cc.Director.getInstance();
      if(enabled) {
        director.getAccelerometer().setDelegate(this)
      }else {
        director.getAccelerometer().setDelegate(null)
      }
    }
  }
}, setAccelerometerInterval:function(interval) {
  if(this._isAccelerometerEnabled) {
    if(this._running) {
      var director = cc.Director.getInstance();
      director.getAccelerometer().setAccelerometerInterval(interval)
    }
  }
}, onAccelerometer:function(accelerationValue) {
}, isKeyboardEnabled:function() {
  return this._isKeyboardEnabled
}, setKeyboardEnabled:function(enabled) {
  if(enabled !== this._isKeyboardEnabled) {
    this._isKeyboardEnabled = enabled;
    if(this._running) {
      var director = cc.Director.getInstance();
      if(enabled) {
        director.getKeyboardDispatcher().addDelegate(this)
      }else {
        director.getKeyboardDispatcher().removeDelegate(this)
      }
    }
  }
}, onEnter:function() {
  var director = cc.Director.getInstance();
  if(this._isTouchEnabled) {
    this.registerWithTouchDispatcher()
  }
  this._super();
  if(this._isAccelerometerEnabled) {
    director.getAccelerometer().setDelegate(this)
  }
  if(this._isKeyboardEnabled) {
    director.getKeyboardDispatcher().addDelegate(this)
  }
  if(this._isMouseEnabled) {
    director.getMouseDispatcher().addMouseDelegate(this, this._mousePriority)
  }
}, onExit:function() {
  var director = cc.Director.getInstance();
  if(this._isTouchEnabled) {
    director.getTouchDispatcher().removeDelegate(this)
  }
  if(this._isAccelerometerEnabled) {
    director.getAccelerometer().setDelegate(null)
  }
  if(this._isKeyboardEnabled) {
    director.getKeyboardDispatcher().removeDelegate(this)
  }
  if(this._isMouseEnabled) {
    director.getMouseDispatcher().removeMouseDelegate(this)
  }
  this._super()
}, onEnterTransitionDidFinish:function() {
  if(this._isAccelerometerEnabled) {
    cc.Director.getInstance().getAccelerometer().setDelegate(this)
  }
  this._super()
}, onTouchBegan:function(touch, event) {
  cc.Assert(false, "Layer#onTouchBegan override me");
  return true
}, onTouchMoved:function(touch, event) {
}, onTouchEnded:function(touch, event) {
}, onTouchCancelled:function(touch, event) {
}, onTouchesBegan:function(touch, event) {
}, onTouchesMoved:function(touch, event) {
}, onTouchesEnded:function(touch, event) {
}, onTouchesCancelled:function(touch, event) {
}, onMouseDown:function(event) {
  return false
}, onMouseDragged:function(event) {
  return false
}, onMouseMoved:function(event) {
  return false
}, onMouseUp:function(event) {
  return false
}, onRightMouseDown:function(event) {
  return false
}, onRightMouseDragged:function(event) {
  return false
}, onRightMouseUp:function(event) {
  return false
}, onOtherMouseDown:function(event) {
  return false
}, onOtherMouseDragged:function(event) {
  return false
}, onOtherMouseUp:function(event) {
  return false
}, onScrollWheel:function(event) {
  return false
}, onMouseEntered:function(theEvent) {
  return false
}, onMouseExited:function(theEvent) {
  return false
}, onKeyDown:function(keyCode) {
}, onKeyUp:function(keyCode) {
}});
cc.Layer.create = function() {
  var ret = new cc.Layer;
  if(ret && ret.init()) {
    return ret
  }
  return null
};
cc._LayerColorBaseProperties = {};
cc.LayerColorCanvas = cc.Layer.extend({RGBAProtocol:true, _opacity:0, _color:null, _blendFunc:null, getOpacity:function() {
  return this._opacity
}, getColor:function() {
  return this._color
}, getBlendFunc:function() {
  return this._blendFunc
}, changeWidthAndHeight:function(w, h) {
  this.setContentSize(cc.size(w, h))
}, changeWidth:function(w) {
  this.setContentSize(cc.size(w, this._contentSize.height))
}, changeHeight:function(h) {
  this.setContentSize(cc.size(this._contentSize.width, h))
}, setOpacity:function(Var) {
  this._opacity = Var;
  this._updateColor();
  this.setNodeDirty()
}, setColor:function(Var) {
  this._color = Var;
  this._updateColor();
  this.setNodeDirty()
}, setOpacityModifyRGB:function(value) {
}, isOpacityModifyRGB:function() {
  return false
}, _updateColor:function() {
}, _isLighterMode:false, ctor:function() {
  this._super();
  this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
  this._color = new cc.Color4B(0, 0, 0, 0);
  this._opacity = 255
}, setBlendFunc:function(src, dst) {
  if(arguments.length == 1) {
    this._blendFunc = src
  }else {
    this._blendFunc = {src:src, dst:dst}
  }
  this._isLighterMode = this._blendFunc && this._blendFunc.src == 1 && this._blendFunc.dst == 771
}, init:function(color, width, height) {
  this._initLayer();
  var winSize = cc.Director.getInstance().getWinSize();
  color = color || new cc.Color4B(0, 0, 0, 255);
  width = width || winSize.width;
  height = height || winSize.height;
  this._color = new cc.Color3B(color.r, color.g, color.b);
  this._opacity = color.a;
  this.setContentSize(cc.size(width, height));
  this._updateColor();
  return true
}, draw:function(ctx) {
  var context = ctx || cc.renderContext;
  var tWidth = this.getContentSize().width;
  var tHeight = this.getContentSize().height;
  context.fillStyle = "rgba(" + (0 | this._color.r) + "," + (0 | this._color.g) + "," + (0 | this._color.b) + "," + this.getOpacity() / 255 + ")";
  context.fillRect(0, 0, tWidth, -tHeight);
  cc.INCREMENT_GL_DRAWS(1)
}});
cc.LayerColorCanvas.create = function(color, width, height) {
  var ret = new cc.LayerColorCanvas;
  switch(arguments.length) {
    case 0:
      ret.init();
      break;
    case 1:
      ret.init(color);
      break;
    case 3:
      ret.init(color, width, height);
      break;
    default:
      ret.init();
      break
  }
  return ret
};
cc.LayerColorWebGL = cc.Layer.extend({RGBAProtocol:true, _opacity:0, _color:null, _blendFunc:null, getOpacity:function() {
  return this._opacity
}, getColor:function() {
  return this._color
}, getBlendFunc:function() {
  return this._blendFunc
}, changeWidthAndHeight:function(w, h) {
  this.setContentSize(cc.size(w, h))
}, changeWidth:function(w) {
  this.setContentSize(cc.size(w, this._contentSize.height))
}, changeHeight:function(h) {
  this.setContentSize(cc.size(this._contentSize.width, h))
}, setOpacity:function(Var) {
  this._opacity = Var;
  this._updateColor();
  this.setNodeDirty()
}, setColor:function(Var) {
  this._color = Var;
  this._updateColor();
  this.setNodeDirty()
}, setOpacityModifyRGB:function(value) {
}, isOpacityModifyRGB:function() {
  return false
}, _squareVertices:null, _squareColors:null, _verticesFloat32Buffer:null, _colorsUint8Buffer:null, _squareVerticesAB:null, _squareColorsAB:null, ctor:function() {
  this._super();
  this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
  this._color = new cc.Color4B(0, 0, 0, 0);
  this._opacity = 255;
  this._squareVerticesAB = new ArrayBuffer(32);
  this._squareColorsAB = new ArrayBuffer(64);
  this._squareVertices = [new cc.Vertex2F(0, 0, this._squareVerticesAB, 0), new cc.Vertex2F(0, 0, this._squareVerticesAB, cc.Vertex2F.BYTES_PER_ELEMENT), new cc.Vertex2F(0, 0, this._squareVerticesAB, cc.Vertex2F.BYTES_PER_ELEMENT * 2), new cc.Vertex2F(0, 0, this._squareVerticesAB, cc.Vertex2F.BYTES_PER_ELEMENT * 3)];
  this._squareColors = [new cc.Color4F(0, 0, 0, 1, this._squareColorsAB, 0), new cc.Color4F(0, 0, 0, 1, this._squareColorsAB, cc.Color4F.BYTES_PER_ELEMENT), new cc.Color4F(0, 0, 0, 1, this._squareColorsAB, cc.Color4F.BYTES_PER_ELEMENT * 2), new cc.Color4F(0, 0, 0, 1, this._squareColorsAB, cc.Color4F.BYTES_PER_ELEMENT * 3)];
  this._verticesFloat32Buffer = cc.renderContext.createBuffer();
  this._colorsUint8Buffer = cc.renderContext.createBuffer()
}, setBlendFunc:function(src, dst) {
  if(arguments.length == 1) {
    this._blendFunc = src
  }else {
    this._blendFunc = {src:src, dst:dst}
  }
}, init:function(color, width, height) {
  this._initLayer();
  this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_COLOR));
  var winSize = cc.Director.getInstance().getWinSize();
  color = color || new cc.Color4B(0, 0, 0, 255);
  width = width || winSize.width;
  height = height || winSize.height;
  this._color = new cc.Color3B(color.r, color.g, color.b);
  this._opacity = color.a;
  this.setContentSize(cc.size(width, height));
  this._updateColor();
  return true
}, setContentSize:function(size) {
  this._squareVertices[1].x = size.width;
  this._squareVertices[2].y = size.height;
  this._squareVertices[3].x = size.width;
  this._squareVertices[3].y = size.height;
  this._bindLayerVerticesBufferData();
  this._super(size)
}, _updateColor:function() {
  for(var i = 0;i < 4;i++) {
    this._squareColors[i].r = this._color.r / 255;
    this._squareColors[i].g = this._color.g / 255;
    this._squareColors[i].b = this._color.b / 255;
    this._squareColors[i].a = this._opacity / 255
  }
  this._bindLayerColorsBufferData()
}, draw:function(ctx) {
  var context = ctx || cc.renderContext;
  cc.NODE_DRAW_SETUP(this);
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
  context.bindBuffer(context.ARRAY_BUFFER, this._verticesFloat32Buffer);
  context.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, context.FLOAT, false, 0, 0);
  context.bindBuffer(context.ARRAY_BUFFER, this._colorsUint8Buffer);
  context.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, context.FLOAT, false, 0, 0);
  cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
  context.drawArrays(context.TRIANGLE_STRIP, 0, 4)
}, _bindLayerVerticesBufferData:function() {
  cc.renderContext.bindBuffer(cc.renderContext.ARRAY_BUFFER, this._verticesFloat32Buffer);
  cc.renderContext.bufferData(cc.renderContext.ARRAY_BUFFER, this._squareVerticesAB, cc.renderContext.STATIC_DRAW)
}, _bindLayerColorsBufferData:function() {
  cc.renderContext.bindBuffer(cc.renderContext.ARRAY_BUFFER, this._colorsUint8Buffer);
  cc.renderContext.bufferData(cc.renderContext.ARRAY_BUFFER, this._squareColorsAB, cc.renderContext.STATIC_DRAW)
}});
cc.LayerColorWebGL.create = function(color, width, height) {
  var ret = new cc.LayerColorWebGL;
  switch(arguments.length) {
    case 0:
      ret.init();
      break;
    case 1:
      ret.init(color);
      break;
    case 3:
      ret.init(color, width, height);
      break;
    default:
      ret.init();
      break
  }
  return ret
};
cc.LayerColor = cc.Browser.supportWebGL ? cc.LayerColorWebGL : cc.LayerColorCanvas;
cc.LayerGradient = cc.LayerColor.extend({_startColor:null, _endColor:null, _startOpacity:null, _endOpacity:null, _alongVector:null, _compressedInterpolation:false, _gradientStartPoint:null, _gradientEndPoint:null, ctor:function() {
  this._super();
  this._color = new cc.Color3B(0, 0, 0);
  this._startColor = new cc.Color3B(0, 0, 0);
  this._endColor = new cc.Color3B(0, 0, 0);
  this._alongVector = cc.p(0, -1);
  this._startOpacity = 255;
  this._endOpacity = 255;
  this._gradientStartPoint = cc.p(0, 0);
  this._gradientEndPoint = cc.p(0, 0)
}, getStartColor:function() {
  return this._color
}, setStartColor:function(color) {
  this.setColor(color)
}, setEndColor:function(color) {
  this._endColor = color;
  this._updateColor()
}, getEndColor:function() {
  return this._endColor
}, setStartOpacity:function(o) {
  this._startOpacity = o;
  this._updateColor()
}, getStartOpacity:function() {
  return this._startOpacity
}, setEndOpacity:function(o) {
  this._endOpacity = o;
  this._updateColor()
}, getEndOpacity:function() {
  return this._endOpacity
}, setVector:function(Var) {
  this._alongVector = Var;
  this._updateColor()
}, getVector:function() {
  return this._alongVector
}, isCompressedInterpolation:function() {
  return this._compressedInterpolation
}, setCompressedInterpolation:function(compress) {
  this._compressedInterpolation = compress;
  this._updateColor()
}, init:function(start, end, v) {
  var argnum = arguments.length;
  if(argnum === 0) {
    return this._super()
  }
  if(argnum === 2) {
    v = cc.p(0, -1)
  }
  this._startColor.r = start.r;
  this._startColor.g = start.g;
  this._startColor.b = start.b;
  this._startOpacity = start.a;
  this._endColor.r = end.r;
  this._endColor.g = end.g;
  this._endColor.b = end.b;
  this._endOpacity = end.a;
  this._alongVector = v;
  this._compressedInterpolation = true;
  this._super(cc.c4b(start.r, start.g, start.b, 255));
  return true
}, draw:function(ctx) {
  if(cc.renderContextType === cc.WEBGL) {
    this._super(ctx);
    return
  }
  var context = ctx || cc.renderContext;
  if(this._isLighterMode) {
    context.globalCompositeOperation = "lighter"
  }
  context.save();
  var tWidth = this.getContentSize().width;
  var tHeight = this.getContentSize().height;
  var tGradient = context.createLinearGradient(this._gradientStartPoint.x, this._gradientStartPoint.y, this._gradientEndPoint.x, this._gradientEndPoint.y);
  tGradient.addColorStop(0, "rgba(" + Math.round(this._color.r) + "," + Math.round(this._color.g) + "," + Math.round(this._color.b) + "," + (this._startOpacity / 255).toFixed(4) + ")");
  tGradient.addColorStop(1, "rgba(" + Math.round(this._endColor.r) + "," + Math.round(this._endColor.g) + "," + Math.round(this._endColor.b) + "," + (this._endOpacity / 255).toFixed(4) + ")");
  context.fillStyle = tGradient;
  context.fillRect(0, 0, tWidth, -tHeight);
  if(this._rotation != 0) {
    context.rotate(this._rotationRadians)
  }
  context.restore()
}, _updateColor:function() {
  if(cc.renderContextType === cc.CANVAS) {
    var tWidth = this.getContentSize().width * 0.5;
    var tHeight = this.getContentSize().height * 0.5;
    this._gradientStartPoint = cc.p(tWidth * -this._alongVector.x + tWidth, tHeight * this._alongVector.y - tHeight);
    this._gradientEndPoint = cc.p(tWidth * this._alongVector.x + tWidth, tHeight * -this._alongVector.y - tHeight)
  }else {
    var h = cc.pLength(this._alongVector);
    if(h === 0) {
      return
    }
    var c = Math.sqrt(2);
    var u = cc.p(this._alongVector.x / h, this._alongVector.y / h);
    if(this._compressedInterpolation) {
      var h2 = 1 / (Math.abs(u.x) + Math.abs(u.y));
      u = cc.pMult(u, h2 * c)
    }
    var opacityf = this._opacity / 255;
    var S = new cc.Color4F(this._color.r / 255, this._color.g / 255, this._color.b / 255, this._startOpacity * opacityf / 255);
    var E = new cc.Color4F(this._endColor.r / 255, this._endColor.g / 255, this._endColor.b / 255, this._endOpacity * opacityf / 255);
    this._squareColors[0].r = E.r + (S.r - E.r) * ((c + u.x + u.y) / (2 * c));
    this._squareColors[0].g = E.g + (S.g - E.g) * ((c + u.x + u.y) / (2 * c));
    this._squareColors[0].b = E.b + (S.b - E.b) * ((c + u.x + u.y) / (2 * c));
    this._squareColors[0].a = E.a + (S.a - E.a) * ((c + u.x + u.y) / (2 * c));
    this._squareColors[1].r = E.r + (S.r - E.r) * ((c - u.x + u.y) / (2 * c));
    this._squareColors[1].g = E.g + (S.g - E.g) * ((c - u.x + u.y) / (2 * c));
    this._squareColors[1].b = E.b + (S.b - E.b) * ((c - u.x + u.y) / (2 * c));
    this._squareColors[1].a = E.a + (S.a - E.a) * ((c - u.x + u.y) / (2 * c));
    this._squareColors[2].r = E.r + (S.r - E.r) * ((c + u.x - u.y) / (2 * c));
    this._squareColors[2].g = E.g + (S.g - E.g) * ((c + u.x - u.y) / (2 * c));
    this._squareColors[2].b = E.b + (S.b - E.b) * ((c + u.x - u.y) / (2 * c));
    this._squareColors[2].a = E.a + (S.a - E.a) * ((c + u.x - u.y) / (2 * c));
    this._squareColors[3].r = E.r + (S.r - E.r) * ((c - u.x - u.y) / (2 * c));
    this._squareColors[3].g = E.g + (S.g - E.g) * ((c - u.x - u.y) / (2 * c));
    this._squareColors[3].b = E.b + (S.b - E.b) * ((c - u.x - u.y) / (2 * c));
    this._squareColors[3].a = E.a + (S.a - E.a) * ((c - u.x - u.y) / (2 * c));
    this._bindLayerColorsBufferData()
  }
}});
cc.LayerGradient.create = function(start, end, v) {
  var layer = new cc.LayerGradient;
  switch(arguments.length) {
    case 2:
      if(layer && layer.init(start, end)) {
        return layer
      }
      break;
    case 3:
      if(layer && layer.init(start, end, v)) {
        return layer
      }
      break;
    case 0:
      if(layer && layer.init()) {
        return layer
      }
      break;
    default:
      throw"Arguments error ";break
  }
  return null
};
cc.LayerMultiplex = cc.Layer.extend({_enabledLayer:0, _layers:null, ctor:function() {
  this._super()
}, initWithLayer:function(layer) {
  this._layers = [];
  this._layers.push(layer);
  this._enabledLayer = 0;
  this.addChild(layer);
  return true
}, initWithLayers:function(args) {
  this._layers = args;
  this._enabledLayer = 0;
  this.addChild(this._layers[this._enabledLayer]);
  return true
}, switchTo:function(n) {
  cc.Assert(n < this._layers.length, "Invalid index in MultiplexLayer switchTo message");
  this.removeChild(this._layers[this._enabledLayer], true);
  this._enabledLayer = n;
  this.addChild(this._layers[n])
}, switchToAndReleaseMe:function(n) {
  cc.Assert(n < this._layers.count(), "Invalid index in MultiplexLayer switchTo message");
  this.removeChild(this._layers[this._enabledLayer], true);
  this._layers[this._enabledLayer] = null;
  this._enabledLayer = n;
  this.addChild(this._layers[n])
}, addLayer:function(layer) {
  cc.Assert(this._layers, "cc.Layer addLayer");
  this._layers.push(layer)
}});
cc.LayerMultiplex.create = function() {
  var multiplexLayer = new cc.LayerMultiplex;
  if(multiplexLayer.initWithLayers(arguments)) {
    return multiplexLayer
  }
  return null
};
cc.SCENE_FADE = 4208917214;
cc.TransitionEaseScene = cc.Class.extend({easeActionWithAction:function() {
}});
cc.TRANSITION_ORIENTATION_LEFT_OVER = 0;
cc.TRANSITION_ORIENTATION_RIGHT_OVER = 1;
cc.TRANSITION_ORIENTATION_UP_OVER = 0;
cc.TRANSITION_ORIENTATION_DOWN_OVER = 1;
cc.TransitionScene = cc.Scene.extend({_inScene:null, _outScene:null, _duration:null, _isInSceneOnTop:false, _isSendCleanupToScene:false, _setNewScene:function(dt) {
  this.unschedule(this._setNewScene);
  var director = cc.Director.getInstance();
  this._isSendCleanupToScene = director.isSendCleanupToScene();
  director.replaceScene(this._inScene);
  director.getTouchDispatcher().setDispatchEvents(true);
  this._outScene.setVisible(true)
}, _sceneOrder:function() {
  this._isInSceneOnTop = true
}, draw:function() {
  this._super();
  if(this._isInSceneOnTop) {
    this._outScene.visit();
    this._inScene.visit()
  }else {
    this._inScene.visit();
    this._outScene.visit()
  }
}, onEnter:function() {
  this._super();
  this._inScene.onEnter()
}, onExit:function() {
  this._super();
  this._outScene.onExit();
  this._inScene.onEnterTransitionDidFinish()
}, cleanup:function() {
  this._super();
  if(this._isSendCleanupToScene) {
    this._outScene.cleanup()
  }
}, initWithDuration:function(t, scene) {
  cc.Assert(scene != null, "CCTransitionScene.initWithDuration() Argument scene must be non-nil");
  if(this.init()) {
    this._duration = t;
    this.setAnchorPoint(cc.p(0, 0));
    this.setPosition(cc.p(0, 0));
    this._inScene = scene;
    this._outScene = cc.Director.getInstance().getRunningScene();
    if(!this._outScene) {
      this._outScene = cc.Scene.create();
      this._outScene.init()
    }
    cc.Assert(this._inScene != this._outScene, "CCTransitionScene.initWithDuration() Incoming scene must be different from the outgoing scene");
    cc.Director.getInstance().getTouchDispatcher().setDispatchEvents(false);
    this._sceneOrder();
    return true
  }else {
    return false
  }
}, finish:function() {
  this._inScene.setVisible(true);
  this._inScene.setPosition(cc.p(0, 0));
  this._inScene.setScale(1);
  this._inScene.setRotation(0);
  if(cc.renderContextType === cc.WEBGL) {
    this._inScene.getCamera().restore()
  }
  this._outScene.setVisible(false);
  this._outScene.setPosition(cc.p(0, 0));
  this._outScene.setScale(1);
  this._outScene.setRotation(0);
  if(cc.renderContextType === cc.WEBGL) {
    this._outScene.getCamera().restore()
  }
  this.schedule(this._setNewScene, 0)
}, hideOutShowIn:function() {
  this._inScene.setVisible(true);
  this._outScene.setVisible(false)
}});
cc.TransitionScene.create = function(t, scene) {
  var tempScene = new cc.TransitionScene;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionSceneOriented = cc.TransitionScene.extend({_orientation:0, initWithDuration:function(t, scene, orientation) {
  if(this._super(t, scene)) {
    this._orientation = orientation
  }
  return true
}});
cc.TransitionSceneOriented.create = function(t, scene, orientation) {
  var tempScene = new cc.TransitionSceneOriented;
  tempScene.initWithDuration(t, scene, orientation);
  return tempScene
};
cc.TransitionRotoZoom = cc.TransitionScene.extend({ctor:function() {
}, onEnter:function() {
  this._super();
  this._inScene.setScale(0.0010);
  this._outScene.setScale(1);
  this._inScene.setAnchorPoint(cc.p(0.5, 0.5));
  this._outScene.setAnchorPoint(cc.p(0.5, 0.5));
  var rotoZoom = cc.Sequence.create(cc.Spawn.create(cc.ScaleBy.create(this._duration / 2, 0.0010), cc.RotateBy.create(this._duration / 2, 360 * 2)), cc.DelayTime.create(this._duration / 2));
  this._outScene.runAction(rotoZoom);
  this._inScene.runAction(cc.Sequence.create(rotoZoom.reverse(), cc.CallFunc.create(this.finish, this)))
}});
cc.TransitionRotoZoom.create = function(t, scene) {
  var tempScene = new cc.TransitionRotoZoom;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionJumpZoom = cc.TransitionScene.extend({onEnter:function() {
  this._super();
  var winSize = cc.Director.getInstance().getWinSize();
  this._inScene.setScale(0.5);
  this._inScene.setPosition(cc.p(winSize.width, 0));
  this._inScene.setAnchorPoint(cc.p(0.5, 0.5));
  this._outScene.setAnchorPoint(cc.p(0.5, 0.5));
  var jump = cc.JumpBy.create(this._duration / 4, cc.p(-winSize.width, 0), winSize.width / 4, 2);
  var scaleIn = cc.ScaleTo.create(this._duration / 4, 1);
  var scaleOut = cc.ScaleTo.create(this._duration / 4, 0.5);
  var jumpZoomOut = cc.Sequence.create(scaleOut, jump);
  var jumpZoomIn = cc.Sequence.create(jump, scaleIn);
  var delay = cc.DelayTime.create(this._duration / 2);
  this._outScene.runAction(jumpZoomOut);
  this._inScene.runAction(cc.Sequence.create(delay, jumpZoomIn, cc.CallFunc.create(this.finish, this)))
}});
cc.TransitionJumpZoom.create = function(t, scene) {
  var tempScene = new cc.TransitionJumpZoom;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionMoveInL = cc.TransitionScene.extend({onEnter:function() {
  this._super();
  this.initScenes();
  var action = this.action();
  this._inScene.runAction(cc.Sequence.create(this.easeActionWithAction(action), cc.CallFunc.create(this.finish, this)))
}, initScenes:function() {
  this._inScene.setPosition(cc.p(-cc.Director.getInstance().getWinSize().width, 0))
}, action:function() {
  return cc.MoveTo.create(this._duration, cc.p(0, 0))
}, easeActionWithAction:function(action) {
  return cc.EaseOut.create(action, 2)
}});
cc.TransitionMoveInL.create = function(t, scene) {
  var tempScene = new cc.TransitionMoveInL;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionMoveInR = cc.TransitionMoveInL.extend({initScenes:function() {
  this._inScene.setPosition(cc.p(cc.Director.getInstance().getWinSize().width, 0))
}});
cc.TransitionMoveInR.create = function(t, scene) {
  var tempScene = new cc.TransitionMoveInR;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionMoveInT = cc.TransitionMoveInL.extend({initScenes:function() {
  this._inScene.setPosition(cc.p(0, cc.Director.getInstance().getWinSize().height))
}});
cc.TransitionMoveInT.create = function(t, scene) {
  var tempScene = new cc.TransitionMoveInT;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionMoveInB = cc.TransitionMoveInL.extend({initScenes:function() {
  this._inScene.setPosition(cc.p(0, -cc.Director.getInstance().getWinSize().height))
}});
cc.TransitionMoveInB.create = function(t, scene) {
  var tempScene = new cc.TransitionMoveInB;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.ADJUST_FACTOR = 0.5;
cc.TransitionSlideInL = cc.TransitionScene.extend({_sceneOrder:function() {
  this._isInSceneOnTop = false
}, ctor:function() {
}, onEnter:function() {
  this._super();
  this.initScenes();
  var inA = this.action();
  var outA = this.action();
  var inAction = this.easeActionWithAction(inA);
  var outAction = cc.Sequence.create(this.easeActionWithAction(outA), cc.CallFunc.create(this.finish, this));
  this._inScene.runAction(inAction);
  this._outScene.runAction(outAction)
}, initScenes:function() {
  this._inScene.setPosition(cc.p(-(cc.Director.getInstance().getWinSize().width - cc.ADJUST_FACTOR), 0))
}, action:function() {
  return cc.MoveBy.create(this._duration, cc.p(cc.Director.getInstance().getWinSize().width - cc.ADJUST_FACTOR, 0))
}, easeActionWithAction:function(action) {
  return cc.EaseOut.create(action, 2)
}});
cc.TransitionSlideInL.create = function(t, scene) {
  var tempScene = new cc.TransitionSlideInL;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionSlideInR = cc.TransitionSlideInL.extend({_sceneOrder:function() {
  this._isInSceneOnTop = true
}, initScenes:function() {
  this._inScene.setPosition(cc.p(cc.Director.getInstance().getWinSize().width - cc.ADJUST_FACTOR, 0))
}, action:function() {
  return cc.MoveBy.create(this._duration, cc.p(-(cc.Director.getInstance().getWinSize().width - cc.ADJUST_FACTOR), 0))
}});
cc.TransitionSlideInR.create = function(t, scene) {
  var tempScene = new cc.TransitionSlideInR;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionSlideInB = cc.TransitionSlideInL.extend({_sceneOrder:function() {
  this._isInSceneOnTop = false
}, initScenes:function() {
  this._inScene.setPosition(cc.p(0, cc.Director.getInstance().getWinSize().height - cc.ADJUST_FACTOR))
}, action:function() {
  return cc.MoveBy.create(this._duration, cc.p(0, -(cc.Director.getInstance().getWinSize().height - cc.ADJUST_FACTOR)))
}});
cc.TransitionSlideInB.create = function(t, scene) {
  var tempScene = new cc.TransitionSlideInB;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionSlideInT = cc.TransitionSlideInL.extend({_sceneOrder:function() {
  this._isInSceneOnTop = true
}, initScenes:function() {
  this._inScene.setPosition(cc.p(0, -(cc.Director.getInstance().getWinSize().height - cc.ADJUST_FACTOR)))
}, action:function() {
  return cc.MoveBy.create(this._duration, cc.p(0, cc.Director.getInstance().getWinSize().height - cc.ADJUST_FACTOR))
}});
cc.TransitionSlideInT.create = function(t, scene) {
  var tempScene = new cc.TransitionSlideInT;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionShrinkGrow = cc.TransitionScene.extend({onEnter:function() {
  this._super();
  this._inScene.setScale(0.0010);
  this._outScene.setScale(1);
  this._inScene.setAnchorPoint(cc.p(2 / 3, 0.5));
  this._outScene.setAnchorPoint(cc.p(1 / 3, 0.5));
  var scaleOut = cc.ScaleTo.create(this._duration, 0.01);
  var scaleIn = cc.ScaleTo.create(this._duration, 1);
  this._inScene.runAction(this.easeActionWithAction(scaleIn));
  this._outScene.runAction(cc.Sequence.create(this.easeActionWithAction(scaleOut), cc.CallFunc.create(this.finish, this)))
}, easeActionWithAction:function(action) {
  return cc.EaseOut.create(action, 2)
}});
cc.TransitionShrinkGrow.create = function(t, scene) {
  var tempScene = new cc.TransitionShrinkGrow;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionFlipX = cc.TransitionSceneOriented.extend({onEnter:function() {
  this._super();
  var inA, outA;
  this._inScene.setVisible(false);
  var inDeltaZ, inAngleZ, outDeltaZ, outAngleZ;
  if(this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER) {
    inDeltaZ = 90;
    inAngleZ = 270;
    outDeltaZ = 90;
    outAngleZ = 0
  }else {
    inDeltaZ = -90;
    inAngleZ = 90;
    outDeltaZ = -90;
    outAngleZ = 0
  }
  inA = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Show.create(), cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, 0, 0), cc.CallFunc.create(this.finish, this));
  outA = cc.Sequence.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 0, 0), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
  this._inScene.runAction(inA);
  this._outScene.runAction(outA)
}});
cc.TransitionFlipX.create = function(t, scene, o) {
  if(o == null) {
    o = cc.TRANSITION_ORIENTATION_RIGHT_OVER
  }
  var tempScene = new cc.TransitionFlipX;
  tempScene.initWithDuration(t, scene, o);
  return tempScene
};
cc.TransitionFlipY = cc.TransitionSceneOriented.extend({onEnter:function() {
  this._super();
  var inA, outA;
  this._inScene.setVisible(false);
  var inDeltaZ, inAngleZ, outDeltaZ, outAngleZ;
  if(this._orientation == cc.TRANSITION_ORIENTATION_UP_OVER) {
    inDeltaZ = 90;
    inAngleZ = 270;
    outDeltaZ = 90;
    outAngleZ = 0
  }else {
    inDeltaZ = -90;
    inAngleZ = 90;
    outDeltaZ = -90;
    outAngleZ = 0
  }
  inA = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Show.create(), cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, 90, 0), cc.CallFunc.create(this.finish, this));
  outA = cc.Sequence.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 90, 0), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
  this._inScene.runAction(inA);
  this._outScene.runAction(outA)
}});
cc.TransitionFlipY.create = function(t, scene, o) {
  if(o == null) {
    o = cc.TRANSITION_ORIENTATION_UP_OVER
  }
  var tempScene = new cc.TransitionFlipY;
  tempScene.initWithDuration(t, scene, o);
  return tempScene
};
cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend({onEnter:function() {
  this._super();
  var inA, outA;
  this._inScene.setVisible(false);
  var inDeltaZ, inAngleZ, outDeltaZ, outAngleZ;
  if(this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER) {
    inDeltaZ = 90;
    inAngleZ = 270;
    outDeltaZ = 90;
    outAngleZ = 0
  }else {
    inDeltaZ = -90;
    inAngleZ = 90;
    outDeltaZ = -90;
    outAngleZ = 0
  }
  inA = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Show.create(), cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, -45, 0), cc.CallFunc.create(this.finish, this));
  outA = cc.Sequence.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 45, 0), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
  this._inScene.runAction(inA);
  this._outScene.runAction(outA)
}});
cc.TransitionFlipAngular.create = function(t, scene, o) {
  if(o == null) {
    o = cc.TRANSITION_ORIENTATION_RIGHT_OVER
  }
  var tempScene = new cc.TransitionFlipAngular;
  tempScene.initWithDuration(t, scene, o);
  return tempScene
};
cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend({onEnter:function() {
  this._super();
  var inA, outA;
  this._inScene.setVisible(false);
  var inDeltaZ, inAngleZ, outDeltaZ, outAngleZ;
  if(this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER) {
    inDeltaZ = 90;
    inAngleZ = 270;
    outDeltaZ = 90;
    outAngleZ = 0
  }else {
    inDeltaZ = -90;
    inAngleZ = 90;
    outDeltaZ = -90;
    outAngleZ = 0
  }
  inA = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, 0, 0), cc.ScaleTo.create(this._duration / 2, 1), cc.Show.create()), cc.CallFunc.create(this.finish, this));
  outA = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 0, 0), cc.ScaleTo.create(this._duration / 2, 0.5)), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
  this._inScene.setScale(0.5);
  this._inScene.runAction(inA);
  this._outScene.runAction(outA)
}});
cc.TransitionZoomFlipX.create = function(t, scene, o) {
  if(o == null) {
    o = cc.TRANSITION_ORIENTATION_RIGHT_OVER
  }
  var tempScene = new cc.TransitionZoomFlipX;
  tempScene.initWithDuration(t, scene, o);
  return tempScene
};
cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend({onEnter:function() {
  this._super();
  var inA, outA;
  this._inScene.setVisible(false);
  var inDeltaZ, inAngleZ, outDeltaZ, outAngleZ;
  if(this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER) {
    inDeltaZ = 90;
    inAngleZ = 270;
    outDeltaZ = 90;
    outAngleZ = 0
  }else {
    inDeltaZ = -90;
    inAngleZ = 90;
    outDeltaZ = -90;
    outAngleZ = 0
  }
  inA = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, 90, 0), cc.ScaleTo.create(this._duration / 2, 1), cc.Show.create()), cc.CallFunc.create(this.finish, this));
  outA = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 90, 0), cc.ScaleTo.create(this._duration / 2, 0.5)), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
  this._inScene.setScale(0.5);
  this._inScene.runAction(inA);
  this._outScene.runAction(outA)
}});
cc.TransitionZoomFlipY.create = function(t, scene, o) {
  if(o == null) {
    o = cc.TRANSITION_ORIENTATION_UP_OVER
  }
  var tempScene = new cc.TransitionZoomFlipY;
  tempScene.initWithDuration(t, scene, o);
  return tempScene
};
cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend({onEnter:function() {
  this._super();
  var inA, outA;
  this._inScene.setVisible(false);
  var inDeltaZ, inAngleZ, outDeltaZ, outAngleZ;
  if(this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER) {
    inDeltaZ = 90;
    inAngleZ = 270;
    outDeltaZ = 90;
    outAngleZ = 0
  }else {
    inDeltaZ = -90;
    inAngleZ = 90;
    outDeltaZ = -90;
    outAngleZ = 0
  }
  inA = cc.Sequence.create(cc.DelayTime.create(this._duration / 2), cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, -45, 0), cc.ScaleTo.create(this._duration / 2, 1), cc.Show.create()), cc.Show.create(), cc.CallFunc.create(this.finish, this));
  outA = cc.Sequence.create(cc.Spawn.create(cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 45, 0), cc.ScaleTo.create(this._duration / 2, 0.5)), cc.Hide.create(), cc.DelayTime.create(this._duration / 2));
  this._inScene.setScale(0.5);
  this._inScene.runAction(inA);
  this._outScene.runAction(outA)
}});
cc.TransitionZoomFlipAngular.create = function(t, scene, o) {
  if(o == null) {
    o = cc.TRANSITION_ORIENTATION_RIGHT_OVER
  }
  var tempScene = new cc.TransitionZoomFlipAngular;
  tempScene.initWithDuration(t, scene, o);
  return tempScene
};
cc.TransitionFade = cc.TransitionScene.extend({_color:null, ctor:function() {
  this._super();
  this._color = new cc.Color3B
}, onEnter:function() {
  this._super();
  var l = cc.LayerColor.create(this._color);
  this._inScene.setVisible(false);
  this.addChild(l, 2, cc.SCENE_FADE);
  var f = this.getChildByTag(cc.SCENE_FADE);
  var a = cc.Sequence.create(cc.FadeIn.create(this._duration / 2), cc.CallFunc.create(this.hideOutShowIn, this), cc.FadeOut.create(this._duration / 2), cc.CallFunc.create(this.finish, this));
  f.runAction(a)
}, onExit:function() {
  this._super();
  this.removeChildByTag(cc.SCENE_FADE, false)
}, initWithDuration:function(t, scene, color) {
  color = color || cc.black();
  if(this._super(t, scene)) {
    this._color.r = color.r;
    this._color.g = color.g;
    this._color.b = color.b;
    this._color.a = 0
  }
  return true
}});
cc.TransitionFade.create = function(t, scene, color) {
  var transition = new cc.TransitionFade;
  transition.initWithDuration(t, scene, color);
  return transition
};
cc.TransitionCrossFade = cc.TransitionScene.extend({onEnter:function() {
  this._super();
  var color = new cc.Color4B(0, 0, 0, 0);
  var winSize = cc.Director.getInstance().getWinSize();
  var layer = cc.LayerColor.create(color);
  var inTexture = cc.RenderTexture.create(winSize.width, winSize.height);
  if(null == inTexture) {
    return
  }
  inTexture.getSprite().setAnchorPoint(cc.p(0.5, 0.5));
  inTexture.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
  inTexture.setAnchorPoint(cc.p(0.5, 0.5));
  inTexture.begin();
  this._inScene.visit();
  inTexture.end();
  var outTexture = cc.RenderTexture.create(winSize.width, winSize.height);
  outTexture.getSprite().setAnchorPoint(cc.p(0.5, 0.5));
  outTexture.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
  outTexture.setAnchorPoint(cc.p(0.5, 0.5));
  outTexture.begin();
  this._outScene.visit();
  outTexture.end();
  inTexture.getSprite().setBlendFunc(gl.ONE, gl.ONE);
  outTexture.getSprite().setBlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  layer.addChild(inTexture);
  layer.addChild(outTexture);
  inTexture.getSprite().setOpacity(255);
  outTexture.getSprite().setOpacity(255);
  var layerAction = cc.Sequence.create(cc.FadeTo.create(this._duration, 0), cc.CallFunc.create(this.hideOutShowIn, this), cc.CallFunc.create(this.finish, this));
  outTexture.getSprite().runAction(layerAction);
  this.addChild(layer, 2, cc.SCENE_FADE)
}, onExit:function() {
  this.removeChildByTag(cc.SCENE_FADE, false);
  this._super()
}, draw:function() {
}});
cc.TransitionCrossFade.create = function(t, scene) {
  var Transition = new cc.TransitionCrossFade;
  Transition.initWithDuration(t, scene);
  return Transition
};
cc.TransitionTurnOffTiles = cc.TransitionScene.extend({_sceneOrder:function() {
  this._isInSceneOnTop = false
}, onEnter:function() {
  this._super();
  var winSize = cc.Director.getInstance().getWinSize();
  var aspect = winSize.width / winSize.height;
  var x = 0 | 12 * aspect;
  var y = 12;
  var toff = cc.TurnOffTiles.create(this._duration, cc.SizeMake(x, y));
  var action = this.easeActionWithAction(toff);
  this._outScene.runAction(cc.Sequence.create(action, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
}, easeActionWithAction:function(action) {
  return action
}});
cc.TransitionTurnOffTiles.create = function(t, scene) {
  var tempScene = new cc.TransitionTurnOffTiles;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionSplitCols = cc.TransitionScene.extend({onEnter:function() {
  this._super();
  this._inScene.setVisible(false);
  var split = this.action();
  var seq = cc.Sequence.create(split, cc.CallFunc.create(this.hideOutShowIn, this), split.reverse());
  this.runAction(cc.Sequence.create(this.easeActionWithAction(seq), cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
}, easeActionWithAction:function(action) {
  return cc.EaseInOut.create(action, 3)
}, action:function() {
  return cc.SplitCols.create(this._duration / 2, 3)
}});
cc.TransitionSplitCols.create = function(t, scene) {
  var tempScene = new cc.TransitionSplitCols;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionSplitRows = cc.TransitionSplitCols.extend({action:function() {
  return cc.SplitRows.create(this._duration / 2, 3)
}});
cc.TransitionSplitRows.create = function(t, scene) {
  var tempScene = new cc.TransitionSplitRows;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionFadeTR = cc.TransitionScene.extend({_sceneOrder:function() {
  this._isInSceneOnTop = false
}, onEnter:function() {
  this._super();
  var winSize = cc.Director.getInstance().getWinSize();
  var aspect = winSize.width / winSize.height;
  var x = 0 | 12 * aspect;
  var y = 12;
  var action = this.actionWithSize(cc.SizeMake(x, y));
  this._outScene.runAction(cc.Sequence.create(this.easeActionWithAction(action), cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
}, easeActionWithAction:function(action) {
  return action
}, actionWithSize:function(size) {
  return cc.FadeOutTRTiles.create(this._duration, size)
}});
cc.TransitionFadeTR.create = function(t, scene) {
  var tempScene = new cc.TransitionFadeTR;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionFadeBL = cc.TransitionFadeTR.extend({actionWithSize:function(size) {
  return cc.FadeOutBLTiles.create(this._duration, size)
}});
cc.TransitionFadeBL.create = function(t, scene) {
  var tempScene = new cc.TransitionFadeBL;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionFadeUp = cc.TransitionFadeTR.extend({actionWithSize:function(size) {
  return cc.FadeOutUpTiles.create(this._duration, size)
}});
cc.TransitionFadeUp.create = function(t, scene) {
  var tempScene = new cc.TransitionFadeUp;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionFadeDown = cc.TransitionFadeTR.extend({actionWithSize:function(size) {
  return cc.FadeOutDownTiles.create(this._duration, size)
}});
cc.TransitionFadeDown.create = function(t, scene) {
  var tempScene = new cc.TransitionFadeDown;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.SCENE_RADIAL = 49153;
cc.TransitionProgress = cc.TransitionScene.extend({_to:0, _from:0, _sceneToBeModified:null, onEnter:function() {
  this._super();
  this._setupTransition();
  var winSize = cc.Director.getInstance().getWinSize();
  var texture = cc.RenderTexture.create(winSize.width, winSize.height);
  texture.getSprite().setAnchorPoint(cc.p(0.5, 0.5));
  texture.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
  texture.setAnchorPoint(cc.p(0.5, 0.5));
  if(cc.renderContextType === cc.CANVAS) {
    texture.clear();
    this._sceneToBeModified.visit(texture.context)
  }else {
    texture.clear(0, 0, 0, 1);
    texture.begin();
    this._sceneToBeModified.visit();
    texture.end()
  }
  if(this._sceneToBeModified == this._outScene) {
    this.hideOutShowIn()
  }
  var pNode = this._progressTimerNodeWithRenderTexture(texture);
  var layerAction = cc.Sequence.create(cc.ProgressFromTo.create(this._duration, this._from, this._to), cc.CallFunc.create(this.finish, this));
  pNode.runAction(layerAction);
  this.addChild(pNode, 2, cc.SCENE_RADIAL)
}, onExit:function() {
  this.removeChildByTag(cc.SCENE_RADIAL, false);
  this._super()
}, _setupTransition:function() {
  this._sceneToBeModified = this._outScene;
  this._from = 100;
  this._to = 0
}, _progressTimerNodeWithRenderTexture:function(texture) {
  cc.Assert(false, "override me - abstract class");
  return null
}, _sceneOrder:function() {
  this._isInSceneOnTop = false
}});
cc.TransitionProgress.create = function(t, scene) {
  var tempScene = new cc.TransitionProgress;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend({_progressTimerNodeWithRenderTexture:function(texture) {
  var size = cc.Director.getInstance().getWinSize();
  var pNode = cc.ProgressTimer.create(texture.getSprite());
  if(cc.renderContextType === cc.WEBGL) {
    pNode.getSprite().setFlipY(true)
  }
  pNode.setType(cc.PROGRESS_TIMER_TYPE_RADIAL);
  pNode.setReverseDirection(false);
  pNode.setPercentage(100);
  pNode.setPosition(cc.p(size.width / 2, size.height / 2));
  pNode.setAnchorPoint(cc.p(0.5, 0.5));
  return pNode
}});
cc.TransitionProgressRadialCCW.create = function(t, scene) {
  var tempScene = new cc.TransitionProgressRadialCCW;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionProgressRadialCW = cc.TransitionProgress.extend({_progressTimerNodeWithRenderTexture:function(texture) {
  var size = cc.Director.getInstance().getWinSize();
  var pNode = cc.ProgressTimer.create(texture.getSprite());
  if(cc.renderContextType === cc.WEBGL) {
    pNode.getSprite().setFlipY(true)
  }
  pNode.setType(cc.PROGRESS_TIMER_TYPE_RADIAL);
  pNode.setReverseDirection(true);
  pNode.setPercentage(100);
  pNode.setPosition(cc.p(size.width / 2, size.height / 2));
  pNode.setAnchorPoint(cc.p(0.5, 0.5));
  return pNode
}});
cc.TransitionProgressRadialCW.create = function(t, scene) {
  var tempScene = new cc.TransitionProgressRadialCW;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionProgressHorizontal = cc.TransitionProgress.extend({_progressTimerNodeWithRenderTexture:function(texture) {
  var size = cc.Director.getInstance().getWinSize();
  var pNode = cc.ProgressTimer.create(texture.getSprite());
  if(cc.renderContextType == cc.WEBGL) {
    pNode.getSprite().setFlipY(true)
  }
  pNode.setType(cc.PROGRESS_TIMER_TYPE_BAR);
  pNode.setMidpoint(cc.p(1, 0));
  pNode.setBarChangeRate(cc.p(1, 0));
  pNode.setPercentage(100);
  pNode.setPosition(cc.p(size.width / 2, size.height / 2));
  pNode.setAnchorPoint(cc.p(0.5, 0.5));
  return pNode
}});
cc.TransitionProgressHorizontal.create = function(t, scene) {
  var tempScene = new cc.TransitionProgressHorizontal;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionProgressVertical = cc.TransitionProgress.extend({_progressTimerNodeWithRenderTexture:function(texture) {
  var size = cc.Director.getInstance().getWinSize();
  var pNode = cc.ProgressTimer.create(texture.getSprite());
  if(cc.renderContextType == cc.WEBGL) {
    pNode.getSprite().setFlipY(true)
  }
  pNode.setType(cc.PROGRESS_TIMER_TYPE_BAR);
  pNode.setMidpoint(cc.p(0, 0));
  pNode.setBarChangeRate(cc.p(0, 1));
  pNode.setPercentage(100);
  pNode.setPosition(cc.p(size.width / 2, size.height / 2));
  pNode.setAnchorPoint(cc.p(0.5, 0.5));
  return pNode
}});
cc.TransitionProgressVertical.create = function(t, scene) {
  var tempScene = new cc.TransitionProgressVertical;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionProgressInOut = cc.TransitionProgress.extend({_progressTimerNodeWithRenderTexture:function(texture) {
  var size = cc.Director.getInstance().getWinSize();
  var pNode = cc.ProgressTimer.create(texture.getSprite());
  if(cc.renderContextType == cc.WEBGL) {
    pNode.getSprite().setFlipY(true)
  }
  pNode.setType(cc.PROGRESS_TIMER_TYPE_BAR);
  pNode.setMidpoint(cc.p(0.5, 0.5));
  pNode.setBarChangeRate(cc.p(1, 1));
  pNode.setPercentage(0);
  pNode.setPosition(cc.p(size.width / 2, size.height / 2));
  pNode.setAnchorPoint(cc.p(0.5, 0.5));
  return pNode
}, _sceneOrder:function() {
  this._isInSceneOnTop = false
}, _setupTransition:function() {
  this._sceneToBeModified = this._inScene;
  this._from = 0;
  this._to = 100
}});
cc.TransitionProgressInOut.create = function(t, scene) {
  var tempScene = new cc.TransitionProgressInOut;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionProgressOutIn = cc.TransitionProgress.extend({_progressTimerNodeWithRenderTexture:function(texture) {
  var size = cc.Director.getInstance().getWinSize();
  var pNode = cc.ProgressTimer.create(texture.getSprite());
  if(cc.renderContextType == cc.WEBGL) {
    pNode.getSprite().setFlipY(true)
  }
  pNode.setType(cc.PROGRESS_TIMER_TYPE_BAR);
  pNode.setMidpoint(cc.p(0.5, 0.5));
  pNode.setBarChangeRate(cc.p(1, 1));
  pNode.setPercentage(100);
  pNode.setPosition(cc.p(size.width / 2, size.height / 2));
  pNode.setAnchorPoint(cc.p(0.5, 0.5));
  return pNode
}});
cc.TransitionProgressOutIn.create = function(t, scene) {
  var tempScene = new cc.TransitionProgressOutIn;
  if(tempScene != null && tempScene.initWithDuration(t, scene)) {
    return tempScene
  }
  return null
};
cc.TransitionPageTurn = cc.TransitionScene.extend({_back:true, initWithDuration:function(t, scene, backwards) {
  this._back = backwards;
  if(this._super(t, scene)) {
  }
  return true
}, actionWithSize:function(vector) {
  if(this._back) {
    return cc.ReverseTime.create(cc.PageTurn3D.create(this._duration, vector))
  }else {
    return cc.PageTurn3D.create(this._duration, vector)
  }
}, onEnter:function() {
  this._super();
  var winSize = cc.Director.getInstance().getWinSize();
  var x, y;
  if(winSize.width > winSize.height) {
    x = 16;
    y = 12
  }else {
    x = 12;
    y = 16
  }
  var action = this.actionWithSize(cc.SizeMake(x, y));
  if(!this._back) {
    this._outScene.runAction(cc.Sequence.create(action, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
  }else {
    this._inScene.setVisible(false);
    this._inScene.runAction(cc.Sequence.create(cc.Show.create(), action, cc.CallFunc.create(this.finish, this), cc.StopGrid.create()))
  }
}, _sceneOrder:function() {
  this._isInSceneOnTop = this._back
}});
cc.TransitionPageTurn.create = function(t, scene, backwards) {
  var transition = new cc.TransitionPageTurn;
  transition.initWithDuration(t, scene, backwards);
  return transition
};
cc.SPRITE_INDEX_NOT_INITIALIZED = -1;
cc.generateTextureCacheForColor = function(texture) {
  if(texture.hasOwnProperty("channelCache")) {
    return texture.channelCache
  }
  var textureCache = [document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas")];
  function renderToCache() {
    var ref = cc.generateTextureCacheForColor;
    var w = texture.width;
    var h = texture.height;
    textureCache[0].width = w;
    textureCache[0].height = h;
    textureCache[1].width = w;
    textureCache[1].height = h;
    textureCache[2].width = w;
    textureCache[2].height = h;
    ref.canvas.width = w;
    ref.canvas.height = h;
    var ctx = ref.canvas.getContext("2d");
    ctx.drawImage(texture, 0, 0);
    ref.tempCanvas.width = w;
    ref.tempCanvas.height = h;
    var pixels = ctx.getImageData(0, 0, w, h).data;
    for(var rgbI = 0;rgbI < 3;rgbI++) {
      var cacheCtx = textureCache[rgbI].getContext("2d");
      cacheCtx.getImageData(0, 0, w, h).data;
      ref.tempCtx.drawImage(texture, 0, 0);
      var to = ref.tempCtx.getImageData(0, 0, w, h);
      var toData = to.data;
      for(var i = 0;i < pixels.length;i += 4) {
        toData[i] = rgbI === 0 ? pixels[i] : 0;
        toData[i + 1] = rgbI === 1 ? pixels[i + 1] : 0;
        toData[i + 2] = rgbI === 2 ? pixels[i + 2] : 0;
        toData[i + 3] = pixels[i + 3]
      }
      cacheCtx.putImageData(to, 0, 0)
    }
    texture.onload = null
  }
  try {
    renderToCache()
  }catch(e) {
    texture.onload = renderToCache
  }
  texture.channelCache = textureCache;
  return textureCache
};
cc.generateTextureCacheForColor.canvas = document.createElement("canvas");
cc.generateTextureCacheForColor.tempCanvas = document.createElement("canvas");
cc.generateTextureCacheForColor.tempCtx = cc.generateTextureCacheForColor.tempCanvas.getContext("2d");
cc.generateTintImage2 = function(texture, color, rect) {
  if(!rect) {
    rect = cc.rect(0, 0, texture.width, texture.height)
  }
  var selColor;
  if(color instanceof cc.Color4F) {
    selColor = cc.c4b(color.r * 255, color.g * 255, color.b * 255, color.a * 255)
  }else {
    selColor = cc.c4b(color.r, color.g, color.b, 50)
  }
  var buff = document.createElement("canvas");
  var ctx = buff.getContext("2d");
  if(buff.width != rect.size.width) {
    buff.width = rect.size.width
  }
  if(buff.height != rect.size.height) {
    buff.height = rect.size.height
  }
  ctx.save();
  ctx.drawImage(texture, rect.origin.x, rect.origin.y, rect.size.width, rect.size.height, 0, 0, rect.size.width, rect.size.height);
  ctx.globalCompositeOperation = "source-in";
  ctx.globalAlpha = selColor.a / 255;
  ctx.fillStyle = "rgb(" + selColor.r + "," + selColor.g + "," + selColor.b + ")";
  ctx.fillRect(0, 0, rect.size.width, rect.size.height);
  ctx.restore();
  return buff
};
cc.generateTintImage = function(texture, tintedImgCache, color, rect, renderCanvas, overdraw) {
  if(!rect) {
    rect = cc.rect(0, 0, texture.width, texture.height)
  }
  var selColor;
  if(color instanceof cc.Color3B) {
    selColor = cc.c4f(color.r / 255, color.g / 255, color.b / 255, 1)
  }else {
    selColor = color
  }
  var w = Math.min(rect.size.width, tintedImgCache[0].width);
  var h = Math.min(rect.size.height, tintedImgCache[0].height);
  var buff = renderCanvas;
  var ctx;
  if(!buff) {
    buff = document.createElement("canvas");
    buff.width = w;
    buff.height = h;
    ctx = buff.getContext("2d")
  }else {
    ctx = buff.getContext("2d");
    ctx.clearRect(0, 0, w, h)
  }
  ctx.save();
  ctx.globalCompositeOperation = "lighter";
  var a = ctx.globalAlpha;
  if(selColor.r > 0) {
    ctx.globalAlpha = selColor.r * a;
    ctx.drawImage(tintedImgCache[0], rect.origin.x, rect.origin.y, w, h, 0, 0, w, h)
  }
  if(selColor.g > 0) {
    ctx.globalAlpha = selColor.g * a;
    ctx.drawImage(tintedImgCache[1], rect.origin.x, rect.origin.y, w, h, 0, 0, w, h)
  }
  if(selColor.b > 0) {
    ctx.globalAlpha = selColor.b * a;
    ctx.drawImage(tintedImgCache[2], rect.origin.x, rect.origin.y, w, h, 0, 0, w, h)
  }
  ctx.restore();
  return buff
};
cc.cutRotateImageToCanvas = function(texture, rect) {
  if(!texture) {
    return null
  }
  if(!rect) {
    return texture
  }
  var nCanvas = document.createElement("canvas");
  nCanvas.width = rect.size.width;
  nCanvas.height = rect.size.height;
  var ctx = nCanvas.getContext("2d");
  ctx.translate(nCanvas.width / 2, nCanvas.height / 2);
  ctx.rotate(-1.5707963267948966);
  ctx.drawImage(texture, rect.origin.x, rect.origin.y, rect.size.height, rect.size.width, -rect.size.height / 2, -rect.size.width / 2, rect.size.height, rect.size.width);
  return nCanvas
};
cc.TransformValues = function(pos, scale, rotation, skew, ap, visible) {
  this.pos = pos;
  this.scale = scale;
  this.rotation = rotation;
  this.skew = skew;
  this.ap = ap;
  this.visible = visible
};
cc.RENDER_IN_SUBPIXEL = function(A) {
  return cc.SPRITEBATCHNODE_RENDER_SUBPIXEL ? A : 0 | A
};
cc.SpriteCanvas = cc.Node.extend({RGBAProtocol:true, _textureAtlas:null, _atlasIndex:0, _batchNode:null, _dirty:null, _recursiveDirty:null, _hasChildren:null, _shouldBeHidden:false, _transformToBatch:null, _blendFunc:null, _texture:null, _color:null, _rect:cc.rect(0, 0, 0, 0), _rectRotated:null, _offsetPosition:null, _unflippedOffsetPositionFromCenter:null, colorUnmodified:null, _opacityModifyRGB:null, _flipX:null, _flipY:null, _opacity:255, isDirty:function() {
  return this._dirty
}, setDirty:function(bDirty) {
  this._dirty = bDirty
}, getQuad:function() {
  return null
}, isTextureRectRotated:function() {
  return this._rectRotated
}, getAtlasIndex:function() {
  return this._atlasIndex
}, setAtlasIndex:function(atlasIndex) {
  this._atlasIndex = atlasIndex
}, getTextureRect:function() {
  return cc.rect(this._rect.origin.x, this._rect.origin.y, this._rect.size.width, this._rect.size.height)
}, getTextureAtlas:function(pobTextureAtlas) {
  return this._textureAtlas
}, setTextureAtlas:function(textureAtlas) {
  this._textureAtlas = textureAtlas
}, getSpriteBatchNode:function() {
  return this._batchNode
}, setSpriteBatchNode:function(spriteBatchNode) {
  this._batchNode = spriteBatchNode
}, getOffsetPosition:function() {
  return cc.p(this._offsetPosition.x, this._offsetPosition.y)
}, getBlendFunc:function() {
  return this._blendFunc
}, initWithSpriteFrame:function(spriteFrame) {
  cc.Assert(spriteFrame != null, "");
  var ret = this.initWithTexture(spriteFrame.getTexture(), spriteFrame.getRect());
  this.setDisplayFrame(spriteFrame);
  return ret
}, initWithSpriteFrameName:function(spriteFrameName) {
  cc.Assert(spriteFrameName != null, "");
  var frame = cc.SpriteFrameCache.getInstance().getSpriteFrame(spriteFrameName);
  return this.initWithSpriteFrame(frame)
}, useBatchNode:function(batchNode) {
  this._textureAtlas = batchNode.getTextureAtlas();
  this._batchNode = batchNode
}, setVertexRect:function(rect) {
  this._rect = rect
}, sortAllChildren:function() {
  if(this._reorderChildDirty) {
    var j;
    var tempItem = null;
    for(var i = 1;i < this._children.length;i++) {
      tempItem = this._children[i];
      j = i - 1;
      while(j >= 0 && (tempItem.getZOrder() < this._children[j].getZOrder() || tempItem.getZOrder() == this._children[j].getZOrder() && tempItem.getOrderOfArrival() < this._children[j].getOrderOfArrival())) {
        this._children[j + 1] = this._children[j];
        j = j - 1
      }
      this._children[j + 1] = tempItem
    }
    if(this._batchNode) {
      this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.sortAllChildren)
    }
    this._reorderChildDirty = false
  }
}, reorderChild:function(child, zOrder) {
  cc.Assert(child != null, "child is null");
  cc.Assert(this._children.indexOf(child) > -1, "this child is not in children list");
  if(zOrder === child.getZOrder()) {
    return
  }
  if(this._batchNode && !this._reorderChildDirty) {
    this._setReorderChildDirtyRecursively();
    this._batchNode.reorderBatch(true)
  }
  this._super(child, zOrder)
}, removeChild:function(child, cleanup) {
  if(this._batchNode) {
    this._batchNode.removeSpriteFromAtlas(child)
  }
  this._super(child, cleanup)
}, removeAllChildren:function(cleanup) {
  if(this._batchNode) {
    if(this._children != null) {
      for(var i = 0;i < this._children.length;i++) {
        if(this._children[i] instanceof cc.Sprite) {
          this._batchNode.removeSpriteFromAtlas(this._children[i])
        }
      }
    }
  }
  this._super(cleanup);
  this._hasChildren = false
}, setDirtyRecursively:function(value) {
  this._recursiveDirty = value;
  this.setDirty(value);
  if(this._children != null) {
    for(var i = 0;i < this._children.length;i++) {
      if(this._children[i] instanceof cc.Sprite) {
        this._children[i].setDirtyRecursively(true)
      }
    }
  }
}, SET_DIRTY_RECURSIVELY:function() {
  if(this._batchNode && !this._recursiveDirty) {
    this._recursiveDirty = true;
    this._dirty = true;
    if(this._hasChildren) {
      this.setDirtyRecursively(true)
    }
  }
}, setPosition:function(pos) {
  if(arguments.length >= 2) {
    cc.Node.prototype.setPosition.call(this, pos, arguments[1])
  }else {
    cc.Node.prototype.setPosition.call(this, pos)
  }
  this.SET_DIRTY_RECURSIVELY()
}, setRotation:function(rotation) {
  cc.Node.prototype.setRotation.call(this, rotation);
  this.SET_DIRTY_RECURSIVELY()
}, setRotationX:function(rotationX) {
  cc.Node.prototype.setRotationX.call(this, rotationX);
  this.SET_DIRTY_RECURSIVELY()
}, setRotationY:function(rotationY) {
  cc.Node.prototype.setRotationY.call(this, rotationY);
  this.SET_DIRTY_RECURSIVELY()
}, setSkewX:function(sx) {
  cc.Node.prototype.setSkewX.call(this, sx);
  this.SET_DIRTY_RECURSIVELY()
}, setSkewY:function(sy) {
  cc.Node.prototype.setSkewY.call(this, sy);
  this.SET_DIRTY_RECURSIVELY()
}, setScaleX:function(scaleX) {
  cc.Node.prototype.setScaleX.call(this, scaleX);
  this.SET_DIRTY_RECURSIVELY()
}, setScaleY:function(scaleY) {
  cc.Node.prototype.setScaleY.call(this, scaleY);
  this.SET_DIRTY_RECURSIVELY()
}, setScale:function(scale, scaleY) {
  cc.Node.prototype.setScale.call(this, scale, scaleY);
  this.SET_DIRTY_RECURSIVELY()
}, setVertexZ:function(vertexZ) {
  cc.Node.prototype.setVertexZ.call(this, vertexZ);
  this.SET_DIRTY_RECURSIVELY()
}, setAnchorPoint:function(anchor) {
  cc.Node.prototype.setAnchorPoint.call(this, anchor);
  this.SET_DIRTY_RECURSIVELY()
}, setVisible:function(visible) {
  cc.Node.prototype.setVisible.call(this, visible);
  this.SET_DIRTY_RECURSIVELY()
}, ignoreAnchorPointForPosition:function(relative) {
  cc.Assert(!this._batchNode, "ignoreAnchorPointForPosition is invalid in cc.Sprite");
  this._super(relative)
}, setFlipX:function(flipX) {
  if(this._flipX != flipX) {
    this._flipX = flipX;
    this.setTextureRect(this._rect, this._rectRotated, this._contentSize);
    this.setNodeDirty()
  }
}, setFlipY:function(flipY) {
  if(this._flipY != flipY) {
    this._flipY = flipY;
    this.setTextureRect(this._rect, this._rectRotated, this._contentSize);
    this.setNodeDirty()
  }
}, isFlippedX:function() {
  return this._flipX
}, isFlippedY:function() {
  return this._flipY
}, getOpacity:function() {
  return this._opacity
}, getColor:function() {
  if(this._opacityModifyRGB) {
    return new cc.Color3B(this._colorUnmodified)
  }
  return new cc.Color3B(this._color)
}, setOpacityModifyRGB:function(value) {
  var oldColor = this._color;
  this._opacityModifyRGB = value;
  this._color = oldColor
}, isOpacityModifyRGB:function() {
  return this._opacityModifyRGB
}, setDisplayFrameWithAnimationName:function(animationName, frameIndex) {
  cc.Assert(animationName, "cc.Sprite#setDisplayFrameWithAnimationName. animationName must not be null");
  var cache = cc.AnimationCache.getInstance().getAnimation(animationName);
  cc.Assert(cache, "cc.Sprite#setDisplayFrameWithAnimationName: Frame not found");
  var animFrame = cache.getFrames()[frameIndex];
  cc.Assert(animFrame, "cc.Sprite#setDisplayFrame. Invalid frame");
  this.setDisplayFrame(animFrame.getSpriteFrame())
}, getBatchNode:function() {
  return this._batchNode
}, _setReorderChildDirtyRecursively:function() {
  if(!this._reorderChildDirty) {
    this._reorderChildDirty = true;
    var pNode = this._parent;
    while(pNode && pNode != this._batchNode) {
      pNode._setReorderChildDirtyRecursively();
      pNode = pNode.getParent()
    }
  }
}, getTexture:function() {
  return this._texture
}, _colorized:false, _isLighterMode:false, _originalTexture:null, ctor:function(fileName) {
  this._super();
  this._shouldBeHidden = false;
  this._offsetPosition = cc.p(0, 0);
  this._unflippedOffsetPositionFromCenter = cc.p(0, 0);
  this._color = cc.white();
  this._blendFunc = {src:cc.BLEND_SRC, dst:cc.BLEND_DST};
  if(fileName) {
    if(typeof fileName == "string") {
      var frame = cc.SpriteFrameCache.getInstance().getSpriteFrame(fileName);
      this.initWithSpriteFrame(frame)
    }else {
      if(typeof fileName === "object") {
        if(fileName instanceof cc.SpriteFrame) {
          this.initWithSpriteFrame(fileName)
        }else {
          if(fileName instanceof cc.SpriteBatchNode) {
            if(arguments.length > 1) {
              var rect = arguments[1];
              if(rect instanceof cc.Rect) {
                this.initWithBatchNode(fileName, rect)
              }
            }
          }else {
            if(fileName instanceof HTMLImageElement || fileName instanceof HTMLCanvasElement) {
              this.initWithTexture(fileName)
            }
          }
        }
      }
    }
  }
}, setBlendFunc:function(src, dst) {
  if(arguments.length == 1) {
    this._blendFunc = src
  }else {
    this._blendFunc = {src:src, dst:dst}
  }
  this._isLighterMode = this._blendFunc && this._blendFunc.src === gl.SRC_ALPHA && this._blendFunc.dst === gl.ONE
}, init:function() {
  if(arguments.length > 0) {
    return this.initWithFile(arguments[0], arguments[1])
  }
  this._super();
  this._dirty = this._recursiveDirty = false;
  this._opacityModifyRGB = true;
  this._opacity = 255;
  this._color = cc.white();
  this._colorUnmodified = cc.white();
  this._blendFunc.src = cc.BLEND_SRC;
  this._blendFunc.dst = cc.BLEND_DST;
  this.setTexture(null);
  this._flipX = this._flipY = false;
  this.setAnchorPoint(cc.p(0.5, 0.5));
  this._offsetPosition = cc.PointZero();
  this._hasChildren = false;
  this.setTextureRect(cc.RectZero(), false, cc.SizeZero());
  return true
}, initWithFile:function(filename, rect) {
  cc.Assert(filename != null, "Sprite#initWithFile():Invalid filename for sprite");
  var selfPointer = this;
  var texture = cc.TextureCache.getInstance().textureForKey(cc.FileUtils.getInstance().fullPathForFilename(filename));
  if(!texture) {
    this._visible = false;
    var loadImg = new Image;
    loadImg.addEventListener("load", function() {
      if(!rect) {
        rect = cc.rect(0, 0, loadImg.width, loadImg.height)
      }
      selfPointer.initWithTexture(loadImg, rect);
      cc.TextureCache.getInstance().cacheImage(filename, loadImg);
      selfPointer._visible = true
    });
    loadImg.addEventListener("error", function() {
      cc.log("load failure:" + filename)
    });
    loadImg.src = filename;
    return true
  }else {
    if(texture) {
      if(!rect) {
        rect = cc.rect(0, 0, texture.width, texture.height)
      }
      return this.initWithTexture(texture, rect)
    }
  }
  return false
}, initWithTexture:function(texture, rect, rotated) {
  var argnum = arguments.length;
  if(argnum == 0) {
    throw"Sprite.initWithTexture(): Argument must be non-nil ";
  }
  rotated = rotated || false;
  this._batchNode = null;
  this._recursiveDirty = false;
  this.setDirty(false);
  this._opacityModifyRGB = true;
  this._opacity = 255;
  this._color = cc.white();
  this._colorUnmodified = cc.white();
  this._blendFunc.src = cc.BLEND_SRC;
  this._blendFunc.dst = cc.BLEND_DST;
  this._flipX = this._flipY = false;
  this.setAnchorPoint(cc.p(0.5, 0.5));
  this._offsetPosition = cc.p(0, 0);
  this._hasChildren = false;
  if(!rect) {
    rect = cc.rect(0, 0, 0, 0);
    if(texture instanceof HTMLImageElement || texture instanceof HTMLCanvasElement) {
      rect.size = cc.size(texture.width, texture.height)
    }
  }
  this._originalTexture = texture;
  this.setTexture(texture);
  this.setTextureRect(rect, rotated, rect.size);
  this.setBatchNode(null);
  return true
}, setTextureRect:function(rect, rotated, untrimmedSize) {
  this._rectRotated = rotated || false;
  untrimmedSize = untrimmedSize || rect.size;
  this.setContentSize(untrimmedSize);
  this.setVertexRect(rect);
  var relativeOffset = this._unflippedOffsetPositionFromCenter;
  this._offsetPosition.x = relativeOffset.x + (this._contentSize.width - this._rect.size.width) / 2;
  this._offsetPosition.y = relativeOffset.y + (this._contentSize.height - this._rect.size.height) / 2;
  if(this._batchNode) {
    this._dirty = true
  }
}, updateTransform:function() {
  if(this.isDirty()) {
    if(!this._visible || this._parent && this._parent != this._batchNode && this._parent._shouldBeHidden) {
      this._shouldBeHidden = true
    }else {
      this._shouldBeHidden = false;
      if(!this._parent || this._parent == this._batchNode) {
        this._transformToBatch = this.nodeToParentTransform()
      }else {
        this._transformToBatch = cc.AffineTransformConcat(this.nodeToParentTransform(), this._parent._transformToBatch)
      }
    }
    this._recursiveDirty = false;
    this.setDirty(false)
  }
  if(this._hasChildren) {
    this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform)
  }
}, addChild:function(child, zOrder, tag) {
  cc.Assert(child != null, "Argument must be non-NULL");
  if(zOrder == null) {
    zOrder = child._zOrder
  }
  if(tag == null) {
    tag = child._tag
  }
  this._super(child, zOrder, tag);
  this._hasChildren = true
}, setOpacity:function(opacity) {
  this._opacity = opacity;
  this.setNodeDirty()
}, setColor:function(color3) {
  if(this._color.r == color3.r && this._color.g == color3.g && this._color.b == color3.b) {
    return
  }
  this._color = this._colorUnmodified = new cc.Color3B(color3.r, color3.g, color3.b);
  this._changeTextureColor();
  if(this._opacityModifyRGB) {
    this._color.r = 0 | color3.r * this._opacity / 255;
    this._color.g = 0 | color3.g * this._opacity / 255;
    this._color.b = 0 | color3.b * this._opacity / 255
  }
  this.setNodeDirty()
}, setDisplayFrame:function(newFrame) {
  this.setNodeDirty();
  this._unflippedOffsetPositionFromCenter = newFrame.getOffset();
  var pNewTexture = newFrame.getTexture();
  if(pNewTexture != this._texture) {
    this.setTexture(pNewTexture)
  }
  this._rectRotated = newFrame.isRotated();
  if(this._rectRotated) {
    this._originalTexture = pNewTexture
  }
  this.setTextureRect(newFrame.getRect(), this._rectRotated, newFrame.getOriginalSize());
  if(this._color.r !== 255 || this._color.g !== 255 || this._color.b !== 255) {
    this._changeTextureColor()
  }
}, isFrameDisplayed:function(frame) {
  if(frame.getTexture() != this._texture) {
    return false
  }
  return cc.Rect.CCRectEqualToRect(frame.getRect(), this._rect)
}, displayFrame:function() {
  return cc.SpriteFrame._frameWithTextureForCanvas(this._texture, cc.RECT_POINTS_TO_PIXELS(this._rect), this._rectRotated, this._unflippedOffsetPositionFromCenter, cc.SIZE_POINTS_TO_PIXELS(this._contentSize))
}, setBatchNode:function(spriteBatchNode) {
  this._batchNode = spriteBatchNode;
  if(!this._batchNode) {
    this._atlasIndex = cc.SPRITE_INDEX_NOT_INITIALIZED;
    this.setTextureAtlas(null);
    this._recursiveDirty = false;
    this.setDirty(false)
  }else {
    this._transformToBatch = cc.AffineTransformIdentity();
    this.setTextureAtlas(this._batchNode.getTextureAtlas())
  }
}, setTexture:function(texture) {
  cc.Assert(!texture || texture instanceof HTMLImageElement || texture instanceof HTMLCanvasElement, "setTexture expects a CCTexture2D. Invalid argument");
  if(this._texture != texture) {
    if(texture instanceof HTMLImageElement) {
      if(!this._rect || cc.rectEqualToRect(this._rect, cc.RectZero())) {
        this._rect = cc.rect(0, 0, texture.width, texture.height)
      }
      this._originalTexture = texture
    }
    this._texture = texture
  }
}, _changeTextureColor:function() {
  if(this.getTexture()) {
    var cacheTextureForColor = cc.TextureCache.getInstance().getTextureColors(this._originalTexture);
    if(cacheTextureForColor) {
      this._colorized = true;
      if(this._texture instanceof HTMLCanvasElement && !this._rectRotated) {
        cc.generateTintImage(this.getTexture(), cacheTextureForColor, this._color, this.getTextureRect(), this._texture)
      }else {
        var colorTexture = cc.generateTintImage(this.getTexture(), cacheTextureForColor, this._color, this.getTextureRect());
        this.setTexture(colorTexture)
      }
    }
  }
}, draw:function(ctx) {
  var context = ctx || cc.renderContext;
  if(this._isLighterMode) {
    context.globalCompositeOperation = "lighter"
  }
  context.globalAlpha = this._opacity / 255;
  var flipXOffset = 0, flipYOffset = 0;
  if(this._flipX) {
    flipXOffset = this._rect.size.width;
    context.scale(-1, 1)
  }
  if(this._flipY) {
    flipYOffset = this._rect.size.height;
    context.scale(1, -1)
  }
  var posX = 0 | this._offsetPosition.x;
  var posY = 0 | this._offsetPosition.y;
  if(this._texture) {
    if(this._colorized) {
      context.drawImage(this._texture, 0, 0, this._rect.size.width, this._rect.size.height, this._offsetPosition.x - flipXOffset, -this._offsetPosition.y - this._rect.size.height + flipYOffset, this._rect.size.width, this._rect.size.height)
    }else {
      context.drawImage(this._texture, this._rect.origin.x, this._rect.origin.y, this._rect.size.width, this._rect.size.height, this._offsetPosition.x - flipXOffset, -this._offsetPosition.y - this._rect.size.height + flipYOffset, this._rect.size.width, this._rect.size.height)
    }
  }else {
    if(this._contentSize.width !== 0) {
      context.fillStyle = "rgba(" + this._color.r + "," + this._color.g + "," + this._color.b + ",1)";
      context.fillRect(posX, posY, this._contentSize.width, -this._contentSize.height)
    }
  }
  if(cc.SPRITE_DEBUG_DRAW === 1) {
    context.strokeStyle = "rgba(0,255,0,1)";
    var vertices1 = [cc.p(posX, posY), cc.p(posX + this._rect.size.width, posY), cc.p(posX + this._rect.size.width, posY + this._rect.size.height), cc.p(posX, posY + this._rect.size.height)];
    cc.drawingUtil.drawPoly(vertices1, 4, true)
  }else {
    if(cc.SPRITE_DEBUG_DRAW === 2) {
      context.strokeStyle = "rgba(0,255,0,1)";
      var drawSize = this._rect.size;
      var offsetPix = this.getOffsetPosition();
      var vertices2 = [cc.p(offsetPix.x, offsetPix.y), cc.p(offsetPix.x + drawSize.width, offsetPix.y), cc.p(offsetPix.x + drawSize.width, offsetPix.y + drawSize.height), cc.p(offsetPix.x, offsetPix.y + drawSize.height)];
      cc.drawingUtil.drawPoly(vertices2, 4, true)
    }
  }
  cc.g_NumberOfDraws++
}});
cc.SpriteCanvas.createWithTexture = function(texture, rect, offset) {
  var argnum = arguments.length;
  var sprite = new cc.SpriteCanvas;
  switch(argnum) {
    case 1:
      if(sprite && sprite.initWithTexture(texture)) {
        return sprite
      }
      return null;
      break;
    case 2:
      if(sprite && sprite.initWithTexture(texture, rect)) {
        return sprite
      }
      return null;
      break;
    case 3:
      cc.Assert(0, "");
      return null;
      break;
    default:
      throw"Sprite.createWithTexture(): Argument must be non-nil ";break
  }
};
cc.SpriteCanvas.create = function(fileName, rect) {
  var argnum = arguments.length;
  var sprite = new cc.SpriteCanvas;
  if(argnum === 0) {
    if(sprite.init()) {
      return sprite
    }
  }else {
    if(sprite && sprite.init(fileName, rect)) {
      return sprite
    }
  }
  return null
};
cc.SpriteCanvas.createWithSpriteFrameName = function(spriteFrameName) {
  var spriteFrame = null;
  if(typeof spriteFrameName == "string") {
    spriteFrame = cc.SpriteFrameCache.getInstance().getSpriteFrame(spriteFrameName);
    if(!spriteFrame) {
      cc.log("Invalid spriteFrameName: " + spriteFrameName);
      return null
    }
  }else {
    cc.log("Invalid argument. Expecting string.");
    return null
  }
  var sprite = new cc.SpriteCanvas;
  if(sprite && sprite.initWithSpriteFrame(spriteFrame)) {
    return sprite
  }
  return null
};
cc.SpriteCanvas.createWithSpriteFrame = function(spriteFrame) {
  var sprite = new cc.SpriteCanvas;
  if(sprite && sprite.initWithSpriteFrame(spriteFrame)) {
    return sprite
  }
  return null
};
cc.SpriteWebGL = cc.Node.extend({RGBAProtocol:true, _textureAtlas:null, _atlasIndex:0, _batchNode:null, _dirty:null, _recursiveDirty:null, _hasChildren:null, _shouldBeHidden:false, _transformToBatch:null, _blendFunc:null, _texture:null, _color:null, _rect:cc.rect(0, 0, 0, 0), _rectRotated:null, _offsetPosition:null, _unflippedOffsetPositionFromCenter:null, colorUnmodified:null, _opacityModifyRGB:null, _flipX:null, _flipY:null, _opacity:255, isDirty:function() {
  return this._dirty
}, setDirty:function(bDirty) {
  this._dirty = bDirty
}, getQuad:function() {
  return null
}, isTextureRectRotated:function() {
  return this._rectRotated
}, getAtlasIndex:function() {
  return this._atlasIndex
}, setAtlasIndex:function(atlasIndex) {
  this._atlasIndex = atlasIndex
}, getTextureRect:function() {
  return cc.rect(this._rect.origin.x, this._rect.origin.y, this._rect.size.width, this._rect.size.height)
}, getTextureAtlas:function(pobTextureAtlas) {
  return this._textureAtlas
}, setTextureAtlas:function(textureAtlas) {
  this._textureAtlas = textureAtlas
}, getSpriteBatchNode:function() {
  return this._batchNode
}, setSpriteBatchNode:function(spriteBatchNode) {
  this._batchNode = spriteBatchNode
}, getOffsetPosition:function() {
  return cc.p(this._offsetPosition.x, this._offsetPosition.y)
}, getBlendFunc:function() {
  return this._blendFunc
}, initWithSpriteFrame:function(spriteFrame) {
  cc.Assert(spriteFrame != null, "");
  var ret = this.initWithTexture(spriteFrame.getTexture(), spriteFrame.getRect());
  this.setDisplayFrame(spriteFrame);
  return ret
}, initWithSpriteFrameName:function(spriteFrameName) {
  cc.Assert(spriteFrameName != null, "");
  var frame = cc.SpriteFrameCache.getInstance().getSpriteFrame(spriteFrameName);
  return this.initWithSpriteFrame(frame)
}, useBatchNode:function(batchNode) {
  this._textureAtlas = batchNode.getTextureAtlas();
  this._batchNode = batchNode
}, setVertexRect:function(rect) {
  this._rect = rect
}, sortAllChildren:function() {
  if(this._reorderChildDirty) {
    var j;
    var tempItem = null;
    for(var i = 1;i < this._children.length;i++) {
      tempItem = this._children[i];
      j = i - 1;
      while(j >= 0 && (tempItem.getZOrder() < this._children[j].getZOrder() || tempItem.getZOrder() == this._children[j].getZOrder() && tempItem.getOrderOfArrival() < this._children[j].getOrderOfArrival())) {
        this._children[j + 1] = this._children[j];
        j = j - 1
      }
      this._children[j + 1] = tempItem
    }
    if(this._batchNode) {
      this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.sortAllChildren)
    }
    this._reorderChildDirty = false
  }
}, reorderChild:function(child, zOrder) {
  cc.Assert(child != null, "child is null");
  cc.Assert(this._children.indexOf(child) > -1, "this child is not in children list");
  if(zOrder === child.getZOrder()) {
    return
  }
  if(this._batchNode && !this._reorderChildDirty) {
    this._setReorderChildDirtyRecursively();
    this._batchNode.reorderBatch(true)
  }
  this._super(child, zOrder)
}, removeChild:function(child, cleanup) {
  if(this._batchNode) {
    this._batchNode.removeSpriteFromAtlas(child)
  }
  this._super(child, cleanup)
}, removeAllChildren:function(cleanup) {
  if(this._batchNode) {
    if(this._children != null) {
      for(var i = 0;i < this._children.length;i++) {
        if(this._children[i] instanceof cc.Sprite) {
          this._batchNode.removeSpriteFromAtlas(this._children[i])
        }
      }
    }
  }
  this._super(cleanup);
  this._hasChildren = false
}, setDirtyRecursively:function(value) {
  this._recursiveDirty = value;
  this.setDirty(value);
  if(this._children != null) {
    for(var i = 0;i < this._children.length;i++) {
      if(this._children[i] instanceof cc.Sprite) {
        this._children[i].setDirtyRecursively(true)
      }
    }
  }
}, SET_DIRTY_RECURSIVELY:function() {
  if(this._batchNode && !this._recursiveDirty) {
    this._recursiveDirty = true;
    this._dirty = true;
    if(this._hasChildren) {
      this.setDirtyRecursively(true)
    }
  }
}, setPosition:function(pos) {
  if(arguments.length >= 2) {
    cc.Node.prototype.setPosition.call(this, pos, arguments[1])
  }else {
    cc.Node.prototype.setPosition.call(this, pos)
  }
  this.SET_DIRTY_RECURSIVELY()
}, setRotation:function(rotation) {
  cc.Node.prototype.setRotation.call(this, rotation);
  this.SET_DIRTY_RECURSIVELY()
}, setRotationX:function(rotationX) {
  cc.Node.prototype.setRotationX.call(this, rotationX);
  this.SET_DIRTY_RECURSIVELY()
}, setRotationY:function(rotationY) {
  cc.Node.prototype.setRotationY.call(this, rotationY);
  this.SET_DIRTY_RECURSIVELY()
}, setSkewX:function(sx) {
  cc.Node.prototype.setSkewX.call(this, sx);
  this.SET_DIRTY_RECURSIVELY()
}, setSkewY:function(sy) {
  cc.Node.prototype.setSkewY.call(this, sy);
  this.SET_DIRTY_RECURSIVELY()
}, setScaleX:function(scaleX) {
  cc.Node.prototype.setScaleX.call(this, scaleX);
  this.SET_DIRTY_RECURSIVELY()
}, setScaleY:function(scaleY) {
  cc.Node.prototype.setScaleY.call(this, scaleY);
  this.SET_DIRTY_RECURSIVELY()
}, setScale:function(scale, scaleY) {
  cc.Node.prototype.setScale.call(this, scale, scaleY);
  this.SET_DIRTY_RECURSIVELY()
}, setVertexZ:function(vertexZ) {
  cc.Node.prototype.setVertexZ.call(this, vertexZ);
  this.SET_DIRTY_RECURSIVELY()
}, setAnchorPoint:function(anchor) {
  cc.Node.prototype.setAnchorPoint.call(this, anchor);
  this.SET_DIRTY_RECURSIVELY()
}, setVisible:function(visible) {
  cc.Node.prototype.setVisible.call(this, visible);
  this.SET_DIRTY_RECURSIVELY()
}, ignoreAnchorPointForPosition:function(relative) {
  cc.Assert(!this._batchNode, "ignoreAnchorPointForPosition is invalid in cc.Sprite");
  this._super(relative)
}, setFlipX:function(flipX) {
  if(this._flipX != flipX) {
    this._flipX = flipX;
    this.setTextureRect(this._rect, this._rectRotated, this._contentSize);
    this.setNodeDirty()
  }
}, setFlipY:function(flipY) {
  if(this._flipY != flipY) {
    this._flipY = flipY;
    this.setTextureRect(this._rect, this._rectRotated, this._contentSize);
    this.setNodeDirty()
  }
}, isFlippedX:function() {
  return this._flipX
}, isFlippedY:function() {
  return this._flipY
}, getOpacity:function() {
  return this._opacity
}, getColor:function() {
  if(this._opacityModifyRGB) {
    return new cc.Color3B(this._colorUnmodified)
  }
  return new cc.Color3B(this._color)
}, setOpacityModifyRGB:function(value) {
  var oldColor = this._color;
  this._opacityModifyRGB = value;
  this._color = oldColor
}, isOpacityModifyRGB:function() {
  return this._opacityModifyRGB
}, setDisplayFrameWithAnimationName:function(animationName, frameIndex) {
  cc.Assert(animationName, "cc.Sprite#setDisplayFrameWithAnimationName. animationName must not be null");
  var cache = cc.AnimationCache.getInstance().getAnimation(animationName);
  cc.Assert(cache, "cc.Sprite#setDisplayFrameWithAnimationName: Frame not found");
  var animFrame = cache.getFrames()[frameIndex];
  cc.Assert(animFrame, "cc.Sprite#setDisplayFrame. Invalid frame");
  this.setDisplayFrame(animFrame.getSpriteFrame())
}, getBatchNode:function() {
  return this._batchNode
}, _setReorderChildDirtyRecursively:function() {
  if(!this._reorderChildDirty) {
    this._reorderChildDirty = true;
    var pNode = this._parent;
    while(pNode && pNode != this._batchNode) {
      pNode._setReorderChildDirtyRecursively();
      pNode = pNode.getParent()
    }
  }
}, getTexture:function() {
  return this._texture
}, _quad:null, _quadWebBuffer:null, _quadDirty:false, ctor:function(fileName) {
  this._super();
  this._shouldBeHidden = false;
  this._offsetPosition = cc.p(0, 0);
  this._unflippedOffsetPositionFromCenter = cc.p(0, 0);
  this._color = cc.white();
  this._blendFunc = {src:cc.BLEND_SRC, dst:cc.BLEND_DST};
  this._quad = new cc.V3F_C4B_T2F_Quad;
  this._quadWebBuffer = cc.renderContext.createBuffer();
  this._quadDirty = true;
  if(fileName) {
    if(typeof fileName == "string") {
      var frame = cc.SpriteFrameCache.getInstance().getSpriteFrame(fileName);
      this.initWithSpriteFrame(frame)
    }else {
      if(typeof fileName == "object") {
        if(fileName instanceof cc.SpriteFrame) {
          this.initWithSpriteFrame(fileName)
        }else {
          if(fileName instanceof cc.SpriteBatchNode) {
            if(arguments.length > 1) {
              var rect = arguments[1];
              if(rect instanceof cc.Rect) {
                this.initWithBatchNode(fileName, rect)
              }
            }
          }else {
            if(fileName instanceof HTMLImageElement || fileName instanceof HTMLCanvasElement) {
              var texture2d = new cc.Texture2D;
              texture2d.initWithElement(fileName);
              texture2d.handleLoadedTexture();
              this.initWithTexture(texture2d)
            }else {
              if(fileName instanceof cc.Texture2D) {
                this.initWithTexture(fileName)
              }
            }
          }
        }
      }
    }
  }
}, getQuad:function() {
  return this._quad
}, setBlendFunc:function(src, dst) {
  if(arguments.length == 1) {
    this._blendFunc = src
  }else {
    this._blendFunc = {src:src, dst:dst}
  }
}, init:function() {
  if(arguments.length > 0) {
    return this.initWithFile(arguments[0], arguments[1])
  }
  this._super();
  this._dirty = this._recursiveDirty = false;
  this._opacityModifyRGB = true;
  this._opacity = 255;
  this._color = cc.white();
  this._colorUnmodified = cc.white();
  this._blendFunc.src = cc.BLEND_SRC;
  this._blendFunc.dst = cc.BLEND_DST;
  this.setTexture(null);
  this._flipX = this._flipY = false;
  this.setAnchorPoint(cc.p(0.5, 0.5));
  this._offsetPosition = cc.PointZero();
  this._hasChildren = false;
  this._quad.bl.colors = new cc.Color4B(255, 255, 255, 255);
  this._quad.br.colors = new cc.Color4B(255, 255, 255, 255);
  this._quad.tl.colors = new cc.Color4B(255, 255, 255, 255);
  this._quad.tr.colors = new cc.Color4B(255, 255, 255, 255);
  this._quadDirty = true;
  this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
  this.setTextureRect(cc.RectZero(), false, cc.SizeZero());
  return true
}, initWithFile:function(filename, rect) {
  cc.Assert(filename != null, "Sprite#initWithFile():Invalid filename for sprite");
  var selfPointer = this;
  var texture = cc.TextureCache.getInstance().textureForKey(cc.FileUtils.getInstance().fullPathForFilename(filename));
  if(!texture) {
    this._visible = false;
    var loadImg = new Image;
    loadImg.addEventListener("load", function() {
      if(!rect) {
        rect = cc.rect(0, 0, loadImg.width, loadImg.height)
      }
      var texture2d = new cc.Texture2D;
      texture2d.initWithElement(loadImg);
      texture2d.handleLoadedTexture();
      selfPointer.initWithTexture(texture2d, rect);
      cc.TextureCache.getInstance().cacheImage(filename, loadImg);
      selfPointer._visible = true
    });
    loadImg.addEventListener("error", function() {
      cc.log("load failure:" + filename)
    });
    loadImg.src = filename;
    return true
  }else {
    if(texture) {
      if(!rect) {
        var size = texture.getContentSize();
        rect = cc.rect(0, 0, size.width, size.height)
      }
      return this.initWithTexture(texture, rect)
    }
  }
  return false
}, initWithTexture:function(texture, rect, rotated) {
  var argnum = arguments.length;
  if(argnum == 0) {
    throw"Sprite.initWithTexture(): Argument must be non-nil ";
  }
  rotated = rotated || false;
  this._batchNode = null;
  this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
  this._recursiveDirty = false;
  this.setDirty(false);
  this._opacityModifyRGB = true;
  this._opacity = 255;
  this._color = cc.white();
  this._colorUnmodified = cc.white();
  this._blendFunc.src = cc.BLEND_SRC;
  this._blendFunc.dst = cc.BLEND_DST;
  this._flipX = this._flipY = false;
  this.setAnchorPoint(cc.p(0.5, 0.5));
  this._offsetPosition = cc.p(0, 0);
  this._hasChildren = false;
  var tmpColor = new cc.Color4B(255, 255, 255, 255);
  this._quad.bl.colors = tmpColor;
  this._quad.br.colors = tmpColor;
  this._quad.tl.colors = tmpColor;
  this._quad.tr.colors = tmpColor;
  if(!rect) {
    rect = cc.rect(0, 0, 0, 0);
    rect.size = texture.getContentSize()
  }
  this.setTexture(texture);
  this.setTextureRect(rect, rotated, rect.size);
  this.setBatchNode(null);
  this._quadDirty = true;
  return true
}, setTextureRect:function(rect, rotated, untrimmedSize) {
  this._rectRotated = rotated || false;
  untrimmedSize = untrimmedSize || rect.size;
  this.setContentSize(untrimmedSize);
  this.setVertexRect(rect);
  this._setTextureCoords(rect);
  var relativeOffset = this._unflippedOffsetPositionFromCenter;
  if(this._flipX) {
    relativeOffset.x = -relativeOffset.x
  }
  if(this._flipY) {
    relativeOffset.y = -relativeOffset.y
  }
  this._offsetPosition.x = relativeOffset.x + (this._contentSize.width - this._rect.size.width) / 2;
  this._offsetPosition.y = relativeOffset.y + (this._contentSize.height - this._rect.size.height) / 2;
  if(this._batchNode) {
    this._dirty = true
  }else {
    var x1 = 0 + this._offsetPosition.x;
    var y1 = 0 + this._offsetPosition.y;
    var x2 = x1 + this._rect.size.width;
    var y2 = y1 + this._rect.size.height;
    this._quad.bl.vertices = {x:x1, y:y1, z:0};
    this._quad.br.vertices = {x:x2, y:y1, z:0};
    this._quad.tl.vertices = {x:x1, y:y2, z:0};
    this._quad.tr.vertices = {x:x2, y:y2, z:0};
    this._quadDirty = true
  }
}, updateTransform:function() {
  if(this.isDirty()) {
    if(!this._visible || this._parent && this._parent != this._batchNode && this._parent._shouldBeHidden) {
      this._quad.br.vertices = {x:0, y:0, z:0};
      this._quad.tl.vertices = {x:0, y:0, z:0};
      this._quad.tr.vertices = {x:0, y:0, z:0};
      this._quad.bl.vertices = {x:0, y:0, z:0};
      this._shouldBeHidden = true
    }else {
      this._shouldBeHidden = false;
      if(!this._parent || this._parent == this._batchNode) {
        this._transformToBatch = this.nodeToParentTransform()
      }else {
        this._transformToBatch = cc.AffineTransformConcat(this.nodeToParentTransform(), this._parent._transformToBatch)
      }
      var size = this._rect.size;
      var x1 = this._offsetPosition.x;
      var y1 = this._offsetPosition.y;
      var x2 = x1 + size.width;
      var y2 = y1 + size.height;
      var x = this._transformToBatch.tx;
      var y = this._transformToBatch.ty;
      var cr = this._transformToBatch.a;
      var sr = this._transformToBatch.b;
      var cr2 = this._transformToBatch.d;
      var sr2 = -this._transformToBatch.c;
      var ax = x1 * cr - y1 * sr2 + x;
      var ay = x1 * sr + y1 * cr2 + y;
      var bx = x2 * cr - y1 * sr2 + x;
      var by = x2 * sr + y1 * cr2 + y;
      var cx = x2 * cr - y2 * sr2 + x;
      var cy = x2 * sr + y2 * cr2 + y;
      var dx = x1 * cr - y2 * sr2 + x;
      var dy = x1 * sr + y2 * cr2 + y;
      this._quad.bl.vertices = {x:cc.RENDER_IN_SUBPIXEL(ax), y:cc.RENDER_IN_SUBPIXEL(ay), z:this._vertexZ};
      this._quad.br.vertices = {x:cc.RENDER_IN_SUBPIXEL(bx), y:cc.RENDER_IN_SUBPIXEL(by), z:this._vertexZ};
      this._quad.tl.vertices = {x:cc.RENDER_IN_SUBPIXEL(dx), y:cc.RENDER_IN_SUBPIXEL(dy), z:this._vertexZ};
      this._quad.tr.vertices = {x:cc.RENDER_IN_SUBPIXEL(cx), y:cc.RENDER_IN_SUBPIXEL(cy), z:this._vertexZ}
    }
    if(cc.renderContextType === cc.WEBGL) {
      this._textureAtlas.updateQuad(this._quad, this._atlasIndex)
    }
    this._recursiveDirty = false;
    this.setDirty(false)
  }
  if(this._hasChildren) {
    this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform)
  }
  if(cc.SPRITE_DEBUG_DRAW) {
    var vertices = [cc.p(this._quad.bl.vertices.x, this._quad.bl.vertices.y), cc.p(this._quad.br.vertices.x, this._quad.br.vertices.y), cc.p(this._quad.tr.vertices.x, this._quad.tr.vertices.y), cc.p(this._quad.tl.vertices.x, this._quad.tl.vertices.y)];
    cc.drawingUtil.drawPoly(vertices, 4, true)
  }
}, addChild:function(child, zOrder, tag) {
  cc.Assert(child != null, "Argument must be non-NULL");
  if(zOrder == null) {
    zOrder = child._zOrder
  }
  if(tag == null) {
    tag = child._tag
  }
  if(this._batchNode) {
    cc.Assert(child instanceof cc.Sprite, "cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode");
    cc.Assert(child.getTexture()._webTextureObj === this._textureAtlas.getTexture()._webTextureObj, "");
    this._batchNode.appendChild(child);
    if(!this._reorderChildDirty) {
      this._setReorderChildDirtyRecursively()
    }
  }
  this._super(child, zOrder, tag);
  this._hasChildren = true
}, updateColor:function() {
  var color4 = {r:this._color.r, g:this._color.g, b:this._color.b, a:this._opacity};
  this._quad.bl.colors = color4;
  this._quad.br.colors = color4;
  this._quad.tl.colors = color4;
  this._quad.tr.colors = color4;
  if(this._batchNode) {
    if(this._atlasIndex != cc.SPRITE_INDEX_NOT_INITIALIZED) {
      this._textureAtlas.updateQuad(this._quad, this._atlasIndex)
    }else {
      this._dirty = true
    }
  }
  this._quadDirty = true
}, setOpacity:function(opacity) {
  this._opacity = opacity;
  if(this._opacityModifyRGB) {
    this.setColor(this._colorUnmodified)
  }
  this.updateColor()
}, setColor:function(color3) {
  if(this._color.r == color3.r && this._color.g == color3.g && this._color.b == color3.b) {
    return
  }
  this._color = this._colorUnmodified = new cc.Color3B(color3.r, color3.g, color3.b);
  if(this._opacityModifyRGB) {
    this._color.r = 0 | color3.r * this._opacity / 255;
    this._color.g = 0 | color3.g * this._opacity / 255;
    this._color.b = 0 | color3.b * this._opacity / 255
  }
  this.updateColor()
}, setDisplayFrame:function(newFrame) {
  this.setNodeDirty();
  this._unflippedOffsetPositionFromCenter = newFrame.getOffset();
  var pNewTexture = newFrame.getTexture();
  if(pNewTexture != this._texture) {
    this.setTexture(pNewTexture)
  }
  this._rectRotated = newFrame.isRotated();
  this.setTextureRect(newFrame.getRect(), this._rectRotated, newFrame.getOriginalSize())
}, isFrameDisplayed:function(frame) {
  return cc.Rect.CCRectEqualToRect(frame.getRect(), this._rect) && frame.getTexture().getName() == this._texture.getName() && cc.Point.CCPointEqualToPoint(frame.getOffset(), this._unflippedOffsetPositionFromCenter)
}, displayFrame:function() {
  return cc.SpriteFrame.createWithTexture(this._texture, cc.RECT_POINTS_TO_PIXELS(this._rect), this._rectRotated, this._unflippedOffsetPositionFromCenter, cc.SIZE_POINTS_TO_PIXELS(this._contentSize))
}, setBatchNode:function(spriteBatchNode) {
  this._batchNode = spriteBatchNode;
  if(!this._batchNode) {
    this._atlasIndex = cc.SPRITE_INDEX_NOT_INITIALIZED;
    this.setTextureAtlas(null);
    this._recursiveDirty = false;
    this.setDirty(false);
    var x1 = this._offsetPosition.x;
    var y1 = this._offsetPosition.y;
    var x2 = x1 + this._rect.size.width;
    var y2 = y1 + this._rect.size.height;
    this._quad.bl.vertices = {x:x1, y:y1, z:0};
    this._quad.br.vertices = {x:x2, y:y1, z:0};
    this._quad.tl.vertices = {x:x1, y:y2, z:0};
    this._quad.tr.vertices = {x:x2, y:y2, z:0};
    this._quadDirty = true
  }else {
    this._transformToBatch = cc.AffineTransformIdentity();
    this.setTextureAtlas(this._batchNode.getTextureAtlas())
  }
}, setTexture:function(texture) {
  cc.Assert(!texture || texture instanceof cc.Texture2D, "setTexture expects a CCTexture2D. Invalid argument");
  cc.Assert(!this._batchNode, "cc.Sprite: Batched sprites should use the same texture as the batchnode");
  if(!this._batchNode && this._texture != texture) {
    this._texture = texture;
    this._updateBlendFunc()
  }
}, _updateBlendFunc:function() {
  cc.Assert(!this._batchNode, "cc.Sprite: _updateBlendFunc doesn't work when the sprite is rendered using a cc.SpriteSheet");
  if(!this._texture || !this._texture.hasPremultipliedAlpha()) {
    this._blendFunc.src = gl.SRC_ALPHA;
    this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA;
    this.setOpacityModifyRGB(false)
  }else {
    this._blendFunc.src = cc.BLEND_SRC;
    this._blendFunc.dst = cc.BLEND_DST;
    this.setOpacityModifyRGB(true)
  }
}, _setTextureCoords:function(rect) {
  rect = cc.RECT_POINTS_TO_PIXELS(rect);
  var tex = this._batchNode ? this._textureAtlas.getTexture() : this._texture;
  if(!tex) {
    return
  }
  var atlasWidth = tex.getPixelsWide();
  var atlasHeight = tex.getPixelsHigh();
  var left, right, top, bottom, tempSwap;
  if(this._rectRotated) {
    if(cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
      left = (2 * rect.origin.x + 1) / (2 * atlasWidth);
      right = left + (rect.size.height * 2 - 2) / (2 * atlasWidth);
      top = (2 * rect.origin.y + 1) / (2 * atlasHeight);
      bottom = top + (rect.size.width * 2 - 2) / (2 * atlasHeight)
    }else {
      left = rect.origin.x / atlasWidth;
      right = (rect.origin.x + rect.size.height) / atlasWidth;
      top = rect.origin.y / atlasHeight;
      bottom = (rect.origin.y + rect.size.width) / atlasHeight
    }
    if(this._flipX) {
      tempSwap = top;
      top = bottom;
      bottom = tempSwap
    }
    if(this._flipY) {
      tempSwap = left;
      left = right;
      right = tempSwap
    }
    this._quad.bl.texCoords.u = left;
    this._quad.bl.texCoords.v = top;
    this._quad.br.texCoords.u = left;
    this._quad.br.texCoords.v = bottom;
    this._quad.tl.texCoords.u = right;
    this._quad.tl.texCoords.v = top;
    this._quad.tr.texCoords.u = right;
    this._quad.tr.texCoords.v = bottom
  }else {
    if(cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
      left = (2 * rect.origin.x + 1) / (2 * atlasWidth);
      right = left + (rect.size.width * 2 - 2) / (2 * atlasWidth);
      top = (2 * rect.origin.y + 1) / (2 * atlasHeight);
      bottom = top + (rect.size.height * 2 - 2) / (2 * atlasHeight)
    }else {
      left = rect.origin.x / atlasWidth;
      right = (rect.origin.x + rect.size.width) / atlasWidth;
      top = rect.origin.y / atlasHeight;
      bottom = (rect.origin.y + rect.size.height) / atlasHeight
    }
    if(this._flipX) {
      tempSwap = left;
      left = right;
      right = tempSwap
    }
    if(this._flipY) {
      tempSwap = top;
      top = bottom;
      bottom = tempSwap
    }
    this._quad.bl.texCoords.u = left;
    this._quad.bl.texCoords.v = bottom;
    this._quad.br.texCoords.u = right;
    this._quad.br.texCoords.v = bottom;
    this._quad.tl.texCoords.u = left;
    this._quad.tl.texCoords.v = top;
    this._quad.tr.texCoords.u = right;
    this._quad.tr.texCoords.v = top
  }
  this._quadDirty = true
}, draw:function(ctx) {
  var gl = ctx || cc.renderContext;
  if(this._texture) {
    if(this._texture._isLoaded) {
      this._shaderProgram.use();
      this._shaderProgram.setUniformForModelViewProjectionMatrixWithMat4(this._mvpMatrix);
      cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
      cc.glBindTexture2D(this._texture);
      cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSCOLORTEX);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._quadWebBuffer);
      if(this._quadDirty) {
        gl.bufferData(gl.ARRAY_BUFFER, this._quad.arrayBuffer, gl.STATIC_DRAW);
        this._quadDirty = false
      }
      gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 24, 0);
      gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 24, 16);
      gl.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, 24, 12);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
    }
  }else {
    var shaderProgram = cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_COLOR);
    shaderProgram.use();
    shaderProgram.setUniformForModelViewProjectionMatrixWithMat4(this._mvpMatrix);
    cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
    cc.glBindTexture2D(null);
    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._quadWebBuffer);
    if(this._quadDirty) {
      cc.renderContext.bufferData(cc.renderContext.ARRAY_BUFFER, this._quad.arrayBuffer, cc.renderContext.STATIC_DRAW);
      this._quadDirty = false
    }
    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 24, 0);
    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, 24, 12);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
  }
  if(cc.SPRITE_DEBUG_DRAW === 1) {
    var verticesG1 = [cc.p(this._quad.tl.vertices.x, this._quad.tl.vertices.y), cc.p(this._quad.bl.vertices.x, this._quad.bl.vertices.y), cc.p(this._quad.br.vertices.x, this._quad.br.vertices.y), cc.p(this._quad.tr.vertices.x, this._quad.tr.vertices.y)];
    cc.drawingUtil.drawPoly(verticesG1, 4, true)
  }else {
    if(cc.SPRITE_DEBUG_DRAW === 2) {
      var drawSizeG2 = this.getTextureRect().size;
      var offsetPixG2 = this.getOffsetPosition();
      var verticesG2 = [cc.p(offsetPixG2.x, offsetPixG2.y), cc.p(offsetPixG2.x + drawSizeG2.width, offsetPixG2.y), cc.p(offsetPixG2.x + drawSizeG2.width, offsetPixG2.y + drawSizeG2.height), cc.p(offsetPixG2.x, offsetPixG2.y + drawSizeG2.height)];
      cc.drawingUtil.drawPoly(verticesG2, 4, true)
    }
  }
  cc.g_NumberOfDraws++
}});
cc.SpriteWebGL.createWithTexture = function(texture, rect, offset) {
  var argnum = arguments.length;
  var sprite = new cc.SpriteWebGL;
  switch(argnum) {
    case 1:
      if(sprite && sprite.initWithTexture(texture)) {
        return sprite
      }
      return null;
      break;
    case 2:
      if(sprite && sprite.initWithTexture(texture, rect)) {
        return sprite
      }
      return null;
      break;
    case 3:
      cc.Assert(0, "");
      return null;
      break;
    default:
      throw"Sprite.createWithTexture(): Argument must be non-nil ";break
  }
};
cc.SpriteWebGL.create = function(fileName, rect) {
  var argnum = arguments.length;
  var sprite = new cc.SpriteWebGL;
  if(argnum === 0) {
    if(sprite.init()) {
      return sprite
    }
  }else {
    if(sprite && sprite.init(fileName, rect)) {
      return sprite
    }
  }
  return null
};
cc.SpriteWebGL.createWithSpriteFrameName = function(spriteFrameName) {
  var spriteFrame = null;
  if(typeof spriteFrameName == "string") {
    spriteFrame = cc.SpriteFrameCache.getInstance().getSpriteFrame(spriteFrameName);
    if(!spriteFrame) {
      cc.log("Invalid spriteFrameName: " + spriteFrameName);
      return null
    }
  }else {
    cc.log("Invalid argument. Expecting string.");
    return null
  }
  var sprite = new cc.SpriteWebGL;
  if(sprite && sprite.initWithSpriteFrame(spriteFrame)) {
    return sprite
  }
  return null
};
cc.SpriteWebGL.createWithSpriteFrame = function(spriteFrame) {
  var sprite = new cc.SpriteWebGL;
  if(sprite && sprite.initWithSpriteFrame(spriteFrame)) {
    return sprite
  }
  return null
};
cc.Sprite = cc.Browser.supportWebGL ? cc.SpriteWebGL : cc.SpriteCanvas;
cc.AnimationFrame = cc.Class.extend({_spriteFrame:null, _delayPerUnit:0, _userInfo:null, ctor:function() {
  this._delayPerUnit = 0
}, copyWithZone:function(pZone) {
  return cc.clone(this)
}, copy:function(pZone) {
  var newFrame = new cc.AnimationFrame;
  newFrame.initWithSpriteFrame(this._spriteFrame.copy(), this._delayPerUnit, this._userInfo);
  return newFrame
}, initWithSpriteFrame:function(spriteFrame, delayUnits, userInfo) {
  this.setSpriteFrame(spriteFrame);
  this.setDelayUnits(delayUnits);
  this.setUserInfo(userInfo);
  return true
}, getSpriteFrame:function() {
  return this._spriteFrame
}, setSpriteFrame:function(spriteFrame) {
  this._spriteFrame = spriteFrame
}, getDelayUnits:function() {
  return this._delayPerUnit
}, setDelayUnits:function(delayUnits) {
  this._delayPerUnit = delayUnits
}, getUserInfo:function() {
  return this._userInfo
}, setUserInfo:function(userInfo) {
  this._userInfo = userInfo
}});
cc.Animation = cc.Class.extend({_frames:null, _loops:0, _restoreOriginalFrame:false, _duration:0, _delayPerUnit:0, _totalDelayUnits:0, ctor:function() {
  this._frames = []
}, getFrames:function() {
  return this._frames
}, setFrames:function(frames) {
  this._frames = frames
}, addSpriteFrame:function(frame) {
  var animFrame = new cc.AnimationFrame;
  animFrame.initWithSpriteFrame(frame, 1, null);
  this._frames.push(animFrame);
  this._totalDelayUnits++
}, addSpriteFrameWithFile:function(fileName) {
  var texture = cc.TextureCache.getInstance().addImage(fileName);
  var rect = cc.RectZero();
  if(texture instanceof HTMLImageElement || texture instanceof HTMLCanvasElement) {
    rect.size = cc.size(texture.width, texture.height)
  }else {
    rect.size = texture.getContentSize()
  }
  var frame = cc.SpriteFrame.createWithTexture(texture, rect);
  this.addSpriteFrame(frame)
}, addSpriteFrameWithTexture:function(texture, rect) {
  var pFrame = cc.SpriteFrame.createWithTexture(texture, rect);
  this.addSpriteFrame(pFrame)
}, initWithAnimationFrames:function(arrayOfAnimationFrames, delayPerUnit, loops) {
  cc.ArrayVerifyType(arrayOfAnimationFrames, cc.AnimationFrame);
  this._delayPerUnit = delayPerUnit;
  this._loops = loops;
  this.setFrames([]);
  for(var i = 0;i < arrayOfAnimationFrames.length;i++) {
    var animFrame = arrayOfAnimationFrames[i];
    this._frames.push(animFrame);
    this._totalDelayUnits += animFrame.getDelayUnits()
  }
  return true
}, copyWithZone:function(pZone) {
  var pCopy = new cc.Animation;
  pCopy.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
  pCopy.setRestoreOriginalFrame(this._restoreOriginalFrame);
  return pCopy
}, _copyFrames:function() {
  var copyFrames = [];
  for(var i = 0;i < this._frames.length;i++) {
    copyFrames.push(this._frames[i].copy())
  }
  return copyFrames
}, copy:function(pZone) {
  return this.copyWithZone(null)
}, getLoops:function() {
  return this._loops
}, setLoops:function(value) {
  this._loops = value
}, setRestoreOriginalFrame:function(restOrigFrame) {
  this._restoreOriginalFrame = restOrigFrame
}, getRestoreOriginalFrame:function() {
  return this._restoreOriginalFrame
}, getDuration:function() {
  return this._totalDelayUnits * this._delayPerUnit
}, getDelayPerUnit:function() {
  return this._delayPerUnit
}, setDelayPerUnit:function(delayPerUnit) {
  this._delayPerUnit = delayPerUnit
}, getTotalDelayUnits:function() {
  return this._totalDelayUnits
}, initWithSpriteFrames:function(frames, delay) {
  cc.ArrayVerifyType(frames, cc.SpriteFrame);
  this._loops = 1;
  delay = delay || 0;
  this._delayPerUnit = delay;
  var tempFrames = [];
  this.setFrames(tempFrames);
  if(frames) {
    for(var i = 0;i < frames.length;i++) {
      var frame = frames[i];
      var animFrame = new cc.AnimationFrame;
      animFrame.initWithSpriteFrame(frame, 1, null);
      this._frames.push(animFrame);
      this._totalDelayUnits++
    }
  }
  return true
}});
cc.Animation.create = function(frames, delay, loops) {
  var len = arguments.length;
  var animation = new cc.Animation;
  if(len == 0) {
    animation.initWithSpriteFrames(null, 0)
  }else {
    if(len == 2) {
      delay = delay || 0;
      animation.initWithSpriteFrames(frames, delay)
    }else {
      if(len == 3) {
        animation.initWithAnimationFrames(frames, delay, loops)
      }
    }
  }
  return animation
};
cc.Animation.createWithAnimationFrames = function(arrayOfAnimationFrameNames, delayPerUnit, loops) {
  var animation = new cc.Animation;
  animation.initWithAnimationFrames(arrayOfAnimationFrameNames, delayPerUnit, loops);
  return animation
};
cc.AnimationCache = cc.Class.extend({addAnimation:function(animation, name) {
  this._animations[name] = animation
}, removeAnimation:function(name) {
  if(!name) {
    return
  }
  if(this._animations.hasOwnProperty(name)) {
    delete this._animations[name]
  }
}, getAnimation:function(name) {
  if(this._animations.hasOwnProperty(name)) {
    return this._animations[name]
  }
  return null
}, addAnimationsWithDictionary:function(dictionary) {
  var animations = dictionary["animations"];
  if(!animations) {
    cc.log("cocos2d: cc.AnimationCache: No animations were found in provided dictionary.");
    return
  }
  var version = 1;
  var properties = dictionary["properties"];
  if(properties) {
    version = properties["format"] != null ? parseInt(properties["format"]) : version;
    var spritesheets = properties["spritesheets"];
    for(var i = 0;i < spritesheets.length;i++) {
      cc.SpriteFrameCache.getInstance().addSpriteFrames(spritesheets[i])
    }
  }
  switch(version) {
    case 1:
      this._parseVersion1(animations);
      break;
    case 2:
      this._parseVersion2(animations);
      break;
    default:
      cc.Assert(false, "Invalid animation format");
      break
  }
}, addAnimations:function(plist) {
  cc.Assert(plist, "Invalid texture file name");
  var path = cc.FileUtils.getInstance().fullPathFromRelativePath(plist);
  var dict = cc.FileUtils.getInstance().dictionaryWithContentsOfFileThreadSafe(path);
  cc.Assert(dict, "cc.AnimationCache: File could not be found");
  this.addAnimationsWithDictionary(dict)
}, _parseVersion1:function(animations) {
  var frameCache = cc.SpriteFrameCache.getInstance();
  for(var key in animations) {
    var animationDict = animations[key];
    var frameNames = animationDict["frames"];
    var delay = parseFloat(animationDict["delay"]) || 0;
    var animation = null;
    if(!frameNames) {
      cc.log("cocos2d: cc.AnimationCache: Animation '" + key + "' found in dictionary without any frames - cannot add to animation cache.");
      continue
    }
    var frames = [];
    for(var i = 0;i < frameNames.length;i++) {
      var spriteFrame = frameCache.getSpriteFrame(frameNames[i]);
      if(!spriteFrame) {
        cc.log("cocos2d: cc.AnimationCache: Animation '" + key + "' refers to frame '" + frameNames[i] + "' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.");
        continue
      }
      var animFrame = new cc.AnimationFrame;
      animFrame.initWithSpriteFrame(spriteFrame, 1, null);
      frames.push(animFrame)
    }
    if(frames.length === 0) {
      cc.log("cocos2d: cc.AnimationCache: None of the frames for animation '" + key + "' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.");
      continue
    }else {
      if(frames.length != frameNames.length) {
        cc.log("cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache." + " Some or all of the frames for the animation '" + key + "' may be missing.")
      }
    }
    animation = cc.Animation.createWithAnimationFrames(frames, delay, 1);
    cc.AnimationCache.getInstance().addAnimation(animation, key)
  }
}, _parseVersion2:function(animations) {
  var frameCache = cc.SpriteFrameCache.getInstance();
  for(var key in animations) {
    var animationDict = animations[key];
    var loopsTemp = parseInt(animationDict["loops"]);
    var loops = isNaN(loopsTemp) ? 1 : loopsTemp;
    var restoreOriginalFrame = animationDict["restoreOriginalFrame"] && animationDict["restoreOriginalFrame"] == true ? true : false;
    var frameArray = animationDict["frames"];
    if(!frameArray) {
      cc.log("cocos2d: CCAnimationCache: Animation '" + key + "' found in dictionary without any frames - cannot add to animation cache.");
      continue
    }
    var arr = [];
    for(var i = 0;i < frameArray.length;i++) {
      var entry = frameArray[i];
      var spriteFrameName = entry["spriteframe"];
      var spriteFrame = frameCache.getSpriteFrame(spriteFrameName);
      if(!spriteFrame) {
        cc.log("cocos2d: cc.AnimationCache: Animation '" + key + "' refers to frame '" + spriteFrameName + "' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.");
        continue
      }
      var delayUnits = parseFloat(entry["delayUnits"]) || 0;
      var userInfo = entry["notification"];
      var animFrame = new cc.AnimationFrame;
      animFrame.initWithSpriteFrame(spriteFrame, delayUnits, userInfo);
      arr.push(animFrame)
    }
    var delayPerUnit = parseFloat(animationDict["delayPerUnit"]) || 0;
    var animation = new cc.Animation;
    animation.initWithAnimationFrames(arr, delayPerUnit, loops);
    animation.setRestoreOriginalFrame(restoreOriginalFrame);
    cc.AnimationCache.getInstance().addAnimation(animation, key)
  }
}, init:function() {
  this._animations = {};
  return true
}, _animations:null});
cc.AnimationCache.purgeSharedAnimationCache = function() {
  if(cc.s_sharedAnimationCache) {
    cc.s_sharedAnimationCache._animations = null;
    cc.s_sharedAnimationCache = null
  }
};
cc.AnimationCache.getInstance = function() {
  if(cc.s_sharedAnimationCache === null) {
    cc.s_sharedAnimationCache = new cc.AnimationCache;
    cc.s_sharedAnimationCache.init()
  }
  return cc.s_sharedAnimationCache
};
cc.s_sharedAnimationCache = null;
cc.SpriteFrame = cc.Class.extend({_offset:null, _originalSize:null, _rectInPixels:null, _rotated:null, _rect:null, _offsetInPixels:null, _originalSizeInPixels:null, _texture:null, _textureFilename:"", ctor:function() {
  this._offset = cc.p(0, 0);
  this._offsetInPixels = cc.p(0, 0);
  this._originalSize = cc.size(0, 0);
  this._rectInPixels = cc.rect(0, 0, 0, 0);
  this._rect = cc.rect(0, 0, 0, 0);
  this._originalSizeInPixels = cc.size(0, 0);
  this._textureFilename = ""
}, getRectInPixels:function() {
  return this._rectInPixels
}, setRectInPixels:function(rectInPixels) {
  this._rectInPixels = rectInPixels;
  this._rect = cc.RECT_PIXELS_TO_POINTS(rectInPixels)
}, isRotated:function() {
  return this._rotated
}, setRotated:function(bRotated) {
  this._rotated = bRotated
}, getRect:function() {
  return this._rect
}, setRect:function(rect) {
  this._rect = rect;
  this._rectInPixels = cc.RECT_POINTS_TO_PIXELS(this._rect)
}, getOffsetInPixels:function() {
  return cc.p(this._offsetInPixels.x, this._offsetInPixels.y)
}, setOffsetInPixels:function(offsetInPixels) {
  this._offsetInPixels = offsetInPixels;
  this._offset = cc.POINT_PIXELS_TO_POINTS(this._offsetInPixels)
}, getOriginalSizeInPixels:function() {
  return this._originalSizeInPixels
}, setOriginalSizeInPixels:function(sizeInPixels) {
  this._originalSizeInPixels = sizeInPixels
}, getOriginalSize:function() {
  return cc.size(this._originalSize.width, this._originalSize.height)
}, setOriginalSize:function(sizeInPixels) {
  this._originalSize = sizeInPixels
}, getTexture:function() {
  if(this._texture) {
    return this._texture
  }
  if(this._textureFilename !== "") {
    return cc.TextureCache.getInstance().addImage(this._textureFilename)
  }
  return null
}, setTexture:function(texture) {
  if(this._texture != texture) {
    this._texture = texture
  }
}, getOffset:function() {
  return cc.p(this._offset.x, this._offset.y)
}, setOffset:function(offsets) {
  this._offset = offsets
}, copyWithZone:function() {
  var copy = new cc.SpriteFrame;
  copy.initWithTextureFilename(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
  copy.setTexture(this._texture);
  return copy
}, copy:function() {
  return this.copyWithZone()
}, initWithTexture:function(texture, rect, rotated, offset, originalSize) {
  var argnum = arguments.length;
  switch(argnum) {
    case 2:
      var rectInPixels = cc.RECT_POINTS_TO_PIXELS(rect);
      return this.initWithTexture(texture, rectInPixels, false, cc.PointZero(), rectInPixels.size);
      break;
    case 5:
      this._texture = texture;
      this._rectInPixels = rect;
      this._rect = cc.RECT_PIXELS_TO_POINTS(rect);
      this._offsetInPixels = offset;
      this._offset = cc.POINT_PIXELS_TO_POINTS(this._offsetInPixels);
      this._originalSizeInPixels = originalSize;
      this._originalSize = cc.SIZE_PIXELS_TO_POINTS(this._originalSizeInPixels);
      this._rotated = rotated;
      return true;
      break;
    default:
      throw"Argument must be non-nil ";break
  }
}, initWithTextureFilename:function(filename, rect, rotated, offset, originalSize) {
  var rectInPixels = cc.RECT_POINTS_TO_PIXELS(rect);
  offset = offset || cc.size(0, 0);
  originalSize = originalSize || rectInPixels.size;
  this._texture = null;
  this._textureFilename = filename;
  this._rectInPixels = rectInPixels;
  this._rect = cc.RECT_PIXELS_TO_POINTS(rectInPixels);
  this._rotated = rotated || false;
  this._offsetInPixels = offset;
  this._offset = cc.POINT_PIXELS_TO_POINTS(offset);
  this._originalSizeInPixels = originalSize;
  this._originalSize = cc.SIZE_PIXELS_TO_POINTS(originalSize);
  return true
}});
cc.SpriteFrame.create = function(filename, rect, rotated, offset, originalSize) {
  var spriteFrame = new cc.SpriteFrame;
  switch(arguments.length) {
    case 2:
      spriteFrame.initWithTextureFilename(filename, rect);
      break;
    case 5:
      spriteFrame.initWithTextureFilename(filename, rect, rotated, offset, originalSize);
      break;
    default:
      throw"Argument must be non-nil ";break
  }
  return spriteFrame
};
cc.SpriteFrame.createWithTexture = function(texture, rect, rotated, offset, originalSize) {
  var argnum = arguments.length;
  var spriteFrame = new cc.SpriteFrame;
  switch(argnum) {
    case 2:
      spriteFrame.initWithTexture(texture, rect);
      break;
    case 5:
      spriteFrame.initWithTexture(texture, rect, rotated, offset, originalSize);
      break;
    default:
      throw"Argument must be non-nil ";break
  }
  return spriteFrame
};
cc.SpriteFrame._frameWithTextureForCanvas = function(texture, rect, rotated, offset, originalSize) {
  var spriteFrame = new cc.SpriteFrame;
  spriteFrame._texture = texture;
  spriteFrame._rectInPixels = rect;
  spriteFrame._rect = cc.RECT_PIXELS_TO_POINTS(rect);
  spriteFrame._offsetInPixels = offset;
  spriteFrame._offset = cc.POINT_PIXELS_TO_POINTS(spriteFrame._offsetInPixels);
  spriteFrame._originalSizeInPixels = originalSize;
  spriteFrame._originalSize = cc.SIZE_PIXELS_TO_POINTS(spriteFrame._originalSizeInPixels);
  spriteFrame._rotated = rotated;
  return spriteFrame
};
cc.SpriteFrameCache = cc.Class.extend({_spriteFrames:null, _spriteFramesAliases:null, _loadedFileNames:null, ctor:function() {
  this._spriteFrames = {};
  this._spriteFramesAliases = {};
  this._loadedFileNames = []
}, _addSpriteFramesWithDictionary:function(dictionary, texture) {
  var metadataDict = dictionary["metadata"];
  var framesDict = dictionary["frames"];
  var format = 0;
  if(metadataDict != null) {
    format = parseInt(this._valueForKey("format", metadataDict))
  }
  cc.Assert(format >= 0 && format <= 3, "format is not supported for cc.SpriteFrameCache addSpriteFramesWithDictionary:textureFilename:");
  for(var key in framesDict) {
    var frameDict = framesDict[key];
    if(frameDict) {
      var spriteFrame = this._spriteFrames[key];
      if(spriteFrame) {
        continue
      }
      if(format == 0) {
        var x = parseFloat(this._valueForKey("x", frameDict));
        var y = parseFloat(this._valueForKey("y", frameDict));
        var w = parseFloat(this._valueForKey("width", frameDict));
        var h = parseFloat(this._valueForKey("height", frameDict));
        var ox = parseFloat(this._valueForKey("offsetX", frameDict));
        var oy = parseFloat(this._valueForKey("offsetY", frameDict));
        var ow = parseInt(this._valueForKey("originalWidth", frameDict));
        var oh = parseInt(this._valueForKey("originalHeight", frameDict));
        if(!ow || !oh) {
          cc.log("cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist")
        }
        ow = Math.abs(ow);
        oh = Math.abs(oh);
        spriteFrame = new cc.SpriteFrame;
        spriteFrame.initWithTexture(texture, cc.rect(x, y, w, h), false, cc.p(ox, oy), cc.size(ow, oh))
      }else {
        if(format == 1 || format == 2) {
          var frame = cc.RectFromString(this._valueForKey("frame", frameDict));
          var rotated = false;
          if(format == 2) {
            rotated = this._valueForKey("rotated", frameDict) == "true"
          }
          var offset = cc.PointFromString(this._valueForKey("offset", frameDict));
          var sourceSize = cc.SizeFromString(this._valueForKey("sourceSize", frameDict));
          spriteFrame = new cc.SpriteFrame;
          spriteFrame.initWithTexture(texture, frame, rotated, offset, sourceSize)
        }else {
          if(format == 3) {
            var spriteSize, spriteOffset, spriteSourceSize, textureRect, textureRotated;
            spriteSize = cc.SizeFromString(this._valueForKey("spriteSize", frameDict));
            spriteOffset = cc.PointFromString(this._valueForKey("spriteOffset", frameDict));
            spriteSourceSize = cc.SizeFromString(this._valueForKey("spriteSourceSize", frameDict));
            textureRect = cc.RectFromString(this._valueForKey("textureRect", frameDict));
            textureRotated = this._valueForKey("textureRotated", frameDict) == "true";
            var aliases = frameDict["aliases"];
            var frameKey = key.toString();
            for(var aliasKey in aliases) {
              if(this._spriteFramesAliases.hasOwnProperty(aliases[aliasKey])) {
                cc.log("cocos2d: WARNING: an alias with name " + aliasKey + " already exists")
              }
              this._spriteFramesAliases[aliases[aliasKey]] = frameKey
            }
            spriteFrame = new cc.SpriteFrame;
            if(frameDict.hasOwnProperty("spriteSize")) {
              spriteFrame.initWithTexture(texture, cc.rect(textureRect.origin.x, textureRect.origin.y, spriteSize.width, spriteSize.height), textureRotated, spriteOffset, spriteSourceSize)
            }else {
              spriteFrame.initWithTexture(texture, spriteSize, textureRotated, spriteOffset, spriteSourceSize)
            }
          }
        }
      }
      if(cc.renderContextType === cc.CANVAS && spriteFrame.isRotated()) {
        var tempTexture = cc.cutRotateImageToCanvas(spriteFrame.getTexture(), spriteFrame.getRect());
        var rect = spriteFrame.getRect();
        spriteFrame.setRect(cc.rect(0, 0, rect.size.width, rect.size.height));
        spriteFrame.setTexture(tempTexture)
      }
      this._spriteFrames[key] = spriteFrame
    }
  }
}, addSpriteFramesWithJson:function(jsonData) {
  var dict = jsonData;
  var texturePath = "";
  var metadataDict = dict["metadata"];
  if(metadataDict) {
    texturePath = this._valueForKey("textureFileName", metadataDict);
    texturePath = texturePath.toString()
  }
  var texture = cc.TextureCache.getInstance().addImage(texturePath);
  if(texture) {
    this._addSpriteFramesWithDictionary(dict, texture)
  }else {
    cc.log("cocos2d: cc.SpriteFrameCache: Couldn't load texture")
  }
}, addSpriteFrames:function(plist, texture) {
  var dict = cc.FileUtils.getInstance().dictionaryWithContentsOfFileThreadSafe(plist);
  switch(arguments.length) {
    case 1:
      cc.Assert(plist, "plist filename should not be NULL");
      if(!cc.ArrayContainsObject(this._loadedFileNames, plist)) {
        var texturePath = "";
        var metadataDict = dict["metadata"];
        if(metadataDict) {
          texturePath = this._valueForKey("textureFileName", metadataDict).toString()
        }
        if(texturePath != "") {
          var getIndex = plist.lastIndexOf("/"), pszPath;
          pszPath = getIndex ? plist.substring(0, getIndex + 1) : "";
          texturePath = pszPath + texturePath
        }else {
          texturePath = plist;
          var startPos = texturePath.lastIndexOf(".", texturePath.length);
          texturePath = texturePath.substr(0, startPos);
          texturePath = texturePath + ".png"
        }
        var getTexture = cc.TextureCache.getInstance().addImage(texturePath);
        if(getTexture) {
          this._addSpriteFramesWithDictionary(dict, getTexture)
        }else {
          cc.log("cocos2d: cc.SpriteFrameCache: Couldn't load texture")
        }
      }
      break;
    case 2:
      if(texture instanceof cc.Texture2D || texture instanceof HTMLImageElement || texture instanceof HTMLCanvasElement) {
        this._addSpriteFramesWithDictionary(dict, texture)
      }else {
        var textureFileName = texture;
        cc.Assert(textureFileName, "texture name should not be null");
        var gTexture = cc.TextureCache.getInstance().addImage(textureFileName);
        if(gTexture) {
          this._addSpriteFramesWithDictionary(dict, gTexture)
        }else {
          cc.log("cocos2d: cc.SpriteFrameCache: couldn't load texture file. File not found " + textureFileName)
        }
      }
      break;
    default:
      throw"Argument must be non-nil ";
  }
}, addSpriteFrame:function(frame, frameName) {
  this._spriteFrames[frameName] = frame
}, removeSpriteFrames:function() {
  this._spriteFrames = [];
  this._spriteFramesAliases = [];
  this._loadedFileNames = {}
}, removeSpriteFrameByName:function(name) {
  if(!name) {
    return
  }
  if(this._spriteFramesAliases.hasOwnProperty(name)) {
    delete this._spriteFramesAliases[name]
  }
  if(this._spriteFrames.hasOwnProperty(name)) {
    delete this._spriteFrames[name]
  }
  this._loadedFileNames = {}
}, removeSpriteFramesFromFile:function(plist) {
  var path = cc.FileUtils.getInstance().fullPathFromRelativePath(plist);
  var dict = cc.FileUtils.getInstance().dictionaryWithContentsOfFileThreadSafe(path);
  this._removeSpriteFramesFromDictionary(dict);
  if(cc.ArrayContainsObject(this._loadedFileNames, plist)) {
    cc.ArrayRemoveObject(plist)
  }
}, _removeSpriteFramesFromDictionary:function(dictionary) {
  var framesDict = dictionary["frames"];
  for(var key in framesDict) {
    if(this._spriteFrames.hasOwnProperty(key)) {
      delete this._spriteFrames[key]
    }
  }
}, removeSpriteFramesFromTexture:function(texture) {
  for(var key in this._spriteFrames) {
    var frame = this._spriteFrames[key];
    if(frame && frame.getTexture() == texture) {
      delete this._spriteFrames[key]
    }
  }
}, getSpriteFrame:function(name) {
  var frame;
  if(this._spriteFrames.hasOwnProperty(name)) {
    frame = this._spriteFrames[name]
  }
  if(!frame) {
    var key;
    if(this._spriteFramesAliases.hasOwnProperty(name)) {
      key = this._spriteFramesAliases[name]
    }
    if(key) {
      if(this._spriteFrames.hasOwnProperty(key.toString())) {
        frame = this._spriteFrames[key.toString()]
      }
      if(!frame) {
        cc.log("cocos2d: cc.SpriteFrameCahce: Frame " + name + " not found")
      }
    }
  }
  return frame
}, _valueForKey:function(key, dict) {
  if(dict) {
    if(dict.hasOwnProperty(key)) {
      return dict[key].toString()
    }
  }
  return""
}});
cc.s_sharedSpriteFrameCache = null;
cc.SpriteFrameCache.getInstance = function() {
  if(!cc.s_sharedSpriteFrameCache) {
    cc.s_sharedSpriteFrameCache = new cc.SpriteFrameCache
  }
  return cc.s_sharedSpriteFrameCache
};
cc.SpriteFrameCache.purgeSharedSpriteFrameCache = function() {
  cc.s_sharedSpriteFrameCache = null
};
cc.DEFAULT_SPRITE_BATCH_CAPACITY = 29;
cc.SpriteBatchNodeCanvas = cc.Node.extend({_textureAtlas:null, _blendFunc:null, _descendants:null, addSpriteWithoutQuad:function(child, z, aTag) {
  cc.Assert(child != null, "SpriteBatchNode.addQuadFromSprite():Argument must be non-nil");
  cc.Assert(child instanceof cc.Sprite, "cc.SpriteBatchNode only supports cc.Sprites as children");
  child.setAtlasIndex(z);
  var i = 0;
  if(this._descendants && this._descendants.length > 0) {
    for(var index = 0;index < this._descendants.length;index++) {
      var obj = this._descendants[index];
      if(obj && obj.getAtlasIndex() >= z) {
        ++i
      }
    }
  }
  this._descendants = cc.ArrayAppendObjectToIndex(this._descendants, child, i);
  cc.Node.prototype.addChild.call(this, child, z, aTag);
  this.reorderBatch(false);
  return this
}, getTextureAtlas:function() {
  return this._textureAtlas
}, setTextureAtlas:function(textureAtlas) {
  if(textureAtlas != this._textureAtlas) {
    this._textureAtlas = textureAtlas
  }
}, getDescendants:function() {
  return this._descendants
}, initWithFile:function(fileImage, capacity) {
  var texture2D = cc.TextureCache.getInstance().textureForKey(fileImage);
  if(!texture2D) {
    texture2D = cc.TextureCache.getInstance().addImage(fileImage)
  }
  return this.initWithTexture(texture2D, capacity)
}, _setNodeDirtyForCache:function() {
  this._cacheDirty = true
}, init:function(fileImage, capacity) {
  var texture2D = cc.TextureCache.getInstance().textureForKey(fileImage);
  if(!texture2D) {
    texture2D = cc.TextureCache.getInstance().addImage(fileImage)
  }
  return this.initWithTexture(texture2D, capacity)
}, increaseAtlasCapacity:function() {
  var quantity = Math.floor((this._textureAtlas.getCapacity() + 1) * 4 / 3);
  cc.log("cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from " + this._textureAtlas.getCapacity() + " to " + quantity + ".");
  if(!this._textureAtlas.resizeCapacity(quantity)) {
    cc.log("cocos2d: WARNING: Not enough memory to resize the atlas");
    cc.Assert(false, "Not enough memory to resize the atla")
  }
}, removeChildAtIndex:function(index, doCleanup) {
  this.removeChild(this._children[index], doCleanup)
}, rebuildIndexInOrder:function(pobParent, index) {
  var children = pobParent.getChildren();
  if(children && children.length > 0) {
    for(var i = 0;i < children.length;i++) {
      var obj = children[i];
      if(obj && obj.getZOrder() < 0) {
        index = this.rebuildIndexInOrder(obj, index)
      }
    }
  }
  if(!pobParent == this) {
    pobParent.setAtlasIndex(index);
    index++
  }
  if(children && children.length > 0) {
    for(i = 0;i < children.length;i++) {
      obj = children[i];
      if(obj && obj.getZOrder() >= 0) {
        index = this.rebuildIndexInOrder(obj, index)
      }
    }
  }
  return index
}, highestAtlasIndexInChild:function(sprite) {
  var children = sprite.getChildren();
  if(!children || children.length == 0) {
    return sprite.getAtlasIndex()
  }else {
    return this.highestAtlasIndexInChild(children[children.length - 1])
  }
}, lowestAtlasIndexInChild:function(sprite) {
  var children = sprite.getChildren();
  if(!children || children.length == 0) {
    return sprite.getAtlasIndex()
  }else {
    return this.lowestAtlasIndexInChild(children[children.length - 1])
  }
}, atlasIndexForChild:function(sprite, nZ) {
  var brothers = sprite.getParent().getChildren();
  var childIndex = cc.ArrayGetIndexOfObject(brothers, sprite);
  var ignoreParent = sprite.getParent() == this;
  var previous = null;
  if(childIndex > 0 && childIndex < cc.UINT_MAX) {
    previous = brothers[childIndex - 1]
  }
  if(ignoreParent) {
    if(childIndex == 0) {
      return 0
    }
    return this.highestAtlasIndexInChild(previous) + 1
  }
  var selParent;
  if(childIndex == 0) {
    selParent = sprite.getParent();
    if(nZ < 0) {
      return selParent.getAtlasIndex()
    }else {
      return selParent.getAtlasIndex() + 1
    }
  }else {
    if(previous.getZOrder() < 0 && nZ < 0 || previous.getZOrder() >= 0 && nZ >= 0) {
      return this.highestAtlasIndexInChild(previous) + 1
    }
    selParent = sprite.getParent();
    return selParent.getAtlasIndex() + 1
  }
}, reorderBatch:function(reorder) {
  this._reorderChildDirty = reorder
}, setBlendFunc:function(src, dst) {
  if(arguments.length == 1) {
    this._blendFunc = src
  }else {
    this._blendFunc = {src:src, dst:dst}
  }
}, getBlendFunc:function() {
  return this._blendFunc
}, reorderChild:function(child, zOrder) {
  cc.Assert(child != null, "SpriteBatchNode.addChild():the child should not be null");
  cc.Assert(this._children.indexOf(child) > -1, "SpriteBatchNode.addChild():Child doesn't belong to Sprite");
  if(zOrder === child.getZOrder()) {
    return
  }
  this._super(child, zOrder);
  this.setNodeDirty()
}, removeChild:function(child, cleanup) {
  if(child == null) {
    return
  }
  cc.Assert(this._children.indexOf(child) > -1, "SpriteBatchNode.addChild():sprite batch node should contain the child");
  this.removeSpriteFromAtlas(child);
  this._super(child, cleanup)
}, _textureForCanvas:null, _renderTexture:null, _useCache:false, _originalTexture:null, ctor:function(fileImage) {
  this._super();
  if(fileImage) {
    this.init(fileImage, cc.DEFAULT_SPRITE_BATCH_CAPACITY)
  }
  this._renderTexture = cc.RenderTexture.create(cc.canvas.width, cc.canvas.height);
  this.setContentSize(cc.size(cc.canvas.width, cc.canvas.height))
}, updateQuadFromSprite:function(sprite, index) {
  cc.Assert(sprite != null, "SpriteBatchNode.addQuadFromSprite():Argument must be non-nil");
  cc.Assert(sprite instanceof cc.Sprite, "cc.SpriteBatchNode only supports cc.Sprites as children");
  sprite.setBatchNode(this);
  sprite.setAtlasIndex(index);
  sprite.setDirty(true);
  sprite.updateTransform()
}, insertQuadFromSprite:function(sprite, index) {
  cc.Assert(sprite != null, "Argument must be non-NULL");
  cc.Assert(sprite instanceof cc.Sprite, "cc.SpriteBatchNode only supports cc.Sprites as children");
  sprite.setBatchNode(this);
  sprite.setAtlasIndex(index);
  sprite.setDirty(true);
  sprite.updateTransform();
  this._children = cc.ArrayAppendObjectToIndex(this._children, sprite, index)
}, setContentSize:function(size) {
  if(!size) {
    return
  }
  this._super(size);
  this._renderTexture.setContentSize(size)
}, initWithTexture:function(tex, capacity) {
  this._children = [];
  this._descendants = [];
  this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
  this._originalTexture = tex;
  this._textureForCanvas = tex;
  return true
}, appendChild:function(sprite) {
  this._reorderChildDirty = true;
  sprite.setBatchNode(this);
  sprite.setDirty(true);
  cc.ArrayAppendObject(this._descendants, sprite);
  var index = this._descendants.length - 1;
  sprite.setAtlasIndex(index);
  var children = sprite.getChildren();
  for(var i = 0;i < children.length;i++) {
    this.appendChild(children[i])
  }
}, removeSpriteFromAtlas:function(sprite) {
  sprite.setBatchNode(null);
  var index = cc.ArrayGetIndexOfObject(this._descendants, sprite);
  if(index != -1) {
    cc.ArrayRemoveObjectAtIndex(this._descendants, index);
    var len = this._descendants.length;
    for(;index < len;++index) {
      var s = this._descendants[index];
      s.setAtlasIndex(s.getAtlasIndex() - 1)
    }
  }
  var children = sprite.getChildren();
  if(children && children.length > 0) {
    for(var i = 0;i < children.length;i++) {
      if(children[i]) {
        this.removeSpriteFromAtlas(children[i])
      }
    }
  }
}, getTexture:function() {
  if(this._useCache) {
    return this._renderTexture.getCanvas()
  }
  return this._textureForCanvas
}, setTexture:function(texture) {
  this._textureForCanvas = texture;
  for(var i = 0;i < this._children.length;i++) {
    this._children[i].setTexture(texture)
  }
}, visit:function(ctx) {
  var context = ctx || cc.renderContext;
  if(!this._visible) {
    return
  }
  context.save();
  this.transform(ctx);
  var i;
  if(this._useCache) {
    if(this._cacheDirty) {
      this._renderTexture.clear();
      this._renderTexture.context.save();
      this._renderTexture.context.translate(this._anchorPointInPoints.x, -this._anchorPointInPoints.y);
      if(this._children) {
        this.sortAllChildren();
        for(i = 0;i < this._children.length;i++) {
          if(this._children[i]) {
            this._children[i].visit(this._renderTexture.context)
          }
        }
      }
      this._renderTexture.context.restore();
      this._cacheDirty = false
    }
    this.draw(ctx)
  }else {
    if(this._children) {
      this.sortAllChildren();
      for(i = 0;i < this._children.length;i++) {
        if(this._children[i]) {
          this._children[i].visit(context)
        }
      }
    }
  }
  context.restore()
}, addChild:function(child, zOrder, tag) {
  if(child == null) {
    return
  }
  if(arguments.length === 4) {
    if(arguments[3] == true) {
      this._super(child, zOrder, tag);
      this.setNodeDirty();
      return
    }
  }
  zOrder = zOrder == null ? child.getZOrder() : zOrder;
  tag = tag == null ? child.getTag() : tag;
  cc.Assert(child != null, "SpriteBatchNode.addChild():child should not be null");
  cc.Assert(child instanceof cc.Sprite, "cc.SpriteBatchNode only supports cc.Sprites as children");
  this._super(child, zOrder, tag);
  this.appendChild(child);
  this.setNodeDirty()
}, removeAllChildren:function(cleanup) {
  if(this._descendants && this._descendants.length > 0) {
    for(var i = 0;i < this._descendants.length;i++) {
      if(this._descendants[i]) {
        this._descendants[i].setBatchNode(null)
      }
    }
  }
  this._super(cleanup);
  this._descendants = []
}, sortAllChildren:function() {
  if(this._reorderChildDirty) {
    var i = 0, j = 0, length = this._children.length;
    for(i = 1;i < length;i++) {
      var tempItem = this._children[i];
      j = i - 1;
      while(j >= 0 && (tempItem.getZOrder() < this._children[j].getZOrder() || tempItem.getZOrder() == this._children[j].getZOrder() && tempItem.getOrderOfArrival() < this._children[j].getOrderOfArrival())) {
        this._children[j + 1] = this._children[j];
        j--
      }
      this._children[j + 1] = tempItem
    }
    if(this._children.length > 0) {
      this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.sortAllChildren)
    }
    this._reorderChildDirty = false
  }
}, draw:function(ctx) {
  var context = ctx || cc.renderContext;
  var pos = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
  if(this._renderTexture) {
    context.drawImage(this._renderTexture.getCanvas(), pos.x, -(pos.y + this._renderTexture.getCanvas().height))
  }
}});
cc.SpriteBatchNodeCanvas.create = function(fileImage, capacity) {
  capacity = capacity || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
  var batchNode = new cc.SpriteBatchNodeCanvas;
  batchNode.init(fileImage, capacity);
  return batchNode
};
cc.SpriteBatchNodeCanvas.createWithTexture = function(texture, capacity) {
  capacity = capacity || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
  var batchNode = new cc.SpriteBatchNodeCanvas;
  batchNode.initWithTexture(texture, capacity);
  return batchNode
};
cc.SpriteBatchNodeWebGL = cc.Node.extend({_textureAtlas:null, _blendFunc:null, _descendants:null, addSpriteWithoutQuad:function(child, z, aTag) {
  cc.Assert(child != null, "SpriteBatchNode.addQuadFromSprite():Argument must be non-nil");
  cc.Assert(child instanceof cc.Sprite, "cc.SpriteBatchNode only supports cc.Sprites as children");
  child.setAtlasIndex(z);
  var i = 0;
  if(this._descendants && this._descendants.length > 0) {
    for(var index = 0;index < this._descendants.length;index++) {
      var obj = this._descendants[index];
      if(obj && obj.getAtlasIndex() >= z) {
        ++i
      }
    }
  }
  this._descendants = cc.ArrayAppendObjectToIndex(this._descendants, child, i);
  cc.Node.prototype.addChild.call(this, child, z, aTag);
  this.reorderBatch(false);
  return this
}, getTextureAtlas:function() {
  return this._textureAtlas
}, setTextureAtlas:function(textureAtlas) {
  if(textureAtlas != this._textureAtlas) {
    this._textureAtlas = textureAtlas
  }
}, getDescendants:function() {
  return this._descendants
}, initWithFile:function(fileImage, capacity) {
  var texture2D = cc.TextureCache.getInstance().textureForKey(fileImage);
  if(!texture2D) {
    texture2D = cc.TextureCache.getInstance().addImage(fileImage)
  }
  return this.initWithTexture(texture2D, capacity)
}, _setNodeDirtyForCache:function() {
  this._cacheDirty = true
}, init:function(fileImage, capacity) {
  var texture2D = cc.TextureCache.getInstance().textureForKey(fileImage);
  if(!texture2D) {
    texture2D = cc.TextureCache.getInstance().addImage(fileImage)
  }
  return this.initWithTexture(texture2D, capacity)
}, increaseAtlasCapacity:function() {
  var quantity = 0 | (this._textureAtlas.getCapacity() + 1) * 4 / 3;
  cc.log("cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from " + this._textureAtlas.getCapacity() + " to [" + quantity + "].");
  if(!this._textureAtlas.resizeCapacity(quantity)) {
    cc.log("cocos2d: WARNING: Not enough memory to resize the atlas");
    cc.Assert(false, "Not enough memory to resize the atla")
  }
}, removeChildAtIndex:function(index, doCleanup) {
  this.removeChild(this._children[index], doCleanup)
}, rebuildIndexInOrder:function(pobParent, index) {
  var children = pobParent.getChildren();
  if(children && children.length > 0) {
    for(var i = 0;i < children.length;i++) {
      var obj = children[i];
      if(obj && obj.getZOrder() < 0) {
        index = this.rebuildIndexInOrder(obj, index)
      }
    }
  }
  if(!pobParent == this) {
    pobParent.setAtlasIndex(index);
    index++
  }
  if(children && children.length > 0) {
    for(i = 0;i < children.length;i++) {
      obj = children[i];
      if(obj && obj.getZOrder() >= 0) {
        index = this.rebuildIndexInOrder(obj, index)
      }
    }
  }
  return index
}, highestAtlasIndexInChild:function(sprite) {
  var children = sprite.getChildren();
  if(!children || children.length == 0) {
    return sprite.getAtlasIndex()
  }else {
    return this.highestAtlasIndexInChild(children[children.length - 1])
  }
}, lowestAtlasIndexInChild:function(sprite) {
  var children = sprite.getChildren();
  if(!children || children.length == 0) {
    return sprite.getAtlasIndex()
  }else {
    return this.lowestAtlasIndexInChild(children[children.length - 1])
  }
}, atlasIndexForChild:function(sprite, nZ) {
  var brothers = sprite.getParent().getChildren();
  var childIndex = cc.ArrayGetIndexOfObject(brothers, sprite);
  var ignoreParent = sprite.getParent() == this;
  var previous = null;
  if(childIndex > 0 && childIndex < cc.UINT_MAX) {
    previous = brothers[childIndex - 1]
  }
  if(ignoreParent) {
    if(childIndex == 0) {
      return 0
    }
    return this.highestAtlasIndexInChild(previous) + 1
  }
  var selParent;
  if(childIndex == 0) {
    selParent = sprite.getParent();
    if(nZ < 0) {
      return selParent.getAtlasIndex()
    }else {
      return selParent.getAtlasIndex() + 1
    }
  }else {
    if(previous.getZOrder() < 0 && nZ < 0 || previous.getZOrder() >= 0 && nZ >= 0) {
      return this.highestAtlasIndexInChild(previous) + 1
    }
    selParent = sprite.getParent();
    return selParent.getAtlasIndex() + 1
  }
}, reorderBatch:function(reorder) {
  this._reorderChildDirty = reorder
}, setBlendFunc:function(src, dst) {
  if(arguments.length == 1) {
    this._blendFunc = src
  }else {
    this._blendFunc = {src:src, dst:dst}
  }
}, getBlendFunc:function() {
  return this._blendFunc
}, reorderChild:function(child, zOrder) {
  cc.Assert(child != null, "SpriteBatchNode.addChild():the child should not be null");
  cc.Assert(this._children.indexOf(child) > -1, "SpriteBatchNode.addChild():Child doesn't belong to Sprite");
  if(zOrder === child.getZOrder()) {
    return
  }
  this._super(child, zOrder);
  this.setNodeDirty()
}, removeChild:function(child, cleanup) {
  if(child == null) {
    return
  }
  cc.Assert(this._children.indexOf(child) > -1, "SpriteBatchNode.addChild():sprite batch node should contain the child");
  this.removeSpriteFromAtlas(child);
  this._super(child, cleanup)
}, ctor:function(fileImage) {
  this._super();
  if(fileImage) {
    this.init(fileImage, cc.DEFAULT_SPRITE_BATCH_CAPACITY)
  }
}, updateQuadFromSprite:function(sprite, index) {
  cc.Assert(sprite != null, "SpriteBatchNode.addQuadFromSprite():Argument must be non-nil");
  cc.Assert(sprite instanceof cc.Sprite, "cc.SpriteBatchNode only supports cc.Sprites as children");
  while(index >= this._textureAtlas.getCapacity() || this._textureAtlas.getCapacity() == this._textureAtlas.getTotalQuads()) {
    this.increaseAtlasCapacity()
  }
  sprite.setBatchNode(this);
  sprite.setAtlasIndex(index);
  sprite.setDirty(true);
  sprite.updateTransform()
}, _swap:function(oldIndex, newIndex) {
  var quads = this._textureAtlas.getQuads();
  var tempItem = this._descendants[oldIndex];
  var tempIteQuad = quads[oldIndex];
  this._descendants[newIndex].setAtlasIndex(oldIndex);
  this._descendants[oldIndex] = this._descendants[newIndex];
  this._textureAtlas.updateQuad(quads[newIndex], oldIndex);
  this._descendants[newIndex] = tempItem;
  this._textureAtlas.updateQuad(tempIteQuad, newIndex)
}, insertQuadFromSprite:function(sprite, index) {
  cc.Assert(sprite != null, "Argument must be non-NULL");
  cc.Assert(sprite instanceof cc.Sprite, "cc.SpriteBatchNode only supports cc.Sprites as children");
  while(index >= this._textureAtlas.getCapacity() || this._textureAtlas.getCapacity() === this._textureAtlas.getTotalQuads()) {
    this.increaseAtlasCapacity()
  }
  sprite.setBatchNode(this);
  sprite.setAtlasIndex(index);
  this._textureAtlas.insertQuad(sprite.getQuad(), index);
  sprite.setDirty(true);
  sprite.updateTransform()
}, _updateAtlasIndex:function(sprite, curIndex) {
  var count = 0;
  var pArray = sprite.getChildren();
  if(pArray) {
    count = pArray.length
  }
  var oldIndex = 0;
  if(count == 0) {
    oldIndex = sprite.getAtlasIndex();
    sprite.setAtlasIndex(curIndex);
    sprite.setOrderOfArrival(0);
    if(oldIndex != curIndex) {
      this._swap(oldIndex, curIndex)
    }
    curIndex++
  }else {
    var needNewIndex = true;
    if(pArray[0].getZOrder() >= 0) {
      oldIndex = sprite.getAtlasIndex();
      sprite.setAtlasIndex(curIndex);
      sprite.setOrderOfArrival(0);
      if(oldIndex != curIndex) {
        this._swap(oldIndex, curIndex)
      }
      curIndex++;
      needNewIndex = false
    }
    for(var i = 0;i < pArray.length;i++) {
      var child = pArray[i];
      if(needNewIndex && child.getZOrder() >= 0) {
        oldIndex = sprite.getAtlasIndex();
        sprite.setAtlasIndex(curIndex);
        sprite.setOrderOfArrival(0);
        if(oldIndex != curIndex) {
          this._swap(oldIndex, curIndex)
        }
        curIndex++;
        needNewIndex = false
      }
      curIndex = this._updateAtlasIndex(child, curIndex)
    }
    if(needNewIndex) {
      oldIndex = sprite.getAtlasIndex();
      sprite.setAtlasIndex(curIndex);
      sprite.setOrderOfArrival(0);
      if(oldIndex != curIndex) {
        this._swap(oldIndex, curIndex)
      }
      curIndex++
    }
  }
  return curIndex
}, _updateBlendFunc:function() {
  if(!this._textureAtlas.getTexture().hasPremultipliedAlpha()) {
    this._blendFunc.src = gl.SRC_ALPHA;
    this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA
  }
}, initWithTexture:function(tex, capacity) {
  this._children = [];
  this._descendants = [];
  this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
  capacity = capacity || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
  this._textureAtlas = new cc.TextureAtlas;
  this._textureAtlas.initWithTexture(tex, capacity);
  this._updateBlendFunc();
  this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
  return true
}, insertChild:function(sprite, index) {
  sprite.setBatchNode(this);
  sprite.setAtlasIndex(index);
  sprite.setDirty(true);
  if(this._textureAtlas.getTotalQuads() == this._textureAtlas.getCapacity()) {
    this.increaseAtlasCapacity()
  }
  this._textureAtlas.insertQuad(sprite.getQuad(), index);
  this._descendants = cc.ArrayAppendObjectToIndex(this._descendants, sprite, index);
  var i = index + 1;
  if(this._descendants && this._descendants.length > 0) {
    for(;i < this._descendants.length;i++) {
      this._descendants[i].setAtlasIndex(this._descendants[i].getAtlasIndex() + 1)
    }
  }
  var children = sprite.getChildren();
  if(children && children.length > 0) {
    for(i = 0;i < children.length;i++) {
      if(children[i]) {
        var getIndex = this.atlasIndexForChild(children[i], children[i].getZOrder());
        this.insertChild(children[i], getIndex)
      }
    }
  }
}, appendChild:function(sprite) {
  this._reorderChildDirty = true;
  sprite.setBatchNode(this);
  sprite.setDirty(true);
  cc.ArrayAppendObject(this._descendants, sprite);
  var index = this._descendants.length - 1;
  sprite.setAtlasIndex(index);
  if(this._textureAtlas.getTotalQuads() == this._textureAtlas.getCapacity()) {
    this.increaseAtlasCapacity()
  }
  this._textureAtlas.insertQuad(sprite.getQuad(), index);
  var children = sprite.getChildren();
  for(var i = 0;i < children.length;i++) {
    this.appendChild(children[i])
  }
}, removeSpriteFromAtlas:function(sprite) {
  this._textureAtlas.removeQuadAtIndex(sprite.getAtlasIndex());
  sprite.setBatchNode(null);
  var index = cc.ArrayGetIndexOfObject(this._descendants, sprite);
  if(index != -1) {
    cc.ArrayRemoveObjectAtIndex(this._descendants, index);
    var len = this._descendants.length;
    for(;index < len;++index) {
      var s = this._descendants[index];
      s.setAtlasIndex(s.getAtlasIndex() - 1)
    }
  }
  var children = sprite.getChildren();
  if(children && children.length > 0) {
    for(var i = 0;i < children.length;i++) {
      if(children[i]) {
        this.removeSpriteFromAtlas(children[i])
      }
    }
  }
}, getTexture:function() {
  return this._textureAtlas.getTexture()
}, setTexture:function(texture) {
  this._textureAtlas.setTexture(texture);
  this._updateBlendFunc()
}, visit:function(ctx) {
  var gl = ctx || cc.renderContext;
  if(!this._visible) {
    return
  }
  cc.kmGLPushMatrix();
  if(this._grid && this._grid.isActive()) {
    this._grid.beforeDraw();
    this.transformAncestors()
  }
  this.sortAllChildren();
  this.transform(gl);
  this.draw(gl);
  if(this._grid && this._grid.isActive()) {
    this._grid.afterDraw(this)
  }
  cc.kmGLPopMatrix();
  this.setOrderOfArrival(0)
}, addChild:function(child, zOrder, tag) {
  if(child == null) {
    return
  }
  if(arguments.length === 4) {
    if(arguments[3] == true) {
      this._super(child, zOrder, tag);
      this.setNodeDirty();
      return
    }
  }
  zOrder = zOrder == null ? child.getZOrder() : zOrder;
  tag = tag == null ? child.getTag() : tag;
  cc.Assert(child != null, "SpriteBatchNode.addChild():child should not be null");
  cc.Assert(child instanceof cc.Sprite, "cc.SpriteBatchNode only supports cc.Sprites as children");
  cc.Assert(child.getTexture()._webTextureObj == this._textureAtlas.getTexture()._webTextureObj, "SpriteBatchNode.addChild():cc.Sprite is not using the same texture id");
  this._super(child, zOrder, tag);
  this.appendChild(child);
  this.setNodeDirty()
}, removeAllChildren:function(cleanup) {
  if(this._descendants && this._descendants.length > 0) {
    for(var i = 0;i < this._descendants.length;i++) {
      if(this._descendants[i]) {
        this._descendants[i].setBatchNode(null)
      }
    }
  }
  this._super(cleanup);
  this._descendants = [];
  this._textureAtlas.removeAllQuads()
}, sortAllChildren:function() {
  if(this._reorderChildDirty) {
    var i = 0, j = 0, length = this._children.length;
    for(i = 1;i < length;i++) {
      var tempItem = this._children[i];
      j = i - 1;
      while(j >= 0 && (tempItem.getZOrder() < this._children[j].getZOrder() || tempItem.getZOrder() == this._children[j].getZOrder() && tempItem.getOrderOfArrival() < this._children[j].getOrderOfArrival())) {
        this._children[j + 1] = this._children[j];
        j--
      }
      this._children[j + 1] = tempItem
    }
    if(this._children.length > 0) {
      this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.sortAllChildren);
      var index = 0;
      for(i = 0;i < this._children.length;i++) {
        index = this._updateAtlasIndex(this._children[i], index)
      }
    }
    this._reorderChildDirty = false
  }
}, draw:function(ctx) {
  if(this._textureAtlas.getTotalQuads() === 0) {
    return
  }
  cc.NODE_DRAW_SETUP(this);
  this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform);
  cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
  this._textureAtlas.drawQuads()
}});
cc.SpriteBatchNodeWebGL.create = function(fileImage, capacity) {
  capacity = capacity || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
  var batchNode = new cc.SpriteBatchNodeWebGL;
  batchNode.init(fileImage, capacity);
  return batchNode
};
cc.SpriteBatchNodeWebGL.createWithTexture = function(texture, capacity) {
  capacity = capacity || cc.DEFAULT_SPRITE_BATCH_CAPACITY;
  var batchNode = new cc.SpriteBatchNodeWebGL;
  batchNode.initWithTexture(texture, capacity);
  return batchNode
};
cc.SpriteBatchNode = cc.Browser.supportWebGL ? cc.SpriteBatchNodeWebGL : cc.SpriteBatchNodeCanvas;
cc.LabelAtlasCanvas = cc.AtlasNode.extend({_string:null, _mapStartChar:null, initWithString:function(strText, charMapFile, itemWidth, itemHeight, startCharMap) {
  var label = strText + "", textureFilename, width, height, startChar;
  cc.Assert(label !== null, "Label must be non-nil");
  if(arguments.length === 2) {
    var dict = cc.FileUtils.getInstance().dictionaryWithContentsOfFileThreadSafe(charMapFile);
    cc.Assert(parseInt(dict["version"], 10) == 1, "Unsupported version. Upgrade cocos2d version");
    textureFilename = cc.FileUtils.getInstance().fullPathFromRelativeFile(dict["textureFilename"], charMapFile);
    width = parseInt(dict["itemWidth"], 10) / cc.CONTENT_SCALE_FACTOR();
    height = parseInt(dict["itemHeight"], 10) / cc.CONTENT_SCALE_FACTOR();
    startChar = String.fromCharCode(parseInt(dict["firstChar"], 10))
  }else {
    textureFilename = charMapFile;
    width = itemWidth || 0;
    height = itemHeight || 0;
    startChar = startCharMap || " "
  }
  if(this.initWithTileFile(textureFilename, width, height, label.length)) {
    this._mapStartChar = startChar;
    this.setString(label);
    return true
  }
  return false
}, setColor:function(color3) {
  this._super(color3);
  this.updateAtlasValues()
}, getString:function() {
  return this._string
}, draw:function() {
  this._super();
  if(cc.LABELATLAS_DEBUG_DRAW) {
    var s = this.getContentSize();
    var vertices = [cc.p(0, 0), cc.p(s.width, 0), cc.p(s.width, s.height), cc.p(0, s.height)];
    cc.drawingUtil.drawPoly(vertices, 4, true)
  }
}, updateAtlasValues:function() {
  var texture = this.getTexture();
  for(var i = 0;i < this._string.length;i++) {
    var a = this._string.charCodeAt(i) - this._mapStartChar.charCodeAt(0);
    var row = parseInt(a % this._itemsPerRow, 10) * cc.CONTENT_SCALE_FACTOR();
    var col = parseInt(a / this._itemsPerRow, 10) * cc.CONTENT_SCALE_FACTOR();
    var rect = cc.rect(row * this._itemWidth, col * this._itemHeight, this._itemWidth, this._itemHeight);
    var c = this._string.charCodeAt(i);
    var fontChar = this.getChildByTag(i);
    if(!fontChar) {
      fontChar = new cc.Sprite;
      if(c == 32) {
        fontChar.init();
        fontChar.setTextureRect(cc.rect(0, 0, 10, 10), false, cc.SizeZero())
      }else {
        fontChar.initWithTexture(texture, rect)
      }
      this.addChild(fontChar, 0, i)
    }else {
      if(c == 32) {
        fontChar.init();
        fontChar.setTextureRect(cc.rect(0, 0, 10, 10), false, cc.SizeZero())
      }else {
        fontChar.initWithTexture(texture, rect);
        fontChar.setVisible(true);
        fontChar.setOpacity(this._opacity)
      }
    }
    fontChar.setPosition(cc.p(i * this._itemWidth + this._itemWidth / 2, this._itemHeight / 2))
  }
}, setString:function(label) {
  var len = label.length;
  this._string = label;
  this.setContentSize(cc.size(len * this._itemWidth, this._itemHeight));
  if(this._children) {
    for(var i = 0;i < this._children.length;i++) {
      var node = this._children[i];
      if(node) {
        node.setVisible(false)
      }
    }
  }
  this.updateAtlasValues();
  this._quadsToDraw = len
}, setOpacity:function(opacity) {
  if(this._opacity != opacity) {
    this._super(opacity);
    for(var i = 0;i < this._children.length;i++) {
      if(this._children[i]) {
        this._children[i].setOpacity(opacity)
      }
    }
  }
}});
cc.LabelAtlasCanvas.create = function(strText, charMapFile, itemWidth, itemHeight, startCharMap) {
  var ret = new cc.LabelAtlasCanvas;
  if(ret && cc.LabelAtlasCanvas.prototype.initWithString.apply(ret, arguments)) {
    return ret
  }
  return null
};
cc.LabelAtlasWebGL = cc.AtlasNode.extend({_string:null, _mapStartChar:null, initWithString:function(strText, charMapFile, itemWidth, itemHeight, startCharMap) {
  var label = strText + "", textureFilename, width, height, startChar;
  cc.Assert(label !== null, "Label must be non-nil");
  if(arguments.length === 2) {
    var dict = cc.FileUtils.getInstance().dictionaryWithContentsOfFileThreadSafe(charMapFile);
    cc.Assert(parseInt(dict["version"], 10) == 1, "Unsupported version. Upgrade cocos2d version");
    textureFilename = cc.FileUtils.getInstance().fullPathFromRelativeFile(dict["textureFilename"], charMapFile);
    width = parseInt(dict["itemWidth"], 10) / cc.CONTENT_SCALE_FACTOR();
    height = parseInt(dict["itemHeight"], 10) / cc.CONTENT_SCALE_FACTOR();
    startChar = String.fromCharCode(parseInt(dict["firstChar"], 10))
  }else {
    textureFilename = charMapFile;
    width = itemWidth || 0;
    height = itemHeight || 0;
    startChar = startCharMap || " "
  }
  if(this.initWithTileFile(textureFilename, width, height, label.length)) {
    this._mapStartChar = startChar;
    this.setString(label);
    return true
  }
  return false
}, setColor:function(color3) {
  this._super(color3);
  this.updateAtlasValues()
}, getString:function() {
  return this._string
}, draw:function() {
  this._super();
  if(cc.LABELATLAS_DEBUG_DRAW) {
    var s = this.getContentSize();
    var vertices = [cc.p(0, 0), cc.p(s.width, 0), cc.p(s.width, s.height), cc.p(0, s.height)];
    cc.drawingUtil.drawPoly(vertices, 4, true)
  }
}, updateAtlasValues:function() {
  var texture = this._textureAtlas.getTexture();
  var textureWide = texture.getPixelsWide();
  var textureHigh = texture.getPixelsHigh();
  var itemWidthInPixels = this._itemWidth * cc.CONTENT_SCALE_FACTOR();
  var itemHeightInPixels = this._itemHeight * cc.CONTENT_SCALE_FACTOR();
  for(var i = 0;i < this._string.length;i++) {
    var a = this._string.charCodeAt(i) - this._mapStartChar.charCodeAt(0);
    var row = a % this._itemsPerRow;
    var col = 0 | a / this._itemsPerRow;
    var left, right, top, bottom;
    if(cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
      left = (2 * row * itemWidthInPixels + 1) / (2 * textureWide);
      right = left + (itemWidthInPixels * 2 - 2) / (2 * textureWide);
      top = (2 * col * itemHeightInPixels + 1) / (2 * textureHigh);
      bottom = top + (itemHeightInPixels * 2 - 2) / (2 * textureHigh)
    }else {
      left = row * itemWidthInPixels / textureWide;
      right = left + itemWidthInPixels / textureWide;
      top = col * itemHeightInPixels / textureHigh;
      bottom = top + itemHeightInPixels / textureHigh
    }
    var quad = new cc.V3F_C4B_T2F_Quad;
    quad.tl.texCoords.u = left;
    quad.tl.texCoords.v = top;
    quad.tr.texCoords.u = right;
    quad.tr.texCoords.v = top;
    quad.bl.texCoords.u = left;
    quad.bl.texCoords.v = bottom;
    quad.br.texCoords.u = right;
    quad.br.texCoords.v = bottom;
    quad.bl.vertices.x = i * this._itemWidth;
    quad.bl.vertices.y = 0;
    quad.bl.vertices.z = 0;
    quad.br.vertices.x = i * this._itemWidth + this._itemWidth;
    quad.br.vertices.y = 0;
    quad.br.vertices.z = 0;
    quad.tl.vertices.x = i * this._itemWidth;
    quad.tl.vertices.y = this._itemHeight;
    quad.tl.vertices.z = 0;
    quad.tr.vertices.x = i * this._itemWidth + this._itemWidth;
    quad.tr.vertices.y = this._itemHeight;
    quad.tr.vertices.z = 0;
    var c = cc.c4b(this._color.r, this._color.g, this._color.b, this._opacity);
    quad.tl.colors = c;
    quad.tr.colors = c;
    quad.bl.colors = c;
    quad.br.colors = c;
    this._textureAtlas.updateQuad(quad, i)
  }
}, setString:function(label) {
  var len = label.length;
  if(len > this._textureAtlas.getTotalQuads()) {
    this._textureAtlas.resizeCapacity(len)
  }
  this._string = label;
  this.setContentSize(cc.size(len * this._itemWidth, this._itemHeight));
  this.updateAtlasValues();
  this._quadsToDraw = len
}, setOpacity:function(opacity) {
  if(this._opacity !== opacity) {
    this._super(opacity)
  }
}});
cc.LabelAtlasWebGL.create = function(strText, charMapFile, itemWidth, itemHeight, startCharMap) {
  var ret = new cc.LabelAtlasWebGL;
  if(ret && cc.LabelAtlasWebGL.prototype.initWithString.apply(ret, arguments)) {
    return ret
  }
  return null
};
cc.LabelAtlas = cc.Browser.supportWebGL ? cc.LabelAtlasWebGL : cc.LabelAtlasCanvas;
cc.LabelTTFCanvas = cc.Sprite.extend({_dimensions:null, _hAlignment:cc.TEXT_ALIGNMENT_CENTER, _vAlignment:cc.VERTICAL_TEXT_ALIGNMENT_TOP, _fontName:"Arial", _fontSize:0, _string:"", _isMultiLine:false, _fontStyleStr:null, _colorStyleStr:null, ctor:function() {
  this._super();
  this._dimensions = cc.SizeZero();
  this._opacityModifyRGB = false;
  this._fontStyleStr = "";
  this._colorStyleStr = "";
  this._opacity = 255;
  this._color = cc.white();
  this._setColorStyleStr()
}, init:function(callsuper) {
  if(callsuper) {
    return this._super()
  }
  return this.initWithString([" ", this._fontName, this._fontSize])
}, description:function() {
  return"<cc.LabelTTF | FontName =" + this._fontName + " FontSize = " + this._fontSize.toFixed(1) + ">"
}, setColor:function(color3) {
  if(this._color.r == color3.r && this._color.g == color3.g && this._color.b == color3.b) {
    return
  }
  this._super(color3);
  this._setColorStyleStr();
  this.setNodeDirty()
}, setOpacity:function(opacity) {
  if(this._opacity === opacity) {
    return
  }
  this._super(opacity);
  this._setColorStyleStr()
}, _setColorStyleStr:function() {
  this._colorStyleStr = "rgba(" + this._color.r + "," + this._color.g + "," + this._color.b + ", " + this._opacity / 255 + ")"
}, getString:function() {
  return this._string
}, getHorizontalAlignment:function() {
  return this._hAlignment
}, getVerticalAlignment:function() {
  return this._vAlignment
}, getDimensions:function() {
  return this._dimensions
}, getFontSize:function() {
  return this._fontSize
}, getFontName:function() {
  return this._fontName
}, initWithString:function(arg) {
  var strInfo = arg[0] + "", fontName, fontSize, dimensions, hAlignment, vAlignment;
  cc.Assert(strInfo != null, "cc.LabelTTF.initWithString() label is null");
  if(arg.length == 6) {
    fontName = arg[1];
    fontSize = arg[2];
    dimensions = arg[3];
    hAlignment = arg[4];
    vAlignment = arg[5]
  }else {
    if(arg.length == 5) {
      fontName = arg[1];
      fontSize = arg[2];
      dimensions = arg[3];
      hAlignment = arg[4];
      vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP
    }else {
      fontName = arg[1] || "Arial";
      fontSize = arg[2] || 16;
      dimensions = cc.size(0, arg[2]);
      hAlignment = cc.TEXT_ALIGNMENT_LEFT;
      vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM
    }
  }
  if(cc.Sprite.prototype.init.call(this)) {
    this._opacityModifyRGB = false;
    this._dimensions = cc.size(dimensions.width, dimensions.height);
    this._fontName = fontName;
    this._hAlignment = hAlignment;
    this._vAlignment = vAlignment;
    this._fontSize = fontSize * cc.CONTENT_SCALE_FACTOR();
    this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
    this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
    this.setString(strInfo);
    return true
  }
  return false
}, setString:function(text) {
  cc.Assert(text != null, "Invalid string");
  if(this._string != text) {
    this._string = text + "";
    if(this._string.length > 0) {
      this._updateTTF()
    }
  }
}, setHorizontalAlignment:function(alignment) {
  if(alignment != this._hAlignment) {
    this._hAlignment = alignment;
    if(this._string.length > 0) {
      this._updateTTF()
    }
  }
}, setVerticalAlignment:function(verticalAlignment) {
  if(verticalAlignment != this._vAlignment) {
    this._vAlignment = verticalAlignment;
    if(this._string.length > 0) {
      this._updateTTF()
    }
  }
}, setDimensions:function(dim) {
  if(dim.width != this._dimensions.width || dim.height != this._dimensions.height) {
    this._dimensions = dim;
    if(this._string.length > 0) {
      this._updateTTF()
    }
  }
}, setFontSize:function(fontSize) {
  if(this._fontSize != fontSize) {
    this._fontSize = fontSize;
    this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
    this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
    if(this._string.length > 0) {
      this._updateTTF()
    }
  }
}, setFontName:function(fontName) {
  if(this._fontName != fontName) {
    this._fontName = new String(fontName);
    this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
    this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
    if(this._string.length > 0) {
      this._updateTTF()
    }
  }
}, _updateTTF:function() {
  if(cc.renderContext.font != this._fontStyleStr) {
    cc.renderContext.font = this._fontStyleStr
  }
  var stringWidth = cc.renderContext.measureText(this._string).width;
  if(this._string.indexOf("\n") !== -1 || this._dimensions.width !== 0 && stringWidth > this._dimensions.width && this._string.indexOf(" ") !== -1) {
    var strings = this._strings = this._string.split("\n");
    var lineWidths = this._lineWidths = [];
    for(var i = 0;i < strings.length;i++) {
      if(strings[i].indexOf(" ") !== -1 && this._dimensions.width > 0) {
        var percent = this._dimensions.width / cc.renderContext.measureText(this._strings[i]).width;
        var startSearch = 0 | percent * strings[i].length + 1;
        var cutoff = startSearch;
        var tempLineWidth = 0;
        if(percent < 1) {
          do {
            cutoff = strings[i].lastIndexOf(" ", cutoff - 1);
            var str = strings[i].substring(0, cutoff);
            tempLineWidth = cc.renderContext.measureText(str).width;
            if(cutoff === -1) {
              cutoff = strings[i].indexOf(" ", startSearch);
              break
            }
          }while(tempLineWidth > this._dimensions.width);
          var newline = strings[i].substr(cutoff + 1);
          strings.splice(i + 1, 0, newline);
          strings[i] = str
        }
      }
      lineWidths[i] = tempLineWidth || cc.renderContext.measureText(strings[i]).width
    }
    this._isMultiLine = true
  }else {
    this._isMultiLine = false
  }
  if(this._dimensions.width === 0) {
    if(this._isMultiLine) {
      this.setContentSize(cc.size(Math.max.apply(Math, this._lineWidths), this._fontClientHeight * this._strings.length))
    }else {
      this.setContentSize(cc.size(stringWidth, this._fontClientHeight))
    }
    this._anchorPointInPoints = new cc.Point(this._contentSize.width * this._anchorPoint.x, this._contentSize.height * this._anchorPoint.y)
  }else {
    this.setContentSize(cc.size(this._dimensions.width, this._dimensions.height));
    this._anchorPointInPoints = new cc.Point(this._contentSize.width * this._anchorPoint.x, this._contentSize.height * this._anchorPoint.y)
  }
}, draw:function(ctx, renderType) {
  var context = ctx || cc.renderContext;
  if(this._flipX) {
    context.scale(-1, 1)
  }
  if(this._flipY) {
    context.scale(1, -1)
  }
  context.fillStyle = this._colorStyleStr;
  if(context.font != this._fontStyleStr) {
    context.font = this._fontStyleStr
  }
  context.textBaseline = cc.LabelTTF._textBaseline[this._vAlignment];
  context.textAlign = cc.LabelTTF._textAlign[this._hAlignment];
  var xoffset = 0;
  if(this._hAlignment === cc.TEXT_ALIGNMENT_RIGHT) {
    xoffset = this._contentSize.width
  }else {
    if(this._hAlignment === cc.TEXT_ALIGNMENT_CENTER) {
      xoffset = this._contentSize.width / 2
    }
  }
  if(this._isMultiLine) {
    var yOffset = 0;
    if(this._vAlignment === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM) {
      yOffset = this._fontSize + this._contentSize.height - this._fontSize * this._strings.length
    }else {
      if(this._vAlignment === cc.VERTICAL_TEXT_ALIGNMENT_CENTER) {
        yOffset = this._fontSize / 2 + (this._contentSize.height - this._fontSize * this._strings.length) / 2
      }
    }
    for(var i = 0;i < this._strings.length;i++) {
      var line = this._strings[i];
      context.fillText(line, xoffset, -this._contentSize.height + this._fontSize * i + yOffset)
    }
  }else {
    if(this._vAlignment === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM) {
      context.fillText(this._string, xoffset, 0)
    }else {
      if(this._vAlignment === cc.VERTICAL_TEXT_ALIGNMENT_TOP) {
        context.fillText(this._string, xoffset, -this._contentSize.height)
      }else {
        context.fillText(this._string, xoffset, -this._contentSize.height / 2)
      }
    }
  }
  if(cc.SPRITE_DEBUG_DRAW === 1) {
    context.fillStyle = "rgba(255,0,0,0.2)";
    context.fillRect(this._offsetPosition.x, this._offsetPosition.y, this._contentSize.width, -this._contentSize.height)
  }
  cc.INCREMENT_GL_DRAWS(1)
}});
cc.LabelTTFCanvas._textAlign = ["left", "center", "right"];
cc.LabelTTFCanvas._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTFCanvas.create = function() {
  var ret = new cc.LabelTTFCanvas;
  if(ret.initWithString(arguments)) {
    return ret
  }
  return null
};
cc.LabelTTFWebGL = cc.Sprite.extend({_dimensions:null, _hAlignment:cc.TEXT_ALIGNMENT_CENTER, _vAlignment:cc.VERTICAL_TEXT_ALIGNMENT_TOP, _fontName:"Arial", _fontSize:0, _string:"", _isMultiLine:false, _fontStyleStr:null, _colorStyleStr:null, ctor:function() {
  this._super();
  this._dimensions = cc.SizeZero();
  this._opacityModifyRGB = false;
  this._fontStyleStr = "";
  this._colorStyleStr = "";
  this._opacity = 255;
  this._color = cc.white();
  this._setColorStyleStr()
}, init:function(callsuper) {
  if(callsuper) {
    return this._super()
  }
  return this.initWithString([" ", this._fontName, this._fontSize])
}, description:function() {
  return"<cc.LabelTTF | FontName =" + this._fontName + " FontSize = " + this._fontSize.toFixed(1) + ">"
}, setColor:function(color3) {
  if(this._color.r == color3.r && this._color.g == color3.g && this._color.b == color3.b) {
    return
  }
  this._super(color3);
  this._setColorStyleStr();
  this.setNodeDirty()
}, setOpacity:function(opacity) {
  if(this._opacity === opacity) {
    return
  }
  this._super(opacity);
  this._setColorStyleStr()
}, _setColorStyleStr:function() {
  this._colorStyleStr = "rgba(" + this._color.r + "," + this._color.g + "," + this._color.b + ", " + this._opacity / 255 + ")"
}, getString:function() {
  return this._string
}, getHorizontalAlignment:function() {
  return this._hAlignment
}, getVerticalAlignment:function() {
  return this._vAlignment
}, getDimensions:function() {
  return this._dimensions
}, getFontSize:function() {
  return this._fontSize
}, getFontName:function() {
  return this._fontName
}, initWithString:function(arg) {
  var strInfo = arg[0] == undefined ? " " : arg[0] + "", fontName, fontSize, dimensions, hAlignment, vAlignment;
  cc.Assert(strInfo != null, "cc.LabelTTF.initWithString() label is null");
  if(arg.length == 6) {
    fontName = arg[1];
    fontSize = arg[2];
    dimensions = arg[3];
    hAlignment = arg[4];
    vAlignment = arg[5]
  }else {
    if(arg.length == 5) {
      fontName = arg[1];
      fontSize = arg[2];
      dimensions = arg[3];
      hAlignment = arg[4];
      vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP
    }else {
      fontName = arg[1] || "Arial";
      fontSize = arg[2] || 16;
      dimensions = cc.size(0, arg[2]);
      hAlignment = cc.TEXT_ALIGNMENT_LEFT;
      vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM
    }
  }
  if(cc.Sprite.prototype.init.call(this)) {
    this._opacityModifyRGB = false;
    this._dimensions = cc.size(dimensions.width, dimensions.height);
    this._fontName = fontName;
    this._hAlignment = hAlignment;
    this._vAlignment = vAlignment;
    this._fontSize = fontSize * cc.CONTENT_SCALE_FACTOR();
    this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
    this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
    this.setString(strInfo);
    this._updateTexture();
    return true
  }
  return false
}, _fontClientHeight:18, setString:function(text) {
  cc.Assert(text != null, "Invalid string");
  if(this._string != text) {
    this._string = text + "";
    this._needUpdateTexture = true
  }
}, setHorizontalAlignment:function(alignment) {
  if(alignment != this._hAlignment) {
    this._hAlignment = alignment;
    this._needUpdateTexture = true
  }
}, setVerticalAlignment:function(verticalAlignment) {
  if(verticalAlignment != this._vAlignment) {
    this._vAlignment = verticalAlignment;
    this._needUpdateTexture = true
  }
}, setDimensions:function(dim) {
  if(dim.width != this._dimensions.width || dim.height != this._dimensions.height) {
    this._dimensions = dim;
    this._needUpdateTexture = true
  }
}, setFontSize:function(fontSize) {
  if(this._fontSize != fontSize) {
    this._fontSize = fontSize;
    this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
    this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
    this._needUpdateTexture = true
  }
}, setFontName:function(fontName) {
  if(this._fontName && this._fontName != fontName) {
    this._fontName = fontName;
    this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
    this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(this._fontName, this._fontSize);
    this._needUpdateTexture = true
  }
}, _drawTTFInCanvasForWebGL:function(context) {
  if(!context) {
    return
  }
  context.setTransform(1, 0, 0, 1, 0, this._contentSize.height);
  if(context.font != this._fontStyleStr) {
    context.font = this._fontStyleStr
  }
  context.fillStyle = "rgba(255,255,255,1)";
  context.textBaseline = cc.LabelTTF._textBaseline[this._vAlignment];
  context.textAlign = cc.LabelTTF._textAlign[this._hAlignment];
  var xoffset = 0;
  if(this._hAlignment === cc.TEXT_ALIGNMENT_RIGHT) {
    xoffset = this._contentSize.width
  }else {
    if(this._hAlignment === cc.TEXT_ALIGNMENT_CENTER) {
      xoffset = this._contentSize.width / 2
    }
  }
  if(this._isMultiLine) {
    var yOffset = 0;
    if(this._vAlignment === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM) {
      yOffset = this._fontSize + this._contentSize.height - this._fontSize * this._strings.length
    }else {
      if(this._vAlignment === cc.VERTICAL_TEXT_ALIGNMENT_CENTER) {
        yOffset = this._fontSize / 2 + (this._contentSize.height - this._fontSize * this._strings.length) / 2
      }
    }
    for(var i = 0;i < this._strings.length;i++) {
      var line = this._strings[i];
      context.fillText(line, xoffset, -this._contentSize.height + this._fontSize * i + yOffset)
    }
  }else {
    if(this._vAlignment === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM) {
      context.fillText(this._string, xoffset, 0)
    }else {
      if(this._vAlignment === cc.VERTICAL_TEXT_ALIGNMENT_TOP) {
        context.fillText(this._string, xoffset, -this._contentSize.height)
      }else {
        context.fillText(this._string, xoffset, -this._contentSize.height / 2)
      }
    }
  }
}, _getLabelContext:function() {
  if(this._labelContext) {
    return this._labelContext
  }
  if(!this._labelCanvas) {
    this._labelCanvas = document.createElement("canvas");
    var labelTexture = new cc.Texture2D;
    labelTexture.initWithElement(this._labelCanvas);
    this.setTexture(labelTexture)
  }
  this._labelContext = this._labelCanvas.getContext("2d");
  return this._labelContext
}, _updateTTF:function() {
  var stringWidth = this._labelContext.measureText(this._string).width;
  if(this._string.indexOf("\n") !== -1 || this._dimensions.width !== 0 && stringWidth > this._dimensions.width && this._string.indexOf(" ") !== -1) {
    var strings = this._strings = this._string.split("\n");
    var lineWidths = this._lineWidths = [];
    for(var i = 0;i < strings.length;i++) {
      if(strings[i].indexOf(" ") !== -1 && this._dimensions.width > 0) {
        var percent = this._dimensions.width / this._labelContext.measureText(this._strings[i]).width;
        var startSearch = 0 | percent * strings[i].length + 1;
        var cutoff = startSearch;
        var tempLineWidth = 0;
        if(percent < 1) {
          do {
            cutoff = strings[i].lastIndexOf(" ", cutoff - 1);
            var str = strings[i].substring(0, cutoff);
            tempLineWidth = this._labelContext.measureText(str).width;
            if(cutoff === -1) {
              cutoff = strings[i].indexOf(" ", startSearch);
              break
            }
          }while(tempLineWidth > this._dimensions.width);
          var newline = strings[i].substr(cutoff + 1);
          strings.splice(i + 1, 0, newline);
          strings[i] = str
        }
      }
      lineWidths[i] = tempLineWidth || this._labelContext.measureText(strings[i]).width
    }
    this._isMultiLine = true
  }else {
    this._isMultiLine = false
  }
  if(this._dimensions.width === 0) {
    if(this._isMultiLine) {
      this.setContentSize(cc.size(Math.max.apply(Math, this._lineWidths), this._fontClientHeight * this._strings.length))
    }else {
      this.setContentSize(cc.size(stringWidth, this._fontClientHeight))
    }
    this._anchorPointInPoints = new cc.Point(this._contentSize.width * this._anchorPoint.x, this._contentSize.height * this._anchorPoint.y)
  }else {
    this.setContentSize(cc.size(this._dimensions.width, this._dimensions.height));
    this._anchorPointInPoints = new cc.Point(this._contentSize.width * this._anchorPoint.x, this._contentSize.height * this._anchorPoint.y)
  }
}, _updateTexture:function() {
  this._labelContext = this._getLabelContext();
  this._labelContext.font = this._fontStyleStr;
  this._updateTTF();
  this._labelCanvas.width = this._contentSize.width;
  this._labelCanvas.height = this._contentSize.height;
  this._drawTTFInCanvasForWebGL(this._labelContext);
  this._texture.handleLoadedTexture();
  this.setTextureRect(cc.rect(0, 0, this._labelCanvas.width, this._labelCanvas.height));
  return true
}, _needUpdateTexture:false, visit:function() {
  if(this._needUpdateTexture && this._string.length > 0) {
    this._needUpdateTexture = false;
    this._updateTexture()
  }
  this._super()
}, draw:function(ctx) {
  var gl = ctx || cc.renderContext;
  if(this._texture && this._texture.isLoaded()) {
    this._shaderProgram.use();
    this._shaderProgram.setUniformForModelViewProjectionMatrixWithMat4(this._mvpMatrix);
    cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
    cc.glBindTexture2D(this._texture);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this._texture._webTextureObj);
    cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSCOLORTEX);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._quadWebBuffer);
    if(this._quadDirty) {
      gl.bufferData(gl.ARRAY_BUFFER, this._quad.arrayBuffer, gl.STATIC_DRAW);
      this._quadDirty = false
    }
    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 24, 0);
    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 24, 16);
    gl.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, 24, 12);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
  }
  if(cc.SPRITE_DEBUG_DRAW === 1) {
    var verticesG1 = [cc.p(this._quad.tl.vertices.x, this._quad.tl.vertices.y), cc.p(this._quad.bl.vertices.x, this._quad.bl.vertices.y), cc.p(this._quad.br.vertices.x, this._quad.br.vertices.y), cc.p(this._quad.tr.vertices.x, this._quad.tr.vertices.y)];
    cc.drawingUtil.drawPoly(verticesG1, 4, true)
  }else {
    if(cc.SPRITE_DEBUG_DRAW === 2) {
      var drawSizeG2 = this.getTextureRect().size;
      var offsetPixG2 = this.getOffsetPosition();
      var verticesG2 = [cc.p(offsetPixG2.x, offsetPixG2.y), cc.p(offsetPixG2.x + drawSizeG2.width, offsetPixG2.y), cc.p(offsetPixG2.x + drawSizeG2.width, offsetPixG2.y + drawSizeG2.height), cc.p(offsetPixG2.x, offsetPixG2.y + drawSizeG2.height)];
      cc.drawingUtil.drawPoly(verticesG2, 4, true)
    }
  }
  cc.g_NumberOfDraws++
}});
cc.LabelTTFWebGL._textAlign = ["left", "center", "right"];
cc.LabelTTFWebGL._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTFWebGL.create = function() {
  var ret = new cc.LabelTTFWebGL;
  if(ret.initWithString(arguments)) {
    return ret
  }
  return null
};
cc.LabelTTF = cc.Browser.supportWebGL ? cc.LabelTTFWebGL : cc.LabelTTFCanvas;
cc.LabelTTF.__labelHeightDiv = document.createElement("div");
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial";
cc.LabelTTF.__labelHeightDiv.innerHTML = "ajghl~!";
cc.LabelTTF.__labelHeightDiv.style.position = "absolute";
cc.LabelTTF.__labelHeightDiv.style.left = "-100px";
cc.LabelTTF.__labelHeightDiv.style.top = "-100px";
document.body.appendChild(cc.LabelTTF.__labelHeightDiv);
cc.LabelTTF.__getFontHeightByDiv = function(fontName, fontSize) {
  var labelDiv = cc.LabelTTF.__labelHeightDiv;
  labelDiv.style.fontFamily = fontName;
  labelDiv.style.fontSize = fontSize + "px";
  return labelDiv.clientHeight
};
cc.LABEL_AUTOMATIC_WIDTH = -1;
cc.KerningHashElement = function(key, amount) {
  this.key = key || 0;
  this.amount = amount || 0
};
cc.FontDefHashElement = function(key, fontDef) {
  this.key = key || 0;
  this.fontDef = fontDef || new cc.BMFontDef
};
cc.BMFontDef = function(charID, rect, xOffset, yOffset, xAdvance) {
  this.charID = charID || 0;
  this.rect = rect || cc.rect(0, 0, 0.1, 0.1);
  this.xOffset = xOffset || 0;
  this.yOffset = yOffset || 0;
  this.xAdvance = xAdvance || 0
};
cc.BMFontPadding = function(left, top, right, bottom) {
  this.left = left || 0;
  this.top = top || 0;
  this.right = right || 0;
  this.bottom = bottom || 0
};
cc.BMFontConfiguration = cc.Class.extend({commonHeight:0, padding:null, atlasName:null, kerningDictionary:null, fontDefDictionary:null, characterSet:null, ctor:function() {
  this.padding = new cc.BMFontPadding;
  this.atlasName = "";
  this.kerningDictionary = new cc.KerningHashElement;
  this.fontDefDictionary = {};
  this.characterSet = []
}, description:function() {
  return"<cc.BMFontConfiguration | Kernings:" + this.kerningDictionary.amount + " | Image = " + this.atlasName.toString() + ">"
}, getAtlasName:function() {
  return this.atlasName
}, setAtlasName:function(atlasName) {
  this.atlasName = atlasName
}, getCharacterSet:function() {
  return this.characterSet
}, initWithFNTfile:function(FNTfile) {
  cc.Assert(FNTfile != null && FNTfile.length != 0, "");
  this.characterSet = this._parseConfigFile(FNTfile);
  return this.characterSet != null
}, _parseConfigFile:function(controlFile) {
  var data = cc.SAXParser.getInstance().getList(controlFile);
  cc.Assert(data, "cc.BMFontConfiguration._parseConfigFile | Open file error.");
  if(!data) {
    cc.log("cocos2d: Error parsing FNTfile " + controlFile);
    return null
  }
  var validCharsString = [];
  var line, re, i;
  re = /padding+[a-z0-9\-= ",]+/gi;
  line = re.exec(data)[0];
  if(line) {
    this._parseInfoArguments(line)
  }
  re = /common lineHeight+[a-z0-9\-= ",]+/gi;
  line = re.exec(data)[0];
  if(line) {
    this._parseCommonArguments(line)
  }
  re = /page id=[0-9]+ file="[\w\-\.]+/gi;
  line = re.exec(data)[0];
  if(line) {
    this._parseImageFileName(line, controlFile)
  }
  re = /chars c+[a-z0-9\-= ",]+/gi;
  line = re.exec(data)[0];
  if(line) {
  }
  re = /char id=\w[a-z0-9\-= ]+/gi;
  line = data.match(re);
  if(line) {
    for(i = 0;i < line.length;i++) {
      var element = new cc.FontDefHashElement;
      this._parseCharacterDefinition(line[i], element.fontDef);
      element.key = element.fontDef.charID;
      this.fontDefDictionary[element.key] = element;
      validCharsString.push(element.fontDef.charID)
    }
  }
  re = /kerning first=\w[a-z0-9\-= ]+/gi;
  line = data.match(re);
  if(line) {
    for(i = 0;i < line.length;i++) {
      this._parseKerningEntry(line[i])
    }
  }
  return validCharsString
}, _parseCharacterDefinition:function(line, characterDefinition) {
  var value = /id=(\d+)/gi.exec(line)[1];
  characterDefinition.charID = value.toString();
  value = /x=([\-\d]+)/gi.exec(line)[1];
  characterDefinition.rect.origin.x = parseInt(value);
  value = /y=([\-\d]+)/gi.exec(line)[1];
  characterDefinition.rect.origin.y = parseInt(value);
  value = /width=([\-\d]+)/gi.exec(line)[1];
  characterDefinition.rect.size.width = parseInt(value);
  value = /height=([\-\d]+)/gi.exec(line)[1];
  characterDefinition.rect.size.height = parseInt(value);
  value = /xoffset=([\-\d]+)/gi.exec(line)[1];
  characterDefinition.xOffset = parseInt(value);
  value = /yoffset=([\-\d]+)/gi.exec(line)[1];
  characterDefinition.yOffset = parseInt(value);
  value = /xadvance=([\-\d]+)/gi.exec(line)[1];
  characterDefinition.xAdvance = parseInt(value)
}, _parseInfoArguments:function(line) {
  var tmpPadding = /padding=(\d+)[,](\d+)[,](\d+)[,](\d+)/gi.exec(line);
  this.padding.left = tmpPadding[1];
  this.padding.top = tmpPadding[2];
  this.padding.right = tmpPadding[3];
  this.padding.bottom = tmpPadding[4];
  cc.log("cocos2d: padding: " + this.padding.left + "," + this.padding.top + "," + this.padding.right + "," + this.padding.bottom)
}, _parseCommonArguments:function(line) {
  var value;
  this.commonHeight = parseInt(/lineHeight=(\d+)/gi.exec(line)[1]);
  if(cc.renderContextType === cc.WEBGL) {
    var scaleW = parseInt(/scaleW=(\d+)/gi.exec(line)[1]);
    cc.Assert(scaleW <= cc.Configuration.getInstance().getMaxTextureSize(), "cc.LabelBMFont: page can't be larger than supported");
    var scaleH = parseInt(/scaleH=(\d+)/gi.exec(line)[1]);
    cc.Assert(scaleH <= cc.Configuration.getInstance().getMaxTextureSize(), "cc.LabelBMFont: page can't be larger than supported")
  }
  value = /pages=(\d+)/gi.exec(line)[1];
  cc.Assert(parseInt(value) == 1, "cc.BitfontAtlas: only supports 1 page")
}, _parseImageFileName:function(line, fntFile) {
  var value;
  value = /id=(\d+)/gi.exec(line)[1];
  cc.Assert(parseInt(value) == 0, "LabelBMFont file could not be found");
  value = /file="([a-zA-Z0-9\-\._]+)/gi.exec(line)[1];
  this.atlasName = cc.FileUtils.getInstance().fullPathFromRelativeFile(value, fntFile)
}, _parseKerningCapacity:function(line) {
}, _parseKerningEntry:function(line) {
  var value = /first=([\-\d]+)/gi.exec(line)[1];
  var first = parseInt(value);
  value = /second=([\-\d]+)/gi.exec(line)[1];
  var second = parseInt(value);
  value = /amount=([\-\d]+)/gi.exec(line)[1];
  var amount = parseInt(value);
  var element = new cc.KerningHashElement;
  element.amount = amount;
  element.key = first << 16 | second & 65535;
  this.kerningDictionary[element.key] = element
}, _purgeKerningDictionary:function() {
  this.kerningDictionary = null
}, _purgeFontDefDictionary:function() {
  this.fontDefDictionary = null
}});
cc.BMFontConfiguration.create = function(FNTfile) {
  var ret = new cc.BMFontConfiguration;
  if(ret.initWithFNTfile(FNTfile)) {
    return ret
  }
  return null
};
cc.LabelBMFont = cc.SpriteBatchNode.extend({RGBAProtocol:true, _opacity:0, _color:null, _opacityModifyRGB:false, _string:null, _configuration:null, _fntFile:null, _initialString:"", _alignment:null, _width:0, _lineBreakWithoutSpaces:false, _imageOffset:null, _reusedChar:null, ctor:function() {
  this._super();
  this._imageOffset = cc.POINT_ZERO;
  this._string = "";
  this._fntFile = "";
  this._initialString = "";
  this._reusedChar = []
}, draw:function(ctx) {
  this._super();
  if(cc.LABELBMFONT_DEBUG_DRAW) {
    var size = this.getContentSize();
    var pos = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
    var vertices = [cc.p(pos.x, pos.y), cc.p(pos.x + size.width, pos.y), cc.p(pos.x + size.width, pos.y + size.height), cc.p(pos.x, pos.y + size.height)];
    cc.drawingUtil.setDrawColor4B(0, 255, 0, 255);
    cc.drawingUtil.drawPoly(vertices, 4, true)
  }
}, getOpacity:function() {
  return this._opacity
}, setOpacity:function(opacity) {
  this._opacity = opacity;
  if(this._children) {
    for(var i = 0;i < this._children.length;i++) {
      var node = this._children[i];
      if(node && node.RGBAProtocol) {
        node.setOpacity(this._opacity)
      }
    }
  }
}, getColor:function() {
  return this._color
}, setColor:function(color3) {
  if(this._color.r == color3.r && this._color.g == color3.g && this._color.b == color3.b) {
    return
  }
  this._color = color3;
  if(cc.renderContextType === cc.WEBGL) {
    if(this._children) {
      for(var i = 0;i < this._children.length;i++) {
        var node = this._children[i];
        if(node) {
          node.setColor(this._color)
        }
      }
    }
  }else {
    if(this.getTexture()) {
      var cacheTextureForColor = cc.TextureCache.getInstance().getTextureColors(this._originalTexture);
      if(cacheTextureForColor) {
        var tx = this.getTexture();
        var textureRect = cc.rect(0, 0, tx.width, tx.height);
        var colorTexture = cc.generateTintImage(tx, cacheTextureForColor, this._color, textureRect);
        this.setTexture(colorTexture);
        this.updateString(false)
      }
    }
  }
}, isOpacityModifyRGB:function() {
  return this._opacityModifyRGB
}, setOpacityModifyRGB:function(opacityModifyRGB) {
  this._opacityModifyRGB = opacityModifyRGB;
  if(this._children) {
    for(var i = 0;i < this._children.length;i++) {
      var node = this._children[i];
      if(node && node.RGBAProtocol) {
        node.setOpacityModifyRGB(this._opacityModifyRGB)
      }
    }
  }
}, init:function() {
  return this.initWithString(null, null, null, null, null)
}, initWithString:function(str, fntFile, width, alignment, imageOffset) {
  var theString = str || "";
  cc.Assert(!this._configuration, "re-init is no longer supported");
  var texture;
  if(fntFile) {
    var newConf = cc.FNTConfigLoadFile(fntFile);
    cc.Assert(newConf, "cc.LabelBMFont: Impossible to create font. Please check file");
    this._configuration = newConf;
    this._fntFile = fntFile;
    texture = cc.TextureCache.getInstance().addImage(this._configuration.getAtlasName())
  }else {
    texture = cc.renderContextType === cc.CANVAS ? new Image : new cc.Texture2D
  }
  if(this.initWithTexture(texture, theString.length)) {
    this._alignment = alignment || cc.TEXT_ALIGNMENT_LEFT;
    this._imageOffset = imageOffset || cc.PointZero();
    this._width = width == null ? cc.LabelAutomaticWidth : width;
    this._opacity = 255;
    this._color = cc.white();
    this._contentSize = cc.SizeZero();
    this.setAnchorPoint(cc.p(0.5, 0.5));
    if(cc.renderContextType === cc.WEBGL) {
      this._opacityModifyRGB = this._textureAtlas.getTexture().hasPremultipliedAlpha();
      this._reusedChar = new cc.Sprite;
      this._reusedChar.initWithTexture(this._textureAtlas.getTexture(), cc.RectMake(0, 0, 0, 0), false);
      this._reusedChar.setBatchNode(this)
    }
    this.setString(theString);
    return true
  }
  return false
}, createFontChars:function() {
  var nextFontPositionX = 0;
  var prev = -1;
  var kerningAmount = 0;
  var tmpSize = cc.SizeZero();
  var longestLine = 0;
  var quantityOfLines = 1;
  var stringLen = this._string.length;
  if(stringLen === 0) {
    return
  }
  var i, charSet = this._configuration.getCharacterSet();
  for(i = 0;i < stringLen - 1;i++) {
    if(this._string.charCodeAt(i) == 10) {
      quantityOfLines++
    }
  }
  var totalHeight = this._configuration.commonHeight * quantityOfLines;
  var nextFontPositionY = -(this._configuration.commonHeight - this._configuration.commonHeight * quantityOfLines);
  for(i = 0;i < stringLen;i++) {
    var key = this._string.charCodeAt(i);
    if(key === 10) {
      nextFontPositionX = 0;
      nextFontPositionY -= this._configuration.commonHeight;
      continue
    }
    if(charSet[key] === null) {
      cc.log("cc.LabelBMFont: Attempted to use character not defined in this bitmap: " + this._string[i]);
      continue
    }
    var element = this._configuration.fontDefDictionary[key];
    if(!element) {
      cc.log("cocos2d: LabelBMFont: character not found " + this._string[i]);
      continue
    }
    var fontDef = element.fontDef;
    var rect = cc.rect(fontDef.rect.origin.x, fontDef.rect.origin.y, fontDef.rect.size.width, fontDef.rect.size.height);
    rect = cc.RECT_PIXELS_TO_POINTS(rect);
    rect.origin.x += this._imageOffset.x;
    rect.origin.y += this._imageOffset.y;
    var fontChar = this.getChildByTag(i);
    if(!fontChar) {
      fontChar = new cc.Sprite;
      if(key === 32 && cc.renderContextType === cc.CANVAS) {
        fontChar.init();
        fontChar.setTextureRect(cc.RectZero(), false, cc.SizeZero())
      }else {
        fontChar.initWithTexture(this.getTexture(), rect, false)
      }
      this.addChild(fontChar, 0, i)
    }else {
      if(key === 32 && cc.renderContextType === cc.CANVAS) {
        fontChar.init();
        fontChar.setTextureRect(cc.RectZero(), false, cc.SizeZero())
      }else {
        if(cc.renderContextType === cc.CANVAS) {
          fontChar.initWithTexture(this.getTexture(), rect, false)
        }else {
          fontChar.setTextureRect(rect, false, rect.size)
        }
        fontChar.setVisible(true);
        fontChar.setOpacity(255)
      }
    }
    var yOffset = this._configuration.commonHeight - fontDef.yOffset;
    var fontPos = cc.p(nextFontPositionX + fontDef.xOffset + fontDef.rect.size.width * 0.5 + kerningAmount, nextFontPositionY + yOffset - rect.size.height * 0.5 * cc.CONTENT_SCALE_FACTOR());
    fontChar.setPosition(cc.POINT_PIXELS_TO_POINTS(fontPos));
    nextFontPositionX += fontDef.xAdvance + kerningAmount;
    prev = key;
    fontChar.setOpacityModifyRGB(this._opacityModifyRGB);
    if(cc.renderContextType === cc.WEBGL) {
      fontChar.setColor(this._color)
    }
    if(this._opacity !== 255) {
      fontChar.setOpacity(this._opacity)
    }
    if(longestLine < nextFontPositionX) {
      longestLine = nextFontPositionX
    }
  }
  tmpSize.width = longestLine;
  tmpSize.height = totalHeight;
  this.setContentSize(cc.SIZE_PIXELS_TO_POINTS(tmpSize))
}, updateString:function(fromUpdate) {
  if(this._children) {
    for(var i = 0;i < this._children.length;i++) {
      var node = this._children[i];
      if(node) {
        node.setVisible(false)
      }
    }
  }
  if(this._configuration) {
    this.createFontChars()
  }
  if(!fromUpdate) {
    this.updateLabel()
  }
}, getString:function() {
  return this._initialString
}, setString:function(newString, fromUpdate) {
  fromUpdate = fromUpdate || false;
  if(this._string != newString) {
    this._string = newString + "";
    if(this._initialString !== this._string) {
      this._initialString = this._string
    }
    this.updateString(fromUpdate)
  }
}, setCString:function(label) {
  this.setString(label)
}, updateLabel:function() {
  if(this._width > 0) {
    this.setString(this._initialString, true);
    var stringLength = this._string.length;
    var multiline_string = [];
    var last_word = [];
    var line = 1, i = 0, start_line = false, start_word = false, startOfLine = -1, startOfWord = -1, skip = 0, j;
    var characterSprite;
    for(j = 0;j < this._children.length;j++) {
      while(!(characterSprite = this.getChildByTag(j + skip))) {
        skip++
      }
      if(i >= stringLength) {
        break
      }
      var character = this._string[i];
      if(!start_word) {
        startOfWord = this._getLetterPosXLeft(characterSprite);
        start_word = true
      }
      if(!start_line) {
        startOfLine = startOfWord;
        start_line = true
      }
      if(character.charCodeAt(0) == 10) {
        last_word.push("\n");
        multiline_string = multiline_string.concat(last_word);
        last_word.length = 0;
        start_word = false;
        start_line = false;
        startOfWord = -1;
        startOfLine = -1;
        i++;
        line++;
        if(i >= stringLength) {
          break
        }
        character = this._string[i];
        if(!startOfWord) {
          startOfWord = this._getLetterPosXLeft(characterSprite);
          start_word = true
        }
        if(!startOfLine) {
          startOfLine = startOfWord;
          start_line = true
        }
      }
      if(character.charCodeAt(0) == 32) {
        last_word.push(character);
        multiline_string = multiline_string.concat(last_word);
        last_word.length = 0;
        start_word = false;
        startOfWord = -1;
        i++;
        continue
      }
      if(this._getLetterPosXRight(characterSprite) - startOfLine > this._width) {
        if(!this._lineBreakWithoutSpaces) {
          last_word.push(character);
          var found = multiline_string.lastIndexOf(" ");
          if(found != -1) {
            cc.utf8_trim_ws(multiline_string)
          }else {
            multiline_string = []
          }
          if(multiline_string.length > 0) {
            multiline_string.push("\n")
          }
          line++;
          start_line = false;
          startOfLine = -1;
          i++
        }else {
          cc.utf8_trim_ws(last_word);
          last_word.push("\n");
          multiline_string = multiline_string.concat(last_word);
          last_word.length = 0;
          start_word = false;
          start_line = false;
          startOfWord = -1;
          startOfLine = -1;
          line++;
          if(i >= stringLength) {
            break
          }
          if(!startOfWord) {
            startOfWord = this._getLetterPosXLeft(characterSprite);
            start_word = true
          }
          if(!startOfLine) {
            startOfLine = startOfWord;
            start_line = true
          }
          j--
        }
      }else {
        last_word.push(character);
        i++
      }
    }
    multiline_string = multiline_string.concat(last_word);
    var len = multiline_string.length;
    var str_new = "";
    for(i = 0;i < len;++i) {
      str_new += multiline_string[i]
    }
    this._string = str_new + String.fromCharCode(0);
    this.updateString(true)
  }
  if(this._alignment != cc.TEXT_ALIGNMENT_LEFT) {
    i = 0;
    var lineNumber = 0;
    var strlen = this._string.length;
    var last_line = [];
    for(var ctr = 0;ctr < strlen;ctr++) {
      if(this._string[ctr].charCodeAt(0) == 10 || this._string[ctr].charCodeAt(0) == 0) {
        var lineWidth = 0;
        var line_length = last_line.length;
        var index = i + line_length - 1 + lineNumber;
        if(index < 0) {
          continue
        }
        var lastChar = this.getChildByTag(index);
        if(lastChar == null) {
          continue
        }
        lineWidth = lastChar.getPosition().x + lastChar.getContentSize().width / 2;
        var shift = 0;
        switch(this._alignment) {
          case cc.TEXT_ALIGNMENT_CENTER:
            shift = this.getContentSize().width / 2 - lineWidth / 2;
            break;
          case cc.TEXT_ALIGNMENT_RIGHT:
            shift = this.getContentSize().width - lineWidth;
            break;
          default:
            break
        }
        if(shift != 0) {
          for(j = 0;j < line_length;j++) {
            index = i + j + lineNumber;
            if(index < 0) {
              continue
            }
            characterSprite = this.getChildByTag(index);
            if(characterSprite) {
              characterSprite.setPosition(cc.pAdd(characterSprite.getPosition(), cc.p(shift, 0)))
            }
          }
        }
        i += line_length;
        lineNumber++;
        last_line.length = 0;
        continue
      }
      last_line.push(this._string[i])
    }
  }
}, setAlignment:function(alignment) {
  this._alignment = alignment;
  this.updateLabel()
}, setWidth:function(width) {
  this._width = width;
  this.updateLabel()
}, setLineBreakWithoutSpace:function(breakWithoutSpace) {
  this._lineBreakWithoutSpaces = breakWithoutSpace;
  this.updateLabel()
}, setScale:function(scale, scaleY) {
  this._super(scale, scaleY);
  this.updateLabel()
}, setScaleX:function(scaleX) {
  this._super(scaleX);
  this.updateLabel()
}, setScaleY:function(scaleY) {
  this._super(scaleY);
  this.updateLabel()
}, setFntFile:function(fntFile) {
  if(fntFile != null && fntFile != this._fntFile) {
    var newConf = cc.FNTConfigLoadFile(fntFile);
    cc.Assert(newConf, "cc.LabelBMFont: Impossible to create font. Please check file");
    this._fntFile = fntFile;
    this._configuration = newConf;
    this.setTexture(cc.TextureCache.getInstance().addImage(this._configuration.getAtlasName()));
    if(cc.renderContextType == cc.CANVAS) {
      this._originalTexture = this.getTexture()
    }
    this.createFontChars()
  }
}, getFntFile:function() {
  return this._fntFile
}, setAnchorPoint:function(point) {
  if(!cc.Point.CCPointEqualToPoint(point, this._anchorPoint)) {
    this._super(point);
    this.updateLabel()
  }
}, _atlasNameFromFntFile:function(fntFile) {
}, _kerningAmountForFirst:function(first, second) {
  var ret = 0;
  var key = first << 16 | second & 65535;
  if(this._configuration.kerningDictionary) {
    var element = this._configuration.kerningDictionary[key.toString()];
    if(element) {
      ret = element.amount
    }
  }
  return ret
}, _getLetterPosXLeft:function(sp) {
  return sp.getPosition().x * this._scaleX + sp.getContentSize().width * this._scaleX * sp.getAnchorPoint().x
}, _getLetterPosXRight:function(sp) {
  return sp.getPosition().x * this._scaleX - sp.getContentSize().width * this._scaleX * sp.getAnchorPoint().x
}});
cc.LabelBMFont.create = function(str, fntFile, width, alignment, imageOffset) {
  var ret = new cc.LabelBMFont;
  if(arguments.length == 0) {
    if(ret && ret.init()) {
      return ret
    }
    return null
  }
  if(ret && ret.initWithString(str, fntFile, width, alignment, imageOffset)) {
    return ret
  }
  return null
};
cc.LabelBMFont._configurations = null;
cc.FNTConfigLoadFile = function(fntFile) {
  if(!cc.LabelBMFont._configurations) {
    cc.LabelBMFont._configurations = {}
  }
  var ret = cc.LabelBMFont._configurations[fntFile];
  if(!ret) {
    ret = cc.BMFontConfiguration.create(fntFile);
    cc.LabelBMFont._configurations[fntFile] = ret
  }
  return ret
};
cc.LabelBMFont.purgeCachedData = function() {
  cc.FNTConfigRemoveCache()
};
cc.FNTConfigRemoveCache = function() {
  if(cc.LabelBMFont._configurations) {
    cc.LabelBMFont._configurations = null
  }
};
cc.isspace_unicode = function(ch) {
  ch = ch.charCodeAt(0);
  return ch >= 9 && ch <= 13 || ch == 32 || ch == 133 || ch == 160 || ch == 5760 || ch >= 8192 && ch <= 8202 || ch == 8232 || ch == 8233 || ch == 8239 || ch == 8287 || ch == 12288
};
cc.utf8_trim_ws = function(str) {
  var len = str.length;
  if(len <= 0) {
    return
  }
  var last_index = len - 1;
  if(cc.isspace_unicode(str[last_index])) {
    for(var i = last_index - 1;i >= 0;--i) {
      if(cc.isspace_unicode(str[i])) {
        last_index = i
      }else {
        break
      }
    }
    cc.utf8_trim_from(str, last_index)
  }
};
cc.utf8_trim_from = function(str, index) {
  var len = str.length;
  if(index >= len || index < 0) {
    return
  }
  str.splice(index, len)
};
cc.PARTICLE_SHAPE_MODE = 0;
cc.PARTICLE_TEXTURE_MODE = 1;
cc.PARTICLE_STAR_SHAPE = 0;
cc.PARTICLE_BALL_SHAPE = 1;
cc.PARTICLE_DURATION_INFINITY = -1;
cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE = -1;
cc.PARTICLE_START_RADIUS_EQUAL_TO_END_RADIUS = -1;
cc.PARTICLE_MODE_GRAVITY = 0;
cc.PARTICLE_MODE_RADIUS = 1;
cc.PARTICLE_TYPE_FREE = 0;
cc.PARTICLE_TYPE_RELATIVE = 1;
cc.PARTICLE_TYPE_GROUPED = 2;
cc.PARTICLE_TYPE_FREE = cc.PARTICLE_TYPE_FREE;
cc.PARTICLE_TYPE_GROUPED = cc.PARTICLE_TYPE_GROUPED;
cc.Particle = function(pos, startPos, color, deltaColor, size, deltaSize, rotation, deltaRotation, timeToLive, atlasIndex, modeA, modeB) {
  this.pos = pos ? pos : cc.PointZero();
  this.startPos = startPos ? startPos : cc.PointZero();
  this.color = color ? color : new cc.Color4F(0, 0, 0, 1);
  this.deltaColor = deltaColor ? deltaColor : new cc.Color4F(0, 0, 0, 1);
  this.size = size || 0;
  this.deltaSize = deltaSize || 0;
  this.rotation = rotation || 0;
  this.deltaRotation = deltaRotation || 0;
  this.timeToLive = timeToLive || 0;
  this.atlasIndex = atlasIndex || 0;
  this.modeA = modeA ? modeA : new cc.Particle.ModeA;
  this.modeB = modeB ? modeB : new cc.Particle.ModeB;
  this.isChangeColor = false;
  this.drawPos = cc.p(0, 0)
};
cc.Particle.ModeA = function(dir, radialAccel, tangentialAccel) {
  this.dir = dir ? dir : cc.PointZero();
  this.radialAccel = radialAccel || 0;
  this.tangentialAccel = tangentialAccel || 0
};
cc.Particle.ModeB = function(angle, degreesPerSecond, radius, deltaRadius) {
  this.angle = angle || 0;
  this.degreesPerSecond = degreesPerSecond || 0;
  this.radius = radius || 0;
  this.deltaRadius = deltaRadius || 0
};
cc.ParticleSystem = cc.Node.extend({_plistFile:"", _elapsed:0, _dontTint:false, modeA:null, modeB:null, _pointZeroForParticle:cc.p(0, 0), _particles:null, _particlePool:null, _emitCounter:0, _particleIdx:0, _batchNode:null, getBatchNode:function() {
  return this._batchNode
}, setBatchNode:function(batchNode) {
  if(this._batchNode != batchNode) {
    this._batchNode = batchNode;
    if(batchNode) {
      for(var i = 0;i < this._totalParticles;i++) {
        this._particles[i].atlasIndex = i
      }
    }
  }
}, _atlasIndex:0, getAtlasIndex:function() {
  return this._atlasIndex
}, setAtlasIndex:function(atlasIndex) {
  this._atlasIndex = atlasIndex
}, _transformSystemDirty:false, _allocatedParticles:0, _drawMode:cc.PARTICLE_SHAPE_MODE, getDrawMode:function() {
  return this._drawMode
}, setDrawMode:function(drawMode) {
  this._drawMode = drawMode
}, _shapeType:cc.PARTICLE_BALL_SHAPE, getShapeType:function() {
  return this._shapeType
}, setShapeType:function(shapeType) {
  this._shapeType = shapeType
}, _isActive:false, isActive:function() {
  return this._isActive
}, _particleCount:0, getParticleCount:function() {
  return this._particleCount
}, setParticleCount:function(particleCount) {
  this._particleCount = particleCount
}, _duration:0, getDuration:function() {
  return this._duration
}, setDuration:function(duration) {
  this._duration = duration
}, _sourcePosition:cc.PointZero(), getSourcePosition:function() {
  return this._sourcePosition
}, setSourcePosition:function(sourcePosition) {
  this._sourcePosition = sourcePosition
}, _posVar:cc.PointZero(), getPosVar:function() {
  return this._posVar
}, setPosVar:function(posVar) {
  this._posVar = posVar
}, _life:0, getLife:function() {
  return this._life
}, setLife:function(life) {
  this._life = life
}, _lifeVar:0, getLifeVar:function() {
  return this._lifeVar
}, setLifeVar:function(lifeVar) {
  this._lifeVar = lifeVar
}, _angle:0, getAngle:function() {
  return this._angle
}, setAngle:function(angle) {
  this._angle = angle
}, _angleVar:0, getAngleVar:function() {
  return this._angleVar
}, setAngleVar:function(angleVar) {
  this._angleVar = angleVar
}, getGravity:function() {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
  return this.modeA.gravity
}, setGravity:function(gravity) {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
  this.modeA.gravity = gravity
}, getSpeed:function() {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
  return this.modeA.speed
}, setSpeed:function(speed) {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
  this.modeA.speed = speed
}, getSpeedVar:function() {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
  return this.modeA.speedVar
}, setSpeedVar:function(speedVar) {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
  this.modeA.speedVar = speedVar
}, getTangentialAccel:function() {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
  return this.modeA.tangentialAccel
}, setTangentialAccel:function(tangentialAccel) {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
  this.modeA.tangentialAccel = tangentialAccel
}, getTangentialAccelVar:function() {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
  return this.modeA.tangentialAccelVar
}, setTangentialAccelVar:function(tangentialAccelVar) {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
  this.modeA.tangentialAccelVar = tangentialAccelVar
}, getRadialAccel:function() {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
  return this.modeA.radialAccel
}, setRadialAccel:function(radialAccel) {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
  this.modeA.radialAccel = radialAccel
}, getRadialAccelVar:function() {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
  return this.modeA.radialAccelVar
}, setRadialAccelVar:function(radialAccelVar) {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
  this.modeA.radialAccelVar = radialAccelVar
}, getStartRadius:function() {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_RADIUS, "Particle Mode should be Radius");
  return this.modeB.startRadius
}, setStartRadius:function(startRadius) {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_RADIUS, "Particle Mode should be Radius");
  this.modeB.startRadius = startRadius
}, getStartRadiusVar:function() {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_RADIUS, "Particle Mode should be Radius");
  return this.modeB.startRadiusVar
}, setStartRadiusVar:function(startRadiusVar) {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_RADIUS, "Particle Mode should be Radius");
  this.modeB.startRadiusVar = startRadiusVar
}, getEndRadius:function() {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_RADIUS, "Particle Mode should be Radius");
  return this.modeB.endRadius
}, setEndRadius:function(endRadius) {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_RADIUS, "Particle Mode should be Radius");
  this.modeB.endRadius = endRadius
}, getEndRadiusVar:function() {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_RADIUS, "Particle Mode should be Radius");
  return this.modeB.endRadiusVar
}, setEndRadiusVar:function(endRadiusVar) {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_RADIUS, "Particle Mode should be Radius");
  this.modeB.endRadiusVar = endRadiusVar
}, getRotatePerSecond:function() {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_RADIUS, "Particle Mode should be Radius");
  return this.modeB.rotatePerSecond
}, setRotatePerSecond:function(degrees) {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_RADIUS, "Particle Mode should be Radius");
  this.modeB.rotatePerSecond = degrees
}, getRotatePerSecondVar:function() {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_RADIUS, "Particle Mode should be Radius");
  return this.modeB.rotatePerSecondVar
}, setRotatePerSecondVar:function(degrees) {
  cc.Assert(this._emitterMode == cc.PARTICLE_MODE_RADIUS, "Particle Mode should be Radius");
  this.modeB.rotatePerSecondVar = degrees
}, setScale:function(scale, scaleY) {
  this._transformSystemDirty = true;
  this._super(scale, scaleY)
}, setRotation:function(newRotation) {
  this._transformSystemDirty = true;
  this._super(newRotation)
}, setScaleX:function(newScaleX) {
  this._transformSystemDirty = true;
  this._super(newScaleX)
}, setScaleY:function(newScaleY) {
  this._transformSystemDirty = true;
  this._super(newScaleY)
}, _startSize:0, getStartSize:function() {
  return this._startSize
}, setStartSize:function(startSize) {
  this._startSize = startSize
}, _startSizeVar:0, getStartSizeVar:function() {
  return this._startSizeVar
}, setStartSizeVar:function(startSizeVar) {
  this._startSizeVar = startSizeVar
}, _endSize:0, getEndSize:function() {
  return this._endSize
}, setEndSize:function(endSize) {
  this._endSize = endSize
}, _endSizeVar:0, getEndSizeVar:function() {
  return this._endSizeVar
}, setEndSizeVar:function(endSizeVar) {
  this._endSizeVar = endSizeVar
}, _startColor:new cc.Color4F(0, 0, 0, 1), getStartColor:function() {
  return this._startColor
}, setStartColor:function(startColor) {
  if(startColor instanceof cc.Color3B) {
    startColor = cc.c4FFromccc3B(startColor)
  }
  this._startColor = startColor
}, _startColorVar:new cc.Color4F(0, 0, 0, 1), getStartColorVar:function() {
  return this._startColorVar
}, setStartColorVar:function(startColorVar) {
  if(startColorVar instanceof cc.Color3B) {
    startColorVar = cc.c4FFromccc3B(startColorVar)
  }
  this._startColorVar = startColorVar
}, _endColor:new cc.Color4F(0, 0, 0, 1), getEndColor:function() {
  return this._endColor
}, setEndColor:function(endColor) {
  if(endColor instanceof cc.Color3B) {
    endColor = cc.c4FFromccc3B(endColor)
  }
  this._endColor = endColor
}, _endColorVar:new cc.Color4F(0, 0, 0, 1), getEndColorVar:function() {
  return this._endColorVar
}, setEndColorVar:function(endColorVar) {
  if(endColorVar instanceof cc.Color3B) {
    endColorVar = cc.c4FFromccc3B(endColorVar)
  }
  this._endColorVar = endColorVar
}, _startSpin:0, getStartSpin:function() {
  return this._startSpin
}, setStartSpin:function(startSpin) {
  this._startSpin = startSpin
}, _startSpinVar:0, getStartSpinVar:function() {
  return this._startSpinVar
}, setStartSpinVar:function(startSpinVar) {
  this._startSpinVar = startSpinVar
}, _endSpin:0, getEndSpin:function() {
  return this._endSpin
}, setEndSpin:function(endSpin) {
  this._endSpin = endSpin
}, _endSpinVar:0, getEndSpinVar:function() {
  return this._endSpinVar
}, setEndSpinVar:function(endSpinVar) {
  this._endSpinVar = endSpinVar
}, _emissionRate:0, getEmissionRate:function() {
  return this._emissionRate
}, setEmissionRate:function(emissionRate) {
  this._emissionRate = emissionRate
}, _totalParticles:0, getTotalParticles:function() {
  return this._totalParticles
}, setTotalParticles:function(totalParticles) {
  cc.Assert(totalParticles <= this._allocatedParticles, "Particle: resizing particle array only supported for quads");
  this._totalParticles = totalParticles
}, _texture:null, getTexture:function() {
  return this._texture
}, setTexture:function(texture) {
  if(this._texture != texture) {
    this._texture = texture;
    this._updateBlendFunc()
  }
}, _blendFunc:null, getBlendFunc:function() {
  return this._blendFunc
}, setBlendFunc:function(src, dst) {
  if(arguments.length == 1) {
    if(this._blendFunc != src) {
      this._blendFunc = src;
      this._updateBlendFunc()
    }
  }else {
    if(this._blendFunc.src != src || this._blendFunc.dst != dst) {
      this._blendFunc = {src:src, dst:dst};
      this._updateBlendFunc()
    }
  }
}, _opacityModifyRGB:false, getOpacityModifyRGB:function() {
  return this._opacityModifyRGB
}, setOpacityModifyRGB:function(newValue) {
  this._opacityModifyRGB = newValue
}, isBlendAdditive:function() {
  return this._blendFunc.src == gl.SRC_ALPHA && this._blendFunc.dst == gl.ONE || this._blendFunc.src == gl.ONE && this._blendFunc.dst == gl.ONE
}, setBlendAdditive:function(isBlendAdditive) {
  if(isBlendAdditive) {
    this._blendFunc.src = gl.SRC_ALPHA;
    this._blendFunc.dst = gl.ONE
  }else {
    if(cc.renderContextType === cc.WEBGL) {
      if(this._texture && !this._texture.hasPremultipliedAlpha()) {
        this._blendFunc.src = gl.SRC_ALPHA;
        this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA
      }else {
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST
      }
    }else {
      this._blendFunc.src = cc.BLEND_SRC;
      this._blendFunc.dst = cc.BLEND_DST
    }
  }
}, _positionType:cc.PARTICLE_TYPE_FREE, getPositionType:function() {
  return this._positionType
}, setPositionType:function(positionType) {
  this._positionType = positionType
}, _isAutoRemoveOnFinish:false, isAutoRemoveOnFinish:function() {
  return this._isAutoRemoveOnFinish
}, setAutoRemoveOnFinish:function(isAutoRemoveOnFinish) {
  this._isAutoRemoveOnFinish = isAutoRemoveOnFinish
}, _emitterMode:0, getEmitterMode:function() {
  return this._emitterMode
}, setEmitterMode:function(emitterMode) {
  this._emitterMode = emitterMode
}, ctor:function() {
  this._super();
  this._emitterMode = cc.PARTICLE_MODE_GRAVITY;
  this.modeA = new cc.ParticleSystem.ModeA;
  this.modeB = new cc.ParticleSystem.ModeB;
  this._blendFunc = {src:cc.BLEND_SRC, dst:cc.BLEND_DST};
  this._particles = [];
  this._sourcePosition = new cc.Point(0, 0);
  this._posVar = new cc.Point(0, 0);
  this._startColor = new cc.Color4F(1, 1, 1, 1);
  this._startColorVar = new cc.Color4F(1, 1, 1, 1);
  this._endColor = new cc.Color4F(1, 1, 1, 1);
  this._endColorVar = new cc.Color4F(1, 1, 1, 1);
  this._particlePool = []
}, init:function() {
  return this.initWithTotalParticles(150)
}, initWithFile:function(plistFile) {
  this._plistFile = plistFile;
  var dict = cc.FileUtils.getInstance().dictionaryWithContentsOfFileThreadSafe(this._plistFile);
  cc.Assert(dict != null, "Particles: file not found");
  return this.initWithDictionary(dict, "")
}, getBoundingBoxToWorld:function() {
  return cc.rect(0, 0, cc.canvas.width, cc.canvas.height)
}, initWithDictionary:function(dictionary, dirname) {
  var ret = false;
  var buffer = null;
  var image = null;
  var maxParticles = parseInt(this._valueForKey("maxParticles", dictionary));
  if(this.initWithTotalParticles(maxParticles)) {
    this._angle = parseFloat(this._valueForKey("angle", dictionary));
    this._angleVar = parseFloat(this._valueForKey("angleVariance", dictionary));
    this._duration = parseFloat(this._valueForKey("duration", dictionary));
    this._blendFunc.src = parseInt(this._valueForKey("blendFuncSource", dictionary));
    this._blendFunc.dst = parseInt(this._valueForKey("blendFuncDestination", dictionary));
    this._startColor.r = parseFloat(this._valueForKey("startColorRed", dictionary));
    this._startColor.g = parseFloat(this._valueForKey("startColorGreen", dictionary));
    this._startColor.b = parseFloat(this._valueForKey("startColorBlue", dictionary));
    this._startColor.a = parseFloat(this._valueForKey("startColorAlpha", dictionary));
    this._startColorVar.r = parseFloat(this._valueForKey("startColorVarianceRed", dictionary));
    this._startColorVar.g = parseFloat(this._valueForKey("startColorVarianceGreen", dictionary));
    this._startColorVar.b = parseFloat(this._valueForKey("startColorVarianceBlue", dictionary));
    this._startColorVar.a = parseFloat(this._valueForKey("startColorVarianceAlpha", dictionary));
    this._endColor.r = parseFloat(this._valueForKey("finishColorRed", dictionary));
    this._endColor.g = parseFloat(this._valueForKey("finishColorGreen", dictionary));
    this._endColor.b = parseFloat(this._valueForKey("finishColorBlue", dictionary));
    this._endColor.a = parseFloat(this._valueForKey("finishColorAlpha", dictionary));
    this._endColorVar.r = parseFloat(this._valueForKey("finishColorVarianceRed", dictionary));
    this._endColorVar.g = parseFloat(this._valueForKey("finishColorVarianceGreen", dictionary));
    this._endColorVar.b = parseFloat(this._valueForKey("finishColorVarianceBlue", dictionary));
    this._endColorVar.a = parseFloat(this._valueForKey("finishColorVarianceAlpha", dictionary));
    this._startSize = parseFloat(this._valueForKey("startParticleSize", dictionary));
    this._startSizeVar = parseFloat(this._valueForKey("startParticleSizeVariance", dictionary));
    this._endSize = parseFloat(this._valueForKey("finishParticleSize", dictionary));
    this._endSizeVar = parseFloat(this._valueForKey("finishParticleSizeVariance", dictionary));
    var x = parseFloat(this._valueForKey("sourcePositionx", dictionary));
    var y = parseFloat(this._valueForKey("sourcePositiony", dictionary));
    this.setPosition(cc.p(x, y));
    this._posVar.x = parseFloat(this._valueForKey("sourcePositionVariancex", dictionary));
    this._posVar.y = parseFloat(this._valueForKey("sourcePositionVariancey", dictionary));
    this._startSpin = parseFloat(this._valueForKey("rotationStart", dictionary));
    this._startSpinVar = parseFloat(this._valueForKey("rotationStartVariance", dictionary));
    this._endSpin = parseFloat(this._valueForKey("rotationEnd", dictionary));
    this._endSpinVar = parseFloat(this._valueForKey("rotationEndVariance", dictionary));
    this._emitterMode = parseInt(this._valueForKey("emitterType", dictionary));
    if(this._emitterMode == cc.PARTICLE_MODE_GRAVITY) {
      this.modeA.gravity.x = parseFloat(this._valueForKey("gravityx", dictionary));
      this.modeA.gravity.y = parseFloat(this._valueForKey("gravityy", dictionary));
      this.modeA.speed = parseFloat(this._valueForKey("speed", dictionary));
      this.modeA.speedVar = parseFloat(this._valueForKey("speedVariance", dictionary));
      var pszTmp = this._valueForKey("radialAcceleration", dictionary);
      this.modeA.radialAccel = pszTmp ? parseFloat(pszTmp) : 0;
      pszTmp = this._valueForKey("radialAccelVariance", dictionary);
      this.modeA.radialAccelVar = pszTmp ? parseFloat(pszTmp) : 0;
      pszTmp = this._valueForKey("tangentialAcceleration", dictionary);
      this.modeA.tangentialAccel = pszTmp ? parseFloat(pszTmp) : 0;
      pszTmp = this._valueForKey("tangentialAccelVariance", dictionary);
      this.modeA.tangentialAccelVar = pszTmp ? parseFloat(pszTmp) : 0
    }else {
      if(this._emitterMode == cc.PARTICLE_MODE_RADIUS) {
        this.modeB.startRadius = parseFloat(this._valueForKey("maxRadius", dictionary));
        this.modeB.startRadiusVar = parseFloat(this._valueForKey("maxRadiusVariance", dictionary));
        this.modeB.endRadius = parseFloat(this._valueForKey("minRadius", dictionary));
        this.modeB.endRadiusVar = 0;
        this.modeB.rotatePerSecond = parseFloat(this._valueForKey("rotatePerSecond", dictionary));
        this.modeB.rotatePerSecondVar = parseFloat(this._valueForKey("rotatePerSecondVariance", dictionary))
      }else {
        cc.Assert(false, "Invalid emitterType in config file");
        return false
      }
    }
    this._life = parseFloat(this._valueForKey("particleLifespan", dictionary));
    this._lifeVar = parseFloat(this._valueForKey("particleLifespanVariance", dictionary));
    this._emissionRate = this._totalParticles / this._life;
    if(!this._batchNode) {
      this._opacityModifyRGB = false;
      var textureName = this._valueForKey("textureFileName", dictionary);
      var fullpath = cc.FileUtils.getInstance().fullPathFromRelativeFile(textureName, this._plistFile);
      var tex = cc.TextureCache.getInstance().textureForKey(fullpath);
      if(tex) {
        this.setTexture(tex)
      }else {
        var textureData = this._valueForKey("textureImageData", dictionary);
        if(textureData && textureData.length == 0) {
          cc.Assert(textureData, "cc.ParticleSystem.initWithDictory:textureImageData is null");
          tex = cc.TextureCache.getInstance().addImage(fullpath);
          if(!tex) {
            return false
          }
          this.setTexture(tex)
        }else {
          buffer = cc.unzipBase64AsArray(textureData, 1);
          if(!buffer) {
            cc.log("cc.ParticleSystem: error decoding or ungzipping textureImageData");
            return false
          }
          var imageFormat = cc.getImageFormatByData(buffer);
          if(imageFormat !== cc.FMT_TIFF && imageFormat !== cc.FMT_PNG) {
            cc.log("cc.ParticleSystem: unknown image format with Data");
            return false
          }
          var canvasObj = document.createElement("canvas");
          if(imageFormat === cc.FMT_PNG) {
            var myPngObj = new cc.PNGReader(buffer);
            myPngObj.render(canvasObj)
          }else {
            var myTIFFObj = cc.TIFFReader.getInstance();
            myTIFFObj.parseTIFF(buffer, canvasObj)
          }
          cc.TextureCache.getInstance().cacheImage(fullpath, canvasObj);
          var addTexture = cc.TextureCache.getInstance().textureForKey(fullpath);
          cc.Assert(addTexture != null, "cc.ParticleSystem: error loading the texture");
          this.setTexture(addTexture)
        }
      }
    }
    ret = true
  }
  return ret
}, initWithTotalParticles:function(numberOfParticles) {
  this._totalParticles = numberOfParticles;
  this._particles = [];
  this._particlePool = [];
  if(!this._particles) {
    cc.log("Particle system: not enough memory");
    return false
  }
  this._allocatedParticles = numberOfParticles;
  if(this._batchNode) {
    for(var i = 0;i < this._totalParticles;i++) {
      this._particles[i].atlasIndex = i
    }
  }
  this._isActive = true;
  this._blendFunc.src = cc.BLEND_SRC;
  this._blendFunc.dst = cc.BLEND_DST;
  this._positionType = cc.PARTICLE_TYPE_FREE;
  this._emitterMode = cc.PARTICLE_MODE_GRAVITY;
  this._isAutoRemoveOnFinish = false;
  this._transformSystemDirty = false;
  this.scheduleUpdateWithPriority(1);
  return true
}, destroyParticleSystem:function() {
  this._particlePool = null;
  this.unscheduleUpdate()
}, _getParticleObject:function() {
  if(this._particlePool.length > 0) {
    return this._particlePool.pop()
  }
  return new cc.Particle
}, addParticle:function() {
  if(this.isFull()) {
    return false
  }
  var particle = this._getParticleObject();
  this.initParticle(particle);
  this._particles.push(particle);
  ++this._particleCount;
  return true
}, initParticle:function(particle) {
  particle.timeToLive = this._life + this._lifeVar * cc.RANDOM_MINUS1_1();
  particle.timeToLive = Math.max(0, particle.timeToLive);
  particle.pos.x = this._sourcePosition.x + this._posVar.x * cc.RANDOM_MINUS1_1();
  particle.pos.y = this._sourcePosition.y + this._posVar.y * cc.RANDOM_MINUS1_1();
  var start = new cc.Color4F(cc.clampf(this._startColor.r + this._startColorVar.r * cc.RANDOM_MINUS1_1(), 0, 1), cc.clampf(this._startColor.g + this._startColorVar.g * cc.RANDOM_MINUS1_1(), 0, 1), cc.clampf(this._startColor.b + this._startColorVar.b * cc.RANDOM_MINUS1_1(), 0, 1), cc.clampf(this._startColor.a + this._startColorVar.a * cc.RANDOM_MINUS1_1(), 0, 1));
  var end = new cc.Color4F(cc.clampf(this._endColor.r + this._endColorVar.r * cc.RANDOM_MINUS1_1(), 0, 1), cc.clampf(this._endColor.g + this._endColorVar.g * cc.RANDOM_MINUS1_1(), 0, 1), cc.clampf(this._endColor.b + this._endColorVar.b * cc.RANDOM_MINUS1_1(), 0, 1), cc.clampf(this._endColor.a + this._endColorVar.a * cc.RANDOM_MINUS1_1(), 0, 1));
  particle.color = start;
  particle.deltaColor.r = (end.r - start.r) / particle.timeToLive;
  particle.deltaColor.g = (end.g - start.g) / particle.timeToLive;
  particle.deltaColor.b = (end.b - start.b) / particle.timeToLive;
  particle.deltaColor.a = (end.a - start.a) / particle.timeToLive;
  var startS = this._startSize + this._startSizeVar * cc.RANDOM_MINUS1_1();
  startS = Math.max(0, startS);
  particle.size = startS;
  if(this._endSize == cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE) {
    particle.deltaSize = 0
  }else {
    var endS = this._endSize + this._endSizeVar * cc.RANDOM_MINUS1_1();
    endS = Math.max(0, endS);
    particle.deltaSize = (endS - startS) / particle.timeToLive
  }
  var startA = this._startSpin + this._startSpinVar * cc.RANDOM_MINUS1_1();
  var endA = this._endSpin + this._endSpinVar * cc.RANDOM_MINUS1_1();
  particle.rotation = startA;
  particle.deltaRotation = (endA - startA) / particle.timeToLive;
  if(this._positionType == cc.PARTICLE_TYPE_FREE) {
    particle.startPos = this.convertToWorldSpace(this._pointZeroForParticle)
  }else {
    if(this._positionType == cc.PARTICLE_TYPE_RELATIVE) {
      particle.startPos = this._position
    }
  }
  var a = cc.DEGREES_TO_RADIANS(this._angle + this._angleVar * cc.RANDOM_MINUS1_1());
  if(this._emitterMode == cc.PARTICLE_MODE_GRAVITY) {
    var v = cc.p(Math.cos(a), Math.sin(a));
    var s = this.modeA.speed + this.modeA.speedVar * cc.RANDOM_MINUS1_1();
    particle.modeA.dir = cc.pMult(v, s);
    particle.modeA.radialAccel = this.modeA.radialAccel + this.modeA.radialAccelVar * cc.RANDOM_MINUS1_1();
    particle.modeA.tangentialAccel = this.modeA.tangentialAccel + this.modeA.tangentialAccelVar * cc.RANDOM_MINUS1_1()
  }else {
    var startRadius = this.modeB.startRadius + this.modeB.startRadiusVar * cc.RANDOM_MINUS1_1();
    var endRadius = this.modeB.endRadius + this.modeB.endRadiusVar * cc.RANDOM_MINUS1_1();
    particle.modeB.radius = startRadius;
    if(this.modeB.endRadius == cc.PARTICLE_START_RADIUS_EQUAL_TO_END_RADIUS) {
      particle.modeB.deltaRadius = 0
    }else {
      particle.modeB.deltaRadius = (endRadius - startRadius) / particle.timeToLive
    }
    particle.modeB.angle = a;
    particle.modeB.degreesPerSecond = cc.DEGREES_TO_RADIANS(this.modeB.rotatePerSecond + this.modeB.rotatePerSecondVar * cc.RANDOM_MINUS1_1())
  }
}, stopSystem:function() {
  this._isActive = false;
  this._elapsed = this._duration;
  this._emitCounter = 0;
  this._particlePool = []
}, resetSystem:function() {
  this._isActive = true;
  this._elapsed = 0;
  for(this._particleIdx = 0;this._particleIdx < this._particleCount;++this._particleIdx) {
    var p = this._particles[this._particleIdx];
    p.timeToLive = 0
  }
}, isFull:function() {
  return this._particleCount >= this._totalParticles
}, updateQuadWithParticle:function(particle, newPosition) {
}, postStep:function() {
}, update:function(dt) {
  if(this._isActive && this._emissionRate) {
    var rate = 1 / this._emissionRate;
    if(this._particleCount < this._totalParticles) {
      this._emitCounter += dt
    }
    while(this._particleCount < this._totalParticles && this._emitCounter > rate) {
      this.addParticle();
      this._emitCounter -= rate
    }
    this._elapsed += dt;
    if(this._duration != -1 && this._duration < this._elapsed) {
      this.stopSystem()
    }
  }
  this._particleIdx = 0;
  var currentPosition;
  if(this._positionType == cc.PARTICLE_TYPE_FREE) {
    currentPosition = this.convertToWorldSpace(this._pointZeroForParticle)
  }else {
    if(this._positionType == cc.PARTICLE_TYPE_RELATIVE) {
      currentPosition = cc.p(this._position.x, this._position.y)
    }
  }
  if(this._visible) {
    while(this._particleIdx < this._particleCount) {
      var selParticle = this._particles[this._particleIdx];
      selParticle.timeToLive -= dt;
      if(selParticle.timeToLive > 0) {
        if(this._emitterMode == cc.PARTICLE_MODE_GRAVITY) {
          var tmp, radial, tangential;
          if(selParticle.pos.x || selParticle.pos.y) {
            radial = cc.pNormalize(selParticle.pos)
          }else {
            radial = cc.PointZero()
          }
          tangential = radial;
          radial = cc.pMult(radial, selParticle.modeA.radialAccel);
          var newy = tangential.x;
          tangential.x = -tangential.y;
          tangential.y = newy;
          tangential = cc.pMult(tangential, selParticle.modeA.tangentialAccel);
          tmp = cc.pAdd(cc.pAdd(radial, tangential), this.modeA.gravity);
          tmp = cc.pMult(tmp, dt);
          selParticle.modeA.dir = cc.pAdd(selParticle.modeA.dir, tmp);
          tmp = cc.pMult(selParticle.modeA.dir, dt);
          selParticle.pos = cc.pAdd(selParticle.pos, tmp)
        }else {
          selParticle.modeB.angle += selParticle.modeB.degreesPerSecond * dt;
          selParticle.modeB.radius += selParticle.modeB.deltaRadius * dt;
          selParticle.pos.x = -Math.cos(selParticle.modeB.angle) * selParticle.modeB.radius;
          selParticle.pos.y = -Math.sin(selParticle.modeB.angle) * selParticle.modeB.radius
        }
        if(!this._dontTint) {
          selParticle.color.r += selParticle.deltaColor.r * dt;
          selParticle.color.g += selParticle.deltaColor.g * dt;
          selParticle.color.b += selParticle.deltaColor.b * dt;
          selParticle.color.a += selParticle.deltaColor.a * dt;
          selParticle.isChangeColor = true
        }
        selParticle.size += selParticle.deltaSize * dt;
        selParticle.size = Math.max(0, selParticle.size);
        selParticle.rotation += selParticle.deltaRotation * dt;
        var newPos;
        if(this._positionType == cc.PARTICLE_TYPE_FREE || this._positionType == cc.PARTICLE_TYPE_RELATIVE) {
          var diff = cc.pSub(currentPosition, selParticle.startPos);
          newPos = cc.pSub(selParticle.pos, diff)
        }else {
          newPos = selParticle.pos
        }
        if(this._batchNode) {
          newPos.x += this._position.x;
          newPos.y += this._position.y
        }
        if(cc.renderContextType == cc.WEBGL) {
          this.updateQuadWithParticle(selParticle, newPos)
        }else {
          selParticle.drawPos = newPos
        }
        ++this._particleIdx
      }else {
        var currentIndex = selParticle.atlasIndex;
        cc.ArrayRemoveObject(this._particles, selParticle);
        this._particlePool.push(selParticle);
        if(this._batchNode) {
          this._batchNode.disableParticle(this._atlasIndex + currentIndex);
          this._particles[this._particleCount - 1].atlasIndex = currentIndex
        }
        --this._particleCount;
        if(this._particleCount == 0 && this._isAutoRemoveOnFinish) {
          this.unscheduleUpdate();
          this._parent.removeChild(this, true);
          return
        }
      }
    }
    this._transformSystemDirty = false
  }
  if(!this._batchNode) {
    this.postStep()
  }
}, updateWithNoTime:function() {
  this.update(0)
}, _valueForKey:function(key, dict) {
  if(dict) {
    var pString = dict[key];
    return pString != null ? pString : ""
  }
  return""
}, _updateBlendFunc:function() {
  cc.Assert(!this._batchNode, "Can't change blending functions when the particle is being batched");
  if(this._texture) {
    if(this._texture instanceof HTMLImageElement || this._texture instanceof HTMLCanvasElement) {
    }else {
      var premultiplied = this._texture.hasPremultipliedAlpha();
      this._opacityModifyRGB = false;
      if(this._texture && this._blendFunc.src == cc.BLEND_SRC && this._blendFunc.dst == cc.BLEND_DST) {
        if(premultiplied) {
          this._opacityModifyRGB = true
        }else {
          this._blendFunc.src = gl.SRC_ALPHA;
          this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA
        }
      }
    }
  }
}});
cc.ParticleSystem.create = function(plistFile) {
  return cc.ParticleSystemQuad.create(plistFile)
};
cc.ParticleSystem.createWithTotalParticles = function(number_of_particles) {
  return cc.ParticleSystemQuad.create(number_of_particles)
};
cc.ParticleSystem.ModeA = function(gravity, speed, speedVar, tangentialAccel, tangentialAccelVar, radialAccel, radialAccelVar) {
  this.gravity = gravity ? gravity : cc.PointZero();
  this.speed = speed || 0;
  this.speedVar = speedVar || 0;
  this.tangentialAccel = tangentialAccel || 0;
  this.tangentialAccelVar = tangentialAccelVar || 0;
  this.radialAccel = radialAccel || 0;
  this.radialAccelVar = radialAccelVar || 0
};
cc.ParticleSystem.ModeB = function(startRadius, startRadiusVar, endRadius, endRadiusVar, rotatePerSecond, rotatePerSecondVar) {
  this.startRadius = startRadius || 0;
  this.startRadiusVar = startRadiusVar || 0;
  this.endRadius = endRadius || 0;
  this.endRadiusVar = endRadiusVar || 0;
  this.rotatePerSecond = rotatePerSecond || 0;
  this.rotatePerSecondVar = rotatePerSecondVar || 0
};
cc.encodeToBase64 = function(bytes) {
  var padding = "=", chrTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", binTable = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 0, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 
  29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1];
  var result = "", length = bytes.length, i;
  for(i = 0;i < length - 2;i += 3) {
    result += chrTable[bytes[i] >> 2];
    result += chrTable[((bytes[i] & 3) << 4) + (bytes[i + 1] >> 4)];
    result += chrTable[((bytes[i + 1] & 15) << 2) + (bytes[i + 2] >> 6)];
    result += chrTable[bytes[i + 2] & 63]
  }
  if(length % 3) {
    i = length - length % 3;
    result += chrTable[bytes[i] >> 2];
    if(length % 3 === 2) {
      result += chrTable[((bytes[i] & 3) << 4) + (bytes[i + 1] >> 4)];
      result += chrTable[(bytes[i + 1] & 15) << 2];
      result += padding
    }else {
      result += chrTable[(bytes[i] & 3) << 4];
      result += padding + padding
    }
  }
  return result
};
cc.ParticleSystemQuad = cc.ParticleSystem.extend({_quads:null, _indices:null, _VAOname:0, _buffersVBO:null, _pointRect:null, ctor:function() {
  this._super();
  this._buffersVBO = [0, 0];
  this._quads = [];
  this._indices = [];
  this._pointRect = cc.RectZero();
  if(cc.renderContextType === cc.WEBGL) {
    this._positionsArray = null;
    this._positionsArrayBuffer = null;
    this._colorsArray = null;
    this._colorsArrayBuffer = null;
    this._texCoordsArray = null;
    this._texCoordsArrayBuffer = null
  }
}, setupIndices:function() {
  for(var i = 0;i < this._totalParticles;++i) {
    var i6 = i * 6;
    var i4 = i * 4;
    this._indices[i6 + 0] = i4 + 0;
    this._indices[i6 + 1] = i4 + 1;
    this._indices[i6 + 2] = i4 + 2;
    this._indices[i6 + 5] = i4 + 1;
    this._indices[i6 + 4] = i4 + 2;
    this._indices[i6 + 3] = i4 + 3
  }
}, initTexCoordsWithRect:function(pointRect) {
  var rect = cc.rect(pointRect.origin.x * cc.CONTENT_SCALE_FACTOR(), pointRect.origin.y * cc.CONTENT_SCALE_FACTOR(), pointRect.size.width * cc.CONTENT_SCALE_FACTOR(), pointRect.size.height * cc.CONTENT_SCALE_FACTOR());
  var wide = pointRect.size.width;
  var high = pointRect.size.height;
  if(this._texture) {
    if(this._texture instanceof HTMLImageElement || this._texture instanceof HTMLCanvasElement) {
      wide = this._texture.width;
      high = this._texture.height
    }else {
      wide = this._texture.getPixelsWide();
      high = this._texture.getPixelsHigh()
    }
  }
  var left, bottom, right, top;
  if(cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
    left = (rect.origin.x * 2 + 1) / (wide * 2);
    bottom = (rect.origin.y * 2 + 1) / (high * 2);
    right = left + (rect.size.width * 2 - 2) / (wide * 2);
    top = bottom + (rect.size.height * 2 - 2) / (high * 2)
  }else {
    left = rect.origin.x / wide;
    bottom = rect.origin.y / high;
    right = left + rect.size.width / wide;
    top = bottom + rect.size.height / high
  }
  var temp = top;
  top = bottom;
  bottom = temp;
  var quads;
  var start = 0, end = 0;
  if(this._batchNode) {
    quads = this._batchNode.getTextureAtlas().getQuads();
    start = this._atlasIndex;
    end = this._atlasIndex + this._totalParticles
  }else {
    quads = this._quads;
    start = 0;
    end = this._totalParticles
  }
  for(var i = start;i < end;i++) {
    if(!quads[i]) {
      quads[i] = cc.V3F_C4B_T2F_QuadZero()
    }
    quads[i].bl.texCoords.u = left;
    quads[i].bl.texCoords.v = bottom;
    quads[i].br.texCoords.u = right;
    quads[i].br.texCoords.v = bottom;
    quads[i].tl.texCoords.u = left;
    quads[i].tl.texCoords.v = top;
    quads[i].tr.texCoords.u = right;
    quads[i].tr.texCoords.v = top
  }
}, clone:function() {
  var retParticle = new cc.ParticleSystemQuad;
  if(retParticle.initWithTotalParticles(this._totalParticles)) {
    retParticle._angle = this._angle;
    retParticle._angleVar = this._angleVar;
    retParticle._duration = this._duration;
    retParticle._blendFunc.src = this._blendFunc.src;
    retParticle._blendFunc.dst = this._blendFunc.dst;
    retParticle._startColor.r = this._startColor.r;
    retParticle._startColor.g = this._startColor.g;
    retParticle._startColor.b = this._startColor.b;
    retParticle._startColor.a = this._startColor.a;
    retParticle._startColorVar.r = this._startColorVar.r;
    retParticle._startColorVar.g = this._startColorVar.g;
    retParticle._startColorVar.b = this._startColorVar.b;
    retParticle._startColorVar.a = this._startColorVar.a;
    retParticle._endColor.r = this._endColor.r;
    retParticle._endColor.g = this._endColor.g;
    retParticle._endColor.b = this._endColor.b;
    retParticle._endColor.a = this._endColor.a;
    retParticle._endColorVar.r = this._endColorVar.r;
    retParticle._endColorVar.g = this._endColorVar.g;
    retParticle._endColorVar.b = this._endColorVar.b;
    retParticle._endColorVar.a = this._endColorVar.a;
    retParticle._startSize = this._startSize;
    retParticle._startSizeVar = this._startSizeVar;
    retParticle._endSize = this._endSize;
    retParticle._endSizeVar = this._endSizeVar;
    retParticle.setPosition(new cc.Point(this._position.x, this._position.y));
    retParticle._posVar.x = this._posVar.x;
    retParticle._posVar.y = this._posVar.y;
    retParticle._startSpin = this._startSpin;
    retParticle._startSpinVar = this._startSpinVar;
    retParticle._endSpin = this._endSpin;
    retParticle._endSpinVar = this._endSpinVar;
    retParticle._emitterMode = this._emitterMode;
    if(this._emitterMode == cc.PARTICLE_MODE_GRAVITY) {
      retParticle.modeA.gravity.x = this.modeA.gravity.x;
      retParticle.modeA.gravity.y = this.modeA.gravity.y;
      retParticle.modeA.speed = this.modeA.speed;
      retParticle.modeA.speedVar = this.modeA.speedVar;
      retParticle.modeA.radialAccel = this.modeA.radialAccel;
      retParticle.modeA.radialAccelVar = this.modeA.radialAccelVar;
      retParticle.modeA.tangentialAccel = this.modeA.tangentialAccel;
      retParticle.modeA.tangentialAccelVar = this.modeA.tangentialAccelVar
    }else {
      if(this._emitterMode == cc.PARTICLE_MODE_RADIUS) {
        retParticle.modeB.startRadius = this.modeB.startRadius;
        retParticle.modeB.startRadiusVar = this.modeB.startRadiusVar;
        retParticle.modeB.endRadius = this.modeB.endRadius;
        retParticle.modeB.endRadiusVar = this.modeB.endRadiusVar;
        retParticle.modeB.rotatePerSecond = this.modeB.rotatePerSecond;
        retParticle.modeB.rotatePerSecondVar = this.modeB.rotatePerSecondVar
      }
    }
    retParticle._life = this._life;
    retParticle._lifeVar = this._lifeVar;
    retParticle._emissionRate = this._emissionRate;
    if(!this._batchNode) {
      retParticle._opacityModifyRGB = this._opacityModifyRGB;
      if(this._texture instanceof cc.Texture2D) {
        retParticle._texture = this._texture
      }else {
        retParticle._texture = this._texture
      }
    }
  }
  return retParticle
}, setDisplayFrame:function(spriteFrame) {
  cc.Assert(cc.Point.CCPointEqualToPoint(spriteFrame.getOffsetInPixels(), cc.PointZero()), "QuadParticle only supports SpriteFrames with no offsets");
  if(cc.renderContextType === cc.WEBGL) {
    if(!this._texture || spriteFrame.getTexture()._webTextureObj != this._texture._webTextureObj) {
      this.setTexture(spriteFrame.getTexture())
    }
  }
}, setTextureWithRect:function(texture, rect) {
  if(cc.renderContextType === cc.WEBGL) {
    if(!this._texture || texture._webTextureObj != this._texture._webTextureObj) {
      cc.ParticleSystem.prototype.setTexture.call(this, texture)
    }
    this._pointRect = rect;
    this.initTexCoordsWithRect(rect)
  }else {
    if(!this._texture || texture != this._texture) {
      cc.ParticleSystem.prototype.setTexture.call(this, texture)
    }
    this._pointRect = rect;
    this.initTexCoordsWithRect(rect)
  }
}, initWithTotalParticles:function(numberOfParticles) {
  if(this._super(numberOfParticles)) {
    if(cc.renderContextType === cc.CANVAS) {
      return true
    }
    if(!this._allocMemory()) {
      return false
    }
    this.setupIndices();
    if(cc.TEXTURE_ATLAS_USE_VAO) {
      this._setupVBOandVAO()
    }else {
      this._setupVBO()
    }
    this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
    return true
  }
  return false
}, setTexture:function(texture, isCallSuper) {
  if(isCallSuper != null && isCallSuper === true) {
    this._super(texture);
    return
  }
  var size = null;
  if(texture instanceof HTMLImageElement || texture instanceof HTMLCanvasElement) {
    size = cc.size(texture.width, texture.height)
  }else {
    size = texture.getContentSize()
  }
  this.setTextureWithRect(texture, cc.rect(0, 0, size.width, size.height))
}, updateQuadWithParticle:function(particle, newPosition) {
  var quad = null;
  if(this._batchNode) {
    var batchQuads = this._batchNode.getTextureAtlas().getQuads();
    quad = batchQuads[this._atlasIndex + particle.atlasIndex];
    this._batchNode.getTextureAtlas()._dirty = true
  }else {
    quad = this._quads[this._particleIdx]
  }
  var color = this._opacityModifyRGB ? new cc.Color4B(0 | particle.color.r * particle.color.a * 255, 0 | particle.color.g * particle.color.a * 255, 0 | particle.color.b * particle.color.a * 255, 0 | particle.color.a * 255) : new cc.Color4B(0 | particle.color.r * 255, 0 | particle.color.g * 255, 0 | particle.color.b * 255, 0 | particle.color.a * 255);
  quad.bl.colors = color;
  quad.br.colors = color;
  quad.tl.colors = color;
  quad.tr.colors = color;
  var size_2 = particle.size / 2;
  if(particle.rotation) {
    var x1 = -size_2;
    var y1 = -size_2;
    var x2 = size_2;
    var y2 = size_2;
    var x = newPosition.x;
    var y = newPosition.y;
    var r = -cc.DEGREES_TO_RADIANS(particle.rotation);
    var cr = Math.cos(r);
    var sr = Math.sin(r);
    var ax = x1 * cr - y1 * sr + x;
    var ay = x1 * sr + y1 * cr + y;
    var bx = x2 * cr - y1 * sr + x;
    var by = x2 * sr + y1 * cr + y;
    var cx = x2 * cr - y2 * sr + x;
    var cy = x2 * sr + y2 * cr + y;
    var dx = x1 * cr - y2 * sr + x;
    var dy = x1 * sr + y2 * cr + y;
    quad.bl.vertices.x = ax;
    quad.bl.vertices.y = ay;
    quad.br.vertices.x = bx;
    quad.br.vertices.y = by;
    quad.tl.vertices.x = dx;
    quad.tl.vertices.y = dy;
    quad.tr.vertices.x = cx;
    quad.tr.vertices.y = cy
  }else {
    quad.bl.vertices.x = newPosition.x - size_2;
    quad.bl.vertices.y = newPosition.y - size_2;
    quad.br.vertices.x = newPosition.x + size_2;
    quad.br.vertices.y = newPosition.y - size_2;
    quad.tl.vertices.x = newPosition.x - size_2;
    quad.tl.vertices.y = newPosition.y + size_2;
    quad.tr.vertices.x = newPosition.x + size_2;
    quad.tr.vertices.y = newPosition.y + size_2
  }
  if(!this._batchNode) {
    this._setQuadToPositionsTypeArray(quad, this._particleIdx);
    this._setQuadToColorsTypeArray(quad, this._particleIdx);
    this._setQuadToTexCoordsTypeArray(quad, this._particleIdx)
  }
}, postStep:function() {
  if(cc.renderContextType === cc.WEBGL) {
    var gl = cc.renderContext;
    gl.bindBuffer(gl.ARRAY_BUFFER, this._positionsArrayBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this._positionsArray, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._colorsArrayBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this._colorsArray, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordsArrayBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this._texCoordsArray, gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null)
  }
}, _setQuadToPositionsTypeArray:function(quad, index) {
  this._positionsArray[index * 12] = quad.bl.vertices.x;
  this._positionsArray[index * 12 + 1] = quad.bl.vertices.y;
  this._positionsArray[index * 12 + 2] = quad.bl.vertices.z;
  this._positionsArray[index * 12 + 3] = quad.br.vertices.x;
  this._positionsArray[index * 12 + 4] = quad.br.vertices.y;
  this._positionsArray[index * 12 + 5] = quad.br.vertices.z;
  this._positionsArray[index * 12 + 6] = quad.tl.vertices.x;
  this._positionsArray[index * 12 + 7] = quad.tl.vertices.y;
  this._positionsArray[index * 12 + 8] = quad.tl.vertices.z;
  this._positionsArray[index * 12 + 9] = quad.tr.vertices.x;
  this._positionsArray[index * 12 + 10] = quad.tr.vertices.y;
  this._positionsArray[index * 12 + 11] = quad.tr.vertices.z
}, _setQuadToColorsTypeArray:function(quad, index) {
  this._colorsArray[index * 16] = quad.bl.colors.r;
  this._colorsArray[index * 16 + 1] = quad.bl.colors.g;
  this._colorsArray[index * 16 + 2] = quad.bl.colors.b;
  this._colorsArray[index * 16 + 3] = quad.bl.colors.a;
  this._colorsArray[index * 16 + 4] = quad.br.colors.r;
  this._colorsArray[index * 16 + 5] = quad.br.colors.g;
  this._colorsArray[index * 16 + 6] = quad.br.colors.b;
  this._colorsArray[index * 16 + 7] = quad.br.colors.a;
  this._colorsArray[index * 16 + 8] = quad.tl.colors.r;
  this._colorsArray[index * 16 + 9] = quad.tl.colors.g;
  this._colorsArray[index * 16 + 10] = quad.tl.colors.b;
  this._colorsArray[index * 16 + 11] = quad.tl.colors.a;
  this._colorsArray[index * 16 + 12] = quad.tr.colors.r;
  this._colorsArray[index * 16 + 13] = quad.tr.colors.g;
  this._colorsArray[index * 16 + 14] = quad.tr.colors.b;
  this._colorsArray[index * 16 + 15] = quad.tr.colors.a
}, _setQuadToTexCoordsTypeArray:function(quad, index) {
  this._texCoordsArray[index * 8] = quad.bl.texCoords.u;
  this._texCoordsArray[index * 8 + 1] = quad.bl.texCoords.v;
  this._texCoordsArray[index * 8 + 2] = quad.br.texCoords.u;
  this._texCoordsArray[index * 8 + 3] = quad.br.texCoords.v;
  this._texCoordsArray[index * 8 + 4] = quad.tl.texCoords.u;
  this._texCoordsArray[index * 8 + 5] = quad.tl.texCoords.v;
  this._texCoordsArray[index * 8 + 6] = quad.tr.texCoords.u;
  this._texCoordsArray[index * 8 + 7] = quad.tr.texCoords.v
}, draw:function(ctx) {
  cc.Assert(!this._batchNode, "draw should not be called when added to a particleBatchNode");
  if(cc.renderContextType === cc.CANVAS) {
    this._drawForCanvas(ctx)
  }else {
    this._drawForWebGL(ctx)
  }
  cc.INCREMENT_GL_DRAWS(1)
}, _drawForCanvas:function(ctx) {
  var context = ctx || cc.renderContext;
  context.save();
  if(this.isBlendAdditive()) {
    context.globalCompositeOperation = "lighter"
  }else {
    context.globalCompositeOperation = "source-over"
  }
  for(var i = 0;i < this._particleCount;i++) {
    var particle = this._particles[i];
    var lpx = 0 | particle.size * 0.5;
    if(this._drawMode == cc.PARTICLE_TEXTURE_MODE) {
      var drawTexture = this.getTexture();
      if(!drawTexture.width || !drawTexture.height) {
        continue
      }
      context.save();
      context.globalAlpha = particle.color.a;
      context.translate(0 | particle.drawPos.x, -(0 | particle.drawPos.y));
      var size = Math.floor(particle.size / 4) * 4;
      var w = this._pointRect.size.width;
      var h = this._pointRect.size.height;
      context.scale(Math.max(1 / w * size, 1E-6), Math.max(1 / h * size, 1E-6));
      if(particle.rotation) {
        context.rotate(cc.DEGREES_TO_RADIANS(particle.rotation))
      }
      context.translate(-(0 | w / 2), -(0 | h / 2));
      if(particle.isChangeColor) {
        var cacheTextureForColor = cc.TextureCache.getInstance().getTextureColors(drawTexture);
        if(cacheTextureForColor) {
          if(!cacheTextureForColor.tintCache) {
            cacheTextureForColor.tintCache = document.createElement("canvas");
            cacheTextureForColor.tintCache.width = drawTexture.width;
            cacheTextureForColor.tintCache.height = drawTexture.height
          }
          cc.generateTintImage(drawTexture, cacheTextureForColor, particle.color, this._pointRect, cacheTextureForColor.tintCache);
          drawTexture = cacheTextureForColor.tintCache
        }
      }
      context.drawImage(drawTexture, 0, 0);
      context.restore()
    }else {
      context.save();
      context.globalAlpha = particle.color.a;
      context.translate(0 | particle.drawPos.x, -(0 | particle.drawPos.y));
      if(this._shapeType == cc.PARTICLE_STAR_SHAPE) {
        if(particle.rotation) {
          context.rotate(cc.DEGREES_TO_RADIANS(particle.rotation))
        }
        cc.drawingUtil.drawStar(context, lpx, particle.color)
      }else {
        cc.drawingUtil.drawColorBall(context, lpx, particle.color)
      }
      context.restore()
    }
  }
  context.restore()
}, _drawForWebGL:function(ctx) {
  if(!this._texture || !this._texture.isLoaded()) {
    return
  }
  var gl = ctx || cc.renderContext;
  cc.NODE_DRAW_SETUP(this);
  cc.glBindTexture2D(this._texture);
  cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
  cc.Assert(this._particleIdx == this._particleCount, "Abnormal error in particle quad");
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSCOLORTEX);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._positionsArrayBuffer);
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._colorsArrayBuffer);
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordsArrayBuffer);
  gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
  gl.drawElements(gl.TRIANGLES, this._particleIdx * 6, gl.UNSIGNED_SHORT, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  cc.INCREMENT_GL_DRAWS(1)
}, setBatchNode:function(batchNode) {
  if(this._batchNode != batchNode) {
    var oldBatch = this._batchNode;
    this._super(batchNode);
    if(!batchNode) {
      this._allocMemory();
      this.setupIndices();
      this.setTexture(oldBatch.getTexture());
      if(cc.TEXTURE_ATLAS_USE_VAO) {
        this._setupVBOandVAO()
      }else {
        this._setupVBO()
      }
    }else {
      if(!oldBatch) {
        this._batchNode.getTextureAtlas().insertQuads(this._quads, this._atlasIndex, this._quads.length);
        cc.renderContext.deleteBuffer(this._buffersVBO[1])
      }
    }
  }
}, setTotalParticles:function(tp) {
  if(tp < 200) {
    this._totalParticles = tp
  }else {
    this._totalParticles = 200
  }
  if(cc.renderContextType === cc.CANVAS) {
    return
  }
  if(tp > this._allocatedParticles) {
    var particlesNew = [];
    var quadsNew = [];
    var indicesNew = new Uint16Array(tp * 6);
    if(particlesNew && quadsNew && indicesNew) {
      this._particles = particlesNew;
      this._quads = quadsNew;
      this._indices = indicesNew;
      this._positionsArray = new Float32Array(tp * 12);
      this._colorsArray = new Uint8Array(tp * 16);
      this._texCoordsArray = new Float32Array(tp * 8);
      for(var j = 0;j < tp;j++) {
        this._particles[j] = new cc.Particle;
        this._quads[j] = new cc.V3F_C4B_T2F_Quad
      }
      this._allocatedParticles = tp
    }else {
      if(particlesNew) {
        this._particles = particlesNew
      }
      if(quadsNew) {
        this._quads = quadsNew
      }
      if(indicesNew) {
        this._indices = indicesNew
      }
      cc.log("Particle system: out of memory");
      return
    }
    this._totalParticles = tp;
    if(this._batchNode) {
      for(var i = 0;i < this._totalParticles;i++) {
        this._particles[i].atlasIndex = i
      }
    }
    this.setupIndices();
    if(cc.TEXTURE_ATLAS_USE_VAO) {
      this._setupVBOandVAO()
    }else {
      this._setupVBO()
    }
  }else {
    this._totalParticles = tp
  }
}, listenBackToForeground:function(obj) {
  if(cc.TEXTURE_ATLAS_USE_VAO) {
    this._setupVBOandVAO()
  }else {
    this._setupVBO()
  }
}, _setupVBOandVAO:function() {
}, _setupVBO:function() {
  if(cc.renderContextType == cc.CANVAS) {
    return
  }
  var gl = cc.renderContext;
  this._positionsArrayBuffer = gl.createBuffer();
  this._colorsArrayBuffer = gl.createBuffer();
  this._texCoordsArrayBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, this._positionsArrayBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, this._positionsArray, gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._colorsArrayBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, this._colorsArray, gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordsArrayBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, this._texCoordsArray, gl.DYNAMIC_DRAW);
  this._buffersVBO[1] = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)
}, _allocMemory:function() {
  if(cc.renderContextType === cc.CANVAS) {
    return
  }
  cc.Assert(!this._batchNode, "Memory should not be allocated when not using batchNode");
  this._quads = [];
  this._indices = new Uint16Array(this._totalParticles * 6);
  this._positionsArray = new Float32Array(this._totalParticles * 12);
  this._colorsArray = new Uint8Array(this._totalParticles * 16);
  this._texCoordsArray = new Float32Array(this._totalParticles * 8);
  for(var i = 0;i < this._totalParticles;i++) {
    this._quads[i] = new cc.V3F_C4B_T2F_Quad
  }
  if(!this._quads || !this._indices) {
    cc.log("cocos2d: Particle system: not enough memory");
    return false
  }
  return true
}});
cc.ParticleSystemQuad.create = function(pListFile) {
  var ret = new cc.ParticleSystemQuad;
  if(!pListFile || typeof pListFile === "number") {
    var ton = pListFile || 100;
    ret.setDrawMode(cc.PARTICLE_TEXTURE_MODE);
    ret.initWithTotalParticles(ton);
    return ret
  }
  if(ret && ret.initWithFile(pListFile)) {
    return ret
  }
  return null
};
cc.ParticleSystemQuad.createWithTotalParticles = function(numberOfParticles) {
  return cc.ParticleSystemQuad.create(numberOfParticles)
};
cc.ARCH_OPTIMAL_PARTICLE_SYSTEM = cc.ParticleSystemQuad;
cc.ParticleFire = cc.ParticleSystemQuad.extend({init:function() {
  return this.initWithTotalParticles(cc.renderContextType === cc.WEBGL ? 300 : 150)
}, initWithTotalParticles:function(numberOfParticles) {
  if(this._super(numberOfParticles)) {
    this._duration = cc.PARTICLE_DURATION_INFINITY;
    this._emitterMode = cc.PARTICLE_MODE_GRAVITY;
    this.modeA.gravity = cc.p(0, 0);
    this.modeA.radialAccel = 0;
    this.modeA.radialAccelVar = 0;
    this.modeA.speed = 60;
    this.modeA.speedVar = 20;
    this._angle = 90;
    this._angleVar = 10;
    var winSize = cc.Director.getInstance().getWinSize();
    this.setPosition(cc.p(winSize.width / 2, 60));
    this._posVar = cc.p(40, 20);
    this._life = 3;
    this._lifeVar = 0.25;
    this._startSize = 54;
    this._startSizeVar = 10;
    this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;
    this._emissionRate = this._totalParticles / this._life;
    this._startColor.r = 0.76;
    this._startColor.g = 0.25;
    this._startColor.b = 0.12;
    this._startColor.a = 1;
    this._startColorVar.r = 0;
    this._startColorVar.g = 0;
    this._startColorVar.b = 0;
    this._startColorVar.a = 0;
    this._endColor.r = 0;
    this._endColor.g = 0;
    this._endColor.b = 0;
    this._endColor.a = 1;
    this._endColorVar.r = 0;
    this._endColorVar.g = 0;
    this._endColorVar.b = 0;
    this._endColorVar.a = 0;
    this.setBlendAdditive(true);
    return true
  }
  return false
}});
cc.ParticleFire.create = function() {
  var ret = new cc.ParticleFire;
  if(ret.init()) {
    return ret
  }
  return null
};
cc.ParticleFireworks = cc.ParticleSystemQuad.extend({init:function() {
  return this.initWithTotalParticles(cc.renderContextType === cc.WEBGL ? 1500 : 150)
}, initWithTotalParticles:function(numberOfParticles) {
  if(this._super(numberOfParticles)) {
    this._duration = cc.PARTICLE_DURATION_INFINITY;
    this._emitterMode = cc.PARTICLE_MODE_GRAVITY;
    this.modeA.gravity = cc.p(0, -90);
    this.modeA.radialAccel = 0;
    this.modeA.radialAccelVar = 0;
    this.modeA.speed = 180;
    this.modeA.speedVar = 50;
    var winSize = cc.Director.getInstance().getWinSize();
    this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
    this._angle = 90;
    this._angleVar = 20;
    this._life = 3.5;
    this._lifeVar = 1;
    this._emissionRate = this._totalParticles / this._life;
    this._startColor.r = 0.5;
    this._startColor.g = 0.5;
    this._startColor.b = 0.5;
    this._startColor.a = 1;
    this._startColorVar.r = 0.5;
    this._startColorVar.g = 0.5;
    this._startColorVar.b = 0.5;
    this._startColorVar.a = 0.1;
    this._endColor.r = 0.1;
    this._endColor.g = 0.1;
    this._endColor.b = 0.1;
    this._endColor.a = 0.2;
    this._endColorVar.r = 0.1;
    this._endColorVar.g = 0.1;
    this._endColorVar.b = 0.1;
    this._endColorVar.a = 0.2;
    this._startSize = 8;
    this._startSizeVar = 2;
    this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;
    this.setBlendAdditive(false);
    return true
  }
  return false
}});
cc.ParticleFireworks.create = function() {
  var ret = new cc.ParticleFireworks;
  if(ret.init()) {
    return ret
  }
  return null
};
cc.ParticleSun = cc.ParticleSystemQuad.extend({init:function() {
  return this.initWithTotalParticles(cc.renderContextType === cc.WEBGL ? 350 : 150)
}, initWithTotalParticles:function(numberOfParticles) {
  if(this._super(numberOfParticles)) {
    this.setBlendAdditive(true);
    this._duration = cc.PARTICLE_DURATION_INFINITY;
    this._emitterMode = cc.PARTICLE_MODE_GRAVITY;
    this.modeA.gravity = cc.p(0, 0);
    this.modeA.radialAccel = 0;
    this.modeA.radialAccelVar = 0;
    this.modeA.speed = 20;
    this.modeA.speedVar = 5;
    this._angle = 90;
    this._angleVar = 360;
    var winSize = cc.Director.getInstance().getWinSize();
    this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
    this._posVar = cc.PointZero();
    this._life = 1;
    this._lifeVar = 0.5;
    this._startSize = 30;
    this._startSizeVar = 10;
    this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;
    this._emissionRate = this._totalParticles / this._life;
    this._startColor.r = 0.76;
    this._startColor.g = 0.25;
    this._startColor.b = 0.12;
    this._startColor.a = 1;
    this._startColorVar.r = 0;
    this._startColorVar.g = 0;
    this._startColorVar.b = 0;
    this._startColorVar.a = 0;
    this._endColor.r = 0;
    this._endColor.g = 0;
    this._endColor.b = 0;
    this._endColor.a = 1;
    this._endColorVar.r = 0;
    this._endColorVar.g = 0;
    this._endColorVar.b = 0;
    this._endColorVar.a = 0;
    return true
  }
  return false
}});
cc.ParticleSun.create = function() {
  var ret = new cc.ParticleSun;
  if(ret.init()) {
    return ret
  }
  return null
};
cc.ParticleGalaxy = cc.ParticleSystemQuad.extend({init:function() {
  return this.initWithTotalParticles(cc.renderContextType === cc.WEBGL ? 200 : 100)
}, initWithTotalParticles:function(numberOfParticles) {
  if(this._super(numberOfParticles)) {
    this._duration = cc.PARTICLE_DURATION_INFINITY;
    this._emitterMode = cc.PARTICLE_MODE_GRAVITY;
    this.modeA.gravity = cc.p(0, 0);
    this.modeA.speed = 60;
    this.modeA.speedVar = 10;
    this.modeA.radialAccel = -80;
    this.modeA.radialAccelVar = 0;
    this.modeA.tangentialAccel = 80;
    this.modeA.tangentialAccelVar = 0;
    this._angle = 90;
    this._angleVar = 360;
    var winSize = cc.Director.getInstance().getWinSize();
    this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
    this._posVar = cc.PointZero();
    this._life = 4;
    this._lifeVar = 1;
    this._startSize = 37;
    this._startSizeVar = 10;
    this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;
    this._emissionRate = this._totalParticles / this._life;
    this._startColor.r = 0.12;
    this._startColor.g = 0.25;
    this._startColor.b = 0.76;
    this._startColor.a = 1;
    this._startColorVar.r = 0;
    this._startColorVar.g = 0;
    this._startColorVar.b = 0;
    this._startColorVar.a = 0;
    this._endColor.r = 0;
    this._endColor.g = 0;
    this._endColor.b = 0;
    this._endColor.a = 1;
    this._endColorVar.r = 0;
    this._endColorVar.g = 0;
    this._endColorVar.b = 0;
    this._endColorVar.a = 0;
    this.setBlendAdditive(true);
    return true
  }
  return false
}});
cc.ParticleGalaxy.create = function() {
  var ret = new cc.ParticleGalaxy;
  if(ret.init()) {
    return ret
  }
  return null
};
cc.ParticleFlower = cc.ParticleSystemQuad.extend({init:function() {
  return this.initWithTotalParticles(cc.renderContextType === cc.WEBGL ? 250 : 100)
}, initWithTotalParticles:function(numberOfParticles) {
  if(this._super(numberOfParticles)) {
    this._duration = cc.PARTICLE_DURATION_INFINITY;
    this._emitterMode = cc.PARTICLE_MODE_GRAVITY;
    this.modeA.gravity = cc.p(0, 0);
    this.modeA.speed = 80;
    this.modeA.speedVar = 10;
    this.modeA.radialAccel = -60;
    this.modeA.radialAccelVar = 0;
    this.modeA.tangentialAccel = 15;
    this.modeA.tangentialAccelVar = 0;
    this._angle = 90;
    this._angleVar = 360;
    var winSize = cc.Director.getInstance().getWinSize();
    this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
    this._posVar = cc.PointZero();
    this._life = 4;
    this._lifeVar = 1;
    this._startSize = 30;
    this._startSizeVar = 10;
    this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;
    this._emissionRate = this._totalParticles / this._life;
    this._startColor.r = 0.5;
    this._startColor.g = 0.5;
    this._startColor.b = 0.5;
    this._startColor.a = 1;
    this._startColorVar.r = 0.5;
    this._startColorVar.g = 0.5;
    this._startColorVar.b = 0.5;
    this._startColorVar.a = 0.5;
    this._endColor.r = 0;
    this._endColor.g = 0;
    this._endColor.b = 0;
    this._endColor.a = 1;
    this._endColorVar.r = 0;
    this._endColorVar.g = 0;
    this._endColorVar.b = 0;
    this._endColorVar.a = 0;
    this.setBlendAdditive(true);
    return true
  }
  return false
}});
cc.ParticleFlower.create = function() {
  var ret = new cc.ParticleFlower;
  if(ret.init()) {
    return ret
  }
  return null
};
cc.ParticleMeteor = cc.ParticleSystemQuad.extend({init:function() {
  return this.initWithTotalParticles(cc.renderContextType === cc.WEBGL ? 150 : 100)
}, initWithTotalParticles:function(numberOfParticles) {
  if(this._super(numberOfParticles)) {
    this._duration = cc.PARTICLE_DURATION_INFINITY;
    this._emitterMode = cc.PARTICLE_MODE_GRAVITY;
    this.modeA.gravity = cc.p(-200, 200);
    this.modeA.speed = 15;
    this.modeA.speedVar = 5;
    this.modeA.radialAccel = 0;
    this.modeA.radialAccelVar = 0;
    this.modeA.tangentialAccel = 0;
    this.modeA.tangentialAccelVar = 0;
    this._angle = 90;
    this._angleVar = 360;
    var winSize = cc.Director.getInstance().getWinSize();
    this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
    this._posVar = cc.PointZero();
    this._life = 2;
    this._lifeVar = 1;
    this._startSize = 60;
    this._startSizeVar = 10;
    this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;
    this._emissionRate = this._totalParticles / this._life;
    this._startColor.r = 0.2;
    this._startColor.g = 0.4;
    this._startColor.b = 0.7;
    this._startColor.a = 1;
    this._startColorVar.r = 0;
    this._startColorVar.g = 0;
    this._startColorVar.b = 0.2;
    this._startColorVar.a = 0.1;
    this._endColor.r = 0;
    this._endColor.g = 0;
    this._endColor.b = 0;
    this._endColor.a = 1;
    this._endColorVar.r = 0;
    this._endColorVar.g = 0;
    this._endColorVar.b = 0;
    this._endColorVar.a = 0;
    this.setBlendAdditive(true);
    return true
  }
  return false
}});
cc.ParticleMeteor.create = function() {
  var ret = new cc.ParticleMeteor;
  if(ret.init()) {
    return ret
  }
  return null
};
cc.ParticleSpiral = cc.ParticleSystemQuad.extend({init:function() {
  return this.initWithTotalParticles(cc.renderContextType === cc.WEBGL ? 500 : 100)
}, initWithTotalParticles:function(numberOfParticles) {
  if(this._super(numberOfParticles)) {
    this._duration = cc.PARTICLE_DURATION_INFINITY;
    this._emitterMode = cc.PARTICLE_MODE_GRAVITY;
    this.modeA.gravity = cc.p(0, 0);
    this.modeA.speed = 150;
    this.modeA.speedVar = 0;
    this.modeA.radialAccel = -380;
    this.modeA.radialAccelVar = 0;
    this.modeA.tangentialAccel = 45;
    this.modeA.tangentialAccelVar = 0;
    this._angle = 90;
    this._angleVar = 0;
    var winSize = cc.Director.getInstance().getWinSize();
    this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
    this._posVar = cc.PointZero();
    this._life = 12;
    this._lifeVar = 0;
    this._startSize = 20;
    this._startSizeVar = 0;
    this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;
    this._emissionRate = this._totalParticles / this._life;
    this._startColor.r = 0.5;
    this._startColor.g = 0.5;
    this._startColor.b = 0.5;
    this._startColor.a = 1;
    this._startColorVar.r = 0.5;
    this._startColorVar.g = 0.5;
    this._startColorVar.b = 0.5;
    this._startColorVar.a = 0;
    this._endColor.r = 0.5;
    this._endColor.g = 0.5;
    this._endColor.b = 0.5;
    this._endColor.a = 1;
    this._endColorVar.r = 0.5;
    this._endColorVar.g = 0.5;
    this._endColorVar.b = 0.5;
    this._endColorVar.a = 0;
    this.setBlendAdditive(false);
    return true
  }
  return false
}});
cc.ParticleSpiral.create = function() {
  var ret = new cc.ParticleSpiral;
  if(ret.init()) {
    return ret
  }
  return null
};
cc.ParticleExplosion = cc.ParticleSystemQuad.extend({init:function() {
  return this.initWithTotalParticles(cc.renderContextType === cc.WEBGL ? 700 : 300)
}, initWithTotalParticles:function(numberOfParticles) {
  if(this._super(numberOfParticles)) {
    this._duration = 0.1;
    this._emitterMode = cc.PARTICLE_MODE_GRAVITY;
    this.modeA.gravity = cc.p(0, 0);
    this.modeA.speed = 70;
    this.modeA.speedVar = 40;
    this.modeA.radialAccel = 0;
    this.modeA.radialAccelVar = 0;
    this.modeA.tangentialAccel = 0;
    this.modeA.tangentialAccelVar = 0;
    this._angle = 90;
    this._angleVar = 360;
    var winSize = cc.Director.getInstance().getWinSize();
    this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
    this._posVar = cc.PointZero();
    this._life = 5;
    this._lifeVar = 2;
    this._startSize = 15;
    this._startSizeVar = 10;
    this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;
    this._emissionRate = this._totalParticles / this._duration;
    this._startColor.r = 0.7;
    this._startColor.g = 0.1;
    this._startColor.b = 0.2;
    this._startColor.a = 1;
    this._startColorVar.r = 0.5;
    this._startColorVar.g = 0.5;
    this._startColorVar.b = 0.5;
    this._startColorVar.a = 0;
    this._endColor.r = 0.5;
    this._endColor.g = 0.5;
    this._endColor.b = 0.5;
    this._endColor.a = 0;
    this._endColorVar.r = 0.5;
    this._endColorVar.g = 0.5;
    this._endColorVar.b = 0.5;
    this._endColorVar.a = 0;
    this.setBlendAdditive(false);
    return true
  }
  return false
}});
cc.ParticleExplosion.create = function() {
  var ret = new cc.ParticleExplosion;
  if(ret.init()) {
    return ret
  }
  return null
};
cc.ParticleSmoke = cc.ParticleSystemQuad.extend({init:function() {
  return this.initWithTotalParticles(cc.renderContextType === cc.WEBGL ? 200 : 100)
}, initWithTotalParticles:function(numberOfParticles) {
  if(this._super(numberOfParticles)) {
    this._duration = cc.PARTICLE_DURATION_INFINITY;
    this._emitterMode = cc.PARTICLE_MODE_GRAVITY;
    this.modeA.gravity = cc.p(0, 0);
    this.modeA.radialAccel = 0;
    this.modeA.radialAccelVar = 0;
    this.modeA.speed = 25;
    this.modeA.speedVar = 10;
    this._angle = 90;
    this._angleVar = 5;
    var winSize = cc.Director.getInstance().getWinSize();
    this.setPosition(cc.p(winSize.width / 2, 0));
    this._posVar = cc.p(20, 0);
    this._life = 4;
    this._lifeVar = 1;
    this._startSize = 60;
    this._startSizeVar = 10;
    this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;
    this._emissionRate = this._totalParticles / this._life;
    this._startColor.r = 0.8;
    this._startColor.g = 0.8;
    this._startColor.b = 0.8;
    this._startColor.a = 1;
    this._startColorVar.r = 0.02;
    this._startColorVar.g = 0.02;
    this._startColorVar.b = 0.02;
    this._startColorVar.a = 0;
    this._endColor.r = 0;
    this._endColor.g = 0;
    this._endColor.b = 0;
    this._endColor.a = 1;
    this._endColorVar.r = 0;
    this._endColorVar.g = 0;
    this._endColorVar.b = 0;
    this._endColorVar.a = 0;
    this.setBlendAdditive(false);
    return true
  }
  return false
}});
cc.ParticleSmoke.create = function() {
  var ret = new cc.ParticleSmoke;
  if(ret.init()) {
    return ret
  }
  return null
};
cc.ParticleSnow = cc.ParticleSystemQuad.extend({init:function() {
  return this.initWithTotalParticles(cc.renderContextType === cc.WEBGL ? 700 : 250)
}, initWithTotalParticles:function(numberOfParticles) {
  if(this._super(numberOfParticles)) {
    this._duration = cc.PARTICLE_DURATION_INFINITY;
    this._emitterMode = cc.PARTICLE_MODE_GRAVITY;
    this.modeA.gravity = cc.p(0, -1);
    this.modeA.speed = 5;
    this.modeA.speedVar = 1;
    this.modeA.radialAccel = 0;
    this.modeA.radialAccelVar = 1;
    this.modeA.tangentialAccel = 0;
    this.modeA.tangentialAccelVar = 1;
    var winSize = cc.Director.getInstance().getWinSize();
    this.setPosition(cc.p(winSize.width / 2, winSize.height + 10));
    this._posVar = cc.p(winSize.width / 2, 0);
    this._angle = -90;
    this._angleVar = 5;
    this._life = 45;
    this._lifeVar = 15;
    this._startSize = 10;
    this._startSizeVar = 5;
    this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;
    this._emissionRate = 10;
    this._startColor.r = 1;
    this._startColor.g = 1;
    this._startColor.b = 1;
    this._startColor.a = 1;
    this._startColorVar.r = 0;
    this._startColorVar.g = 0;
    this._startColorVar.b = 0;
    this._startColorVar.a = 0;
    this._endColor.r = 1;
    this._endColor.g = 1;
    this._endColor.b = 1;
    this._endColor.a = 0;
    this._endColorVar.r = 0;
    this._endColorVar.g = 0;
    this._endColorVar.b = 0;
    this._endColorVar.a = 0;
    this.setBlendAdditive(false);
    return true
  }
  return false
}});
cc.ParticleSnow.create = function() {
  var ret = new cc.ParticleSnow;
  if(ret.init()) {
    return ret
  }
  return null
};
cc.ParticleRain = cc.ParticleSystemQuad.extend({init:function() {
  return this.initWithTotalParticles(cc.renderContextType === cc.WEBGL ? 1E3 : 300)
}, initWithTotalParticles:function(numberOfParticles) {
  if(this._super(numberOfParticles)) {
    this._duration = cc.PARTICLE_DURATION_INFINITY;
    this._emitterMode = cc.PARTICLE_MODE_GRAVITY;
    this.modeA.gravity = cc.p(10, -10);
    this.modeA.radialAccel = 0;
    this.modeA.radialAccelVar = 1;
    this.modeA.tangentialAccel = 0;
    this.modeA.tangentialAccelVar = 1;
    this.modeA.speed = 130;
    this.modeA.speedVar = 30;
    this._angle = -90;
    this._angleVar = 5;
    var winSize = cc.Director.getInstance().getWinSize();
    this.setPosition(cc.p(winSize.width / 2, winSize.height));
    this._posVar = cc.p(winSize.width / 2, 0);
    this._life = 4.5;
    this._lifeVar = 0;
    this._startSize = 4;
    this._startSizeVar = 2;
    this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;
    this._emissionRate = 20;
    this._startColor.r = 0.7;
    this._startColor.g = 0.8;
    this._startColor.b = 1;
    this._startColor.a = 1;
    this._startColorVar.r = 0;
    this._startColorVar.g = 0;
    this._startColorVar.b = 0;
    this._startColorVar.a = 0;
    this._endColor.r = 0.7;
    this._endColor.g = 0.8;
    this._endColor.b = 1;
    this._endColor.a = 0.5;
    this._endColorVar.r = 0;
    this._endColorVar.g = 0;
    this._endColorVar.b = 0;
    this._endColorVar.a = 0;
    this.setBlendAdditive(false);
    return true
  }
  return false
}});
cc.ParticleRain.create = function() {
  var ret = new cc.ParticleRain;
  if(ret.init()) {
    return ret
  }
  return null
};
cc.PARTICLE_DEFAULT_CAPACITY = 500;
cc.ParticleBatchNode = cc.Node.extend({TextureProtocol:true, _blendFunc:null, _textureAtlas:null, ctor:function() {
  this._super();
  this._blendFunc = {src:cc.BLEND_SRC, dst:cc.BLEND_DST}
}, initWithTexture:function(texture, capacity) {
  this._textureAtlas = new cc.TextureAtlas;
  this._textureAtlas.initWithTexture(texture, capacity);
  this._children = [];
  if(cc.renderContextType === cc.WEBGL) {
    this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_TEXTURECOLOR))
  }
  return true
}, initWithFile:function(fileImage, capacity) {
  var tex = cc.TextureCache.getInstance().addImage(fileImage);
  return this.initWithTexture(tex, capacity)
}, init:function(fileImage, capacity) {
  var tex = cc.TextureCache.getInstance().addImage(fileImage);
  return this.initWithTexture(tex, capacity)
}, addChild:function(child, zOrder, tag) {
  cc.Assert(child != null, "Argument must be non-NULL");
  cc.Assert(child instanceof cc.ParticleSystem, "cc.ParticleBatchNode only supports cc.ParticleSystemQuads as children");
  zOrder = zOrder == null ? child.getZOrder() : zOrder;
  tag = tag == null ? child.getTag() : tag;
  cc.Assert(child.getTexture() == this._textureAtlas.getTexture(), "cc.ParticleSystem is not using the same texture id");
  if(this._children.length === 0) {
    this.setBlendFunc(child.getBlendFunc())
  }
  cc.Assert(this._blendFunc.src == child.getBlendFunc().src && this._blendFunc.dst == child.getBlendFunc().dst, "Can't add a PaticleSystem that uses a differnt blending function");
  var pos = this._addChildHelper(child, zOrder, tag);
  var atlasIndex = 0;
  if(pos != 0) {
    var p = this._children[pos - 1];
    atlasIndex = p.getAtlasIndex() + p.getTotalParticles()
  }else {
    atlasIndex = 0
  }
  this.insertChild(child, atlasIndex);
  child.setBatchNode(this)
}, insertChild:function(pSystem, index) {
  pSystem.setAtlasIndex(index);
  if(this._textureAtlas.getTotalQuads() + pSystem.getTotalParticles() > this._textureAtlas.getCapacity()) {
    this._increaseAtlasCapacityTo(this._textureAtlas.getTotalQuads() + pSystem.getTotalParticles());
    this._textureAtlas.fillWithEmptyQuadsFromIndex(this._textureAtlas.getCapacity() - pSystem.getTotalParticles(), pSystem.getTotalParticles())
  }
  if(pSystem.getAtlasIndex() + pSystem.getTotalParticles() != this._textureAtlas.getTotalQuads()) {
    this._textureAtlas.moveQuadsFromIndex(index, index + pSystem.getTotalParticles())
  }
  this._textureAtlas.increaseTotalQuadsWith(pSystem.getTotalParticles());
  this._updateAllAtlasIndexes()
}, removeChild:function(child, cleanup) {
  if(child == null) {
    return
  }
  cc.Assert(child instanceof cc.ParticleSystem, "cc.ParticleBatchNode only supports cc.ParticleSystemQuads as children");
  cc.Assert(this._children.indexOf(child) > -1, "cc.ParticleBatchNode doesn't contain the sprite. Can't remove it");
  this._super(child, cleanup);
  this._textureAtlas.removeQuadsAtIndex(child.getAtlasIndex(), child.getTotalParticles());
  this._textureAtlas.fillWithEmptyQuadsFromIndex(this._textureAtlas.getTotalQuads(), child.getTotalParticles());
  child.setBatchNode(null);
  this._updateAllAtlasIndexes()
}, reorderChild:function(child, zOrder) {
  cc.Assert(child != null, "Child must be non-NULL");
  cc.Assert(child instanceof cc.ParticleSystem, "cc.ParticleBatchNode only supports cc.QuadParticleSystems as children");
  cc.Assert(this._children.indexOf(child) === -1, "Child doesn't belong to batch");
  if(zOrder == child.getZOrder()) {
    return
  }
  if(this._children.length > 1) {
    var getIndexes = this._getCurrentIndex(child, zOrder);
    if(getIndexes.oldIndex != getIndexes.newIndex) {
      cc.ArrayRemoveObjectAtIndex(this._children, getIndexes.oldIndex);
      this._children = cc.ArrayAppendObjectToIndex(this._children, child, getIndexes.newIndex);
      var oldAtlasIndex = child.getAtlasIndex();
      this._updateAllAtlasIndexes();
      var newAtlasIndex = 0;
      for(var i = 0;i < this._children.length;i++) {
        var pNode = this._children[i];
        if(pNode == child) {
          newAtlasIndex = child.getAtlasIndex();
          break
        }
      }
      this._textureAtlas.moveQuadsFromIndex(oldAtlasIndex, child.getTotalParticles(), newAtlasIndex);
      child.updateWithNoTime()
    }
  }
  child._setZOrder(zOrder)
}, removeChildAtIndex:function(index, doCleanup) {
  this.removeChild(this._children[i], doCleanup)
}, removeAllChildren:function(doCleanup) {
  for(var i = 0;i < this._children.length;i++) {
    this._children[i].setBatchNode(null)
  }
  this._super(doCleanup);
  this._textureAtlas.removeAllQuads()
}, disableParticle:function(particleIndex) {
  var quad = this._textureAtlas.getQuads()[particleIndex];
  quad.br.vertices.x = quad.br.vertices.y = quad.tr.vertices.x = quad.tr.vertices.y = quad.tl.vertices.x = quad.tl.vertices.y = quad.bl.vertices.x = quad.bl.vertices.y = 0
}, draw:function(ctx) {
  if(cc.renderContextType === cc.CANVAS) {
    return
  }
  if(this._textureAtlas.getTotalQuads() == 0) {
    return
  }
  cc.NODE_DRAW_SETUP(this);
  cc.glBlendFunc(this._blendFunc.src, this._blendFunc.dst);
  this._textureAtlas.drawQuads()
}, getTexture:function() {
  return this._textureAtlas.getTexture()
}, setTexture:function(texture) {
  this._textureAtlas.setTexture(texture);
  if(texture && !texture.hasPremultipliedAlpha() && this._blendFunc.src == gl.BLEND_SRC && this._blendFunc.dst == gl.BLEND_DST) {
    this._blendFunc.src = gl.SRC_ALPHA;
    this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA
  }
}, setBlendFunc:function(src, dst) {
  if(arguments.length == 1) {
    this._blendFunc = src
  }else {
    this._blendFunc = {src:src, dst:dst}
  }
}, getBlendFunc:function() {
  return this._blendFunc
}, visit:function(ctx) {
  if(cc.renderContextType === cc.WEBGL) {
    this._super(ctx);
    return
  }
  if(!this._visible) {
    return
  }
  cc.kmGLPushMatrix();
  if(this._grid && this._grid.isActive()) {
    this._grid.beforeDraw();
    this.transformAncestors()
  }
  this.transform(ctx);
  this.draw(ctx);
  if(this._grid && this._grid.isActive()) {
    this._grid.afterDraw(this)
  }
  cc.kmGLPopMatrix()
}, _updateAllAtlasIndexes:function() {
  var index = 0;
  for(var i = 0;i < this._children[0].length;i++) {
    var child = this._children[i];
    child.setAtlasIndex(index);
    index += child.getTotalParticles()
  }
}, _increaseAtlasCapacityTo:function(quantity) {
  cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this._textureAtlas.getCapacity() + "] to [" + quantity + "].");
  if(!this._textureAtlas.resizeCapacity(quantity)) {
    cc.log("cocos2d: WARNING: Not enough memory to resize the atlas");
    cc.Assert(false, "XXX: cc.ParticleBatchNode #increaseAtlasCapacity SHALL handle this assert")
  }
}, _searchNewPositionInChildrenForZ:function(z) {
  var count = this._children.length;
  for(var i = 0;i < count;i++) {
    if(this._children[i].getZOrder() > z) {
      return i
    }
  }
  return count
}, _getCurrentIndex:function(child, z) {
  var foundCurrentIdx = false;
  var foundNewIdx = false;
  var newIndex = 0;
  var oldIndex = 0;
  var minusOne = 0;
  var count = this._children.length;
  for(var i = 0;i < count;i++) {
    var pNode = this._children[i];
    if(pNode.getZOrder() > z && !foundNewIdx) {
      newIndex = i;
      foundNewIdx = true;
      if(foundCurrentIdx && foundNewIdx) {
        break
      }
    }
    if(child == pNode) {
      oldIndex = i;
      foundCurrentIdx = true;
      if(!foundNewIdx) {
        minusOne = -1
      }
      if(foundCurrentIdx && foundNewIdx) {
        break
      }
    }
  }
  if(!foundNewIdx) {
    newIndex = count
  }
  newIndex += minusOne;
  return{newIndex:newIndex, oldIndex:oldIndex}
}, _addChildHelper:function(child, z, aTag) {
  cc.Assert(child != null, "Argument must be non-nil");
  cc.Assert(child.getParent() == null, "child already added. It can't be added again");
  if(!this._children) {
    this._children = []
  }
  var pos = this._searchNewPositionInChildrenForZ(z);
  this._children = cc.ArrayAppendObjectToIndex(this._children, child, pos);
  child.setTag(aTag);
  child._setZOrder(z);
  child.setParent(this);
  if(this._running) {
    child.onEnter();
    child.onEnterTransitionDidFinish()
  }
  return pos
}, _updateBlendFunc:function() {
  if(!this._textureAtlas.getTexture().hasPremultipliedAlpha()) {
    this._blendFunc.src = gl.SRC_ALPHA;
    this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA
  }
}, getTextureAtlas:function() {
  return this._textureAtlas
}, setTextureAtlas:function(textureAtlas) {
  this._textureAtlas = textureAtlas
}});
cc.ParticleBatchNode.createWithTexture = function(texture, capacity) {
  var ret = new cc.ParticleBatchNode;
  if(ret && ret.initWithTexture(texture, capacity)) {
    return ret
  }
  return null
};
cc.ParticleBatchNode.create = function(fileImage, capacity) {
  var ret = new cc.ParticleBatchNode;
  if(ret && ret.init(fileImage, capacity)) {
    return ret
  }
  return null
};
cc.Touch = cc.Class.extend({_point:null, _prevPoint:cc.PointZero(), _id:0, ctor:function(x, y, id) {
  this._point = cc.p(x || 0, y || 0);
  this._id = id || 0
}, getLocation:function() {
  return this._point
}, getPreviousLocation:function() {
  return this._prevPoint
}, getDelta:function() {
  return cc.pSub(this._point, this._prevPoint)
}, getID:function() {
  return this._id
}, getId:function() {
  return this._id
}, setTouchInfo:function(id, x, y) {
  this._prevPoint = this._point;
  this._point = cc.p(x || 0, y || 0);
  this._id = id
}, _setPrevPoint:function(x, y) {
  this._prevPoint = cc.p(x || 0, y || 0)
}});
cc.TouchDelegate = cc.Class.extend({_eventTypeFuncMap:null, onTouchBegan:function(touch, event) {
  return false
}, onTouchMoved:function(touch, event) {
}, onTouchEnded:function(touch, event) {
}, onTouchCancelled:function(touch, event) {
}, onTouchesBegan:function(touches, event) {
}, onTouchesMoved:function(touches, event) {
}, onTouchesEnded:function(touches, event) {
}, onTouchesCancelled:function(touches, event) {
}, touchDelegateRetain:function() {
}, touchDelegateRelease:function() {
}});
cc.TargetedTouchDelegate = cc.TouchDelegate.extend({onTouchBegan:function(touch, event) {
  return false
}, onTouchMoved:function(touch, event) {
}, onTouchEnded:function(touch, event) {
}, onTouchCancelled:function(touch, event) {
}});
cc.StandardTouchDelegate = cc.TouchDelegate.extend({onTouchesBegan:function(touches, event) {
}, onTouchesMoved:function(touches, event) {
}, onTouchesEnded:function(touches, event) {
}, onTouchesCancelled:function(touches, event) {
}});
cc.TouchHandler = cc.Class.extend({_delegate:null, _priority:0, _enabledSelectors:0, getDelegate:function() {
  return this._delegate
}, setDelegate:function(delegate) {
  this._delegate = delegate
}, getPriority:function() {
  return this._priority
}, setPriority:function(priority) {
  this._priority = priority
}, getEnabledSelectors:function() {
  return this._enabledSelectors
}, setEnalbedSelectors:function(value) {
  this._enabledSelectors = value
}, initWithDelegate:function(delegate, priority) {
  cc.Assert(delegate != null, "TouchHandler.initWithDelegate():touch delegate should not be null");
  this._delegate = delegate;
  this._priority = priority;
  this._enabledSelectors = 0;
  return true
}});
cc.TouchHandler.handlerWithDelegate = function(delegate, priority) {
  var handler = new cc.TouchHandler;
  if(handler) {
    handler.initWithDelegate(delegate, priority)
  }
  return handler
};
cc.StandardTouchHandler = cc.TouchHandler.extend({initWithDelegate:function(delegate, priority) {
  if(this._super(delegate, priority)) {
    return true
  }
  return false
}});
cc.StandardTouchHandler.handlerWithDelegate = function(delegate, priority) {
  var handler = new cc.StandardTouchHandler;
  if(handler) {
    handler.initWithDelegate(delegate, priority)
  }
  return handler
};
cc.TargetedTouchHandler = cc.TouchHandler.extend({_swallowsTouches:false, _claimedTouches:null, isSwallowsTouches:function() {
  return this._swallowsTouches
}, setSwallowsTouches:function(swallowsTouches) {
  this._swallowsTouches = swallowsTouches
}, getClaimedTouches:function() {
  return this._claimedTouches
}, initWithDelegate:function(delegate, priority, swallow) {
  if(this._super(delegate, priority)) {
    this._claimedTouches = [];
    this._swallowsTouches = swallow;
    return true
  }
  return false
}});
cc.TargetedTouchHandler.handlerWithDelegate = function(delegate, priority, swallow) {
  var handler = new cc.TargetedTouchHandler;
  if(handler) {
    handler.initWithDelegate(delegate, priority, swallow)
  }
  return handler
};
cc.TouchSelectorBeganBit = 1 << 0;
cc.TouchSelectorMovedBit = 1 << 1;
cc.TouchSelectorEndedBit = 1 << 2;
cc.TouchSelectorCancelledBit = 1 << 3;
cc.TouchSelectorAllBits = cc.TouchSelectorBeganBit | cc.TouchSelectorMovedBit | cc.TouchSelectorEndedBit | cc.TouchSelectorCancelledBit;
cc.TOUCH_BEGAN = 0;
cc.TOUCH_MOVED = 1;
cc.TOUCH_ENDED = 2;
cc.TOUCH_CANCELLED = 3;
cc.TouchMax = 4;
cc.less = function(p1, p2) {
  return p1.getPriority() > p2.getPriority()
};
cc.TouchHandlerHelperData = function(type) {
  this.type = type
};
cc.TouchDispatcher = cc.Class.extend({_mousePressed:false, _targetedHandlers:null, _standardHandlers:null, _locked:false, _toAdd:false, _toRemove:false, _handlersToAdd:null, _handlersToRemove:null, _toQuit:false, _dispatchEvents:false, _handlerHelperData:[new cc.TouchHandlerHelperData(cc.TOUCH_BEGAN), new cc.TouchHandlerHelperData(cc.TOUCH_MOVED), new cc.TouchHandlerHelperData(cc.TOUCH_ENDED), new cc.TouchHandlerHelperData(cc.TOUCH_CANCELLED)], init:function() {
  this._dispatchEvents = true;
  this._targetedHandlers = [];
  this._standardHandlers = [];
  this._handlersToAdd = [];
  this._handlersToRemove = [];
  this._toRemove = false;
  this._toAdd = false;
  this._toQuit = false;
  this._locked = false;
  this._mousePressed = false;
  cc.TouchDispatcher.registerHtmlElementEvent(cc.canvas);
  return true
}, _setMousePressed:function(pressed) {
  this._mousePressed = pressed
}, _getMousePressed:function() {
  return this._mousePressed
}, isDispatchEvents:function() {
  return this._dispatchEvents
}, setDispatchEvents:function(dispatchEvents) {
  this._dispatchEvents = dispatchEvents
}, addStandardDelegate:function(delegate, priority) {
  var handler = cc.StandardTouchHandler.handlerWithDelegate(delegate, priority);
  if(!this._locked) {
    this._standardHandlers = this.forceAddHandler(handler, this._standardHandlers)
  }else {
    if(this._handlersToRemove.indexOf(delegate) != -1) {
      cc.ArrayRemoveObject(this._handlersToRemove, delegate);
      return
    }
    this._handlersToAdd.push(handler);
    this._toAdd = true
  }
}, addTargetedDelegate:function(delegate, priority, swallowsTouches) {
  var handler = cc.TargetedTouchHandler.handlerWithDelegate(delegate, priority, swallowsTouches);
  if(!this._locked) {
    this._targetedHandlers = this.forceAddHandler(handler, this._targetedHandlers)
  }else {
    if(this._handlersToRemove.indexOf(delegate) != -1) {
      cc.ArrayRemoveObject(this._handlersToRemove, delegate);
      return
    }
    this._handlersToAdd.push(handler);
    this._toAdd = true
  }
}, forceAddHandler:function(handler, array) {
  var u = 0, h;
  for(var i = 0;i < array.length;i++) {
    h = array[i];
    if(h) {
      if(h.getPriority() < handler.getPriority()) {
        ++u
      }
      if(h.getDelegate() == handler.getDelegate()) {
        cc.Assert(0, "TouchDispatcher.forceAddHandler()");
        return array
      }
    }
  }
  return cc.ArrayAppendObjectToIndex(array, handler, u)
}, forceRemoveAllDelegates:function() {
  this._standardHandlers.length = 0;
  this._targetedHandlers.length = 0
}, removeDelegate:function(delegate) {
  if(delegate == null) {
    return
  }
  if(!this._locked) {
    this.forceRemoveDelegate(delegate)
  }else {
    var handler = this.findHandler(this._handlersToAdd, delegate);
    if(handler) {
      cc.ArrayRemoveObject(this._handlersToAdd, handler);
      return
    }
    this._handlersToRemove.push(delegate);
    this._toRemove = true
  }
}, removeAllDelegates:function() {
  if(!this._locked) {
    this.forceRemoveAllDelegates()
  }else {
    this._toQuit = true
  }
}, setPriority:function(priority, delegate) {
  cc.Assert(delegate != null, "TouchDispatcher.setPriority():Arguments is null");
  var handler = this.findHandler(delegate);
  cc.Assert(handler != null, "TouchDispatcher.setPriority():Cant find TouchHandler");
  if(handler.getPriority() != priority) {
    handler.setPriority(priority);
    this.rearrangeHandlers(this._targetedHandlers);
    this.rearrangeHandlers(this._standardHandlers)
  }
}, touches:function(touches, event, index) {
  cc.Assert(index >= 0 && index < 4, "TouchDispatcher.touches()");
  this._locked = true;
  var targetedHandlersCount = this._targetedHandlers.length;
  var standardHandlersCount = this._standardHandlers.length;
  var needsMutableSet = targetedHandlersCount && standardHandlersCount;
  var mutableTouches = needsMutableSet ? touches.slice() : touches;
  var helper = this._handlerHelperData[index];
  if(targetedHandlersCount > 0) {
    var touch, handler, claimed;
    for(var i = 0;i < touches.length;i++) {
      touch = touches[i];
      for(var j = 0;j < this._targetedHandlers.length;j++) {
        handler = this._targetedHandlers[j];
        if(!handler) {
          break
        }
        claimed = false;
        if(index == cc.TOUCH_BEGAN) {
          if(handler.getDelegate().onTouchBegan) {
            claimed = handler.getDelegate().onTouchBegan(touch, event);
            if(claimed) {
              handler.getClaimedTouches().push(touch)
            }
          }
        }else {
          if(handler.getClaimedTouches().length > 0) {
            claimed = true;
            switch(helper.type) {
              case cc.TOUCH_MOVED:
                if(cc.Browser.isMobile) {
                  if(handler.getDelegate().onTouchMoved) {
                    handler.getDelegate().onTouchMoved(touch, event)
                  }
                }else {
                  if(this._mousePressed) {
                    if(handler.getDelegate().onTouchMoved) {
                      handler.getDelegate().onTouchMoved(touch, event)
                    }
                  }
                }
                break;
              case cc.TOUCH_ENDED:
                if(handler.getDelegate().onTouchEnded) {
                  handler.getDelegate().onTouchEnded(touch, event)
                }
                handler.getClaimedTouches().length = 0;
                break;
              case cc.TOUCH_CANCELLED:
                if(handler.getDelegate().onTouchCancelled) {
                  handler.getDelegate().onTouchCancelled(touch, event)
                }
                handler.getClaimedTouches().length = 0;
                break
            }
          }
        }
        if(claimed && handler.isSwallowsTouches()) {
          if(needsMutableSet) {
            cc.ArrayRemoveObject(mutableTouches, touch)
          }
          break
        }
      }
    }
  }
  if(standardHandlersCount > 0) {
    for(i = 0;i < this._standardHandlers.length;i++) {
      handler = this._standardHandlers[i];
      if(!handler) {
        break
      }
      switch(helper.type) {
        case cc.TOUCH_BEGAN:
          if(mutableTouches.length > 0) {
            if(handler.getDelegate().onTouchesBegan) {
              handler.getDelegate().onTouchesBegan(mutableTouches, event)
            }
          }
          break;
        case cc.TOUCH_MOVED:
          if(mutableTouches.length > 0) {
            if(cc.Browser.isMobile) {
              if(handler.getDelegate().onTouchesMoved) {
                handler.getDelegate().onTouchesMoved(mutableTouches, event)
              }
            }else {
              if(this._mousePressed) {
                if(handler.getDelegate().onTouchesMoved) {
                  handler.getDelegate().onTouchesMoved(mutableTouches, event)
                }
              }
            }
          }
          break;
        case cc.TOUCH_ENDED:
          if(handler.getDelegate().onTouchesEnded) {
            handler.getDelegate().onTouchesEnded(mutableTouches, event)
          }
          break;
        case cc.TOUCH_CANCELLED:
          if(handler.getDelegate().onTouchesCancelled) {
            handler.getDelegate().onTouchesCancelled(mutableTouches, event)
          }
          break
      }
    }
  }
  if(needsMutableSet) {
    mutableTouches = null
  }
  this._locked = false;
  if(this._toRemove) {
    this._toRemove = false;
    for(i = 0;i < this._handlersToRemove.length;i++) {
      this.forceRemoveDelegate(this._handlersToRemove[i])
    }
    this._handlersToRemove.length = 0
  }
  if(this._toAdd) {
    this._toAdd = false;
    for(i = 0;i < this._handlersToAdd.length;i++) {
      handler = this._handlersToAdd[i];
      if(!handler) {
        break
      }
      if(handler instanceof cc.TargetedTouchHandler) {
        this._targetedHandlers = this.forceAddHandler(handler, this._targetedHandlers)
      }else {
        this._standardHandlers = this.forceAddHandler(handler, this._standardHandlers)
      }
    }
    this._handlersToAdd.length = 0
  }
  if(this._toQuit) {
    this._toQuit = false;
    this.forceRemoveAllDelegates()
  }
}, touchesBegan:function(touches, event) {
  if(this._dispatchEvents) {
    this.touches(touches, event, cc.TOUCH_BEGAN)
  }
}, touchesMoved:function(touches, event) {
  if(this._dispatchEvents) {
    this.touches(touches, event, cc.TOUCH_MOVED)
  }
}, touchesEnded:function(touches, event) {
  if(this._dispatchEvents) {
    this.touches(touches, event, cc.TOUCH_ENDED)
  }
}, touchesCancelled:function(touches, event) {
  if(this._dispatchEvents) {
    this.touches(touches, event, cc.TOUCH_CANCELLED)
  }
}, findHandler:function(array, delegate) {
  switch(arguments.length) {
    case 1:
      delegate = arguments[0];
      for(var i = 0;i < this._targetedHandlers.length;i++) {
        if(this._targetedHandlers[i].getDelegate() == delegate) {
          return this._targetedHandlers[i]
        }
      }
      for(i = 0;i < this._standardHandlers.length;i++) {
        if(this._standardHandlers[i].getDelegate() == delegate) {
          return this._standardHandlers[i]
        }
      }
      return null;
      break;
    case 2:
      cc.Assert(array != null && delegate != null, "TouchDispatcher.findHandler():Arguments is null");
      for(i = 0;i < array.length;i++) {
        if(array[i].getDelegate() == delegate) {
          return array[i]
        }
      }
      return null;
      break;
    default:
      throw"Argument must be non-nil ";break
  }
}, forceRemoveDelegate:function(delegate) {
  var handler;
  for(var i = 0;i < this._standardHandlers.length;i++) {
    handler = this._standardHandlers[i];
    if(handler && handler.getDelegate() == delegate) {
      cc.ArrayRemoveObject(this._standardHandlers, handler);
      break
    }
  }
  for(i = 0;i < this._targetedHandlers.length;i++) {
    handler = this._targetedHandlers[i];
    if(handler && handler.getDelegate() == delegate) {
      cc.ArrayRemoveObject(this._targetedHandlers, handler);
      break
    }
  }
}, rearrangeHandlers:function(array) {
  array.sort(cc.less)
}});
cc.TouchDispatcher.preTouchPoint = cc.p(0, 0);
cc.TouchDispatcher.isRegisterEvent = false;
cc.getHTMLElementPosition = function(element) {
  var docElem = document.documentElement;
  var win = window;
  var box = null;
  if(typeof element.getBoundingClientRect === "function") {
    box = element.getBoundingClientRect()
  }else {
    if(element instanceof HTMLCanvasElement) {
      box = {left:0, top:0, width:element.width, height:element.height}
    }else {
      box = {left:0, top:0, width:parseInt(element.style.width), height:parseInt(element.style.height)}
    }
  }
  return{left:box.left + win.pageXOffset - docElem.clientLeft, top:box.top + win.pageYOffset - docElem.clientTop, width:box.width, height:box.height}
};
cc.ProcessMouseupEvent = function(element, event) {
  var pos = cc.getHTMLElementPosition(element);
  var tx, ty;
  if(event.hasOwnProperty("pageX")) {
    tx = event.pageX;
    ty = event.pageY
  }else {
    pos.left -= document.body.scrollLeft;
    pos.top -= document.body.scrollTop;
    tx = event.clientX;
    ty = event.clientY
  }
  var location = cc.EGLView.getInstance().convertToLocationInView(tx, ty, pos);
  var touch = new cc.Touch(location.x, location.y);
  touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
  cc.TouchDispatcher.preTouchPoint.x = location.x;
  cc.TouchDispatcher.preTouchPoint.y = location.y;
  var posArr = [];
  posArr.push(touch);
  cc.EGLView.getInstance().touchesEnded(posArr, null)
};
cc.TouchDispatcher.registerHtmlElementEvent = function(element) {
  if(cc.TouchDispatcher.isRegisterEvent) {
    return
  }
  if(!cc.Browser.isMobile) {
    window.addEventListener("mousedown", function(event) {
      cc.Director.getInstance().getTouchDispatcher()._setMousePressed(true)
    });
    window.addEventListener("mouseup", function(event) {
      cc.Director.getInstance().getTouchDispatcher()._setMousePressed(false);
      var pos = cc.getHTMLElementPosition(element);
      var tx, ty;
      if(event.hasOwnProperty("pageX")) {
        tx = event.pageX;
        ty = event.pageY
      }else {
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;
        tx = event.clientX;
        ty = event.clientY
      }
      if(!cc.rectContainsPoint(new cc.Rect(pos.left, pos.top, pos.width, pos.height), cc.p(tx, ty))) {
        var location = cc.EGLView.getInstance().convertToLocationInView(tx, ty, pos);
        var touch = new cc.Touch(location.x, location.y);
        touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
        cc.TouchDispatcher.preTouchPoint.x = location.x;
        cc.TouchDispatcher.preTouchPoint.y = location.y;
        var posArr = [];
        posArr.push(touch);
        cc.EGLView.getInstance().touchesEnded(posArr, null)
      }
    });
    element.addEventListener("mousedown", function(event) {
      var pos = cc.getHTMLElementPosition(element);
      var tx, ty;
      if(event.hasOwnProperty("pageX")) {
        tx = event.pageX;
        ty = event.pageY
      }else {
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;
        tx = event.clientX;
        ty = event.clientY
      }
      var location = cc.EGLView.getInstance().convertToLocationInView(tx, ty, pos);
      var touch = new cc.Touch(location.x, location.y);
      touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
      cc.TouchDispatcher.preTouchPoint.x = location.x;
      cc.TouchDispatcher.preTouchPoint.y = location.y;
      var posArr = [];
      posArr.push(touch);
      cc.EGLView.getInstance().touchesBegan(posArr, null)
    });
    element.addEventListener("mouseup", function(event) {
      cc.ProcessMouseupEvent(element, event)
    });
    element.addEventListener("mousemove", function(event) {
      var pos = cc.getHTMLElementPosition(element);
      var tx, ty;
      if(event.hasOwnProperty("pageX")) {
        tx = event.pageX;
        ty = event.pageY
      }else {
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;
        tx = event.clientX;
        ty = event.clientY
      }
      var location = cc.EGLView.getInstance().convertToLocationInView(tx, ty, pos);
      var touch = new cc.Touch(location.x, location.y);
      touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
      cc.TouchDispatcher.preTouchPoint.x = location.x;
      cc.TouchDispatcher.preTouchPoint.y = location.y;
      var posArr = [];
      posArr.push(touch);
      cc.EGLView.getInstance().touchesMoved(posArr, null)
    })
  }else {
    if(window.navigator.msPointerEnabled) {
      var _pointerEventsMap = {"MSPointerDown":"touchesBegan", "MSPointerMove":"touchesMoved", "MSPointerUp":"touchesEnded", "MSPointerCancel":"touchesCancelled"};
      for(var i in _pointerEventsMap) {
        (function(_pointerEvent, _touchEvent) {
          element.addEventListener(_pointerEvent, function(event) {
            var pos = cc.getHTMLElementPosition(element);
            pos.left -= document.body.scrollLeft;
            pos.top -= document.body.scrollTop;
            var tx, ty, touch, preLocation;
            tx = event.clientX;
            ty = event.clientY;
            var location = cc.EGLView.getInstance().convertToLocationInView(tx, ty, pos);
            var touch = new cc.Touch(location.x, location.y);
            touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
            cc.TouchDispatcher.preTouchPoint.x = location.x;
            cc.TouchDispatcher.preTouchPoint.y = location.y;
            cc.Director.getInstance().getTouchDispatcher()[_touchEvent]([touch], null);
            event.stopPropagation();
            event.preventDefault()
          }, false)
        })(i, _pointerEventsMap[i])
      }
    }else {
      element.addEventListener("touchstart", function(event) {
        if(!event.changedTouches) {
          return
        }
        var posArr = [];
        var pos = cc.getHTMLElementPosition(element);
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;
        var touch_event, tx, ty, touch, preLocation;
        var length = event.changedTouches.length;
        for(var i = 0;i < length;i++) {
          touch_event = event.changedTouches[i];
          if(touch_event) {
            tx = touch_event.clientX;
            ty = touch_event.clientY;
            var location = cc.EGLView.getInstance().convertToLocationInView(tx, ty, pos);
            touch = null;
            if(touch_event.hasOwnProperty("identifier")) {
              touch = new cc.Touch(location.x, location.y, touch_event.identifier);
              preLocation = cc.TouchDispatcher._getPreTouch(touch).getLocation();
              touch._setPrevPoint(preLocation.x, preLocation.y);
              cc.TouchDispatcher._setPreTouch(touch)
            }else {
              touch = new cc.Touch(location.x, location.y);
              touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y)
            }
            cc.TouchDispatcher.preTouchPoint.x = location.x;
            cc.TouchDispatcher.preTouchPoint.y = location.y;
            posArr.push(touch)
          }
        }
        cc.EGLView.getInstance().touchesBegan(posArr, null);
        event.stopPropagation();
        event.preventDefault()
      }, false);
      element.addEventListener("touchmove", function(event) {
        if(!event.changedTouches) {
          return
        }
        var posArr = [];
        var pos = cc.getHTMLElementPosition(element);
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;
        var touch_event, tx, ty, touch, preLocation;
        var length = event.changedTouches.length;
        for(var i = 0;i < length;i++) {
          touch_event = event.changedTouches[i];
          if(touch_event) {
            tx = touch_event.clientX;
            ty = touch_event.clientY;
            var location = cc.EGLView.getInstance().convertToLocationInView(tx, ty, pos);
            touch = null;
            if(touch_event.hasOwnProperty("identifier")) {
              touch = new cc.Touch(location.x, location.y, touch_event.identifier);
              preLocation = cc.TouchDispatcher._getPreTouch(touch).getLocation();
              touch._setPrevPoint(preLocation.x, preLocation.y);
              cc.TouchDispatcher._setPreTouch(touch)
            }else {
              touch = new cc.Touch(location.x, location.y);
              touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y)
            }
            cc.TouchDispatcher.preTouchPoint.x = location.x;
            cc.TouchDispatcher.preTouchPoint.y = location.y;
            posArr.push(touch)
          }
        }
        cc.EGLView.getInstance().touchesMoved(posArr, null);
        event.stopPropagation();
        event.preventDefault()
      }, false);
      element.addEventListener("touchend", function(event) {
        if(!event.changedTouches) {
          return
        }
        var posArr = [];
        var pos = cc.getHTMLElementPosition(element);
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;
        var touch_event, tx, ty, touch, preLocation;
        var length = event.changedTouches.length;
        for(var i = 0;i < length;i++) {
          touch_event = event.changedTouches[i];
          if(touch_event) {
            tx = touch_event.clientX;
            ty = touch_event.clientY;
            var location = cc.EGLView.getInstance().convertToLocationInView(tx, ty, pos);
            touch = null;
            if(touch_event.hasOwnProperty("identifier")) {
              touch = new cc.Touch(location.x, location.y, touch_event.identifier);
              preLocation = cc.TouchDispatcher._getPreTouch(touch).getLocation();
              touch._setPrevPoint(preLocation.x, preLocation.y);
              cc.TouchDispatcher._deletePreTouchWithSameId(touch)
            }else {
              touch = new cc.Touch(location.x, location.y);
              touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y)
            }
            cc.TouchDispatcher.preTouchPoint.x = location.x;
            cc.TouchDispatcher.preTouchPoint.y = location.y;
            posArr.push(touch)
          }
        }
        cc.EGLView.getInstance().touchesEnded(posArr, null);
        event.stopPropagation();
        event.preventDefault()
      }, false);
      element.addEventListener("touchcancel", function(event) {
        if(!event.changedTouches) {
          return
        }
        var posArr = [];
        var pos = cc.getHTMLElementPosition(element);
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;
        var touch_event, tx, ty, touch, preLocation;
        var length = event.changedTouches.length;
        for(var i = 0;i < length;i++) {
          touch_event = event.changedTouches[i];
          if(touch_event) {
            tx = touch_event.clientX;
            ty = touch_event.clientY;
            var location = cc.EGLView.getInstance().convertToLocationInView(tx, ty, pos);
            touch = null;
            if(touch_event.hasOwnProperty("identifier")) {
              touch = new cc.Touch(location.x, location.y, touch_event.identifier);
              preLocation = cc.TouchDispatcher._getPreTouch(touch).getLocation();
              touch._setPrevPoint(preLocation.x, preLocation.y);
              cc.TouchDispatcher._deletePreTouchWithSameId(touch)
            }else {
              touch = new cc.Touch(location.x, location.y);
              touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y)
            }
            cc.TouchDispatcher.preTouchPoint.x = location.x;
            cc.TouchDispatcher.preTouchPoint.y = location.y;
            posArr.push(touch)
          }
        }
        cc.EGLView.getInstance().touchesCancelled(posArr, null);
        event.stopPropagation();
        event.preventDefault()
      }, false)
    }
  }
  cc.TouchDispatcher.isRegisterEvent = true
};
cc.TouchDispatcher._getPreTouch = function(touch) {
  var preTouch = null;
  var preTouchPool = cc.TouchDispatcher._preTouchPool;
  var id = touch.getId();
  for(var i = preTouchPool.length - 1;i >= 0;i--) {
    if(preTouchPool[i].getId() == id) {
      preTouch = preTouchPool[i];
      break
    }
  }
  if(!preTouch) {
    preTouch = touch
  }
  return preTouch
};
cc.TouchDispatcher._setPreTouch = function(touch) {
  var find = false;
  var preTouchPool = cc.TouchDispatcher._preTouchPool;
  var id = touch.getId();
  for(var i = preTouchPool.length - 1;i >= 0;i--) {
    if(preTouchPool[i].getId() == id) {
      preTouchPool[i] = touch;
      find = true;
      break
    }
  }
  if(!find) {
    if(preTouchPool.length <= 50) {
      preTouchPool.push(touch)
    }else {
      preTouchPool[cc.TouchDispatcher._preTouchPoolPointer] = touch;
      cc.TouchDispatcher._preTouchPoolPointer = (cc.TouchDispatcher._preTouchPoolPointer + 1) % 50
    }
  }
};
cc.TouchDispatcher._deletePreTouchWithSameId = function(touch) {
  var changeTouch;
  var preTouchPool = cc.TouchDispatcher._preTouchPool;
  var id = touch.getId();
  for(var i = preTouchPool.length - 1;i >= 0;i--) {
    if(preTouchPool[i].getId() == id) {
      changeTouch = preTouchPool.pop();
      if(i != preTouchPool.length) {
        preTouchPool[i] = changeTouch
      }
      break
    }
  }
};
cc.TouchDispatcher._preTouchPool = [];
cc.TouchDispatcher._preTouchPoolPointer = 0;
cc.MOUSE_DOWN = 1 << 0;
cc.MOUSE_MOVED = 1 << 1;
cc.MOUSE_DRAGGED = 1 << 2;
cc.MOUSE_UP = 1 << 3;
cc.RIGHT_MOUSE_DOWN = 1 << 4;
cc.RIGHT_MOUSE_DRAGGED = 1 << 5;
cc.RIGHT_MOUSE_UP = 1 << 6;
cc.OTHER_MOUSE_DOWN = 1 << 7;
cc.OTHER_MOUSE_DRAGGED = 1 << 8;
cc.OTHER_MOUSE_UP = 1 << 9;
cc.SCROLL_WHEEL = 1 << 10;
cc.MOUSE_ENTERED = 1 << 11;
cc.MOUSE_EXITED = 1 << 12;
cc.MOUSE_LEFTBUTTON = 0;
cc.MOUSE_MIDDLEBUTTON = 1;
cc.MOUSE_RIGHTBUTTON = 2;
cc.MouseEventDelegate = cc.Class.extend({onMouseDown:function(event) {
  return false
}, onMouseDragged:function(event) {
  return false
}, onMouseMoved:function(event) {
  return false
}, onMouseUp:function(event) {
  return false
}, onRightMouseDown:function(event) {
  return false
}, onRightMouseDragged:function(event) {
  return false
}, onRightMouseUp:function(event) {
  return false
}, onOtherMouseDown:function(event) {
  return false
}, onOtherMouseDragged:function(event) {
  return false
}, onOtherMouseUp:function(event) {
  return false
}, onScrollWheel:function(event) {
  return false
}, onMouseEntered:function(theEvent) {
  return false
}, onMouseExited:function(theEvent) {
  return false
}});
cc.Mouse = cc.Touch.extend({_wheelDelta:0, _button:cc.MOUSE_LEFTBUTTON, getWheelDelta:function() {
  return this._wheelDelta
}, setWheelDelta:function(delta) {
  this._wheelDelta = delta
}, getButton:function() {
  return this._button
}, setButton:function(button) {
  this._button = button
}});
cc.MouseHandler = cc.Class.extend({_delegate:null, _priority:0, _enabledSelectors:0, getDelegate:function() {
  return this._delegate
}, setDelegate:function(delegate) {
  this._delegate = delegate
}, getPriority:function() {
  return this._priority
}, setPriority:function(priority) {
  this._priority = priority
}, getEnabledSelectors:function() {
  return this._enabledSelectors
}, setEnalbedSelectors:function(value) {
  this._enabledSelectors = value
}, initWithDelegate:function(delegate, priority) {
  this._delegate = delegate;
  this._priority = priority
}});
cc.MouseHandler.create = function(delegate, priority) {
  var handler = new cc.MouseHandler;
  handler.initWithDelegate(delegate, priority);
  return handler
};
cc.MouseDispatcher = cc.Class.extend({_mousePressed:false, _rightMousePressed:false, _mouseDelegateHandlers:null, _dispatchEvents:false, init:function() {
  this._dispatchEvents = true;
  this._mouseDelegateHandlers = [];
  this._mousePressed = false;
  this._rightMousePressed = false;
  cc.MouseDispatcher._registerHtmlElementEvent(cc.canvas);
  return true
}, _setMousePressed:function(pressed) {
  this._mousePressed = pressed
}, _getMousePressed:function() {
  return this._mousePressed
}, _setRightMousePressed:function(pressed) {
  this._rightMousePressed = pressed
}, _getRightMousePressed:function() {
  return this._rightMousePressed
}, addMouseDelegate:function(delegate, priority) {
  var handler = cc.MouseHandler.create(delegate, priority);
  this._mouseDelegateHandlers = this.forceAddHandler(handler, this._mouseDelegateHandlers)
}, forceAddHandler:function(handler, array) {
  var u = 0;
  for(var i = 0;i < array.length;i++) {
    var h = array[i];
    if(h) {
      if(h.getPriority() < handler.getPriority()) {
        ++u
      }
      if(h.getDelegate() == handler.getDelegate()) {
        cc.Assert(0, "TouchDispatcher.forceAddHandler()");
        return array
      }
    }
  }
  return cc.ArrayAppendObjectToIndex(array, handler, u)
}, removeMouseDelegate:function(delegate) {
  if(delegate == null) {
    return
  }
  for(var i = 0;i < this._mouseDelegateHandlers.length;i++) {
    var handler = this._mouseDelegateHandlers[i];
    if(handler && handler.getDelegate() == delegate) {
      cc.ArrayRemoveObject(this._mouseDelegateHandlers, handler);
      break
    }
  }
}, _findHandler:function(delegate) {
  for(i = 0;i < this._mouseDelegateHandlers.length;i++) {
    if(this._mouseDelegateHandlers[i] && this._mouseDelegateHandlers[i].getDelegate() == delegate) {
      return this._mouseDelegateHandlers[i]
    }
  }
}, setPriority:function(priority, delegate) {
  cc.Assert(delegate != null, "MouseDispatcher.setPriority():Arguments is null");
  var handler = this._findHandler(delegate);
  cc.Assert(handler != null, "MouseDispatcher.setPriority():Cant find MouseHandler");
  if(handler.getPriority() != priority) {
    handler.setPriority(priority);
    this._mouseDelegateHandlers.sort(cc.less)
  }
}, removeAllMouseDelegates:function() {
  this._mouseDelegateHandlers.length = 0
}, mouseHandle:function(mouseObj, event, index) {
  for(var i = 0;i < this._mouseDelegateHandlers.length;i++) {
    var handler = this._mouseDelegateHandlers[i];
    switch(index) {
      case cc.MOUSE_DOWN:
        if(mouseObj.getButton() == cc.MOUSE_RIGHTBUTTON) {
          if(handler.getDelegate().onRightMouseDown) {
            handler.getDelegate().onRightMouseDown(mouseObj)
          }
        }else {
          if(handler.getDelegate().onMouseDown) {
            handler.getDelegate().onMouseDown(mouseObj)
          }
        }
        break;
      case cc.MOUSE_UP:
        if(mouseObj.getButton() == cc.MOUSE_RIGHTBUTTON) {
          if(handler.getDelegate().onRightMouseUp) {
            handler.getDelegate().onRightMouseUp(mouseObj)
          }
        }else {
          if(handler.getDelegate().onMouseUp) {
            handler.getDelegate().onMouseUp(mouseObj)
          }
        }
        break;
      case cc.MOUSE_MOVED:
        if(this._mousePressed) {
          if(handler.getDelegate().onMouseDragged) {
            handler.getDelegate().onMouseDragged(mouseObj)
          }
        }else {
          if(this._rightMousePressed) {
            if(handler.getDelegate().onRightMouseDragged) {
              handler.getDelegate().onRightMouseDragged(mouseObj)
            }
          }else {
            if(handler.getDelegate().onMouseMoved) {
              handler.getDelegate().onMouseMoved(mouseObj)
            }
          }
        }
        break;
      case cc.MOUSE_ENTERED:
        if(handler.getDelegate().onMouseEntered) {
          handler.getDelegate().onMouseEntered(mouseObj)
        }
        break;
      case cc.MOUSE_EXITED:
        if(handler.getDelegate().onMouseExited) {
          handler.getDelegate().onMouseExited(mouseObj)
        }
        break;
      case cc.SCROLL_WHEEL:
        if(handler.getDelegate().onScrollWheel) {
          handler.getDelegate().onScrollWheel(mouseObj)
        }
        break
    }
  }
}});
cc.MouseDispatcher._preMousePoint = cc.p(0, 0);
cc.MouseDispatcher._isRegisterEvent = false;
cc.MouseDispatcher._registerHtmlElementEvent = function(element) {
  if(cc.MouseDispatcher._isRegisterEvent) {
    return
  }
  window.addEventListener("mousedown", function(event) {
    if(event.button == cc.MOUSE_RIGHTBUTTON) {
      cc.Director.getInstance().getMouseDispatcher()._setRightMousePressed(true)
    }else {
      cc.Director.getInstance().getMouseDispatcher()._setMousePressed(true)
    }
  });
  window.addEventListener("mouseup", function(event) {
    if(event.button == cc.MOUSE_RIGHTBUTTON) {
      cc.Director.getInstance().getMouseDispatcher()._setRightMousePressed(false)
    }else {
      cc.Director.getInstance().getMouseDispatcher()._setMousePressed(false)
    }
  });
  function getMouseByEvent(event) {
    var pos = cc.getHTMLElementPosition(element);
    var tx = event.pageX;
    var ty = event.pageY;
    var mouseX = (tx - pos.left) / cc.Director.getInstance().getContentScaleFactor();
    var mouseY = (pos.height - (ty - pos.top)) / cc.Director.getInstance().getContentScaleFactor();
    var mouse = new cc.Mouse(mouseX, mouseY);
    mouse._setPrevPoint(cc.MouseDispatcher._preMousePoint.x, cc.MouseDispatcher._preMousePoint.y);
    mouse.setButton(event.button);
    cc.MouseDispatcher._preMousePoint.x = mouseX;
    cc.MouseDispatcher._preMousePoint.y = mouseY;
    return mouse
  }
  element.addEventListener("mousedown", function(event) {
    cc.Director.getInstance().getMouseDispatcher().mouseHandle(getMouseByEvent(event), event, cc.MOUSE_DOWN)
  });
  element.addEventListener("mouseup", function(event) {
    cc.Director.getInstance().getMouseDispatcher().mouseHandle(getMouseByEvent(event), event, cc.MOUSE_UP)
  });
  element.addEventListener("mousemove", function(event) {
    cc.Director.getInstance().getMouseDispatcher().mouseHandle(getMouseByEvent(event), event, cc.MOUSE_MOVED)
  });
  element.addEventListener("mousewheel", function(event) {
    var mouse = getMouseByEvent(event);
    mouse.setWheelDelta(event.wheelDelta);
    cc.Director.getInstance().getMouseDispatcher().mouseHandle(mouse, event, cc.SCROLL_WHEEL)
  }, false);
  element.addEventListener("DOMMouseScroll", function(event) {
    var mouse = getMouseByEvent(event);
    mouse.setWheelDelta(event.detail * -120);
    cc.Director.getInstance().getMouseDispatcher().mouseHandle(mouse, event, cc.SCROLL_WHEEL)
  });
  element.addEventListener("mouseout", function(event) {
    cc.Director.getInstance().getMouseDispatcher().mouseHandle(getMouseByEvent(event), event, cc.MOUSE_EXITED)
  }, false);
  element.addEventListener("mouseover", function(event) {
    cc.Director.getInstance().getMouseDispatcher().mouseHandle(getMouseByEvent(event), event, cc.MOUSE_ENTERED)
  }, false)
};
cc.KeyboardDelegate = cc.Class.extend({onKeyDown:function(keyCode) {
}, onKeyUp:function(keyCode) {
}});
cc.KeyboardHandler = cc.Class.extend({getDelegate:function() {
  return this._delegate
}, setDelegate:function(delegate) {
  this._delegate = delegate
}, initWithDelegate:function(delegate) {
  cc.Assert(delegate != null, "It's a wrong delegate!");
  this._delegate = delegate;
  return true
}, _delegate:null});
cc.KeyboardHandler.create = function(delegate) {
  var handler = new cc.KeyboardHandler;
  handler.initWithDelegate(delegate);
  return handler
};
cc.TYPE_BACK_CLICKED = 1;
cc.TYPE_MENU_CLICKED = 2;
cc.KEY = {backspace:8, tab:9, enter:13, shift:16, ctrl:17, alt:18, pause:19, capslock:20, escape:27, pageup:33, pagedown:34, end:35, home:36, left:37, up:38, right:39, down:40, insert:45, Delete:46, 0:48, 1:49, 2:50, 3:51, 4:52, 5:53, 6:54, 7:55, 8:56, 9:57, a:65, b:66, c:67, d:68, e:69, f:70, g:71, h:72, i:73, j:74, k:75, l:76, m:77, n:78, o:79, p:80, q:81, r:82, s:83, t:84, u:85, v:86, w:87, x:88, y:89, z:90, num0:96, num1:97, num2:98, num3:99, num4:100, num5:101, num6:102, num7:103, num8:104, 
num9:105, "*":106, "+":107, "-":109, "numdel":110, "/":111, f1:112, f2:113, f3:114, f4:115, f5:116, f6:117, f7:118, f8:119, f9:120, f10:121, f11:122, f12:123, numlock:144, scrolllock:145, semicolon:186, ",":186, equal:187, "=":187, ";":188, comma:188, dash:189, ".":190, period:190, forwardslash:191, grave:192, "[":219, openbracket:219, "]":221, closebracket:221, backslash:220, quote:222, space:32};
cc.KeyboardDispatcher = cc.Class.extend({addDelegate:function(delegate) {
  if(!delegate) {
    return
  }
  if(!this._locked) {
    this.forceAddDelegate(delegate)
  }else {
    this._handlersToAdd.push(delegate);
    this._toAdd = true
  }
}, removeDelegate:function(delegate) {
  if(!delegate) {
    return
  }
  if(!this._locked) {
    this.forceRemoveDelegate(delegate)
  }else {
    this._handlersToRemove.push(delegate);
    this._toRemove = true
  }
}, forceAddDelegate:function(delegate) {
  var handler = cc.KeyboardHandler.create(delegate);
  if(handler) {
    for(var i = 0;i < this._delegates;i++) {
      if(this._delegates[i].getDelegate() == handler.getDelegate()) {
      }
    }
    this._delegates.push(handler)
  }
}, forceRemoveDelegate:function(delegate) {
  for(var i = 0;i < this._delegates.length;i++) {
    if(this._delegates[i].getDelegate() == delegate) {
      this._delegates.splice(i, 1);
      return
    }
  }
}, dispatchKeyboardMSG:function(e, keydown) {
  this._locked = true;
  e.stopPropagation();
  e.preventDefault();
  var i = 0;
  if(keydown && e) {
    for(i = 0;i < this._delegates.length;i++) {
      if(this._delegates[i].getDelegate() && this._delegates[i].getDelegate().onKeyDown) {
        this._delegates[i].getDelegate().onKeyDown(e.keyCode)
      }
    }
  }else {
    if(!keydown && e) {
      for(i = 0;i < this._delegates.length;i++) {
        if(this._delegates[i].getDelegate() && this._delegates[i].getDelegate().onKeyUp) {
          this._delegates[i].getDelegate().onKeyUp(e.keyCode)
        }
      }
    }
  }
  this._locked = false;
  if(this._toRemove) {
    this._toRemove = false;
    for(i = 0;i < this._handlersToRemove.length;++i) {
      this.forceRemoveDelegate(this._handlersToRemove[i])
    }
    delete this._handlersToRemove;
    this._handlersToRemove = []
  }
  if(this._toAdd) {
    this._toAdd = false;
    for(i = 0;i < this._handlersToAdd.length;++i) {
      this.forceAddDelegate(this._handlersToAdd[i])
    }
    this._handlersToAdd = []
  }
  return true
}, _delegates:[], _locked:false, _toAdd:false, _toRemove:false, _handlersToAdd:[], _handlersToRemove:[]});
cc.KeyboardDispatcher.getInstance = function() {
  if(!cc.keyboardDispatcher) {
    cc.keyboardDispatcher = new cc.KeyboardDispatcher;
    cc.canvas.setAttribute("tabindex", 1);
    cc.canvas.style.outline = "none";
    cc.canvas.style.cursor = "default";
    cc.canvas.addEventListener("keydown", function(e) {
      cc.keyboardDispatcher.dispatchKeyboardMSG(e, true)
    });
    cc.canvas.addEventListener("keyup", function(e) {
      cc.keyboardDispatcher.dispatchKeyboardMSG(e, false)
    })
  }
  return cc.keyboardDispatcher
};
cc.KeyboardDispatcher.purgeSharedDispatcher = function() {
  if(cc.keyboardDispatcher) {
    delete cc.keyboardDispatcher;
    cc.keyboardDispatcher = null
  }
};
cc.IMEKeyboardNotificationInfo = function(begin, end, duration) {
  this.begin = begin || cc.RectZero();
  this.end = end || cc.RectZero();
  this.duration = duration || 0
};
cc.IMEDelegate = cc.Class.extend({ctor:function() {
  cc.IMEDispatcher.getInstance().addDelegate(this)
}, removeDelegate:function() {
  cc.IMEDispatcher.getInstance().removeDelegate(this)
}, attachWithIME:function() {
  return cc.IMEDispatcher.getInstance().attachDelegateWithIME(this)
}, detachWithIME:function() {
  return cc.IMEDispatcher.getInstance().detachDelegateWithIME(this)
}, canAttachWithIME:function() {
  return false
}, didAttachWithIME:function() {
}, canDetachWithIME:function() {
  return false
}, didDetachWithIME:function() {
}, insertText:function(text, len) {
}, deleteBackward:function() {
}, getContentText:function() {
  return""
}, keyboardWillShow:function(info) {
}, keyboardDidShow:function(info) {
}, keyboardWillHide:function(info) {
}, keyboardDidHide:function(info) {
}});
cc.IMEDispatcher = cc.Class.extend({_domInputControl:null, impl:null, _currentInputString:"", _lastClickPosition:null, ctor:function() {
  this.impl = new cc.IMEDispatcher.Impl;
  this._lastClickPosition = cc.p(0, 0)
}, init:function() {
  if(cc.Browser.isMobile) {
    return
  }
  this._domInputControl = cc.$("#imeDispatcherInput");
  if(!this._domInputControl) {
    this._domInputControl = cc.$new("input");
    this._domInputControl.setAttribute("type", "text");
    this._domInputControl.setAttribute("id", "imeDispatcherInput");
    this._domInputControl.resize(0, 0);
    this._domInputControl.translates(0, 0);
    this._domInputControl.style.opacity = "0";
    this._domInputControl.style.fontSize = "1px";
    this._domInputControl.setAttribute("tabindex", 2);
    this._domInputControl.style.position = "absolute";
    this._domInputControl.style.top = 0;
    this._domInputControl.style.left = 0;
    document.body.appendChild(this._domInputControl)
  }
  var selfPointer = this;
  this._domInputControl.addEventListener("input", function() {
    selfPointer._processDomInputString(selfPointer._domInputControl.value)
  }, false);
  this._domInputControl.addEventListener("keydown", function(e) {
    if(e.keyCode === cc.KEY.tab) {
      e.stopPropagation();
      e.preventDefault()
    }else {
      if(e.keyCode == cc.KEY.enter) {
        selfPointer.dispatchInsertText("\n", 1);
        e.stopPropagation();
        e.preventDefault()
      }
    }
  }, false);
  if(/msie/i.test(navigator.userAgent)) {
    this._domInputControl.addEventListener("keyup", function(e) {
      if(e.keyCode == cc.KEY.backspace) {
        selfPointer._processDomInputString(selfPointer._domInputControl.value)
      }
    }, false)
  }
  window.addEventListener("mousedown", function(event) {
    var tx = event.pageX || 0;
    var ty = event.pageY || 0;
    selfPointer._lastClickPosition = cc.p(tx, ty)
  }, false)
}, _processDomInputString:function(text) {
  var i, startPos;
  var len = this._currentInputString.length < text.length ? this._currentInputString.length : text.length;
  for(startPos = 0;startPos < len;startPos++) {
    if(text[startPos] !== this._currentInputString[startPos]) {
      break
    }
  }
  var delTimes = this._currentInputString.length - startPos;
  var insTimes = text.length - startPos;
  for(i = 0;i < delTimes;i++) {
    this.dispatchDeleteBackward()
  }
  for(i = 0;i < insTimes;i++) {
    this.dispatchInsertText(text[startPos + i], 1)
  }
  this._currentInputString = text
}, dispatchInsertText:function(text, len) {
  if(!this.impl || !text || len <= 0) {
    return
  }
  if(!this.impl._delegateWithIme) {
    return
  }
  this.impl._delegateWithIme.insertText(text, len)
}, dispatchDeleteBackward:function() {
  if(!this.impl) {
    return
  }
  if(!this.impl._delegateWithIme) {
    return
  }
  this.impl._delegateWithIme.deleteBackward()
}, getContentText:function() {
  if(this.impl && this.impl._delegateWithIme) {
    var pszContentText = this.impl._delegateWithIme.getContentText();
    return pszContentText ? pszContentText : ""
  }
  return""
}, dispatchKeyboardWillShow:function(info) {
  if(this.impl) {
    for(var i = 0;i < this.impl._delegateList.length;i++) {
      var delegate = this.impl._delegateList[i];
      if(delegate) {
        delegate.keyboardWillShow(info)
      }
    }
  }
}, dispatchKeyboardDidShow:function(info) {
  if(this.impl) {
    for(var i = 0;i < this.impl._delegateList.length;i++) {
      var delegate = this.impl._delegateList[i];
      if(delegate) {
        delegate.keyboardDidShow(info)
      }
    }
  }
}, dispatchKeyboardWillHide:function(info) {
  if(this.impl) {
    for(var i = 0;i < this.impl._delegateList.length;i++) {
      var delegate = this.impl._delegateList[i];
      if(delegate) {
        delegate.keyboardWillHide(info)
      }
    }
  }
}, dispatchKeyboardDidHide:function(info) {
  if(this.impl) {
    for(var i = 0;i < this.impl._delegateList.length;i++) {
      var delegate = this.impl._delegateList[i];
      if(delegate) {
        delegate.keyboardDidHide(info)
      }
    }
  }
}, addDelegate:function(delegate) {
  if(!delegate || !this.impl) {
    return
  }
  if(this.impl._delegateList.indexOf(delegate) > -1) {
    return
  }
  this.impl._delegateList = cc.ArrayAppendObjectToIndex(this.impl._delegateList, delegate, 0)
}, attachDelegateWithIME:function(delegate) {
  if(!this.impl || !delegate) {
    return false
  }
  if(this.impl._delegateList.indexOf(delegate) == -1) {
    return false
  }
  if(this.impl._delegateWithIme) {
    if(!this.impl._delegateWithIme.canDetachWithIME() || !delegate.canAttachWithIME()) {
      return false
    }
    var pOldDelegate = this.impl._delegateWithIme;
    this.impl._delegateWithIme = null;
    pOldDelegate.didDetachWithIME();
    this._focusDomInput(delegate);
    return true
  }
  if(!delegate.canAttachWithIME()) {
    return false
  }
  this._focusDomInput(delegate);
  return true
}, _focusDomInput:function(delegate) {
  if(cc.Browser.isMobile) {
    this.impl._delegateWithIme = delegate;
    delegate.didAttachWithIME();
    this._currentInputString = delegate.getString ? delegate.getString() : "";
    var userInput = prompt("please enter your word:", this._currentInputString);
    if(userInput != null) {
      this._processDomInputString(userInput)
    }
    this.dispatchInsertText("\n", 1)
  }else {
    this.impl._delegateWithIme = delegate;
    this._currentInputString = delegate.getString ? delegate.getString() : "";
    delegate.didAttachWithIME();
    this._domInputControl.focus();
    this._domInputControl.value = this._currentInputString;
    this._domInputControlTranslate()
  }
}, _domInputControlTranslate:function() {
  if(/msie/i.test(navigator.userAgent)) {
    this._domInputControl.style.left = this._lastClickPosition.x + "px";
    this._domInputControl.style.top = this._lastClickPosition.y + "px"
  }else {
    this._domInputControl.translates(this._lastClickPosition.x, this._lastClickPosition.y)
  }
}, detachDelegateWithIME:function(delegate) {
  if(!this.impl || !delegate) {
    return false
  }
  if(this.impl._delegateWithIme != delegate) {
    return false
  }
  if(!delegate.canDetachWithIME()) {
    return false
  }
  this.impl._delegateWithIme = null;
  delegate.didDetachWithIME();
  cc.canvas.focus();
  return true
}, removeDelegate:function(delegate) {
  if(!this.impl || !delegate) {
    return
  }
  if(this.impl._delegateList.indexOf(delegate) == -1) {
    return
  }
  if(this.impl._delegateWithIme) {
    if(delegate == this.impl._delegateWithIme) {
      this.impl._delegateWithIme = null
    }
  }
  cc.ArrayRemoveObject(this.impl._delegateList, delegate)
}, processKeycode:function(keyCode) {
  if(keyCode < 32) {
    if(keyCode == cc.KEY.backspace) {
      this.dispatchDeleteBackward()
    }else {
      if(keyCode == cc.KEY.enter) {
        this.dispatchInsertText("\n", 1)
      }else {
        if(keyCode == cc.KEY.tab) {
        }else {
          if(keyCode == cc.KEY.escape) {
          }
        }
      }
    }
  }else {
    if(keyCode < 255) {
      this.dispatchInsertText(String.fromCharCode(keyCode), 1)
    }else {
    }
  }
}});
cc.IMEDispatcher.Impl = cc.Class.extend({_delegateWithIme:null, _delegateList:null, ctor:function() {
  this._delegateList = []
}, findDelegate:function(delegate) {
  for(var i = 0;i < this._delegateList.length;i++) {
    if(this._delegateList[i] == delegate) {
      return i
    }
  }
  return null
}});
cc.IMEDispatcher.getInstance = function() {
  if(!cc.IMEDispatcher.instance) {
    cc.IMEDispatcher.instance = new cc.IMEDispatcher;
    cc.IMEDispatcher.instance.init()
  }
  return cc.IMEDispatcher.instance
};
cc.IMEDispatcher.instance = null;
cc.TextFieldDelegate = cc.Class.extend({onTextFieldAttachWithIME:function(sender) {
  return false
}, onTextFieldDetachWithIME:function(sender) {
  return false
}, onTextFieldInsertText:function(sender, text, len) {
  return false
}, onTextFieldDeleteBackward:function(sender, delText, len) {
  return false
}, onDraw:function(sender) {
  return false
}});
cc.TextFieldTTF = cc.LabelTTF.extend({_lens:null, _inputText:"", _placeHolder:"", _charCount:0, _delegate:null, _ColorSpaceHolder:null, ctor:function() {
  this._ColorSpaceHolder = new cc.Color3B(127, 127, 127);
  cc.IMEDispatcher.getInstance().addDelegate(this);
  this._super()
}, getDelegate:function() {
  return this._delegate
}, setDelegate:function(value) {
  this._delegate = value
}, getCharCount:function() {
  return this._charCount
}, getColorSpaceHolder:function() {
  return this._ColorSpaceHolder
}, setColorSpaceHolder:function(value) {
  this._ColorSpaceHolder = value
}, initWithPlaceHolder:function(placeholder, dimensions, alignment, fontName, fontSize) {
  switch(arguments.length) {
    case 5:
      if(placeholder) {
        this._placeHolder = placeholder
      }
      return this.initWithString(this._placeHolder, dimensions, alignment, fontName, fontSize);
      break;
    case 3:
      if(placeholder) {
        this._placeHolder = placeholder
      }
      fontName = arguments[1];
      fontSize = arguments[2];
      return this.initWithString(this._placeHolder, fontName, fontSize);
      break;
    default:
      throw"Argument must be non-nil ";break
  }
}, setString:function(text, isCallParent) {
  if(isCallParent && isCallParent == true) {
    this._super(text);
    return
  }
  this._inputText = text || "";
  if(!this._inputText.length) {
    this._super(this._placeHolder)
  }else {
    this._super(this._inputText)
  }
  this._charCount = this._inputText.length
}, getString:function() {
  return this._inputText
}, setPlaceHolder:function(text) {
  this._placeHolder = text || "";
  if(!this._inputText.length) {
    cc.LabelTTF.prototype.setString.call(this, this._placeHolder)
  }
}, getPlaceHolder:function() {
  return this._placeHolder
}, draw:function(ctx) {
  var context = ctx || cc.renderContext;
  if(this._delegate && this._delegate.onDraw(this)) {
    return
  }
  if(this._inputText && this._inputText.length > 0) {
    this._super(context);
    return
  }
  var color = this.getColor();
  this.setColor(this._ColorSpaceHolder);
  this._super(context);
  this.setColor(color)
}, attachWithIME:function() {
  return cc.IMEDispatcher.getInstance().attachDelegateWithIME(this)
}, detachWithIME:function() {
  return cc.IMEDispatcher.getInstance().detachDelegateWithIME(this)
}, canAttachWithIME:function() {
  return this._delegate ? !this._delegate.onTextFieldAttachWithIME(this) : true
}, didAttachWithIME:function() {
}, canDetachWithIME:function() {
  return this._delegate ? !this._delegate.onTextFieldDetachWithIME(this) : true
}, didDetachWithIME:function() {
}, deleteBackward:function() {
  var strLen = this._inputText.length;
  if(strLen == 0) {
    return
  }
  var deleteLen = 1;
  if(this._delegate && this._delegate.onTextFieldDeleteBackward(this, this._inputText[strLen - deleteLen], deleteLen)) {
    return
  }
  if(strLen <= deleteLen) {
    this._inputText = "";
    this._charCount = 0;
    cc.LabelTTF.prototype.setString.call(this, this._placeHolder);
    return
  }
  var sText = this._inputText.substring(0, strLen - deleteLen);
  this.setString(sText, false)
}, removeDelegate:function() {
  cc.IMEDispatcher.getInstance().removeDelegate(this)
}, insertText:function(text, len) {
  var sInsert = text;
  var pos = sInsert.indexOf("\n");
  if(pos > -1) {
    sInsert = sInsert.substring(0, pos)
  }
  if(sInsert.length > 0) {
    if(this._delegate && this._delegate.onTextFieldInsertText(this, sInsert, sInsert.length)) {
      return
    }
    var sText = this._inputText + sInsert;
    this._charCount = sText.length;
    this.setString(sText)
  }
  if(pos == -1) {
    return
  }
  if(this._delegate && this._delegate.onTextFieldInsertText(this, "\n", 1)) {
    return
  }
  this.detachWithIME()
}, getContentText:function() {
  return this._inputText
}, keyboardWillShow:function(info) {
}, keyboardDidShow:function(info) {
}, keyboardWillHide:function(info) {
}, keyboardDidHide:function(info) {
}});
cc.TextFieldTTF.create = function(placeholder, dimensions, alignment, fontName, fontSize) {
  var ret;
  switch(arguments.length) {
    case 5:
      ret = new cc.TextFieldTTF;
      if(ret && ret.initWithPlaceHolder("", dimensions, alignment, fontName, fontSize)) {
        if(placeholder) {
          ret.setPlaceHolder(placeholder)
        }
        return ret
      }
      return null;
      break;
    case 3:
      ret = new cc.TextFieldTTF;
      fontName = arguments[1];
      fontSize = arguments[2];
      if(ret && ret.initWithString(["", fontName, fontSize])) {
        if(placeholder) {
          ret.setPlaceHolder(placeholder)
        }
        return ret
      }
      return null;
      break;
    default:
      throw"Argument must be non-nil ";break
  }
};
cc.Configuration = cc.Class.extend({_maxTextureSize:0, _maxModelviewStackDepth:0, _supportsPVRTC:false, _supportsNPOT:false, _supportsBGRA8888:false, _supportsDiscardFramebuffer:false, _supportsShareableVAO:false, _maxSamplesAllowed:0, _maxTextureUnits:0, _GlExtensions:"", getMaxTextureSize:function() {
  return this._maxTextureSize
}, getMaxModelviewStackDepth:function() {
  return this._maxModelviewStackDepth
}, getMaxTextureUnits:function() {
  return this._maxTextureUnits
}, supportsNPOT:function() {
  return this._supportsNPOT
}, supportsPVRTC:function() {
  return this._supportsPVRTC
}, supportsBGRA8888:function() {
  return this._supportsBGRA8888
}, supportsDiscardFramebuffer:function() {
  return this._supportsDiscardFramebuffer
}, supportsShareableVAO:function() {
  return this._supportsShareableVAO
}, checkForGLExtension:function(searchName) {
  return this._GlExtensions.indexOf(searchName) > -1
}, init:function() {
  if(cc.renderContextType === cc.CANVAS) {
    return true
  }
  var gl = cc.renderContext;
  cc.log("cocos2d: GL_VENDOR:     " + gl.getParameter(gl.VENDOR));
  cc.log("cocos2d: GL_RENDERER:   " + gl.getParameter(gl.RENDERER));
  cc.log("cocos2d: GL_VERSION:    " + gl.getParameter(gl.VERSION));
  this._GlExtensions = "";
  var extArr = gl.getSupportedExtensions();
  for(var i = 0;i < extArr.length;i++) {
    this._GlExtensions += extArr[i] + " "
  }
  cc.log("cocos2d: GL_EXTENSIONS:  " + this._GlExtensions);
  this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  this._maxTextureUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
  this._supportsNPOT = true;
  this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
  this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
  this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
  cc.log("cocos2d: GL_MAX_TEXTURE_SIZE: " + this._maxTextureSize);
  cc.log("cocos2d: GL_MAX_TEXTURE_UNITS: " + this._maxTextureUnits);
  cc.log("cocos2d: GL supports PVRTC: " + (this._supportsPVRTC ? "YES" : "NO"));
  cc.log("cocos2d: GL supports BGRA8888 textures: " + (this._supportsBGRA8888 ? "YES" : "NO"));
  cc.log("cocos2d: GL supports NPOT textures: " + (this._supportsNPOT ? "YES" : "NO"));
  cc.log("cocos2d: GL supports discard_framebuffer: " + (this._supportsDiscardFramebuffer ? "YES" : "NO"));
  cc.log("cocos2d: GL supports shareable VAO: " + (this._supportsShareableVAO ? "YES" : "NO"));
  if(cc.ENABLE_GL_STATE_CACHE == 0) {
    cc.log("cocos2d: **** WARNING **** CC_ENABLE_GL_STATE_CACHE is disabled. To improve performance, enable it by editing ccConfig.h")
  }
  cc.CHECK_GL_ERROR_DEBUG();
  return true
}});
cc.Configuration._sharedConfiguration = null;
cc.Configuration.getInstance = function() {
  if(!cc.Configuration._sharedConfiguration) {
    cc.Configuration._sharedConfiguration = new cc.Configuration;
    cc.Configuration._sharedConfiguration.init()
  }
  return cc.Configuration._sharedConfiguration
};
cc.Configuration.purgeConfiguration = function() {
  cc.Configuration._sharedConfiguration = null
};
cc.g_NumberOfDraws = 0;
cc.DIRECTOR_PROJECTION_2D = 0;
cc.DIRECTOR_PROJECTION_3D = 1;
cc.DIRECTOR_PROJECTION_CUSTOM = 3;
cc.DIRECTOR_PROJECTION_DEFAULT = cc.DIRECTOR_PROJECTION_3D;
cc.DEVICE_ORIENTATION_PORTRAIT = 0;
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;
cc.DEVICE_MAX_ORIENTATIONS = 2;
cc.DirectorDelegate = cc.Class.extend({updateProjection:function() {
}});
cc.GLToClipTransform = function(transformOut) {
  var projection = new cc.kmMat4;
  cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, projection);
  var modelview = new cc.kmMat4;
  cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, modelview);
  cc.kmMat4Multiply(transformOut, projection, modelview)
};
cc.Director = cc.Class.extend({_landscape:false, _nextDeltaTimeZero:false, _paused:false, _purgeDirecotorInNextLoop:false, _sendCleanupToScene:false, _animationInterval:0, _oldAnimationInterval:0, _projection:0, _accumDt:0, _contentScaleFactor:1, _displayStats:false, _deltaTime:0, _frameRate:0, _FPSLabel:null, _SPFLabel:null, _drawsLabel:null, _winSizeInPoints:null, _lastUpdate:null, _nextScene:null, _notificationNode:null, _openGLView:null, _scenesStack:null, _projectionDelegate:null, _runningScene:null, 
_frames:0, _totalFrames:0, _secondsPerFrame:0, _dirtyRegion:null, _scheduler:null, _actionManager:null, _touchDispatcher:null, _keyboardDispatcher:null, _accelerometer:null, _mouseDispatcher:null, _isBlur:false, ctor:function() {
  this._lastUpdate = Date.now();
  if(!cc.isAddedHiddenEvent) {
    var selfPointer = this;
    window.addEventListener("focus", function() {
      selfPointer._lastUpdate = Date.now()
    }, false)
  }
}, _resetLastUpdate:function() {
  this._lastUpdate = Date.now()
}, init:function() {
  this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
  this._scenesStack = [];
  this._projection = cc.DIRECTOR_PROJECTION_DEFAULT;
  this._projectionDelegate = null;
  this._accumDt = 0;
  this._frameRate = 0;
  this._displayStats = false;
  this._totalFrames = this._frames = 0;
  this._lastUpdate = Date.now();
  this._paused = false;
  this._purgeDirecotorInNextLoop = false;
  this._winSizeInPoints = cc.size(0, 0);
  this._openGLView = null;
  this._contentScaleFactor = 1;
  this._scheduler = new cc.Scheduler;
  this._actionManager = new cc.ActionManager;
  this._scheduler.scheduleUpdateForTarget(this._actionManager, cc.PRIORITY_SYSTEM, false);
  this._touchDispatcher = new cc.TouchDispatcher;
  this._touchDispatcher.init();
  this._keyboardDispatcher = cc.KeyboardDispatcher.getInstance();
  this._accelerometer = new cc.Accelerometer;
  this._mouseDispatcher = new cc.MouseDispatcher;
  this._mouseDispatcher.init();
  return true
}, calculateDeltaTime:function() {
  var now = Date.now();
  if(this._nextDeltaTimeZero) {
    this._deltaTime = 0;
    this._nextDeltaTimeZero = false
  }else {
    this._deltaTime = (now - this._lastUpdate) / 1E3
  }
  if(cc.COCOS2D_DEBUG > 0 && this._deltaTime > 0.2) {
    this._deltaTime = 1 / 60
  }
  this._lastUpdate = now
}, convertToGL:function(uiPoint) {
  var transform = new cc.kmMat4;
  cc.GLToClipTransform(transform);
  var transformInv = new cc.kmMat4;
  cc.kmMat4Inverse(transformInv, transform);
  var zClip = transform.mat[14] / transform.mat[15];
  var glSize = this._openGLView.getDesignResolutionSize();
  var clipCoord = new cc.kmVec3(2 * uiPoint.x / glSize.width - 1, 1 - 2 * uiPoint.y / glSize.height, zClip);
  var glCoord = new cc.kmVec3;
  cc.kmVec3TransformCoord(glCoord, clipCoord, transformInv);
  return cc.p(glCoord.x, glCoord.y)
}, convertToUI:function(glPoint) {
  var transform = new cc.kmMat4;
  cc.GLToClipTransform(transform);
  var clipCoord = new cc.kmVec3;
  var glCoord = new cc.kmVec3(glPoint.x, glPoint.y, 0);
  cc.kmVec3TransformCoord(clipCoord, glCoord, transform);
  var glSize = this._openGLView.getDesignResolutionSize();
  return cc.p(glSize.width * (clipCoord.x * 0.5 + 0.5), glSize.height * (-clipCoord.y * 0.5 + 0.5))
}, drawScene:function() {
  this.calculateDeltaTime();
  if(!this._paused) {
    this._scheduler.update(this._deltaTime)
  }
  if(cc.renderContextType === cc.CANVAS) {
    this._drawSceneForCanvas()
  }else {
    this._drawSceneForWebGL()
  }
  this._totalFrames++;
  if(this._displayStats) {
    this._calculateMPF()
  }
}, _drawSceneForCanvas:function() {
  cc.renderContext.clearRect(0, 0, cc.canvas.width, -cc.canvas.height);
  if(this._nextScene) {
    this.setNextScene()
  }
  if(this._runningScene) {
    this._runningScene.visit()
  }
  if(this._notificationNode) {
    this._notificationNode.visit()
  }
  if(this._displayStats) {
    this._showStats()
  }
}, _drawSceneForWebGL:function() {
  var gl = cc.renderContext;
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  if(this._nextScene) {
    this.setNextScene()
  }
  cc.kmGLPushMatrix();
  if(this._runningScene) {
    this._runningScene.visit()
  }
  if(this._notificationNode) {
    this._notificationNode.visit()
  }
  if(this._displayStats) {
    this._showStats()
  }
  cc.kmGLPopMatrix()
}, addRegionToDirtyRegion:function(rect) {
  if(!rect) {
    return
  }
  if(!this._dirtyRegion) {
    this._dirtyRegion = cc.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
    return
  }
  this._dirtyRegion = cc.Rect.CCRectUnion(this._dirtyRegion, cc.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height))
}, rectIsInDirtyRegion:function(rect) {
  if(!rect || !this._fullRect) {
    return false
  }
  return cc.Rect.CCRectIntersectsRect(this._fullRect, rect)
}, end:function() {
  this._purgeDirecotorInNextLoop = true
}, getContentScaleFactor:function() {
  return this._contentScaleFactor
}, getNotificationNode:function() {
  return this._notificationNode
}, getWinSize:function() {
  return this._winSizeInPoints
}, getWinSizeInPixels:function() {
  return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
}, getVisibleSize:function() {
  if(this._openGLView) {
    return this._openGLView.getVisibleSize()
  }else {
    return cc.size(0, 0)
  }
}, getVisibleOrigin:function() {
  if(this._openGLView) {
    return this._openGLView.getVisibleOrigin()
  }else {
    return cc.p(0, 0)
  }
}, getZEye:function() {
  return this._winSizeInPoints.height / 1.1566
}, pause:function() {
  if(this._paused) {
    return
  }
  this._oldAnimationInterval = this._animationInterval;
  this.setAnimationInterval(1 / 4);
  this._paused = true
}, popScene:function() {
  cc.Assert(this._runningScene != null, "running scene should not null");
  this._scenesStack.pop();
  var c = this._scenesStack.length;
  if(c == 0) {
    this.end()
  }else {
    this._sendCleanupToScene = true;
    this._nextScene = this._scenesStack[c - 1]
  }
}, purgeCachedData:function() {
  cc.LabelBMFont.purgeCachedData()
}, purgeDirector:function() {
  this.getScheduler().unscheduleAllCallbacks();
  this._touchDispatcher.removeAllDelegates();
  if(this._runningScene) {
    this._runningScene.onExitTransitionDidStart();
    this._runningScene.onExit();
    this._runningScene.cleanup()
  }
  this._runningScene = null;
  this._nextScene = null;
  this._scenesStack = [];
  this.stopAnimation();
  cc.LabelBMFont.purgeCachedData();
  cc.AnimationCache.purgeSharedAnimationCache();
  cc.SpriteFrameCache.purgeSharedSpriteFrameCache();
  cc.TextureCache.purgeSharedTextureCache();
  cc.CHECK_GL_ERROR_DEBUG()
}, pushScene:function(scene) {
  cc.Assert(scene, "the scene should not null");
  this._sendCleanupToScene = false;
  this._scenesStack.push(scene);
  this._nextScene = scene
}, replaceScene:function(scene) {
  cc.Assert(this._runningScene, "Use runWithScene: instead to start the director");
  cc.Assert(scene != null, "the scene should not be null");
  var i = this._scenesStack.length;
  this._sendCleanupToScene = true;
  this._scenesStack[i - 1] = scene;
  this._nextScene = scene
}, resume:function() {
  if(!this._paused) {
    return
  }
  this.setAnimationInterval(this._oldAnimationInterval);
  this._lastUpdate = Date.now();
  if(!this._lastUpdate) {
    cc.log("cocos2d: Director: Error in gettimeofday")
  }
  this._paused = false;
  this._deltaTime = 0
}, runWithScene:function(scene) {
  cc.Assert(scene != null, "This command can only be used to start the CCDirector. There is already a scene present.");
  cc.Assert(this._runningScene == null, "_runningScene should be null");
  this.pushScene(scene);
  this.startAnimation()
}, setAlphaBlending:function(on) {
  if(on) {
    cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST)
  }else {
    cc.glBlendFunc(cc.renderContext.ONE, cc.renderContext.ZERO)
  }
}, setContentScaleFactor:function(scaleFactor) {
  if(scaleFactor != this._contentScaleFactor) {
    this._contentScaleFactor = scaleFactor;
    this._createStatsLabel()
  }
}, setDepthTest:function(on) {
  if(cc.renderContextType === cc.CANVAS) {
    return
  }
  if(on) {
    cc.renderContext.clearDepth(1);
    cc.renderContext.enable(cc.renderContext.DEPTH_TEST);
    cc.renderContext.depthFunc(cc.renderContext.LEQUAL)
  }else {
    cc.renderContext.disable(cc.renderContext.DEPTH_TEST)
  }
}, setGLDefaultValues:function() {
  this.setAlphaBlending(true);
  this.setDepthTest(false);
  this.setProjection(this._projection);
  cc.renderContext.clearColor(0, 0, 0, 1)
}, setNextDeltaTimeZero:function(nextDeltaTimeZero) {
  this._nextDeltaTimeZero = nextDeltaTimeZero
}, setNextScene:function() {
  var runningIsTransition = this._runningScene ? this._runningScene instanceof cc.TransitionScene : false;
  var newIsTransition = this._nextScene ? this._nextScene instanceof cc.TransitionScene : false;
  if(!newIsTransition) {
    if(this._runningScene) {
      this._runningScene.onExitTransitionDidStart();
      this._runningScene.onExit()
    }
    if(this._sendCleanupToScene && this._runningScene) {
      this._runningScene.cleanup()
    }
  }
  this._runningScene = this._nextScene;
  this._nextScene = null;
  if(!runningIsTransition && this._runningScene != null) {
    this._runningScene.onEnter();
    this._runningScene.onEnterTransitionDidFinish()
  }
}, setNotificationNode:function(node) {
  this._notificationNode = node
}, getDelegate:function() {
  return this._projectionDelegate
}, setDelegate:function(delegate) {
  this._projectionDelegate = delegate
}, setOpenGLView:function(openGLView) {
  this._winSizeInPoints = cc.size(cc.canvas.width, cc.canvas.height);
  if(cc.renderContextType === cc.CANVAS) {
    return
  }
  this._openGLView = openGLView || cc.EGLView.getInstance();
  this._createStatsLabel();
  this.setGLDefaultValues();
  this._touchDispatcher.setDispatchEvents(true)
}, setProjection:function(projection) {
  var size = this._winSizeInPoints;
  if(cc.renderContextType === cc.WEBGL) {
    if(this._openGLView) {
      this._openGLView.setViewPortInPoints(0, 0, size.width, size.height)
    }
    switch(projection) {
      case cc.DIRECTOR_PROJECTION_2D:
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLLoadIdentity();
        var orthoMatrix = new cc.kmMat4;
        cc.kmMat4OrthographicProjection(orthoMatrix, 0, size.width, 0, size.height, -1024, 1024);
        cc.kmGLMultMatrix(orthoMatrix);
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLLoadIdentity();
        break;
      case cc.DIRECTOR_PROJECTION_3D:
        var zeye = this.getZEye();
        var matrixPerspective = new cc.kmMat4, matrixLookup = new cc.kmMat4;
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLLoadIdentity();
        cc.kmMat4PerspectiveProjection(matrixPerspective, 60, size.width / size.height, 0.1, zeye * 2);
        cc.kmGLMultMatrix(matrixPerspective);
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLLoadIdentity();
        var eye = cc.kmVec3Fill(null, size.width / 2, size.height / 2, zeye);
        var center = cc.kmVec3Fill(null, size.width / 2, size.height / 2, 0);
        var up = cc.kmVec3Fill(null, 0, 1, 0);
        cc.kmMat4LookAt(matrixLookup, eye, center, up);
        cc.kmGLMultMatrix(matrixLookup);
        break;
      case cc.DIRECTOR_PROJECTION_CUSTOM:
        if(this._projectionDelegate) {
          this._projectionDelegate.updateProjection()
        }
        break;
      default:
        cc.log("cocos2d: Director: unrecognized projection");
        break
    }
  }
  this._projection = projection;
  cc.setProjectionMatrixDirty()
}, _showStats:function() {
  this._frames++;
  this._accumDt += this._deltaTime;
  if(this._displayStats) {
    if(this._FPSLabel && this._SPFLabel && this._drawsLabel) {
      if(this._accumDt > cc.DIRECTOR_FPS_INTERVAL) {
        this._SPFLabel.setString(this._secondsPerFrame.toFixed(3));
        this._frameRate = this._frames / this._accumDt;
        this._frames = 0;
        this._accumDt = 0;
        this._FPSLabel.setString(this._frameRate.toFixed(1));
        this._drawsLabel.setString((0 | cc.g_NumberOfDraws).toString())
      }
      this._FPSLabel.visit();
      this._SPFLabel.visit();
      this._drawsLabel.visit()
    }else {
      this._createStatsLabel()
    }
  }
  cc.g_NumberOfDraws = 0
}, isSendCleanupToScene:function() {
  return this._sendCleanupToScene
}, getRunningScene:function() {
  return this._runningScene
}, getAnimationInterval:function() {
  return this._animationInterval
}, isDisplayStats:function() {
  return this._displayStats
}, setDisplayStats:function(displayStats) {
  this._displayStats = displayStats
}, getSecondsPerFrame:function() {
  return this._secondsPerFrame
}, getOpenGLView:function() {
  return this._openGLView
}, isNextDeltaTimeZero:function() {
  return this._nextDeltaTimeZero
}, isPaused:function() {
  return this._paused
}, getTotalFrames:function() {
  return this._totalFrames
}, getProjection:function() {
  return this._projection
}, popToRootScene:function() {
  cc.Assert(this._runningScene != null, "A running Scene is needed");
  var c = this._scenesStack.length;
  if(c == 1) {
    this._scenesStack.pop();
    this.end()
  }else {
    while(c > 1) {
      var current = this._scenesStack.pop();
      if(current.isRunning()) {
        current.onExitTransitionDidStart();
        current.onExit()
      }
      current.cleanup();
      c--
    }
    this._nextScene = this._scenesStack[this._scenesStack.length - 1];
    this._sendCleanupToScene = false
  }
}, getScheduler:function() {
  return this._scheduler
}, setScheduler:function(scheduler) {
  if(this._scheduler != scheduler) {
    this._scheduler = scheduler
  }
}, getActionManager:function() {
  return this._actionManager
}, setActionManager:function(actionManager) {
  if(this._actionManager != actionManager) {
    this._actionManager = actionManager
  }
}, getTouchDispatcher:function() {
  return this._touchDispatcher
}, setTouchDispatcher:function(touchDispatcher) {
  if(this._touchDispatcher != touchDispatcher) {
    this._touchDispatcher = touchDispatcher
  }
}, getKeyboardDispatcher:function() {
  return this._keyboardDispatcher
}, setKeyboardDispatcher:function(keyboardDispatcher) {
  this._keyboardDispatcher = keyboardDispatcher
}, getAccelerometer:function() {
  return this._accelerometer
}, setAccelerometer:function(accelerometer) {
  if(this._accelerometer != accelerometer) {
    this._accelerometer = accelerometer
  }
}, getMouseDispatcher:function() {
  return this._mouseDispatcher
}, setMouseDispatcher:function(mouseDispatcher) {
  if(this._mouseDispatcher != mouseDispatcher) {
    this._mouseDispatcher = mouseDispatcher
  }
}, _createStatsLabel:function() {
  var fontSize = 0;
  if(this._winSizeInPoints.width > this._winSizeInPoints.height) {
    fontSize = 0 | this._winSizeInPoints.height / 320 * 24
  }else {
    fontSize = 0 | this._winSizeInPoints.width / 320 * 24
  }
  this._FPSLabel = cc.LabelTTF.create("000.0", "Arial", fontSize);
  this._SPFLabel = cc.LabelTTF.create("0.000", "Arial", fontSize);
  this._drawsLabel = cc.LabelTTF.create("0000", "Arial", fontSize);
  var contentSize = this._drawsLabel.getContentSize();
  this._drawsLabel.setPosition(cc.pAdd(cc.p(contentSize.width / 2, contentSize.height * 5 / 2), cc.DIRECTOR_STATS_POSITION));
  contentSize = this._SPFLabel.getContentSize();
  this._SPFLabel.setPosition(cc.pAdd(cc.p(contentSize.width / 2, contentSize.height * 3 / 2), cc.DIRECTOR_STATS_POSITION));
  contentSize = this._FPSLabel.getContentSize();
  this._FPSLabel.setPosition(cc.pAdd(cc.p(contentSize.width / 2, contentSize.height / 2), cc.DIRECTOR_STATS_POSITION))
}, _calculateMPF:function() {
  var now = Date.now();
  this._secondsPerFrame = (now - this._lastUpdate) / 1E3
}});
cc.DisplayLinkDirector = cc.Director.extend({invalid:false, startAnimation:function() {
  this._nextDeltaTimeZero = true;
  this.invalid = false;
  cc.Application.sharedApplication().setAnimationInterval(this._animationInterval)
}, mainLoop:function() {
  if(this._purgeDirecotorInNextLoop) {
    this._purgeDirecotorInNextLoop = false;
    this.purgeDirector()
  }else {
    if(!this.invalid) {
      this.drawScene()
    }
  }
}, stopAnimation:function() {
  this.invalid = true
}, setAnimationInterval:function(value) {
  this._animationInterval = value;
  if(!this.invalid) {
    this.stopAnimation();
    this.startAnimation()
  }
}});
cc.s_SharedDirector = null;
cc.firstUseDirector = true;
cc.Director.getInstance = function() {
  if(cc.firstUseDirector) {
    cc.firstUseDirector = false;
    cc.s_SharedDirector = new cc.DisplayLinkDirector;
    cc.s_SharedDirector.init();
    cc.s_SharedDirector.setOpenGLView(cc.EGLView.getInstance())
  }
  return cc.s_SharedDirector
};
cc.firstRun = true;
cc.defaultFPS = 60;
cc.Camera = cc.Class.extend({_eyeX:null, _eyeY:null, _eyeZ:null, _centerX:null, _centerY:null, _centerZ:null, _upX:null, _upY:null, _upZ:null, _dirty:null, _lookupMatrix:new cc.kmMat4, ctor:function() {
  this.restore()
}, description:function() {
  return"<CCCamera | center =(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")>"
}, setDirty:function(value) {
  this._dirty = value
}, isDirty:function() {
  return this._dirty
}, restore:function() {
  this._eyeX = this._eyeY = 0;
  this._eyeZ = cc.Camera.getZEye();
  this._centerX = this._centerY = this._centerZ = 0;
  this._upX = 0;
  this._upY = 1;
  this._upZ = 0;
  cc.kmMat4Identity(this._lookupMatrix);
  this._dirty = false
}, locate:function() {
  if(this._dirty) {
    var eye = new cc.kmVec3, center = new cc.kmVec3, up = new cc.kmVec3;
    cc.kmVec3Fill(eye, this._eyeX, this._eyeY, this._eyeZ);
    cc.kmVec3Fill(center, this._centerX, this._centerY, this._centerZ);
    cc.kmVec3Fill(up, this._upX, this._upY, this._upZ);
    cc.kmMat4LookAt(this._lookupMatrix, eye, center, up);
    this._dirty = false
  }
  cc.kmGLMultMatrix(this._lookupMatrix)
}, setEyeXYZ:function(eyeX, eyeY, eyeZ) {
  this.setEye(eyeX, eyeY, eyeZ)
}, setEye:function(eyeX, eyeY, eyeZ) {
  this._eyeX = eyeX;
  this._eyeY = eyeY;
  this._eyeZ = eyeZ;
  this._dirty = true
}, setCenterXYZ:function(centerX, centerY, centerZ) {
  this.setCenter(centerX, centerY, centerZ)
}, setCenter:function(centerX, centerY, centerZ) {
  this._centerX = centerX;
  this._centerY = centerY;
  this._centerZ = centerZ;
  this._dirty = true
}, setUpXYZ:function(upX, upY, upZ) {
  this.setUp(upX, upY, upZ)
}, setUp:function(upX, upY, upZ) {
  this._upX = upX;
  this._upY = upY;
  this._upZ = upZ;
  this._dirty = true
}, getEyeXYZ:function(eyeX, eyeY, eyeZ) {
  return{x:this._eyeX, y:this._eyeY, z:this._eyeZ}
}, getEye:function() {
  return{x:this._eyeX, y:this._eyeY, z:this._eyeZ}
}, getCenterXYZ:function(centerX, centerY, centerZ) {
  return{x:this._centerX, y:this._centerY, z:this._centerZ}
}, getCenter:function() {
  return{x:this._centerX, y:this._centerY, z:this._centerZ}
}, getUpXYZ:function(upX, upY, upZ) {
  return{x:this._upX, y:this._upY, z:this._upZ}
}, getUp:function() {
  return{x:this._upX, y:this._upY, z:this._upZ}
}, _DISALLOW_COPY_AND_ASSIGN:function(CCCamera) {
}});
cc.Camera.getZEye = function() {
  return cc.FLT_EPSILON
};
cc.PRIORITY_SYSTEM = -2147483647 - 1;
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
cc.ArrayVerifyType = function(arr, type) {
  if(arr && arr.length > 0) {
    for(var i = 0;i < arr.length;i++) {
      if(!(arr[i] instanceof type)) {
        cc.log("element type is wrong!");
        return false
      }
    }
  }
  return true
};
cc.ArrayRemoveObjectAtIndex = function(arr, index) {
  arr.splice(index, 1)
};
cc.ArrayRemoveObject = function(arr, delObj) {
  for(var i = 0;i < arr.length;i++) {
    if(arr[i] == delObj) {
      arr.splice(i, 1)
    }
  }
};
cc.ArrayRemoveArray = function(arr, minusArr) {
  for(var i = 0;i < minusArr.length;i++) {
    cc.ArrayRemoveObject(arr, minusArr[i])
  }
};
cc.ArrayGetIndexOfValue = function(arr, value) {
  for(var i = 0;i < arr.length;i++) {
    if(arr[i] == value) {
      return i
    }
  }
  return-1
};
cc.ArrayAppendObject = function(arr, addObj) {
  arr.push(addObj)
};
cc.ArrayAppendObjectToIndex = function(arr, addObj, index) {
  var part1 = arr.slice(0, index);
  var part2 = arr.slice(index);
  part1.push(addObj);
  arr = part1.concat(part2);
  return arr
};
cc.ArrayAppendObjectsToIndex = function(arr, addObjs, index) {
  var part1 = arr.slice(0, index);
  var part2 = arr.slice(index);
  for(var i = 0;i < addObjs.length;i++) {
    part1.push(addObjs[i])
  }
  arr = part1.concat(part2);
  return arr
};
cc.ArrayGetIndexOfObject = function(arr, findObj) {
  for(var i = 0;i < arr.length;i++) {
    if(arr[i] == findObj) {
      return i
    }
  }
  return-1
};
cc.ArrayContainsObject = function(arr, findObj) {
  return cc.ArrayGetIndexOfObject(arr, findObj) != -1
};
cc.HASH_FIND_INT = function(arr, findInt) {
  if(arr == null) {
    return null
  }
  for(var i = 0;i < arr.length;i++) {
    if(arr[i].target === findInt) {
      return arr[i]
    }
  }
  return null
};
cc.ListEntry = function(prev, next, target, priority, paused, markedForDeletion) {
  this.prev = prev;
  this.next = next;
  this.target = target;
  this.priority = priority;
  this.paused = paused;
  this.markedForDeletion = markedForDeletion
};
cc.HashUpdateEntry = function(list, entry, target, hh) {
  this.list = list;
  this.entry = entry;
  this.target = target;
  this.hh = hh
};
cc.HashTimerEntry = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused, hh) {
  this.timers = timers;
  this.target = target;
  this.timerIndex = timerIndex;
  this.currentTimer = currentTimer;
  this.currentTimerSalvaged = currentTimerSalvaged;
  this.paused = paused;
  this.hh = hh
};
cc.Timer = cc.Class.extend({_interval:0, _selector:null, _target:null, _elapsed:0, _runForever:false, _useDelay:false, _timesExecuted:0, _repeat:0, _delay:0, ctor:function() {
}, getInterval:function() {
  return this._interval
}, setInterval:function(interval) {
}, getSelector:function() {
  return this._selector
}, initWithTarget:function(target, selector, seconds, repeat, delay) {
  try {
    this._target = target;
    this._selector = selector;
    this._elapsed = -1;
    this._interval = seconds || 0;
    this._delay = delay || 0;
    this._useDelay = this._delay > 0;
    this._repeat = repeat == null ? cc.REPEAT_FOREVER : repeat;
    this._runForever = this._repeat == cc.REPEAT_FOREVER;
    return true
  }catch(e) {
    return false
  }
}, _callSelector:function() {
  if(typeof this._selector == "string") {
    this._target[this._selector](this._elapsed)
  }else {
    this._selector.call(this._target, this._elapsed)
  }
}, update:function(dt) {
  if(this._elapsed == -1) {
    this._elapsed = 0;
    this._timesExecuted = 0
  }else {
    if(this._runForever && !this._useDelay) {
      this._elapsed += dt;
      if(this._elapsed >= this._interval) {
        if(this._selector) {
          this._callSelector()
        }
        this._elapsed = 0
      }
    }else {
      this._elapsed += dt;
      if(this._useDelay) {
        if(this._elapsed >= this._delay) {
          if(this._target && this._selector) {
            this._callSelector()
          }
          this._elapsed = this._elapsed - this._delay;
          this._timesExecuted += 1;
          this._useDelay = false
        }
      }else {
        if(this._elapsed >= this._interval) {
          if(this._target && this._selector) {
            this._callSelector()
          }
          this._elapsed = 0;
          this._timesExecuted += 1
        }
      }
      if(this._timesExecuted > this._repeat) {
        cc.Director.getInstance().getScheduler().unscheduleCallbackForTarget(this._target, this._selector)
      }
    }
  }
}});
cc.Timer.timerWithTarget = function(target, selector, seconds) {
  if(arguments < 2) {
    throw new Error("timerWithTarget'argument can't is null");
  }
  var timer = new cc.Timer;
  if(arguments.length == 2) {
    timer.initWithTarget(target, selector, 0, cc.REPEAT_FOREVER, 0)
  }else {
    timer.initWithTarget(target, selector, seconds, cc.REPEAT_FOREVER, 0)
  }
  return timer
};
cc._sharedScheduler = null;
cc.Scheduler = cc.Class.extend({_timeScale:1, _updatesNegList:null, _updates0List:null, _updatesPosList:null, _hashForUpdates:null, _hashForTimers:null, _currentTarget:null, _currentTargetSalvaged:false, _updateHashLocked:false, ctor:function() {
  this._timeScale = 1;
  this._updatesNegList = [];
  this._updates0List = [];
  this._updatesPosList = [];
  this._hashForUpdates = [];
  this._hashForTimers = [];
  this._currentTarget = null;
  this._currentTargetSalvaged = false;
  this._updateHashLocked = false
}, _removeHashElement:function(element) {
  element.Timer = null;
  element.target = null;
  cc.ArrayRemoveObject(this._hashForTimers, element);
  element = null
}, _findElementFromArray:function(array, target) {
  for(var i = 0;i < array.length;i++) {
    if(array[i].target == target) {
      return array[i]
    }
  }
  return null
}, _removeUpdateFromHash:function(entry) {
  var element = this._findElementFromArray(this._hashForUpdates, entry.target);
  if(element) {
    cc.ArrayRemoveObject(element.list, element.entry);
    element.entry = null;
    element.target = null;
    cc.ArrayRemoveObject(this._hashForUpdates, element)
  }
}, _priorityIn:function(ppList, target, priority, paused) {
  var listElement = new cc.ListEntry(null, null, target, priority, paused, false);
  if(!ppList) {
    ppList = [];
    ppList.push(listElement)
  }else {
    var added = false;
    for(var i = 0;i < ppList.length;i++) {
      if(priority < ppList[i].priority) {
        ppList = cc.ArrayAppendObjectToIndex(ppList, listElement, i);
        added = true;
        break
      }
    }
    if(!added) {
      ppList.push(listElement)
    }
  }
  var hashElement = new cc.HashUpdateEntry(ppList, listElement, target, null);
  this._hashForUpdates.push(hashElement);
  return ppList
}, _appendIn:function(ppList, target, paused) {
  var listElement = new cc.ListEntry(null, null, target, 0, paused, false);
  ppList.push(listElement);
  var hashElement = new cc.HashUpdateEntry(ppList, listElement, target, null);
  this._hashForUpdates.push(hashElement)
}, setTimeScale:function(timeScale) {
  this._timeScale = timeScale
}, getTimeScale:function() {
  return this._timeScale
}, update:function(dt) {
  this._updateHashLocked = true;
  if(this._timeScale != 1) {
    dt *= this._timeScale
  }
  var tmpEntry;
  var i;
  for(i = 0;i < this._updatesNegList.length;i++) {
    tmpEntry = this._updatesNegList[i];
    if(!tmpEntry.paused && !tmpEntry.markedForDeletion) {
      tmpEntry.target.update(dt)
    }
  }
  for(i = 0;i < this._updates0List.length;i++) {
    tmpEntry = this._updates0List[i];
    if(!tmpEntry.paused && !tmpEntry.markedForDeletion) {
      tmpEntry.target.update(dt)
    }
  }
  for(i = 0;i < this._updatesPosList.length;i++) {
    tmpEntry = this._updatesPosList[i];
    if(!tmpEntry.paused && !tmpEntry.markedForDeletion) {
      tmpEntry.target.update(dt)
    }
  }
  var elt;
  for(i = 0;i < this._hashForTimers.length;i++) {
    this._currentTarget = this._hashForTimers[i];
    elt = this._currentTarget;
    this._currentTargetSalvaged = false;
    if(!this._currentTarget.paused) {
      for(elt.timerIndex = 0;elt.timerIndex < elt.timers.length;elt.timerIndex++) {
        elt.currentTimer = elt.timers[elt.timerIndex];
        elt.currentTimerSalvaged = false;
        elt.currentTimer.update(dt);
        elt.currentTimer = null
      }
    }
    if(this._currentTargetSalvaged && this._currentTarget.timers.length == 0) {
      this._removeHashElement(this._currentTarget)
    }
  }
  for(i = 0;i < this._updatesNegList.length;i++) {
    if(this._updatesNegList[i].markedForDeletion) {
      this._removeUpdateFromHash(this._updatesNegList[i])
    }
  }
  for(i = 0;i < this._updates0List.length;i++) {
    if(this._updates0List[i].markedForDeletion) {
      this._removeUpdateFromHash(this._updates0List[i])
    }
  }
  for(i = 0;i < this._updatesPosList.length;i++) {
    if(this._updatesPosList[i].markedForDeletion) {
      this._removeUpdateFromHash(this._updatesPosList[i])
    }
  }
  this._updateHashLocked = false;
  this._currentTarget = null
}, scheduleCallbackForTarget:function(target, callback_fn, interval, repeat, delay, paused) {
  cc.Assert(callback_fn, "scheduler.scheduleCallbackForTarget() Argument callback_fn must be non-NULL");
  cc.Assert(target, "scheduler.scheduleCallbackForTarget() Argument target must be non-NULL");
  interval = interval || 0;
  repeat = repeat == null ? cc.REPEAT_FOREVER : repeat;
  delay = delay || 0;
  paused = paused || false;
  var element = cc.HASH_FIND_INT(this._hashForTimers, target);
  if(!element) {
    element = new cc.HashTimerEntry(null, target, 0, null, null, paused, null);
    this._hashForTimers.push(element)
  }else {
    cc.Assert(element.paused == paused, "Sheduler.scheduleCallbackForTarget()")
  }
  var timer;
  if(element.timers == null) {
    element.timers = []
  }else {
    for(var i = 0;i < element.timers.length;i++) {
      timer = element.timers[i];
      if(callback_fn == timer._selector) {
        cc.log("CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:" + timer.getInterval().toFixed(4) + " to " + interval.toFixed(4));
        timer._interval = interval;
        return
      }
    }
  }
  timer = new cc.Timer;
  timer.initWithTarget(target, callback_fn, interval, repeat, delay);
  element.timers.push(timer)
}, scheduleUpdateForTarget:function(target, priority, paused) {
  var hashElement = cc.HASH_FIND_INT(this._hashForUpdates, target);
  if(hashElement) {
    if(cc.COCOS2D_DEBUG >= 1) {
      cc.Assert(hashElement.entry.markedForDeletion, "")
    }
    hashElement.entry.markedForDeletion = false;
    return
  }
  if(priority == 0) {
    this._appendIn(this._updates0List, target, paused)
  }else {
    if(priority < 0) {
      this._updatesNegList = this._priorityIn(this._updatesNegList, target, priority, paused)
    }else {
      this._updatesPosList = this._priorityIn(this._updatesPosList, target, priority, paused)
    }
  }
}, unscheduleCallbackForTarget:function(target, callback_fn) {
  if(target == null || callback_fn == null) {
    return
  }
  var element = cc.HASH_FIND_INT(this._hashForTimers, target);
  if(element != null) {
    for(var i = 0;i < element.timers.length;i++) {
      var timer = element.timers[i];
      if(callback_fn == timer._selector) {
        if(timer == element.currentTimer && !element.currentTimerSalvaged) {
          element.currentTimerSalvaged = true
        }
        cc.ArrayRemoveObjectAtIndex(element.timers, i);
        if(element.timerIndex >= i) {
          element.timerIndex--
        }
        if(element.timers.length == 0) {
          if(this._currentTarget == element) {
            this._currentTargetSalvaged = true
          }else {
            this._removeHashElement(element)
          }
        }
        return
      }
    }
  }
}, unscheduleUpdateForTarget:function(target) {
  if(target == null) {
    return
  }
  var element = cc.HASH_FIND_INT(this._hashForUpdates, target);
  if(element != null) {
    if(this._updateHashLocked) {
      element.entry.markedForDeletion = true
    }else {
      this._removeUpdateFromHash(element.entry)
    }
  }
}, unscheduleAllCallbacksForTarget:function(target) {
  if(target == null) {
    return
  }
  var element = cc.HASH_FIND_INT(this._hashForTimers, target);
  if(element) {
    if(!element.currentTimerSalvaged && cc.ArrayContainsObject(element.timers, element.currentTimer)) {
      element.currentTimerSalvaged = true
    }
    element.timers.length = 0;
    if(this._currentTarget == element) {
      this._currentTargetSalvaged = true
    }else {
      this._removeHashElement(element)
    }
  }
  this.unscheduleUpdateForTarget(target)
}, unscheduleAllCallbacks:function() {
  this.unscheduleAllCallbacksWithMinPriority(cc.PRIORITY_SYSTEM)
}, unscheduleAllCallbacksWithMinPriority:function(minPriority) {
  var i;
  for(i = 0;i < this._hashForTimers.length;i++) {
    this.unscheduleAllCallbacksForTarget(this._hashForTimers[i].target)
  }
  if(minPriority < 0) {
    for(i = 0;i < this._updatesNegList.length;i++) {
      this.unscheduleUpdateForTarget(this._updatesNegList[i].target)
    }
  }
  if(minPriority <= 0) {
    for(i = 0;i < this._updates0List.length;i++) {
      this.unscheduleUpdateForTarget(this._updates0List[i].target)
    }
  }
  for(i = 0;i < this._updatesPosList.length;i++) {
    if(this._updatesPosList[i].priority >= minPriority) {
      this.unscheduleUpdateForTarget(this._updatesPosList[i].target)
    }
  }
}, pauseAllTargets:function() {
  return this.pauseAllTargetsWithMinPriority(cc.PRIORITY_SYSTEM)
}, pauseAllTargetsWithMinPriority:function(minPriority) {
  var idsWithSelectors = [];
  var i, element;
  for(i = 0;i < this._hashForTimers.length;i++) {
    element = this._hashForTimers[i];
    if(element) {
      element.paused = true;
      idsWithSelectors.push(element.target)
    }
  }
  if(minPriority < 0) {
    for(i = 0;i < this._updatesNegList.length;i++) {
      element = this._updatesNegList[i];
      if(element) {
        element.paused = true;
        idsWithSelectors.push(element.target)
      }
    }
  }
  if(minPriority <= 0) {
    for(i = 0;i < this._updates0List.length;i++) {
      element = this._updates0List[i];
      if(element) {
        element.paused = true;
        idsWithSelectors.push(element.target)
      }
    }
  }
  for(i = 0;i < this._updatesPosList.length;i++) {
    element = this._updatesPosList[i];
    if(element) {
      element.paused = true;
      idsWithSelectors.push(element.target)
    }
  }
  return idsWithSelectors
}, resumeTargets:function(targetsToResume) {
  if(!targetsToResume) {
    return
  }
  for(var i = 0;i < targetsToResume.length;i++) {
    this.resumeTarget(targetsToResume[i])
  }
}, pauseTarget:function(target) {
  cc.Assert(target != null, "Scheduler.pauseTarget():entry must be non nil");
  var element = cc.HASH_FIND_INT(this._hashForTimers, target);
  if(element) {
    element.paused = true
  }
  var elementUpdate = cc.HASH_FIND_INT(this._hashForUpdates, target);
  if(elementUpdate) {
    cc.Assert(elementUpdate.entry != null, "Scheduler.pauseTarget():entry must be non nil");
    elementUpdate.entry.paused = true
  }
}, resumeTarget:function(target) {
  cc.Assert(target != null, "");
  var element = cc.HASH_FIND_INT(this._hashForTimers, target);
  if(element) {
    element.paused = false
  }
  var elementUpdate = cc.HASH_FIND_INT(this._hashForUpdates, target);
  if(elementUpdate) {
    cc.Assert(elementUpdate.entry != null, "Scheduler.resumeTarget():entry must be non nil");
    elementUpdate.entry.paused = false
  }
}, isTargetPaused:function(target) {
  cc.Assert(target != null, "Scheduler.isTargetPaused():target must be non nil");
  var element = cc.HASH_FIND_INT(this._hashForTimers, target);
  if(element) {
    return element.paused
  }
  return false
}});
cc.RESOURCE_TYPE = {"IMAGE":["png", "jpg", "bmp"], "SOUND":["mp3", "ogg", "wav", "mp4", "m4a"], "XML":["plist", "xml", "fnt", "tmx", "tsx"], "BINARY":["ccbi"], "FONT":"FONT", "TEXT":["txt", "vsh", "fsh"], "UNKNOW":[]};
cc.Loader = cc.Class.extend({_curNumber:0, _totalNumber:0, _loadedNumber:0, _resouces:null, _animationInterval:1 / 60, _interval:null, _isAsync:false, ctor:function() {
  this._resouces = []
}, initWithResources:function(resources, selector, target) {
  cc.Assert(resources != null, "resources should not null");
  if(selector) {
    this._selector = selector;
    this._target = target
  }
  if(resources != this._resouces || this._curNumber == 0) {
    this._curNumber = 0;
    this._loadedNumber = 0;
    if(resources[0] instanceof Array) {
      for(var i = 0;i < resources.length;i++) {
        var each = resources[i];
        this._resouces = this._resouces.concat(each)
      }
    }else {
      this._resouces = resources
    }
    this._totalNumber = this._resouces.length
  }
  this._schedulePreload()
}, setAsync:function(isAsync) {
  this._isAsync = isAsync
}, onResLoadingErr:function(name) {
  cc.log("cocos2d:Failed loading resource: " + name)
}, onResLoaded:function() {
  this._loadedNumber++
}, getPercentage:function() {
  var percent = 0;
  if(this._totalNumber == 0) {
    percent = 100
  }else {
    percent = 0 | this._loadedNumber / this._totalNumber * 100
  }
  return percent
}, releaseResources:function(resources) {
  if(resources && resources.length > 0) {
    var sharedTextureCache = cc.TextureCache.getInstance();
    var sharedEngine = cc.AudioEngine.getInstance();
    var sharedParser = cc.SAXParser.getInstance();
    var sharedFileUtils = cc.FileUtils.getInstance();
    var resInfo;
    for(var i = 0;i < resources.length;i++) {
      resInfo = resources[i];
      var type = this._getResType(resInfo);
      switch(type) {
        case "IMAGE":
          sharedTextureCache.removeTextureForKey(resInfo.src);
          break;
        case "SOUND":
          sharedEngine.unloadEffect(resInfo.src);
          break;
        case "XML":
          sharedParser.unloadPlist(resInfo.src);
          break;
        case "BINARY":
          sharedFileUtils.unloadBinaryFileData(resInfo.src);
          break;
        case "TEXT":
          sharedFileUtils.unloadTextFileData(resInfo.src);
          break;
        case "FONT":
          this._unregisterFaceFont(resInfo);
          break;
        default:
          throw"cocos2d:unknown filename extension: " + type;break
      }
    }
  }
}, _preload:function() {
  this._updatePercent();
  if(this._isAsync) {
    var frameRate = cc.Director.getInstance()._frameRate;
    if(frameRate != null && frameRate < 20) {
      cc.log("cocos2d: frame rate less than 20 fps, skip frame.");
      return
    }
  }
  if(this._curNumber < this._totalNumber) {
    this._loadOneResource();
    this._curNumber++
  }
}, _loadOneResource:function() {
  var sharedTextureCache = cc.TextureCache.getInstance();
  var sharedEngine = cc.AudioEngine.getInstance();
  var sharedParser = cc.SAXParser.getInstance();
  var sharedFileUtils = cc.FileUtils.getInstance();
  var resInfo = this._resouces[this._curNumber];
  var type = this._getResType(resInfo);
  switch(type) {
    case "IMAGE":
      sharedTextureCache.addImage(resInfo.src);
      break;
    case "SOUND":
      sharedEngine.preloadSound(resInfo.src);
      break;
    case "XML":
      sharedParser.preloadPlist(resInfo.src);
      break;
    case "BINARY":
      sharedFileUtils.preloadBinaryFileData(resInfo.src);
      break;
    case "TEXT":
      sharedFileUtils.preloadTextFileData(resInfo.src);
      break;
    case "FONT":
      this._registerFaceFont(resInfo);
      break;
    default:
      throw"cocos2d:unknown filename extension: " + type;break
  }
}, _schedulePreload:function() {
  this._interval = setInterval(this._preload.bind(this), this._animationInterval * 1E3)
}, _unschedulePreload:function() {
  clearInterval(this._interval)
}, _getResType:function(resInfo) {
  var isFont = resInfo.fontName;
  if(isFont != null) {
    return cc.RESOURCE_TYPE.FONT
  }else {
    var src = resInfo.src;
    var ext = src.substring(src.lastIndexOf(".") + 1, src.length);
    for(var resType in cc.RESOURCE_TYPE) {
      if(cc.RESOURCE_TYPE[resType].indexOf(ext) != -1) {
        return resType
      }
    }
    return ext
  }
}, _updatePercent:function() {
  var percent = this.getPercentage();
  if(percent >= 100) {
    this._unschedulePreload();
    this._complete()
  }
}, _complete:function() {
  if(this._target && typeof this._selector == "string") {
    this._target[this._selector](this)
  }else {
    if(this._target && typeof this._selector == "function") {
      this._selector.call(this._target, this)
    }else {
      this._selector(this)
    }
  }
  this._curNumber = 0;
  this._loadedNumber = 0
}, _registerFaceFont:function(fontRes) {
  var srcArr = fontRes.src;
  if(srcArr && srcArr.length > 0) {
    var fontStyle = document.createElement("style");
    fontStyle.type = "text/css";
    document.body.appendChild(fontStyle);
    var fontStr = "@font-face { font-family:" + fontRes.fontName + "; src:";
    for(var i = 0;i < srcArr.length;i++) {
      fontStr += "url('" + encodeURI(srcArr[i].src) + "') format('" + srcArr[i].type + "')";
      fontStr += i == srcArr.length - 1 ? ";" : ","
    }
    fontStyle.textContent += fontStr + "};";
    var preloadDiv = document.createElement("div");
    preloadDiv.style.fontFamily = fontRes.fontName;
    preloadDiv.innerHTML = ".";
    preloadDiv.style.position = "absolute";
    preloadDiv.style.left = "-100px";
    preloadDiv.style.top = "-100px";
    document.body.appendChild(preloadDiv)
  }
  cc.Loader.getInstance().onResLoaded()
}, _unregisterFaceFont:function(fontRes) {
}});
cc.Loader.preload = function(resources, selector, target) {
  if(!this._instance) {
    this._instance = new cc.Loader
  }
  this._instance.initWithResources(resources, selector, target);
  return this._instance
};
cc.Loader.preloadAsync = function(resources, selector, target) {
  if(!this._instance) {
    this._instance = new cc.Loader
  }
  this._instance.setAsync(true);
  this._instance.initWithResources(resources, selector, target);
  return this._instance
};
cc.Loader.purgeCachedData = function(resources) {
  if(this._instance) {
    this._instance.releaseResources(resources)
  }
};
cc.Loader.getInstance = function() {
  if(!this._instance) {
    this._instance = new cc.Loader
  }
  return this._instance
};
cc.Loader._instance = null;
cc.LoaderScene = cc.Scene.extend({_logo:null, _logoTexture:null, _texture2d:null, _bgLayer:null, _label:null, ctor:function() {
  this._super();
  this._logoTexture = new Image;
  var _this = this;
  this._logoTexture.addEventListener("load", function() {
    _this.initStage()
  });
  this._logoTexture.src = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAlAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQADQkJCQoJDQoKDRMMCwwTFhENDREWGhUVFhUVGhkUFhUVFhQZGR0fIB8dGScnKionJzk4ODg5QEBAQEBAQEBAQAEODAwOEA4RDw8RFA4RDhQVERISERUfFRUXFRUfKB0ZGRkZHSgjJiAgICYjLCwoKCwsNzc1NzdAQEBAQEBAQEBA/8AAEQgAyACgAwEiAAIRAQMRAf/EALAAAAEFAQEAAAAAAAAAAAAAAAQAAgMFBgcBAQEAAwEBAAAAAAAAAAAAAAAAAQMEAgUQAAIBAgIEBwoLBgQGAwAAAAECAwAEEQUhMRIGQVFxsTITFGGBwdEiQlKSMzWRoeFicqKyI1NzFYJjJDQWB9KjVCbxwkNkJWXik3QRAAIBAgMFBQcDBQEAAAAAAAABAhEDIRIEMUFRcTJhwVIUBZGhsSJyEzOB0ULhYpIjUxX/2gAMAwEAAhEDEQA/AMJSpUqAVKlXuFAeUq9wpUB5XuFe4V6ooDzZHDox0CnGMinzwl7Z8NajaHeoO3vmTBZBtp9YUIqTEV5ROxHKnWRnaU8VRMhFBUjpV7hSoSeUq9pUB5Sr2lhQHlKvcK8oBV7hSFSRrtaKAZs07YNPM1pG2xJIAw1jSeandry/8X4m8VCKkWwaWwam7Xl/4v1W8VLtmX/i/VbxUoKkWwakSM407tmX/i/VbxUmzGwjQsjdY41IARie/U0IbZO0kNtCXnOCkEBeFu4KI3Bs7DNb27ya+jDx3kJeEnpJJEcQVbWDsk17u5urd591ucZkWhym2Vnd9RkCDEpFxDRpbw0bunu5mlp2De2FMLYXOD2wB2xbOeraUcYGJ72mlSUiqzzdzMd3Z3mixltA2yzcK/NlHM1DQyRXce1HocdNOEfJXZ88y9ZojOqhiBszIRiHQ8Y4cK5TvHuzLljHNMqxNoDjLFraHHnjPxcNCGVbxEUzYNTx5jZSxhpW6qTzlwJ+DCvO2Zf+L9VvFSgqyHYNLYNTdssPxfibxUu15f8Ai/VPiqCakOwa82DU/a8v/F+JvFTDdWPBL8R8VKCvYRYV5UzoMAy6QdIIqI0B4KJtxiRQwou16QoGUkntH5Tz0RbZbmF2hktraSVBo2lUkY8tDye0flPPXTslVUyiyVRsjqUOA4yMT8dW2ram2m6UVTNq9S7EIyUVJydMTn/6DnP+im9Wl+g5z/opvVrpteEhQWY4AaSTwAVf5WPiZh/9S5/zj7zltzlmYWkfWXNvJDGTgGcYDHirR7i7mSbwXParsFMrgb7w6jKw/wCmnc9I14kF3vpvCljbMyWMOJL4aEiB8qU/ObUK7HYWVrl1pFZWiCOCBQqKOLjPGTrNZZqKbUXVHq2nNwTuJRk1VpbgXN8s7Rk5ym0UQQzhIG2NAjhxHWbI+gCBVjBBFbwxwQqEiiUJGg1BVGAFe7dV28WYLYZFmF2Th1UD7JGjymGyn1iK5OyzIBGB1HgrLZhamzumQAGJwSqnSCh1q3GOCodxt4cxurdcpzuN4cyhiWaF5Bg09udUmnWw1H/jV9nFuJ7Quo+8h8peThFA+047vduyMtk7fYqTl07YFdfUufMPzT5p71UdtlmYXaGS2t3mQHAsgxANdadYJopLe4QS2867EsZ4QfCNYrCFbjdDPmgkYyWFxgVf04ifJf6ScNdRUW1XBb6FU5TjF5EpSSrGu/s5lN+g5z/opvVpfoOc/wCim9WtdHnatvObJXDW7xLGhB8nrPaY9/HCr+tEdPCVaSeDoYLnqF63lzW4/PFSW3ecxbI84VSzWUwUaSdg0DXXK5nvAipnd6qgKvWnQO7pri9ZUEmm3Vl2j1kr8pRlFRyquBNZjGxQ/S56Y1S2fu9OVueon11Szahoou06QoQUXadIVCD2FJJ7R+U89dMydv8Axdn+TH9muZye0flPPXQstlK5Tbka1gUjlC1q0vVLkeb6r+O3Tx9xcY1nt8c0NrZCyiOE1108NYjGv1joo7Js1jzKyScYLIvkzL6LDwHXVJksH9Sb49dKNq0tj1jA6uriOCL+02FWX7iVtZX1/AzaHTyeoauKn2MX9W79zebiZCuR5MjSrhfXuEtwTrUeZH+yNfdrRNcxI6IzhXlJEak6WIGJ2Rw4ChWnChndtlVBLMdQA0k1gbXNMzzDfDLs6mjaPKppJbWwJ1bOwwxw43OnHh71YT3DpfWUJmFlb5jHHDdeXBHIsrRea5TSqvxqG04cNN62vetoCS4tre5mgnkGE9q+3DKOkuI2WX6LDQRRHWDh1UCtwj7QRg2wdl8Djgw1qe7XvW0BQ3kfZ7mSLgU+T9E6RVbnuVrnWVSWqj+Lt8ZbRuHEdKPkYVcZ2MJY5fSGyeVar45+rkWQHAqccalPE5km1htWK5nK4Wnt5FuUBUwOMG4nGkA/BXUrW4S6torlOjMgcd/xVn7rLo7zKs0uEjCNeSvdwoBhgsZxX1l2j36k3Lu+uyprdj5Vs5A+i/lD48a0aaVJOPi7jB6lbzWozpjB48pf1NDXNN4vfl7+Z4BXS65pvF78vfzPAK71XTHmZ/S/yT+jvJ7L3fHytz1E+upbL+Qj5W56jfXWRnsIYKLtekKEFGWvSFQgyjk9o/Keet3YthlMP/5x9msJJ7R+U89biyb/AMXEv7gD6tadL1T+kwepRrC39ZkLDMbiwMvUHRPG0bjlGg8ore/23sxBldxfMPLupNhT8yL/AORNZbdzJ484scytxgLqJY5LZj6Q2sV5G1Vud1mjjyG0ij0NEGSZToKyhjtqw4waztuiXA3qKTbSxltfGhbZlE95ZtZqxVbgiOZhrER9ph3Svk9+pJILZ4Y4DGBFCUMKjRsGPobPFhUfW0NJmljE2xJcIrcI2vFUEln1lRXd6lrazXT9GCNpD+yNqoI7mOVduNw6nzlOIoPOUa6yye1XXcbMR5GdQ3xY0BSbj31/FcTQZirJ+q431q7anbHCTZ72Bw7lbPrKBMcBWNNgbMBBh+bsjBdni0VJ1lARZs6yWiupxCuMDy6KpS2IwOo6DTr3Mre3e5tZZVUM4ZBjqOOJoWO4jkXajcOOMHGgDISvWIrdAkKR80+TzVl908bPPL3LzxOuHdifxVfiTAg92qI/w+/8gGgSyN/mR7XPVlp0lF/3L3mbVKtu5Hjbk/8AHE2Fc03i9+Xv5ngFdKNc13i9+Xv5ngFaNV0x5nn+l/kn9HeEWXu+PlbnqJ9dS2Xu9OVueon11kZ7CGCjLXpCgxRlr0hUIPYUcntH5Tz1s8vb+Bt1/dqPirGSe0flPPWusG/g4Py15q06XqlyMWvVYQ+ruI9xJOqzO9hOto/sP8tbGOFIrmWeM7IuMDMnAXXQJOUjQeOsJk0nY96ip0CYunrjaHx1t+srPJUbXBm2LrFPikwTOb+T+VhbZxGMrDXp83x1QSy2tucJpUjPETp+Cn5/ftaRvKvtp3Kx48HG3erHMzOxZiWZtLMdJNQSbbL71Vk6yynViOkqnEEfOWtPbXi3EQkGg6mXiNckjeSJxJGxR10qw0GtxuxmvbImD4CZMFlA4fRfv0BqesqqzTMZNMEDbIHtHH2QeCiZJSqMQdOGiue53mz3czQwsRbIcNHnkec3c4qAMuriz68gTIToxwOOnlp0MjxMJYW741Gs3RVldtbygE/dMcHX/moDaxTiWNZB53B3arb8/wC+4SOF4sf/AKxU9kcBsfOGHfoUHtG/RbzY5Die5HHhXdvavqiZ9Q8Jdlq4/gbKua7xe/L38zwCuhpf2Uk/Zo50kmwJKIdogDjw1VzzeL35e/meAVp1LTgqY4nn+mRauzqmqwrjzCLL3fHytz1E+upLL+Qj5W56jfXWRnroYKLtekKEFF2vSFQg9hSSe0flPPWosm/hIfoLzVl5PaPynnrRWb/w0X0F5q06XqlyM2sVYx5gmbFre/t71NY2T+0h8VbSO5SWNJUOKSAMp7jDGspmMPaLRlXS6eWve1/FRO7WYdbZm1Y/eW/R7qHxHRXGojlm3ulid6aVbaW+OALvgCLq2Hm9WxHKWqjhj6xsK1e8dm15l4niG1LZkswGsxtrPeOmsvayBJA1VItlWjptLuTdPMo7LtjRDq9naK4+WF9IrUW7BaHOljGqVHB7w2hzVoZt87d8vaNYSLl02CcRsDEbJbj71Uu7UBkvJ7/D7q2QoDxySaAO8MTXdxRVMpRp5XZOWdF/ms7R5XdyKfKWJsO/5PhrG5XlNxmEywW6bTnTxAAcJNbGSMXkM1pjgbiNo1PziPJ+Os7u7m/6ReM00ZOgxSpqYYHT3wRXMKN4ll9zUG4bQfNshu8sZVuEA2hirA4qe/VOwwrVbzbww5mI44UKRRYkbWG0S3JWctbd7u5WFfOOLHiUdJqmaipfLsIsObhWe001lMkMVvJNjhghIALMcBxCs7fxXQmkupx1bXDswGPlaTidVaEyKNXkoo4eBV+Sq7L7Vs9zcBgeyQ4GQ/MB1crmoim2orezqcowTuSeEY48jQ7oZX2PLzdyLhNd6RjrEY6I7+uspvH78vfzPAK6UAAAFGAGgAcArmu8Xvy9/M8ArTfio24RW5nnaG67uou3H/KPuqT2X8hHytz1G+upLL3enK3PUb66ys9RDBRdr0hQgou06QqEGUkntH5Tz1e238vF9BeaqKT2j8p56vbb+Xi+gvNWjTdUuRn1XTHmTh8KrJTJlt8t1CPIY44cGnpJVjTJYkmjaN9Ib4u7V923njTethRauZJV3PaW1rfLIiXEDYg6R4VYc9CXW7thfOZbKdbGZtLW8uPVY/u3GrkNUkM9zlcxUjbhfWOA90cRq4gv4LhdqN+VToNYWmnRm9NNVWNTyHc6VWBv8wt4YeHqm6xyPmroq1Z7WGFLSxTq7WLSuPSdjrkfumq5yHXDUeA92oO2SKpVumNAaoJLMXH3myp0rpJ4uKhc3tbDM5BMri1zAj79j7KTiY8TcdBpcsith0286o+sPCagEX9Pzg4zXUCp6QYse8oouCG3tk6m1BYv05W6T+IdyolxbHDAAa2OgDlNCz3ryN2WxBd5PJMg1t81eId2ukqnLlTBbfcuY+9uJLiRcvtPvHdsHK+cfRHcHDWsyawjyy0WBcDI3lTP6TeIcFV+S5OmXx9bJg1048o8Cj0V8Jq2DVu09nL80up7OxHi+oal3P8AXB/IsZS8T/YOV65zvCcc7vfzPAK3ivWCz445zeH954BXOr6I8yfSfyz+jvCLP3fHytz1G+upLP3fHytz1E+usbPaQ0UXadIUIKLtekKhB7Ckk9o/Keer22/l4/oLzVRSe0flPPV7b/y8X0F5q0abqlyM+q6Y8yQsBTDMor1o8aiaE1pbluMqS3sbLLHIhSRQyngqukhaJ9uBjo+H5aOa3ao2t34qouRlLajTalGP8v0IY8ylXQ+PKPFU/bYXOLPge6CKia0LaxTOxHu1Q7cuBd9yPEJ7TbjXKO8CajbMIF6CNIeNvJHjqIWJ7tSpYkalqVblwIdyG+RGXur0hXYJFxal+Dhq5y3slkv3Y2pD0pTr+QUClpJRUdo9XW4OLrTHtM16cZLLWkeC7y4jvlNEpcRtw1Ux27Ci448NZrTFy3nn3IQWxlgGrDZ3pza7/M8ArZo+ArF5171uvp+CqdV0R5l/psUrs2vB3hdl7vTlbnqJ9dS2Xu+PlbnqJ9dY2eshooq16QoQUXa9IVCD2FLJ7RuU89WNtmUSQqkgYMgw0accKrpPaPynnrZWG4Vi+VWmY5tnMWXG+XrIYnA0rhj0mdcTgdNdwnKDqjmduM1SRR/qlr8/4KX6pa8T/BVzDuLZXudRZblmbxXcPUNPc3KqCIwrbOzgrHEnHjoyD+3eSXkht7DeKG4umDGOJVUklfouThXfmbnZ7Cvy1vt9pmv1W1+d8FL9VteJvgq5yrcOGfLmzHN80iyyETPbptAEFo2ZG8pmUa1OFNn3Ky6W/sbDKM5hv5bx2WTZA+7RF2y52WOPJTzE+z2Dy1vt9pT/AKpacTerS/U7Tib1a04/t7kDXPY03jhN0W6sQ7K7W3q2dnrMccaDy/8At80kuZfqWYxWNtlcvUPPhiGYhWDeUy7IwYU8xPs9g8tb7faUn6pacTerTxm9oOBvVq3v9z927aynuId44LiWKNnjhAXF2UYhRg516qpsryjLr21665zFLSTaK9U2GOA87SwqY37knRU+BzOzags0s1Oyr+BKM6sxwP6tSDPLMen6vy0rvdm3Sxlu7K/S7WDDrFUDUTxgnTU826eXW7KlxmqQuwDBXUKcD+1Xee/wXuKX5XDGWLapSVcOyhEM/seJ/V+WnjeGx4pPV+Wkm6kKZlFay3Jlt7iFpYZY8ASVK6DjtDDA0f8A0Tl340/1f8Ndx8xJVWXB0KbktFFpNzdVXAC/qOwA0CQni2flrO3Vwbm5lnI2TKxbDirX/wBE5d+NcfV/wVR7xZPa5U9utvI8nWhmbbw0YEAYYAVxfhfy5rlKR4Fulu6X7mW1mzT8S4Yis/5CPlbnqJ9dSWfu9OVueon11mZvQ2i7XpChKKtekKhBlNJ7R+U89bDfGTb3a3ZX0Lcj6kdY+T2j8p560288m1kWQr6MJ+ylSAr+2cnV5renjs3H1loX+3j9XvbbtxLN9lqW4UnV5jdnjtXHxihtyZNjeSBu5J9k1BJe7xy7W5CJ/wCzuD/mTVTf2+fq97LJuLrPsNRueS7W6aJ/38x+vLVXuY+xvHaNxbf2GoCezf8A36j/APsSf8w1sLnqczTefJluYoLm5uo5F61sBshItP1cNFYe1f8A3ir/APfE/wCZUe9bB94r5jwuPsrQFhmG4l/Z2M17HdW90tuu3IkTHaCjWdIw0VVZdks9/C06yJFEp2dp+E1bbqybGTZ8vpQD7L1XRv8A7blT96Oda7tpNuuNE37Cq9KSisjyuUoxrStKllHbLlWTXsMs8chuSuwEPDqwoLe5y+YRE/gLzmqRekvKKtd4327yM/ulHxmrHJStySWVRyrjxKI2XC/CTlnlPPKTpTdFbP0L1bgrf5Lp0G3dPhQHwV0S1lzBsns3sESR8Crh9WAJGjSOKuU3E+zdZQ3oJh8IArdZXFDmOTpHa3i2+YrI2KtKy4ricBsBuHHgFXSo440+Wa2qqxjvM9uMoy+WvzWpLCWWWE28HxL6e43ojgkeSCBY1Ri5BGIUDT51cl3vm276BBqSEH4WbxV0tlkyXJcxTMb+OW6uY9mGHrCzDQwwAbTp2uKuTZ9N1uYsfRRR8WPhrm419mSSjRyiqxVK7y23B/ftuTm2oSdJyzNVw3BFn7vTlbnqF9dS2fu9OVueon11lZuQ2iLdsGFD05H2dNQGV0ntG5Tz1dWm9N1b2kVq8EVwsI2UaQaQOKhmitZGLOmk68DhSFvY+gfWNSAg7z3Qvo7yKCKIohiaNR5LKxx8qpxvjcqS0VpbxvwOAcRQPZ7D0G9Y0uz2HoH1jUCpLY7zXlpbm3eKO5QuzjrBqZji3x17PvNcyT288VvDBJbMWUovS2hslW7mFQ9nsPQPrGl2ew9A+saCod/WNxtbYsrfb17WBxx5ddD2281xC88klvDcSXEnWuzrqOGGC9zRUPZ7D0G9Y0uzWHoH1jQVCLreq6ntZbaO3it1mGy7RjTs1X2mYy20ZiCq8ZOODcdEdmsPQb1jS7PYegfWNdJuLqnQiSUlRqpFLmryxtH1Ma7Qw2gNNPOdSt0oI27p007s9h6B9Y0uz2HoH1jXX3Z+I4+1b8IJdX89xLHKQFMXQUahpxoiPN5P+onfU+A0/s9h6DesaXZ7D0D6xpG7OLbUtu0StW5JJx2bBsmbtiSiEk+cxoCWWSaVpZOk2vDVo0VYdnsPQb1jSNvZcCH1jSd2c+p1XAmFqEOmOPEfaH+BQd1ueo211IzrgFUYKNAAqI1WztCpUqVCRUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoD/9k=";
  this._logoTexture.width = 160;
  this._logoTexture.height = 200
}, initStage:function() {
  this._bgLayer = cc.LayerColor.create(cc.c4(32, 32, 32, 255));
  this._bgLayer.setPosition(cc.p(0, 0));
  this.addChild(this._bgLayer, 0);
  var winSize = cc.Director.getInstance().getWinSize();
  var centerPos = cc.p(winSize.width / 2, winSize.height / 2);
  var logoHeight = 200;
  if(cc.renderContextType === cc.CANVAS) {
    this._logo = cc.Sprite.createWithTexture(this._logoTexture);
    this._logo.setPosition(centerPos);
    this._bgLayer.addChild(this._logo, 10)
  }else {
    this._texture2d = new cc.Texture2D;
    this._texture2d.initWithElement(this._logoTexture);
    this._texture2d.handleLoadedTexture();
    if(this._texture2d) {
      this._logo = cc.Sprite.createWithTexture(this._texture2d);
      this._logo.setPosition(centerPos);
      this._bgLayer.addChild(this._logo, 10);
      logoHeight = this._logo.getContentSize().height
    }
  }
  this._label = cc.LabelTTF.create("Loading... 0%", "Arial", 14);
  this._label.setColor(cc.c3(180, 180, 180));
  this._label.setOpacity(0);
  this._label.setPosition(cc.pAdd(centerPos, cc.p(0, -logoHeight / 2 - 10)));
  this._bgLayer.addChild(this._label, 10);
  this._logoFadeIn();
  this.schedule(this._startLoading, 0.3)
}, initWithResources:function(resources, selector, target) {
  this.resources = resources;
  this.selector = selector;
  this.target = target
}, _startLoading:function() {
  this.unschedule(this._startLoading);
  cc.Loader.preload(this.resources, this.selector, this.target);
  this.schedule(this._updatePercent)
}, _logoFadeIn:function() {
  var logoAction = cc.Spawn.create(cc.EaseBounce.create(cc.MoveBy.create(0.25, cc.p(0, 10))), cc.FadeIn.create(0.5));
  var labelAction = cc.Sequence.create(cc.DelayTime.create(0.15), logoAction.copy());
  this._logo.runAction(logoAction);
  this._label.runAction(labelAction)
}, _updatePercent:function() {
  var percent = cc.Loader.getInstance().getPercentage();
  var tmpStr = "Loading... " + percent + "%";
  this._label.setString(tmpStr);
  if(percent >= 100) {
    this.unschedule(this._updatePercent)
  }
}});
cc.LoaderScene.preload = function(resources, selector, target) {
  if(!this._instance) {
    this._instance = new cc.LoaderScene;
    this._instance.init()
  }
  var director = cc.Director.getInstance();
  if(director.getRunningScene()) {
    director.replaceScene(this._instance)
  }else {
    director.runWithScene(this._instance)
  }
  this._instance.initWithResources(resources, selector, target);
  return this._instance
};
cc.DrawingPrimitive = cc.Class.extend({_renderContext:null, setRenderContext:function(context) {
  this._renderContext = context
}, getRenderContext:function() {
  return this._renderContext
}, ctor:function(renderContext) {
  this._renderContext = renderContext
}, drawPoint:function(point) {
  cc.log("DrawingPrimitive.drawPoint() not implement!")
}, drawPoints:function(points, numberOfPoints) {
  cc.log("DrawingPrimitive.drawPoints() not implement!")
}, drawLine:function(origin, destination) {
  cc.log("DrawingPrimitive.drawLine() not implement!")
}, drawRect:function(origin, destination) {
  cc.log("DrawingPrimitive.drawRect() not implement!")
}, drawSolidRect:function(origin, destination, color) {
  cc.log("DrawingPrimitive.drawSolidRect() not implement!")
}, drawPoly:function(vertices, numOfVertices, closePolygon, fill) {
  cc.log("DrawingPrimitive.drawPoly() not implement!")
}, drawSolidPoly:function(poli, numberOfPoints, color) {
  cc.log("DrawingPrimitive.drawSolidPoly() not implement!")
}, drawCircle:function(center, radius, angle, segments, drawLineToCenter) {
  cc.log("DrawingPrimitive.drawCircle() not implement!")
}, drawQuadBezier:function(origin, control, destination, segments) {
  cc.log("DrawingPrimitive.drawQuadBezier() not implement!")
}, drawCubicBezier:function(origin, control1, control2, destination, segments) {
  cc.log("DrawingPrimitive.drawCubicBezier() not implement!")
}, drawCatmullRom:function(points, segments) {
  cc.log("DrawingPrimitive.drawCardinalSpline() not implement!")
}, drawCardinalSpline:function(config, tension, segments) {
  cc.log("DrawingPrimitive.drawCardinalSpline() not implement!")
}});
cc.DrawingPrimitiveCanvas = cc.DrawingPrimitive.extend({drawPoint:function(point, size) {
  if(!size) {
    size = 1
  }
  var newPoint = cc.p(point.x * cc.CONTENT_SCALE_FACTOR(), point.y * cc.CONTENT_SCALE_FACTOR());
  this._renderContext.beginPath();
  this._renderContext.arc(newPoint.x, -newPoint.y, size * cc.CONTENT_SCALE_FACTOR(), 0, Math.PI * 2, false);
  this._renderContext.closePath();
  this._renderContext.fill()
}, drawPoints:function(points, numberOfPoints, size) {
  if(points == null) {
    return
  }
  if(!size) {
    size = 1
  }
  this._renderContext.beginPath();
  for(var i = 0;i < points.length;i++) {
    this._renderContext.arc(points[i].x * cc.CONTENT_SCALE_FACTOR(), -points[i].y * cc.CONTENT_SCALE_FACTOR(), size * cc.CONTENT_SCALE_FACTOR(), 0, Math.PI * 2, false)
  }
  this._renderContext.closePath();
  this._renderContext.fill()
}, drawLine:function(origin, destination) {
  this._renderContext.beginPath();
  this._renderContext.moveTo(origin.x * cc.CONTENT_SCALE_FACTOR(), -origin.y * cc.CONTENT_SCALE_FACTOR());
  this._renderContext.lineTo(destination.x * cc.CONTENT_SCALE_FACTOR(), -destination.y * cc.CONTENT_SCALE_FACTOR());
  this._renderContext.closePath();
  this._renderContext.stroke()
}, drawRect:function(origin, destination) {
  this.drawLine(cc.p(origin.x, origin.y), cc.p(destination.x, origin.y));
  this.drawLine(cc.p(destination.x, origin.y), cc.p(destination.x, destination.y));
  this.drawLine(cc.p(destination.x, destination.y), cc.p(origin.x, destination.y));
  this.drawLine(cc.p(origin.x, destination.y), cc.p(origin.x, origin.y))
}, drawSolidRect:function(origin, destination, color) {
  var vertices = [origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y)];
  this.drawSolidPoly(vertices, 4, color)
}, drawPoly:function(vertices, numOfVertices, closePolygon, fill) {
  if(fill == "undefined") {
    fill = false
  }
  if(vertices == null) {
    return
  }
  if(vertices.length < 3) {
    throw new Error("Polygon's point must greater than 2");
  }
  var firstPoint = vertices[0];
  this._renderContext.beginPath();
  this._renderContext.moveTo(firstPoint.x * cc.CONTENT_SCALE_FACTOR(), -firstPoint.y * cc.CONTENT_SCALE_FACTOR());
  for(var i = 1;i < vertices.length;i++) {
    this._renderContext.lineTo(vertices[i].x * cc.CONTENT_SCALE_FACTOR(), -vertices[i].y * cc.CONTENT_SCALE_FACTOR())
  }
  if(closePolygon) {
    this._renderContext.closePath()
  }
  if(fill) {
    this._renderContext.fill()
  }else {
    this._renderContext.stroke()
  }
}, drawSolidPoly:function(poli, numberOfPoints, color) {
  this.setDrawColor4F(color.r, color.g, color.b, color.a);
  this.drawPoly(poli, numberOfPoints, true, true)
}, drawCircle:function(center, radius, angle, segments, drawLineToCenter) {
  this._renderContext.beginPath();
  var endAngle = angle - Math.PI * 2;
  this._renderContext.arc(0 | center.x, 0 | -center.y, radius, -angle, -endAngle, false);
  if(drawLineToCenter) {
    this._renderContext.lineTo(0 | center.x, 0 | -center.y)
  }
  this._renderContext.stroke()
}, drawQuadBezier:function(origin, control, destination, segments) {
  var vertices = [];
  var t = 0;
  for(var i = 0;i < segments;i++) {
    var x = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
    var y = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
    vertices.push(cc.p(x * cc.CONTENT_SCALE_FACTOR(), y * cc.CONTENT_SCALE_FACTOR()));
    t += 1 / segments
  }
  vertices.push(cc.p(destination.x * cc.CONTENT_SCALE_FACTOR(), destination.y * cc.CONTENT_SCALE_FACTOR()));
  this.drawPoly(vertices, segments + 1, false, false)
}, drawCubicBezier:function(origin, control1, control2, destination, segments) {
  var vertices = [];
  var t = 0;
  for(var i = 0;i < segments;i++) {
    var x = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
    var y = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
    vertices.push(cc.p(x * cc.CONTENT_SCALE_FACTOR(), y * cc.CONTENT_SCALE_FACTOR()));
    t += 1 / segments
  }
  vertices.push(cc.p(destination.x * cc.CONTENT_SCALE_FACTOR(), destination.y * cc.CONTENT_SCALE_FACTOR()));
  this.drawPoly(vertices, segments + 1, false, false)
}, drawCatmullRom:function(points, segments) {
  this.drawCardinalSpline(points, 0.5, segments)
}, drawCardinalSpline:function(config, tension, segments) {
  cc.renderContext.strokeStyle = "rgba(255,255,255,1)";
  var points = [];
  var p, lt;
  var deltaT = 1 / config.length;
  for(var i = 0;i < segments + 1;i++) {
    var dt = i / segments;
    if(dt == 1) {
      p = config.length - 1;
      lt = 1
    }else {
      p = 0 | dt / deltaT;
      lt = (dt - deltaT * p) / deltaT
    }
    var newPos = cc.CardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p - 0), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
    points.push(newPos)
  }
  this.drawPoly(points, segments + 1, false, false)
}, drawImage:function(image, sourcePoint, sourceSize, destPoint, destSize) {
  var len = arguments.length;
  switch(len) {
    case 2:
      var height = image.height;
      this._renderContext.drawImage(image, sourcePoint.x, -(sourcePoint.y + height));
      break;
    case 3:
      this._renderContext.drawImage(image, sourcePoint.x, -(sourcePoint.y + sourceSize.height), sourceSize.width, sourceSize.height);
      break;
    case 5:
      this._renderContext.drawImage(image, sourcePoint.x, sourcePoint.y, sourceSize.width, sourceSize.height, destPoint.x, -(destPoint.y + destSize.height), destSize.width, destSize.height);
      break;
    default:
      throw new Error("Argument must be non-nil");break
  }
}, drawStar:function(ctx, radius, color) {
  var context = ctx || this._renderContext;
  if(color instanceof cc.Color4F) {
    color = new cc.Color3B(0 | color.r * 255, 0 | color.g * 255, 0 | color.b * 255)
  }
  var colorStr = "rgba(" + color.r + "," + color.g + "," + color.b;
  context.fillStyle = colorStr + ",1)";
  var subRadius = radius / 10;
  context.beginPath();
  context.moveTo(-radius, radius);
  context.lineTo(0, subRadius);
  context.lineTo(radius, radius);
  context.lineTo(subRadius, 0);
  context.lineTo(radius, -radius);
  context.lineTo(0, -subRadius);
  context.lineTo(-radius, -radius);
  context.lineTo(-subRadius, 0);
  context.lineTo(-radius, radius);
  context.closePath();
  context.fill();
  var g1 = context.createRadialGradient(0, 0, subRadius, 0, 0, radius);
  g1.addColorStop(0, colorStr + ", 1)");
  g1.addColorStop(0.3, colorStr + ", 0.8)");
  g1.addColorStop(1, colorStr + ", 0.0)");
  context.fillStyle = g1;
  context.beginPath();
  var startAngle_1 = 0;
  var endAngle_1 = cc.PI2;
  context.arc(0, 0, radius - subRadius, startAngle_1, endAngle_1, false);
  context.closePath();
  context.fill()
}, drawColorBall:function(ctx, radius, color) {
  var context = ctx || this._renderContext;
  if(color instanceof cc.Color4F) {
    color = new cc.Color3B(0 | color.r * 255, 0 | color.g * 255, 0 | color.b * 255)
  }
  var colorStr = "rgba(" + color.r + "," + color.g + "," + color.b;
  var subRadius = radius / 10;
  var g1 = context.createRadialGradient(0, 0, subRadius, 0, 0, radius);
  g1.addColorStop(0, colorStr + ", 1)");
  g1.addColorStop(0.3, colorStr + ", 0.8)");
  g1.addColorStop(0.6, colorStr + ", 0.4)");
  g1.addColorStop(1, colorStr + ", 0.0)");
  context.fillStyle = g1;
  context.beginPath();
  var startAngle_1 = 0;
  var endAngle_1 = cc.PI2;
  context.arc(0, 0, radius, startAngle_1, endAngle_1, false);
  context.closePath();
  context.fill()
}, fillText:function(strText, x, y) {
  this._renderContext.fillText(strText, x, -y)
}, setDrawColor4B:function(r, g, b, a) {
  this._renderContext.fillStyle = "rgba(" + r + "," + g + "," + b + "," + a / 255 + ")";
  this._renderContext.strokeStyle = "rgba(" + r + "," + g + "," + b + "," + a / 255 + ")"
}, setDrawColor4F:function(r, g, b, a) {
  this._renderContext.fillStyle = "rgba(" + (0 | r * 255) + "," + (0 | g * 255) + "," + (0 | b * 255) + "," + a + ")";
  this._renderContext.strokeStyle = "rgba(" + (0 | r * 255) + "," + (0 | g * 255) + "," + (0 | b * 255) + "," + a + ")"
}, setPointSize:function(pointSize) {
}, setLineWidth:function(width) {
  this._renderContext.lineWidth = width
}});
cc.DrawingPrimitiveWebGL = cc.DrawingPrimitive.extend({_initialized:false, _shader:null, _colorLocation:-1, _color:null, _pointSizeLocation:-1, _pointSize:-1, ctor:function(ctx) {
  if(ctx == null) {
    ctx = cc.renderContext
  }
  if(!ctx instanceof WebGLRenderingContext) {
    throw"Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext";
  }
  this._super(ctx);
  this._color = new cc.Color4F(1, 1, 1, 1)
}, lazy_init:function() {
  if(!this._initialized) {
    this._shader = cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_UCOLOR);
    this._colorLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_color");
    this._pointSizeLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_pointSize");
    this._initialized = true
  }
}, drawInit:function() {
  this._initialized = false
}, drawPoint:function(point) {
  this.lazy_init();
  this._shader.use();
  this._shader.setUniformForModelViewProjectionMatrix();
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
  this._shader.setUniformLocationWith4fv(this._colorLocation, new Float32Array(this._color._arrayBuffer, 0, 4), 1);
  this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
  var pointBuffer = this._renderContext.createBuffer();
  this._renderContext.bindBuffer(this._renderContext.ARRAY_BUFFER, pointBuffer);
  this._renderContext.bufferData(this._renderContext.ARRAY_BUFFER, new Float32Array([point.x, point.y]), this._renderContext.STATIC_DRAW);
  this._renderContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, this._renderContext.FLOAT, false, 0, 0);
  this._renderContext.drawArrays(this._renderContext.POINTS, 0, 1);
  cc.INCREMENT_GL_DRAWS(1)
}, drawPoints:function(points, numberOfPoints) {
  if(!points || points.length == 0) {
    return
  }
  this.lazy_init();
  this._shader.use();
  this._shader.setUniformForModelViewProjectionMatrix();
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
  this._shader.setUniformLocationWith4fv(this._colorLocation, new Float32Array(this._color._arrayBuffer, 0, 4), 1);
  this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
  var pointBuffer = this._renderContext.createBuffer();
  this._renderContext.bindBuffer(this._renderContext.ARRAY_BUFFER, pointBuffer);
  this._renderContext.bufferData(this._renderContext.ARRAY_BUFFER, this._pointsToTypeArray(points), this._renderContext.STATIC_DRAW);
  this._renderContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, this._renderContext.FLOAT, false, 0, 0);
  this._renderContext.drawArrays(this._renderContext.POINTS, 0, points.length);
  cc.INCREMENT_GL_DRAWS(1)
}, _pointsToTypeArray:function(points) {
  var typeArr = new Float32Array(points.length * 2);
  for(var i = 0;i < points.length;i++) {
    typeArr[i * 2] = points[i].x;
    typeArr[i * 2 + 1] = points[i].y
  }
  return typeArr
}, drawLine:function(origin, destination) {
  this.lazy_init();
  this._shader.use();
  this._shader.setUniformForModelViewProjectionMatrix();
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
  this._shader.setUniformLocationWith4fv(this._colorLocation, new Float32Array(this._color._arrayBuffer, 0, 4), 1);
  var pointBuffer = this._renderContext.createBuffer();
  this._renderContext.bindBuffer(this._renderContext.ARRAY_BUFFER, pointBuffer);
  this._renderContext.bufferData(this._renderContext.ARRAY_BUFFER, this._pointsToTypeArray([origin, destination]), this._renderContext.STATIC_DRAW);
  this._renderContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, this._renderContext.FLOAT, false, 0, 0);
  this._renderContext.drawArrays(this._renderContext.LINES, 0, 2);
  cc.INCREMENT_GL_DRAWS(1)
}, drawRect:function(origin, destination) {
  this.drawLine(cc.p(origin.x, origin.y), cc.p(destination.x, origin.y));
  this.drawLine(cc.p(destination.x, origin.y), cc.p(destination.x, destination.y));
  this.drawLine(cc.p(destination.x, destination.y), cc.p(origin.x, destination.y));
  this.drawLine(cc.p(origin.x, destination.y), cc.p(origin.x, origin.y))
}, drawSolidRect:function(origin, destination, color) {
  var vertices = [origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y)];
  this.drawSolidPoly(vertices, 4, color)
}, drawPoly:function(vertices, numOfVertices, closePolygon) {
  this.lazy_init();
  this._shader.use();
  this._shader.setUniformForModelViewProjectionMatrix();
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
  this._shader.setUniformLocationWith4fv(this._colorLocation, new Float32Array(this._color._arrayBuffer, 0, 4), 1);
  var pointBuffer = this._renderContext.createBuffer();
  this._renderContext.bindBuffer(this._renderContext.ARRAY_BUFFER, pointBuffer);
  this._renderContext.bufferData(this._renderContext.ARRAY_BUFFER, this._pointsToTypeArray(vertices), this._renderContext.STATIC_DRAW);
  this._renderContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, this._renderContext.FLOAT, false, 0, 0);
  if(closePolygon) {
    this._renderContext.drawArrays(this._renderContext.LINE_LOOP, 0, vertices.length)
  }else {
    this._renderContext.drawArrays(this._renderContext.LINE_STRIP, 0, vertices.length)
  }
  cc.INCREMENT_GL_DRAWS(1)
}, drawSolidPoly:function(poli, numberOfPoints, color) {
  this.lazy_init();
  if(!color) {
    color = this._color
  }
  this._shader.use();
  this._shader.setUniformForModelViewProjectionMatrix();
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
  this._shader.setUniformLocationWith4fv(this._colorLocation, new Float32Array(color._arrayBuffer, 0, 4), 1);
  var pointBuffer = this._renderContext.createBuffer();
  this._renderContext.bindBuffer(this._renderContext.ARRAY_BUFFER, pointBuffer);
  this._renderContext.bufferData(this._renderContext.ARRAY_BUFFER, this._pointsToTypeArray(poli), this._renderContext.STATIC_DRAW);
  this._renderContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, this._renderContext.FLOAT, false, 0, 0);
  this._renderContext.drawArrays(this._renderContext.TRIANGLE_FAN, 0, poli.length);
  cc.INCREMENT_GL_DRAWS(1)
}, drawCircle:function(center, radius, angle, segments, drawLineToCenter) {
  this.lazy_init();
  var additionalSegment = 1;
  if(drawLineToCenter) {
    additionalSegment++
  }
  var coef = 2 * Math.PI / segments;
  var vertices = new Float32Array((segments + 2) * 2);
  if(!vertices) {
    return
  }
  for(var i = 0;i <= segments;i++) {
    var rads = i * coef;
    var j = radius * Math.cos(rads + angle) + center.x;
    var k = radius * Math.sin(rads + angle) + center.y;
    vertices[i * 2] = j;
    vertices[i * 2 + 1] = k
  }
  vertices[(segments + 1) * 2] = center.x;
  vertices[(segments + 1) * 2 + 1] = center.y;
  this._shader.use();
  this._shader.setUniformForModelViewProjectionMatrix();
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
  this._shader.setUniformLocationWith4fv(this._colorLocation, new Float32Array(this._color._arrayBuffer, 0, 4), 1);
  var pointBuffer = this._renderContext.createBuffer();
  this._renderContext.bindBuffer(this._renderContext.ARRAY_BUFFER, pointBuffer);
  this._renderContext.bufferData(this._renderContext.ARRAY_BUFFER, vertices, this._renderContext.STATIC_DRAW);
  this._renderContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, this._renderContext.FLOAT, false, 0, 0);
  this._renderContext.drawArrays(this._renderContext.LINE_STRIP, 0, segments + additionalSegment);
  cc.INCREMENT_GL_DRAWS(1)
}, drawQuadBezier:function(origin, control, destination, segments) {
  this.lazy_init();
  var vertices = new Float32Array((segments + 1) * 2);
  var t = 0;
  for(var i = 0;i < segments;i++) {
    vertices[i * 2] = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
    vertices[i * 2 + 1] = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
    t += 1 / segments
  }
  vertices[segments * 2] = destination.x;
  vertices[segments * 2 + 1] = destination.y;
  this._shader.use();
  this._shader.setUniformForModelViewProjectionMatrix();
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
  this._shader.setUniformLocationWith4fv(this._colorLocation, new Float32Array(this._color._arrayBuffer, 0, 4), 1);
  var pointBuffer = this._renderContext.createBuffer();
  this._renderContext.bindBuffer(this._renderContext.ARRAY_BUFFER, pointBuffer);
  this._renderContext.bufferData(this._renderContext.ARRAY_BUFFER, vertices, this._renderContext.STATIC_DRAW);
  this._renderContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, this._renderContext.FLOAT, false, 0, 0);
  this._renderContext.drawArrays(this._renderContext.LINE_STRIP, 0, segments + 1);
  cc.INCREMENT_GL_DRAWS(1)
}, drawCubicBezier:function(origin, control1, control2, destination, segments) {
  this.lazy_init();
  var vertices = new Float32Array((segments + 1) * 2);
  var t = 0;
  for(var i = 0;i < segments;i++) {
    vertices[i * 2] = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
    vertices[i * 2 + 1] = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
    t += 1 / segments
  }
  vertices[segments * 2] = destination.x;
  vertices[segments * 2 + 1] = destination.y;
  this._shader.use();
  this._shader.setUniformForModelViewProjectionMatrix();
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
  this._shader.setUniformLocationWith4fv(this._colorLocation, new Float32Array(this._color._arrayBuffer, 0, 4), 1);
  var pointBuffer = this._renderContext.createBuffer();
  this._renderContext.bindBuffer(this._renderContext.ARRAY_BUFFER, pointBuffer);
  this._renderContext.bufferData(this._renderContext.ARRAY_BUFFER, vertices, this._renderContext.STATIC_DRAW);
  this._renderContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, this._renderContext.FLOAT, false, 0, 0);
  this._renderContext.drawArrays(this._renderContext.LINE_STRIP, 0, segments + 1);
  cc.INCREMENT_GL_DRAWS(1)
}, drawCatmullRom:function(points, segments) {
  this.drawCardinalSpline(points, 0.5, segments)
}, drawCardinalSpline:function(config, tension, segments) {
  this.lazy_init();
  var vertices = new Float32Array((segments + 1) * 2);
  var p, lt, deltaT = 1 / config.length;
  for(var i = 0;i < segments + 1;i++) {
    var dt = i / segments;
    if(dt == 1) {
      p = config.length - 1;
      lt = 1
    }else {
      p = 0 | dt / deltaT;
      lt = (dt - deltaT * p) / deltaT
    }
    var newPos = cc.CardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
    vertices[i * 2] = newPos.x;
    vertices[i * 2 + 1] = newPos.y
  }
  this._shader.use();
  this._shader.setUniformForModelViewProjectionMatrix();
  cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
  this._shader.setUniformLocationWith4fv(this._colorLocation, new Float32Array(this._color._arrayBuffer, 0, 4), 1);
  var pointBuffer = this._renderContext.createBuffer();
  this._renderContext.bindBuffer(this._renderContext.ARRAY_BUFFER, pointBuffer);
  this._renderContext.bufferData(this._renderContext.ARRAY_BUFFER, vertices, this._renderContext.STATIC_DRAW);
  this._renderContext.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, this._renderContext.FLOAT, false, 0, 0);
  this._renderContext.drawArrays(this._renderContext.LINE_STRIP, 0, segments + 1);
  cc.INCREMENT_GL_DRAWS(1)
}, setDrawColor4B:function(r, g, b, a) {
  this._color.r = r / 255;
  this._color.g = g / 255;
  this._color.b = b / 255;
  this._color.a = a / 255
}, setDrawColor4F:function(r, g, b, a) {
  this._color.r = r;
  this._color.g = g;
  this._color.b = b;
  this._color.a = a
}, setPointSize:function(pointSize) {
  this._pointSize = pointSize * cc.CONTENT_SCALE_FACTOR()
}, setLineWidth:function(width) {
  if(this._renderContext.lineWidth) {
    this._renderContext.lineWidth(width)
  }
}});
cc.PI2 = Math.PI * 2;
cc.ORIENTATION_PORTRAIT = 0;
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
cc.ORIENTATION_LANDSCAPE_LEFT = 2;
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
cc.CANVAS = 0;
cc.WEBGL = 1;
cc.drawingUtil = null;
cc.renderContext = null;
cc.canvas = null;
cc.gameDiv = null;
cc.renderContextType = cc.CANVAS;
cc.originalCanvasSize = cc.size(0, 0);
window.requestAnimFrame = function() {
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame
}();
if(!window.console) {
  window.console = {};
  window.console.log = function() {
  };
  window.console.assert = function() {
  }
}
cc.isAddedHiddenEvent = false;
cc.setup = function(el, width, height) {
  var element = cc.$(el) || cc.$("#" + el);
  if(element.tagName == "CANVAS") {
    width = width || element.width;
    height = height || element.height;
    cc.container = cc.$new("DIV");
    cc.canvas = element;
    cc.canvas.parentNode.insertBefore(cc.container, cc.canvas);
    cc.canvas.appendTo(cc.container);
    cc.container.style.width = (width || 480) + "px";
    cc.container.style.height = (height || 320) + "px";
    cc.container.setAttribute("id", "Cocos2dGameContainer");
    cc.canvas.setAttribute("width", width || 480);
    cc.canvas.setAttribute("height", height || 320)
  }else {
    if(element.tagName != "DIV") {
      cc.log("Warning: target element is not a DIV or CANVAS")
    }
    width = width || element.clientWidth;
    height = height || element.clientHeight;
    cc.canvas = cc.$new("CANVAS");
    cc.canvas.addClass("gameCanvas");
    cc.canvas.setAttribute("width", width || 480);
    cc.canvas.setAttribute("height", height || 320);
    cc.container = element;
    element.appendChild(cc.canvas);
    cc.container.style.width = (width || 480) + "px";
    cc.container.style.height = (height || 320) + "px"
  }
  cc.container.style.position = "relative";
  cc.container.style.overflow = "hidden";
  cc.container.top = "100%";
  if(cc.__renderDoesnotSupport) {
    return
  }
  if(cc.Browser.supportWebGL) {
    cc.renderContext = cc.webglContext = cc.create3DContext(cc.canvas, {"stencil":true, "preserveDrawingBuffer":true, "alpha":false})
  }
  if(cc.renderContext) {
    cc.renderContextType = cc.WEBGL;
    window.gl = cc.renderContext;
    cc.drawingUtil = new cc.DrawingPrimitiveWebGL(cc.renderContext);
    cc.TextureCache.getInstance()._initializingRenderer()
  }else {
    cc.renderContext = cc.canvas.getContext("2d");
    cc.renderContextType = cc.CANVAS;
    cc.renderContext.translate(0, cc.canvas.height);
    cc.drawingUtil = new cc.DrawingPrimitiveCanvas(cc.renderContext)
  }
  cc.originalCanvasSize = cc.size(cc.canvas.width, cc.canvas.height);
  cc.gameDiv = cc.container;
  cc.log(cc.ENGINE_VERSION);
  cc.Configuration.getInstance();
  cc.setContextMenuEnable(false);
  if(cc.Browser.isMobile) {
    cc._addUserSelectStatus()
  }
  var hidden, visibilityChange;
  if(typeof document.hidden !== "undefined") {
    hidden = "hidden";
    visibilityChange = "visibilitychange"
  }else {
    if(typeof document.mozHidden !== "undefined") {
      hidden = "mozHidden";
      visibilityChange = "mozvisibilitychange"
    }else {
      if(typeof document.msHidden !== "undefined") {
        hidden = "msHidden";
        visibilityChange = "msvisibilitychange"
      }else {
        if(typeof document.webkitHidden !== "undefined") {
          hidden = "webkitHidden";
          visibilityChange = "webkitvisibilitychange"
        }
      }
    }
  }
  function handleVisibilityChange() {
    if(!document[hidden]) {
      cc.Director.getInstance()._resetLastUpdate()
    }
  }
  if(typeof document.addEventListener === "undefined" || typeof hidden === "undefined") {
    cc.isAddedHiddenEvent = false
  }else {
    cc.isAddedHiddenEvent = true;
    document.addEventListener(visibilityChange, handleVisibilityChange, false)
  }
};
cc._addUserSelectStatus = function() {
  var fontStyle = document.createElement("style");
  fontStyle.type = "text/css";
  document.body.appendChild(fontStyle);
  fontStyle.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;" + "-webkit-tap-highlight-color:rgba(0,0,0,0);}"
};
cc.bindingRendererClass = function(renderType) {
  if(renderType === cc.WEBGL) {
    cc.Node = cc.NodeWebGL;
    cc.Sprite = cc.SpriteWebGL;
    cc.SpriteBatchNode = cc.SpriteBatchNodeWebGL;
    cc.TextureCache = cc.TextureCacheWebGL;
    cc.ProgressTimer = cc.ProgressTimerWebGL;
    cc.AtlasNode = cc.AtlasNodeWebGL;
    cc.LabelTTF = cc.LabelTTFWebGL;
    cc.LayerColor = cc.LayerColorWebGL;
    cc.DrawNode = cc.DrawNodeWebGL;
    cc.LabelAtlas = cc.LabelAtlasWebGL
  }else {
    cc.Node = cc.NodeCanvas;
    cc.Sprite = cc.SpriteCanvas;
    cc.SpriteBatchNode = cc.SpriteBatchNodeCanvas;
    cc.TextureCache = cc.TextureCacheCanvas;
    cc.ProgressTimer = cc.ProgressTimerCanvas;
    cc.AtlasNode = cc.AtlasNodeCanvas;
    cc.LabelTTF = cc.LabelTTFCanvas;
    cc.LayerColor = cc.LayerColorCanvas;
    cc.DrawNode = cc.DrawNodeCanvas;
    cc.LabelAtlas = cc.LabelAtlasCanvas
  }
};
cc._isContextMenuEnable = false;
cc.setContextMenuEnable = function(enabled) {
  cc._isContextMenuEnable = enabled;
  if(!cc._isContextMenuEnable) {
    cc.canvas.oncontextmenu = function() {
      return false
    }
  }else {
    cc.canvas.oncontextmenu = function() {
    }
  }
};
cc.Application = cc.Class.extend({ctor:function() {
  this._animationInterval = 0;
  cc.Assert(!cc._sharedApplication, "CCApplication ctor");
  cc._sharedApplication = this
}, setAnimationInterval:function(interval) {
  this._animationInterval = interval
}, statusBarFrame:function(rect) {
  if(rect) {
    rect = cc.rect(0, 0, 0, 0)
  }
}, run:function() {
  if(!this.applicationDidFinishLaunching()) {
    return 0
  }
  var callback;
  if(window.requestAnimFrame && this._animationInterval == 1 / 60) {
    callback = function() {
      cc.Director.getInstance().mainLoop();
      window.requestAnimFrame(callback)
    };
    cc.log(window.requestAnimFrame);
    window.requestAnimFrame(callback)
  }else {
    callback = function() {
      cc.Director.getInstance().mainLoop()
    };
    setInterval(callback, this._animationInterval * 1E3)
  }
  return 0
}, _animationInterval:null});
cc.Application.sharedApplication = function() {
  cc.Assert(cc._sharedApplication, "sharedApplication");
  return cc._sharedApplication
};
cc.Application.getCurrentLanguage = function() {
  var ret = cc.LANGUAGE_ENGLISH;
  var currentLang = navigator.language;
  if(!currentLang) {
    currentLang = navigator.browserLanguage || navigator.userLanguage
  }
  if(!currentLang) {
    return ret
  }
  currentLang = currentLang.toLowerCase();
  switch(currentLang) {
    case "zh-cn":
      ret = cc.LANGUAGE_CHINESE;
      break;
    case "fr":
      ret = cc.LANGUAGE_FRENCH;
      break;
    case "it":
      ret = cc.LANGUAGE_ITALIAN;
      break;
    case "de":
      ret = cc.LANGUAGE_GERMAN;
      break;
    case "es":
      ret = cc.LANGUAGE_SPANISH;
      break;
    case "ru":
      ret = cc.LANGUAGE_RUSSIAN;
      break
  }
  return ret
};
cc._sharedApplication = null;
cc.SAXParser = cc.Class.extend({xmlDoc:null, parser:null, _xmlDict:null, plist:null, ctor:function() {
  this._xmlDict = {};
  this.plist = {}
}, parse:function(textxml) {
  textxml = this.getList(textxml);
  if(window.DOMParser) {
    this.parser = new DOMParser;
    this.xmlDoc = this.parser.parseFromString(textxml, "text/xml")
  }else {
    this.xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
    this.xmlDoc.async = "false";
    this.xmlDoc.loadXML(textxml)
  }
  if(this.xmlDoc == null) {
    cc.log("cocos2d:xml " + this.xmlDoc + " not found!")
  }
  var plist = this.xmlDoc.documentElement;
  if(plist.tagName != "plist") {
    throw"cocos2d:Not a plist file";
  }
  var node = null;
  for(var i = 0, len = plist.childNodes.length;i < len;i++) {
    node = plist.childNodes[i];
    if(node.nodeType == 1) {
      break
    }
  }
  this.plist = this._parseNode(node);
  return this.plist
}, tmxParse:function(textxml, isXMLString) {
  if(isXMLString == null || isXMLString === false) {
    textxml = this.getList(textxml)
  }
  if(window.DOMParser) {
    this.parser = new DOMParser;
    this.xmlDoc = this.parser.parseFromString(textxml, "text/xml")
  }else {
    this.xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
    this.xmlDoc.async = "false";
    this.xmlDoc.loadXML(textxml)
  }
  if(this.xmlDoc == null) {
    cc.log("cocos2d:xml " + this.xmlDoc + " not found!")
  }
  return this.xmlDoc
}, _parseNode:function(node) {
  var data = null;
  switch(node.tagName) {
    case "dict":
      data = this._parseDict(node);
      break;
    case "array":
      data = this._parseArray(node);
      break;
    case "string":
      if(node.childNodes.length == 1) {
        data = node.firstChild.nodeValue
      }else {
        data = "";
        for(var i = 0;i < node.childNodes.length;i++) {
          data += node.childNodes[i].nodeValue
        }
      }
      break;
    case "false":
      data = false;
      break;
    case "true":
      data = true;
      break;
    case "real":
      data = parseFloat(node.firstChild.nodeValue);
      break;
    case "integer":
      data = parseInt(node.firstChild.nodeValue, 10);
      break
  }
  return data
}, _parseArray:function(node) {
  var data = [];
  for(var i = 0, len = node.childNodes.length;i < len;i++) {
    var child = node.childNodes[i];
    if(child.nodeType != 1) {
      continue
    }
    data.push(this._parseNode(child))
  }
  return data
}, _parseDict:function(node) {
  var data = {};
  var key = null;
  for(var i = 0, len = node.childNodes.length;i < len;i++) {
    var child = node.childNodes[i];
    if(child.nodeType != 1) {
      continue
    }
    if(child.tagName == "key") {
      key = child.firstChild.nodeValue
    }else {
      data[key] = this._parseNode(child)
    }
  }
  return data
}, preloadPlist:function(filePath) {
  filePath = cc.FileUtils.getInstance().fullPathFromRelativePath(filePath);
  if(window.XMLHttpRequest) {
    var xmlhttp = new XMLHttpRequest;
    if(xmlhttp.overrideMimeType) {
      xmlhttp.overrideMimeType("text/xml")
    }
  }else {
    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP")
  }
  if(xmlhttp != null) {
    var that = this;
    xmlhttp.onreadystatechange = function() {
      if(xmlhttp.readyState == 4) {
        if(xmlhttp.responseText) {
          cc.Loader.getInstance().onResLoaded();
          that._xmlDict[filePath] = xmlhttp.responseText;
          xmlhttp = null
        }else {
          cc.Assert("cocos2d:There was a problem retrieving the xml data:" + xmlhttp.statusText)
        }
      }
    };
    xmlhttp.open("GET", filePath, true);
    xmlhttp.send(null)
  }else {
    cc.Assert("cocos2d:Your browser does not support XMLHTTP.")
  }
}, getName:function(filePath) {
  var startPos = filePath.lastIndexOf("/", filePath.length) + 1;
  var endPos = filePath.lastIndexOf(".", filePath.length);
  return filePath.substring(startPos, endPos)
}, getExt:function(filePath) {
  var startPos = filePath.lastIndexOf(".", filePath.length) + 1;
  return filePath.substring(startPos, filePath.length)
}, getList:function(key) {
  if(this._xmlDict != null) {
    return this._xmlDict[key]
  }
  return null
}});
cc.SAXParser.getInstance = function() {
  if(!this._instance) {
    this._instance = new cc.SAXParser
  }
  return this._instance
};
cc.SAXParser._instance = null;
cc.AppController = cc.Class.extend({didFinishLaunchingWithOptions:function() {
  cc.Application.sharedApplication().run();
  return true
}, applicationWillResignActive:function() {
  cc.Director.getInstance().pause()
}, applicationDidBecomeActive:function() {
  cc.Director.getInstance().resume()
}, applicationDidEnterBackground:function() {
  cc.Application.sharedApplication().applicationDidEnterBackground()
}, applicationWillEnterForeground:function() {
  cc.Application.sharedApplication().applicationWillEnterForeground()
}, applicationWillTerminate:function() {
}});
cc.AppController.shareAppController = function() {
  if(cc.sharedAppController == null) {
    cc.sharedAppController = new cc.AppController
  }
  cc.Assert(cc.sharedAppController, "shareAppController");
  return cc.sharedAppController
};
cc.sharedAppController = null;
cc.ITEM_SIZE = 32;
cc._fontSize = cc.ITEM_SIZE;
cc._fontName = "Arial";
cc._fontNameRelease = false;
cc.CURRENT_ITEM = 3233828865;
cc.ZOOM_ACTION_TAG = 3233828866;
cc.NORMAL_TAG = 8801;
cc.SELECTED_TAG = 8802;
cc.DISABLE_TAG = 8803;
cc.MenuItem = cc.Node.extend({_listener:null, _selector:null, _isSelected:false, _isEnabled:false, isSelected:function() {
  return this._isSelected
}, setTarget:function(selector, rec) {
  this._listener = rec;
  this._selector = selector
}, isEnabled:function() {
  return this._isEnabled
}, setEnabled:function(enable) {
  this._isEnabled = enable
}, initWithCallback:function(selector, rec) {
  this.setAnchorPoint(cc.p(0.5, 0.5));
  this._listener = rec;
  this._selector = selector;
  this._isEnabled = true;
  this._isSelected = false;
  return true
}, rect:function() {
  return cc.rect(this._position.x - this._contentSize.width * this._anchorPoint.x, this._position.y - this._contentSize.height * this._anchorPoint.y, this._contentSize.width, this._contentSize.height)
}, selected:function() {
  this._isSelected = true
}, unselected:function() {
  this._isSelected = false
}, setCallback:function(selector, rec) {
  this._listener = rec;
  this._selector = selector
}, activate:function() {
  if(this._isEnabled) {
    if(this._listener && typeof this._selector == "string") {
      this._listener[this._selector](this)
    }else {
      if(this._listener && typeof this._selector == "function") {
        this._selector.call(this._listener, this)
      }else {
        this._selector(this)
      }
    }
  }
}});
cc.MenuItem.create = function(selector, rec) {
  var ret = new cc.MenuItem;
  ret.initWithCallback(rec, selector);
  return ret
};
cc.MenuItemLabel = cc.MenuItem.extend({RGBAProtocol:true, _disabledColor:new cc.Color3B, getDisabledColor:function() {
  return this._disabledColor
}, setDisabledColor:function(color) {
  this._disabledColor = color
}, _label:null, getLabel:function() {
  return this._label
}, setLabel:function(label) {
  if(label) {
    this.addChild(label);
    label.setAnchorPoint(cc.p(0, 0));
    this.setContentSize(label.getContentSize())
  }
  if(this._label) {
    this.removeChild(this._label, true)
  }
  this._label = label
}, _orginalScale:0, setEnabled:function(enabled) {
  if(this._isEnabled != enabled) {
    if(!enabled) {
      this._colorBackup = this._label.getColor();
      this._label.setColor(this._disabledColor)
    }else {
      this._label.setColor(this._colorBackup)
    }
  }
  this._super(enabled)
}, setOpacity:function(opacity) {
  this._label.setOpacity(opacity)
}, getOpacity:function() {
  return this._label.getOpacity()
}, setColor:function(color) {
  this._label.setColor(color)
}, getColor:function() {
  return this._label.getColor()
}, setOpacityModifyRGB:function(value) {
}, isOpacityModifyRGB:function() {
}, initWithLabel:function(label, selector, target) {
  this.initWithCallback(selector, target);
  this._originalScale = 1;
  this._colorBackup = cc.white();
  this._disabledColor = cc.c3b(126, 126, 126);
  this.setLabel(label);
  return true
}, setString:function(label) {
  this._label.setString(label);
  this.setContentSize(this._label.getContentSize())
}, activate:function() {
  if(this._isEnabled) {
    this.stopAllActions();
    this.setScale(this._originalScale);
    this._super()
  }
}, selected:function() {
  if(this._isEnabled) {
    this._super();
    var action = this.getActionByTag(cc.ZOOM_ACTION_TAG);
    if(action) {
      this.stopAction(action)
    }else {
      this._originalScale = this.getScale()
    }
    var zoomAction = cc.ScaleTo.create(0.1, this._originalScale * 1.2);
    zoomAction.setTag(cc.ZOOM_ACTION_TAG);
    this.runAction(zoomAction)
  }
}, unselected:function() {
  if(this._isEnabled) {
    this._super();
    this.stopActionByTag(cc.ZOOM_ACTION_TAG);
    var zoomAction = cc.ScaleTo.create(0.1, this._originalScale);
    zoomAction.setTag(cc.ZOOM_ACTION_TAG);
    this.runAction(zoomAction)
  }
}});
cc.MenuItemLabel.create = function(label, selector, target) {
  var ret = new cc.MenuItemLabel;
  ret.initWithLabel(label, selector, target);
  return ret
};
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({initWithString:function(value, charMapFile, itemWidth, itemHeight, startCharMap, selector, target) {
  cc.Assert(value != null && value.length != 0, "value length must be greater than 0");
  var label = new cc.LabelAtlas;
  label.initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap);
  if(this.initWithLabel(label, selector, target)) {
  }
  return true
}});
cc.MenuItemAtlasFont.create = function(value, charMapFile, itemWidth, itemHeight, startCharMap, target, selector) {
  var ret = new cc.MenuItemAtlasFont;
  ret.initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap, target, selector);
  return ret
};
cc.MenuItemFont = cc.MenuItemLabel.extend({initWithString:function(value, selector, target) {
  cc.Assert(value != null && value.length != 0, "Value length must be greater than 0");
  this._fontName = cc._fontName;
  this._fontSize = cc._fontSize;
  var label = cc.LabelTTF.create(value, this._fontName, this._fontSize);
  if(this.initWithLabel(label, selector, target)) {
  }
  return true
}, setFontSize:function(s) {
  this._fontSize = s;
  this._recreateLabel()
}, fontSize:function() {
  return this._fontSize
}, setFontName:function(name) {
  this._fontName = name;
  this._recreateLabel()
}, fontName:function() {
  return this._fontName
}, _recreateLabel:function() {
  var label = cc.LabelTTF.create(this._label.getString(), this._fontName, this._fontSize);
  this.setLabel(label)
}, _fontSize:0, _fontName:""});
cc.MenuItemFont.setFontSize = function(fontSize) {
  cc._fontSize = fontSize
};
cc.MenuItemFont.fontSize = function() {
  return cc._fontSize
};
cc.MenuItemFont.setFontName = function(name) {
  if(cc._fontNameRelease) {
    cc._fontName = ""
  }
  cc._fontName = name;
  cc._fontNameRelease = true
};
cc.MenuItemFont.fontName = function() {
  return cc._fontName
};
cc.MenuItemFont.create = function(value, selector, target) {
  var ret = new cc.MenuItemFont;
  ret.initWithString(value, selector, target);
  return ret
};
cc.MenuItemSprite = cc.MenuItem.extend({RGBAProtocol:true, _normalImage:null, getNormalImage:function() {
  return this._normalImage
}, setNormalImage:function(normalImage) {
  if(this._normalImage == normalImage) {
    return
  }
  if(normalImage) {
    this.addChild(normalImage, 0, cc.NORMAL_TAG);
    normalImage.setAnchorPoint(cc.p(0, 0))
  }
  if(this._normalImage) {
    this.removeChild(this._normalImage, true)
  }
  this._normalImage = normalImage;
  this.setContentSize(this._normalImage.getContentSize());
  this._updateImagesVisibility()
}, _selectedImage:null, getSelectedImage:function() {
  return this._selectedImage
}, setSelectedImage:function(selectedImage) {
  if(this._selectedImage == selectedImage) {
    return
  }
  if(selectedImage) {
    this.addChild(selectedImage, 0, cc.SELECTED_TAG);
    selectedImage.setAnchorPoint(cc.p(0, 0))
  }
  if(this._selectedImage) {
    this.removeChild(this._selectedImage, true)
  }
  this._selectedImage = selectedImage;
  this._updateImagesVisibility()
}, _disabledImage:null, getDisabledImage:function() {
  return this._disabledImage
}, setDisabledImage:function(disabledImage) {
  if(this._disabledImage == disabledImage) {
    return
  }
  if(disabledImage) {
    this.addChild(disabledImage, 0, cc.DISABLE_TAG);
    disabledImage.setAnchorPoint(cc.p(0, 0))
  }
  if(this._disabledImage) {
    this.removeChild(this._disabledImage, true)
  }
  this._disabledImage = disabledImage;
  this._updateImagesVisibility()
}, initWithNormalSprite:function(normalSprite, selectedSprite, disabledSprite, selector, target) {
  this.initWithCallback(selector, target);
  this.setNormalImage(normalSprite);
  this.setSelectedImage(selectedSprite);
  this.setDisabledImage(disabledSprite);
  if(this._normalImage) {
    this.setContentSize(this._normalImage.getContentSize())
  }
  return true
}, setColor:function(color) {
  this._normalImage.setColor(color);
  if(this._selectedImage) {
    this._selectedImage.setColor(color)
  }
  if(this._disabledImage) {
    this._disabledImage.setColor(color)
  }
}, getColor:function() {
  return this._normalImage.getColor()
}, setOpacity:function(opacity) {
  this._normalImage.setOpacity(opacity);
  if(this._selectedImage) {
    this._selectedImage.setOpacity(opacity)
  }
  if(this._disabledImage) {
    this._disabledImage.setOpacity(opacity)
  }
}, getOpacity:function() {
  return this._normalImage.getOpacity()
}, selected:function() {
  this._super();
  if(this._normalImage) {
    if(this._disabledImage) {
      this._disabledImage.setVisible(false)
    }
    if(this._selectedImage) {
      this._normalImage.setVisible(false);
      this._selectedImage.setVisible(true)
    }else {
      this._normalImage.setVisible(true)
    }
  }
}, unselected:function() {
  this._super();
  if(this._normalImage) {
    this._normalImage.setVisible(true);
    if(this._selectedImage) {
      this._selectedImage.setVisible(false)
    }
    if(this._disabledImage) {
      this._disabledImage.setVisible(false)
    }
  }
}, setEnabled:function(bEnabled) {
  if(this._isEnabled != bEnabled) {
    this._super(bEnabled);
    this._updateImagesVisibility()
  }
}, setOpacityModifyRGB:function(value) {
}, isOpacityModifyRGB:function() {
  return false
}, _updateImagesVisibility:function() {
  if(this._isEnabled) {
    if(this._normalImage) {
      this._normalImage.setVisible(true)
    }
    if(this._selectedImage) {
      this._selectedImage.setVisible(false)
    }
    if(this._disabledImage) {
      this._disabledImage.setVisible(false)
    }
  }else {
    if(this._disabledImage) {
      if(this._normalImage) {
        this._normalImage.setVisible(false)
      }
      if(this._selectedImage) {
        this._selectedImage.setVisible(false)
      }
      if(this._disabledImage) {
        this._disabledImage.setVisible(true)
      }
    }else {
      if(this._normalImage) {
        this._normalImage.setVisible(true)
      }
      if(this._selectedImage) {
        this._selectedImage.setVisible(false)
      }
      if(this._disabledImage) {
        this._disabledImage.setVisible(false)
      }
    }
  }
}});
cc.MenuItemSprite.create = function(normalSprite, selectedSprite, three, four, five) {
  var len = arguments.length;
  var normalSprite = arguments[0], selectedSprite = arguments[1], disabledImage, target, callback;
  var ret = new cc.MenuItemSprite;
  if(len == 5) {
    disabledImage = arguments[2];
    callback = arguments[3];
    target = arguments[4]
  }else {
    if(len == 4 && typeof arguments[3] === "function") {
      disabledImage = arguments[2];
      callback = arguments[3]
    }else {
      if(len == 4 && typeof arguments[2] === "function") {
        target = arguments[3];
        callback = arguments[2]
      }else {
        if(len <= 2) {
          disabledImage = arguments[2]
        }
      }
    }
  }
  ret.initWithNormalSprite(normalSprite, selectedSprite, disabledImage, callback, target);
  return ret
};
cc.MenuItemImage = cc.MenuItemSprite.extend({setNormalSpriteFrame:function(frame) {
  this.setNormalImage(cc.Sprite.createWithSpriteFrame(frame))
}, setSelectedSpriteFrame:function(frame) {
  this.setSelectedImage(cc.Sprite.createWithSpriteFrame(frame))
}, setDisabledSpriteFrame:function(frame) {
  this.setDisabledImage(cc.Sprite.createWithSpriteFrame(frame))
}, initWithNormalImage:function(normalImage, selectedImage, disabledImage, selector, target) {
  var normalSprite = null;
  var selectedSprite = null;
  var disabledSprite = null;
  if(normalImage) {
    normalSprite = cc.Sprite.create(normalImage)
  }
  if(selectedImage) {
    selectedSprite = cc.Sprite.create(selectedImage)
  }
  if(disabledImage) {
    disabledSprite = cc.Sprite.create(disabledImage)
  }
  return this.initWithNormalSprite(normalSprite, selectedSprite, disabledSprite, selector, target)
}});
cc.MenuItemImage.create = function(normalImage, selectedImage, three, four, five) {
  if(arguments.length == 0) {
    return cc.MenuItemImage.create(null, null, null, null, null)
  }
  if(arguments.length == 3) {
    return cc.MenuItemImage.create(normalImage, selectedImage, null, three, null)
  }
  if(arguments.length == 4) {
    return cc.MenuItemImage.create(normalImage, selectedImage, null, three, four)
  }
  var ret = new cc.MenuItemImage;
  if(ret.initWithNormalImage(normalImage, selectedImage, three, four, five)) {
    return ret
  }
  return null
};
cc.MenuItemToggle = cc.MenuItem.extend({RGBAProtocol:true, _opacity:0, getOpacity:function() {
  return this._opacity
}, setOpacity:function(Opacity) {
  this._opacity = Opacity;
  if(this._subItems && this._subItems.length > 0) {
    for(var it = 0;it < this._subItems.length;it++) {
      this._subItems[it].setOpacity(Opacity)
    }
  }
}, _color:new cc.Color3B, getColor:function() {
  return this._color
}, setColor:function(Color) {
  this._color = Color;
  if(this._subItems && this._subItems.length > 0) {
    for(var it = 0;it < this._subItems.length;it++) {
      this._subItems[it].setColor(Color)
    }
  }
}, _selectedIndex:0, getSelectedIndex:function() {
  return this._selectedIndex
}, setSelectedIndex:function(SelectedIndex) {
  if(SelectedIndex != this._selectedIndex) {
    this._selectedIndex = SelectedIndex;
    var currItem = this.getChildByTag(cc.CURRENT_ITEM);
    if(currItem) {
      currItem.removeFromParent(false)
    }
    var item = this._subItems[this._selectedIndex];
    this.addChild(item, 0, cc.CURRENT_ITEM);
    var s = item.getContentSize();
    this.setContentSize(s);
    item.setPosition(cc.p(s.width / 2, s.height / 2))
  }
}, _subItems:[], getSubItems:function() {
  return this._subItems
}, setSubItems:function(SubItems) {
  this._subItems = SubItems
}, initWithItems:function(args) {
  var l = args.length;
  if(typeof args[args.length - 2] === "function") {
    this.initWithCallback(args[args.length - 2], args[args.length - 1]);
    l = l - 2
  }else {
    if(typeof args[args.length - 1] === "function") {
      this.initWithCallback(args[args.length - 1], null);
      l = l - 1
    }else {
      this.initWithCallback(null, null)
    }
  }
  this._subItems = [];
  for(var i = 0;i < l;i++) {
    if(args[i]) {
      this._subItems.push(args[i])
    }
  }
  this._selectedIndex = cc.UINT_MAX;
  this.setSelectedIndex(0);
  return true
}, addSubItem:function(item) {
  this._subItems.push(item)
}, activate:function() {
  if(this._isEnabled) {
    var newIndex = (this._selectedIndex + 1) % this._subItems.length;
    this.setSelectedIndex(newIndex)
  }
  this._super()
}, selected:function() {
  this._super();
  this._subItems[this._selectedIndex].selected()
}, unselected:function() {
  this._super();
  this._subItems[this._selectedIndex].unselected()
}, setEnabled:function(enabled) {
  if(this._isEnabled != enabled) {
    this._super(enabled);
    if(this._subItems && this._subItems.length > 0) {
      for(var it = 0;it < this._subItems.length;it++) {
        this._subItems[it].setEnabled(enabled)
      }
    }
  }
}, selectedItem:function() {
  return this._subItems[this._selectedIndex]
}, setOpacityModifyRGB:function(value) {
}, isOpacityModifyRGB:function() {
  return false
}, onEnter:function() {
  this._super();
  this.setSelectedIndex(this._selectedIndex)
}});
cc.MenuItemToggle.create = function() {
  var ret = new cc.MenuItemToggle;
  ret.initWithItems(arguments);
  return ret
};
cc.MENU_STATE_WAITING = 0;
cc.MENU_STATE_TRACKING_TOUCH = 1;
cc.MENU_HANDLER_PRIORITY = -128;
cc.DEFAULT_PADDING = 5;
cc.Menu = cc.Layer.extend({RGBAProtocol:true, _color:new cc.Color3B, getColor:function() {
  return this._color
}, setColor:function(color) {
  this._color = color;
  if(this._children && this._children.length > 0) {
    for(var i = 0;i < this._children.length;i++) {
      this._children[i].setColor(this._color)
    }
  }
}, _opacity:0, getOpacity:function() {
  return this._opacity
}, setOpacity:function(opa) {
  this._opacity = opa;
  if(this._children && this._children.length > 0) {
    for(var i = 0;i < this._children.length;i++) {
      this._children[i].setOpacity(this._opacity)
    }
  }
}, _enabled:false, isEnabled:function() {
  return this._enabled
}, setEnabled:function(enabled) {
  this._enabled = enabled
}, _selectedItem:null, initWithItems:function(args) {
  var pArray = [];
  if(args) {
    for(var i = 0;i < args.length;i++) {
      if(args[i]) {
        pArray.push(args[i])
      }
    }
  }
  return this.initWithArray(pArray)
}, initWithArray:function(arrayOfItems) {
  if(this.init()) {
    this.setTouchEnabled(true);
    this._enabled = true;
    var winSize = cc.Director.getInstance().getWinSize();
    this.ignoreAnchorPointForPosition(true);
    this.setAnchorPoint(cc.p(0.5, 0.5));
    this.setContentSize(winSize);
    this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
    if(arrayOfItems) {
      for(var i = 0;i < arrayOfItems.length;i++) {
        this.addChild(arrayOfItems[i], i)
      }
    }
    this._selectedItem = null;
    this._state = cc.MENU_STATE_WAITING;
    return true
  }
  return false
}, addChild:function(child, zOrder, tag) {
  cc.Assert(child instanceof cc.MenuItem, "Menu only supports MenuItem objects as children");
  this._super(child, zOrder, tag)
}, alignItemsVertically:function() {
  this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
}, alignItemsVerticallyWithPadding:function(padding) {
  var height = -padding;
  if(this._children && this._children.length > 0) {
    for(var i = 0;i < this._children.length;i++) {
      height += this._children[i].getContentSize().height * this._children[i].getScaleY() + padding
    }
  }
  var y = height / 2;
  if(this._children && this._children.length > 0) {
    for(i = 0;i < this._children.length;i++) {
      this._children[i].setPosition(cc.p(0, y - this._children[i].getContentSize().height * this._children[i].getScaleY() / 2));
      y -= this._children[i].getContentSize().height * this._children[i].getScaleY() + padding
    }
  }
}, alignItemsHorizontally:function() {
  this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
}, alignItemsHorizontallyWithPadding:function(padding) {
  var width = -padding;
  if(this._children && this._children.length > 0) {
    for(var i = 0;i < this._children.length;i++) {
      width += this._children[i].getContentSize().width * this._children[i].getScaleX() + padding
    }
  }
  var x = -width / 2;
  if(this._children && this._children.length > 0) {
    for(i = 0;i < this._children.length;i++) {
      this._children[i].setPosition(cc.p(x + this._children[i].getContentSize().width * this._children[i].getScaleX() / 2, 0));
      x += this._children[i].getContentSize().width * this._children[i].getScaleX() + padding
    }
  }
}, alignItemsInColumns:function() {
  var rows = [];
  for(var i = 0;i < arguments.length;i++) {
    rows.push(arguments[i])
  }
  var height = -5;
  var row = 0;
  var rowHeight = 0;
  var columnsOccupied = 0;
  var rowColumns;
  if(this._children && this._children.length > 0) {
    for(i = 0;i < this._children.length;i++) {
      cc.Assert(row < rows.length, "");
      rowColumns = rows[row];
      cc.Assert(rowColumns, "");
      var tmp = this._children[i].getContentSize().height;
      rowHeight = rowHeight >= tmp || isNaN(tmp) ? rowHeight : tmp;
      ++columnsOccupied;
      if(columnsOccupied >= rowColumns) {
        height += rowHeight + 5;
        columnsOccupied = 0;
        rowHeight = 0;
        ++row
      }
    }
  }
  cc.Assert(!columnsOccupied, "");
  var winSize = cc.Director.getInstance().getWinSize();
  row = 0;
  rowHeight = 0;
  rowColumns = 0;
  var w = 0;
  var x = 0;
  var y = height / 2;
  if(this._children && this._children.length > 0) {
    for(i = 0;i < this._children.length;i++) {
      var child = this._children[i];
      if(rowColumns == 0) {
        rowColumns = rows[row];
        w = winSize.width / (1 + rowColumns);
        x = w
      }
      var tmp = child.getContentSize().height;
      rowHeight = rowHeight >= tmp || isNaN(tmp) ? rowHeight : tmp;
      child.setPosition(cc.p(x - winSize.width / 2, y - child.getContentSize().height / 2));
      x += w;
      ++columnsOccupied;
      if(columnsOccupied >= rowColumns) {
        y -= rowHeight + 5;
        columnsOccupied = 0;
        rowColumns = 0;
        rowHeight = 0;
        ++row
      }
    }
  }
}, alignItemsInRows:function() {
  var columns = [];
  for(var i = 0;i < arguments.length;i++) {
    columns.push(arguments[i])
  }
  var columnWidths = [];
  var columnHeights = [];
  var width = -10;
  var columnHeight = -5;
  var column = 0;
  var columnWidth = 0;
  var rowsOccupied = 0;
  var columnRows;
  if(this._children && this._children.length > 0) {
    for(var i = 0;i < this._children.length;i++) {
      var child = this._children[i];
      cc.Assert(column < columns.length, "");
      columnRows = columns[column];
      cc.Assert(columnRows, "");
      var tmp = child.getContentSize().width;
      columnWidth = columnWidth >= tmp || isNaN(tmp) ? columnWidth : tmp;
      columnHeight += child.getContentSize().height + 5;
      ++rowsOccupied;
      if(rowsOccupied >= columnRows) {
        columnWidths.push(columnWidth);
        columnHeights.push(columnHeight);
        width += columnWidth + 10;
        rowsOccupied = 0;
        columnWidth = 0;
        columnHeight = -5;
        ++column
      }
    }
  }
  cc.Assert(!rowsOccupied, "");
  var winSize = cc.Director.getInstance().getWinSize();
  column = 0;
  columnWidth = 0;
  columnRows = 0;
  var x = -width / 2;
  var y = 0;
  if(this._children && this._children.length > 0) {
    for(var i = 0;i < this._children.length;i++) {
      var child = this._children[i];
      if(columnRows == 0) {
        columnRows = columns[column];
        y = columnHeights[column]
      }
      var tmp = child.getContentSize().width;
      columnWidth = columnWidth >= tmp || isNaN(tmp) ? columnWidth : tmp;
      child.setPosition(cc.p(x + columnWidths[column] / 2, y - winSize.height / 2));
      y -= child.getContentSize().height + 10;
      ++rowsOccupied;
      if(rowsOccupied >= columnRows) {
        x += columnWidth + 5;
        rowsOccupied = 0;
        columnRows = 0;
        columnWidth = 0;
        ++column
      }
    }
  }
}, registerWithTouchDispatcher:function() {
  cc.Director.getInstance().getTouchDispatcher().addTargetedDelegate(this, cc.MENU_HANDLER_PRIORITY, true)
}, onTouchBegan:function(touch, e) {
  if(this._state != cc.MENU_STATE_WAITING || !this._visible || !this._enabled) {
    return false
  }
  for(var c = this._parent;c != null;c = c.getParent()) {
    if(!c.isVisible()) {
      return false
    }
  }
  this._selectedItem = this._itemForTouch(touch);
  if(this._selectedItem) {
    this._state = cc.MENU_STATE_TRACKING_TOUCH;
    this._selectedItem.selected();
    return true
  }
  return false
}, onTouchEnded:function(touch, e) {
  cc.Assert(this._state == cc.MENU_STATE_TRACKING_TOUCH, "[Menu onTouchEnded] -- invalid state");
  if(this._selectedItem) {
    this._selectedItem.unselected();
    this._selectedItem.activate()
  }
  this._state = cc.MENU_STATE_WAITING
}, onTouchCancelled:function(touch, e) {
  cc.Assert(this._state == cc.MENU_STATE_TRACKING_TOUCH, "[Menu onTouchCancelled] -- invalid state");
  if(this._selectedItem) {
    this._selectedItem.unselected()
  }
  this._state = cc.MENU_STATE_WAITING
}, onTouchMoved:function(touch, e) {
  cc.Assert(this._state == cc.MENU_STATE_TRACKING_TOUCH, "[Menu onTouchMoved] -- invalid state");
  var currentItem = this._itemForTouch(touch);
  if(currentItem != this._selectedItem) {
    if(this._selectedItem) {
      this._selectedItem.unselected()
    }
    this._selectedItem = currentItem;
    if(this._selectedItem) {
      this._selectedItem.selected()
    }
  }
}, onExit:function() {
  if(this._state == cc.MENU_STATE_TRACKING_TOUCH) {
    this._selectedItem.unselected();
    this._state = cc.MENU_STATE_WAITING;
    this._selectedItem = null
  }
  this._super()
}, setOpacityModifyRGB:function(value) {
}, isOpacityModifyRGB:function() {
  return false
}, _itemForTouch:function(touch) {
  var touchLocation = touch.getLocation();
  if(this._children && this._children.length > 0) {
    for(var i = 0;i < this._children.length;i++) {
      if(this._children[i].isVisible() && this._children[i].isEnabled()) {
        var local = this._children[i].convertToNodeSpace(touchLocation);
        var r = this._children[i].rect();
        r.origin = cc.p(0, 0);
        if(cc.Rect.CCRectContainsPoint(r, local)) {
          return this._children[i]
        }
      }
    }
  }
  return null
}, _state:-1, setHandlerPriority:function(newPriority) {
  cc.Director.getInstance().getTouchDispatcher().setPriority(newPriority, this)
}});
cc.Menu.create = function() {
  var ret = new cc.Menu;
  if(arguments.length == 0) {
    ret.initWithItems(null, null)
  }else {
    if(arguments.length == 1) {
      if(arguments[0] instanceof Array) {
        ret.initWithArray(arguments[0]);
        return ret
      }
    }
  }
  ret.initWithItems(arguments);
  return ret
};
cc.TMX_ORIENTATION_ORTHO = 0;
cc.TMX_ORIENTATION_HEX = 1;
cc.TMX_ORIENTATION_ISO = 2;
cc.TMXTiledMap = cc.Node.extend({_mapSize:null, _tileSize:null, _properties:null, _objectGroups:null, _mapOrientation:null, _TMXLayers:null, _tileProperties:null, ctor:function() {
  this._super();
  this._mapSize = cc.SizeZero();
  this._tileSize = cc.SizeZero();
  this._tileProperties = []
}, getMapSize:function() {
  return this._mapSize
}, setMapSize:function(Var) {
  this._mapSize = Var
}, getTileSize:function() {
  return this._tileSize
}, setTileSize:function(Var) {
  this._tileSize = Var
}, getMapOrientation:function() {
  return this._mapOrientation
}, setMapOrientation:function(Var) {
  this._mapOrientation = Var
}, getObjectGroups:function() {
  return this._objectGroups
}, setObjectGroups:function(Var) {
  this._objectGroups = Var
}, getProperties:function() {
  return this._properties
}, setProperties:function(Var) {
  this._properties = Var
}, initWithTMXFile:function(tmxFile, resourcePath) {
  cc.Assert(tmxFile != null && tmxFile.length > 0, "TMXTiledMap: tmx file should not be nil");
  this.setContentSize(cc.SizeZero());
  var mapInfo = cc.TMXMapInfo.create(tmxFile, resourcePath);
  if(!mapInfo) {
    return false
  }
  cc.Assert(mapInfo.getTilesets().length != 0, "TMXTiledMap: Map not found. Please check the filename.");
  this._buildWithMapInfo(mapInfo);
  return true
}, initWithXML:function(tmxString, resourcePath) {
  this.setContentSize(cc.SizeZero());
  var mapInfo = cc.TMXMapInfo.createWithXML(tmxString, resourcePath);
  cc.Assert(mapInfo.getTilesets().length != 0, "TMXTiledMap: Map not found. Please check the filename.");
  this._buildWithMapInfo(mapInfo);
  return true
}, _buildWithMapInfo:function(mapInfo) {
  this._mapSize = mapInfo.getMapSize();
  this._tileSize = mapInfo.getTileSize();
  this._mapOrientation = mapInfo.getOrientation();
  this._objectGroups = mapInfo.getObjectGroups();
  this._properties = mapInfo.getProperties();
  this._tileProperties = mapInfo.getTileProperties();
  var idx = 0;
  var layers = mapInfo.getLayers();
  if(layers) {
    var layerInfo = null;
    for(var i = 0, len = layers.length;i < len;i++) {
      layerInfo = layers[i];
      if(layerInfo && layerInfo.visible) {
        var child = this._parseLayer(layerInfo, mapInfo);
        this.addChild(child, idx, idx);
        var childSize = child.getContentSize();
        var currentSize = this.getContentSize();
        currentSize.width = Math.max(currentSize.width, childSize.width);
        currentSize.height = Math.max(currentSize.height, childSize.height);
        this.setContentSize(currentSize);
        idx++
      }
    }
  }
}, getLayer:function(layerName) {
  cc.Assert(layerName != null && layerName.length > 0, "Invalid layer name!");
  for(var i = 0;i < this._children.length;i++) {
    var layer = this._children[i];
    if(layer) {
      if(layer.getLayerName() == layerName) {
        return layer
      }
    }
  }
  return null
}, getObjectGroup:function(groupName) {
  cc.Assert(groupName != null && groupName.length > 0, "Invalid group name!");
  if(this._objectGroups) {
    for(var i = 0;i < this._objectGroups.length;i++) {
      var objectGroup = this._objectGroups[i];
      if(objectGroup && objectGroup.getGroupName() == groupName) {
        return objectGroup
      }
    }
  }
  return null
}, getProperty:function(propertyName) {
  return this._properties[propertyName.toString()]
}, propertiesForGID:function(GID) {
  return this._tileProperties[GID]
}, _parseLayer:function(layerInfo, mapInfo) {
  var tileset = this._tilesetForLayer(layerInfo, mapInfo);
  var layer = cc.TMXLayer.create(tileset, layerInfo, mapInfo);
  layerInfo.ownTiles = false;
  layer.setupTiles();
  return layer
}, _tilesetForLayer:function(layerInfo, mapInfo) {
  var size = layerInfo._layerSize;
  var tilesets = mapInfo.getTilesets();
  if(tilesets) {
    for(var i = tilesets.length - 1;i >= 0;i--) {
      var tileset = tilesets[i];
      if(tileset) {
        for(var y = 0;y < size.height;y++) {
          for(var x = 0;x < size.width;x++) {
            var pos = x + size.width * y;
            var gid = layerInfo._tiles[pos];
            if(gid != 0) {
              if((gid & cc.TMX_TILE_FLIPPED_MASK) >>> 0 >= tileset.firstGid) {
                return tileset
              }
            }
          }
        }
      }
    }
  }
  cc.log("cocos2d: Warning: TMX Layer " + layerInfo.name + " has no tiles");
  return null
}});
cc.TMXTiledMap.create = function(tmxFile, resourcePath) {
  var ret = new cc.TMXTiledMap;
  if(ret.initWithTMXFile(tmxFile, resourcePath)) {
    return ret
  }
  return null
};
cc.TMXTiledMap.createWithXML = function(tmxString, resourcePath) {
  var tileMap = new cc.TMXTiledMap;
  if(tileMap.initWithXML(tmxString, resourcePath)) {
    return tileMap
  }
  return null
};
cc.TMX_LAYER_ATTRIB_NONE = 1 << 0;
cc.TMX_LAYER_ATTRIB_BASE64 = 1 << 1;
cc.TMX_LAYER_ATTRIB_GZIP = 1 << 2;
cc.TMX_LAYER_ATTRIB_ZLIB = 1 << 3;
cc.TMX_PROPERTY_NONE = 0;
cc.TMX_PROPERTY_MAP = 1;
cc.TMX_PROPERTY_LAYER = 2;
cc.TMX_PROPERTY_OBJECTGROUP = 3;
cc.TMX_PROPERTY_OBJECT = 4;
cc.TMX_PROPERTY_TILE = 5;
cc.TMX_TILE_HORIZONTAL_FLAG = 2147483648;
cc.TMX_TILE_VERTICAL_FLAG = 1073741824;
cc.TMX_TILE_DIAGONAL_FLAG = 536870912;
cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0;
cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0;
cc.TMXLayerInfo = cc.Class.extend({_properties:null, name:"", _layerSize:null, _tiles:null, visible:null, _opacity:null, ownTiles:true, _minGID:1E5, _maxGID:0, offset:null, ctor:function() {
  this._properties = [];
  this._tiles = [];
  this._offset = cc.PointZero()
}, getProperties:function() {
  return this._properties
}, setProperties:function(Var) {
  this._properties = Var
}});
cc.TMXTilesetInfo = cc.Class.extend({name:"", firstGid:0, _tileSize:null, spacing:0, margin:0, sourceImage:"", imageSize:null, ctor:function() {
  this._tileSize = cc.SizeZero();
  this.imageSize = cc.SizeZero()
}, rectForGID:function(gid) {
  var rect = cc.RectZero();
  rect.size = this._tileSize;
  gid &= cc.TMX_TILE_FLIPPED_MASK;
  gid = gid - parseInt(this.firstGid, 10);
  var max_x = parseInt((this.imageSize.width - this.margin * 2 + this.spacing) / (this._tileSize.width + this.spacing), 10);
  rect.origin.x = parseInt(gid % max_x * (this._tileSize.width + this.spacing) + this.margin, 10);
  rect.origin.y = parseInt(parseInt(gid / max_x, 10) * (this._tileSize.height + this.spacing) + this.margin, 10);
  return rect
}});
cc.TMXMapInfo = cc.SAXParser.extend({_orientation:null, _mapSize:null, _tileSize:null, _layers:null, _tileSets:null, _objectGroups:null, _parentElement:null, _parentGID:null, _layerAttribs:0, _storingCharacters:false, _properties:null, _TMXFileName:null, _currentString:null, _tileProperties:null, _resources:null, ctor:function() {
  this._tileSets = [];
  this._tileProperties = [];
  this._properties = [];
  this._mapSize = cc.SizeZero();
  this._tileSize = cc.SizeZero()
}, getOrientation:function() {
  return this._orientation
}, setOrientation:function(Var) {
  this._orientation = Var
}, getMapSize:function() {
  return this._mapSize
}, setMapSize:function(Var) {
  this._mapSize = Var
}, getTileSize:function() {
  return this._tileSize
}, setTileSize:function(Var) {
  this._tileSize = Var
}, getLayers:function() {
  return this._layers
}, setLayers:function(Var) {
  this._layers.push(Var)
}, getTilesets:function() {
  return this._tileSets
}, setTilesets:function(Var) {
  this._tileSets.push(Var)
}, getObjectGroups:function() {
  return this._objectGroups
}, setObjectGroups:function(Var) {
  this._objectGroups.push(Var)
}, getParentElement:function() {
  return this._parentElement
}, setParentElement:function(Var) {
  this._parentElement = Var
}, getParentGID:function() {
  return this._parentGID
}, setParentGID:function(Var) {
  this._parentGID = Var
}, getLayerAttribs:function() {
  return this._layerAttribs
}, setLayerAttribs:function(Var) {
  this._layerAttribs = Var
}, getStoringCharacters:function() {
  return this._storingCharacters
}, setStoringCharacters:function(Var) {
  this._storingCharacters = Var
}, getProperties:function() {
  return this._properties
}, setProperties:function(Var) {
  this._properties.push(Var)
}, initWithTMXFile:function(tmxFile, resourcePath) {
  this._internalInit(tmxFile, resourcePath);
  return this.parseXMLFile(this._TMXFileName)
}, initWithXML:function(tmxString, resourcePath) {
  this._internalInit(null, resourcePath);
  return this.parseXMLString(tmxString)
}, parseXMLFile:function(tmxFile, isXmlString) {
  isXmlString = isXmlString || false;
  var mapXML = cc.SAXParser.getInstance().tmxParse(tmxFile, isXmlString);
  var i, j;
  var i, j;
  var map = mapXML.documentElement;
  var version = map.getAttribute("version");
  var orientationStr = map.getAttribute("orientation");
  if(map.nodeName == "map") {
    if(version != "1.0" && version !== null) {
      cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + version)
    }
    if(orientationStr == "orthogonal") {
      this.setOrientation(cc.TMX_ORIENTATION_ORTHO)
    }else {
      if(orientationStr == "isometric") {
        this.setOrientation(cc.TMX_ORIENTATION_ISO)
      }else {
        if(orientationStr == "hexagonal") {
          this.setOrientation(cc.TMX_ORIENTATION_HEX)
        }else {
          if(orientationStr !== null) {
            cc.log("cocos2d: TMXFomat: Unsupported orientation:" + this.getOrientation())
          }
        }
      }
    }
    var mapSize = cc.size(0, 0);
    mapSize.width = parseFloat(map.getAttribute("width"));
    mapSize.height = parseFloat(map.getAttribute("height"));
    this.setMapSize(mapSize);
    mapSize = cc.size(0, 0);
    mapSize.width = parseFloat(map.getAttribute("tilewidth"));
    mapSize.height = parseFloat(map.getAttribute("tileheight"));
    this.setTileSize(mapSize);
    var propertyArr = map.querySelectorAll("map > properties >  property");
    if(propertyArr) {
      for(i = 0;i < propertyArr.length;i++) {
        var aProperty = {};
        aProperty[propertyArr[i].getAttribute("name")] = propertyArr[i].getAttribute("value");
        this.setProperties(aProperty)
      }
    }
  }
  var tilesets = map.getElementsByTagName("tileset");
  if(map.nodeName !== "map") {
    tilesets = [];
    tilesets.push(map)
  }
  for(i = 0;i < tilesets.length;i++) {
    var selTileset = tilesets[i];
    var externalTilesetFilename = selTileset.getAttribute("source");
    if(externalTilesetFilename) {
      this.parseXMLFile(cc.FileUtils.getInstance().fullPathFromRelativeFile(externalTilesetFilename, isXmlString ? this._resources + "/" : tmxFile))
    }else {
      var tileset = new cc.TMXTilesetInfo;
      tileset.name = selTileset.getAttribute("name") || "";
      tileset.firstGid = parseInt(selTileset.getAttribute("firstgid")) || 1;
      tileset.spacing = parseInt(selTileset.getAttribute("spacing")) || 0;
      tileset.margin = parseInt(selTileset.getAttribute("margin")) || 0;
      var tilesetSize = cc.size(0, 0);
      tilesetSize.width = parseFloat(selTileset.getAttribute("tilewidth"));
      tilesetSize.height = parseFloat(selTileset.getAttribute("tileheight"));
      tileset._tileSize = tilesetSize;
      var image = selTileset.getElementsByTagName("image")[0];
      var imgSource = image.getAttribute("source");
      if(imgSource) {
        if(this._resources) {
          imgSource = this._resources + "/" + imgSource
        }else {
          imgSource = cc.FileUtils.getInstance().fullPathFromRelativeFile(imgSource, tmxFile)
        }
      }
      tileset.sourceImage = imgSource;
      this.setTilesets(tileset)
    }
  }
  var tiles = map.querySelectorAll("tile");
  if(tiles) {
    for(i = 0;i < tiles.length;i++) {
      var info = this._tileSets[0];
      var t = tiles[i];
      this.setParentGID(parseInt(info.firstGid) + parseInt(t.getAttribute("id") || 0));
      var tp = t.querySelectorAll("properties > property");
      if(tp) {
        var dict = {};
        for(j = 0;j < tp.length;j++) {
          var name = tp[j].getAttribute("name");
          var value = tp[j].getAttribute("value");
          dict[name] = value
        }
        this._tileProperties[this.getParentGID()] = dict
      }
    }
  }
  var layers = map.getElementsByTagName("layer");
  if(layers) {
    for(i = 0;i < layers.length;i++) {
      var selLayer = layers[i];
      var data = selLayer.getElementsByTagName("data")[0];
      var layer = new cc.TMXLayerInfo;
      layer.name = selLayer.getAttribute("name");
      var layerSize = cc.size(0, 0);
      layerSize.width = parseFloat(selLayer.getAttribute("width"));
      layerSize.height = parseFloat(selLayer.getAttribute("height"));
      layer._layerSize = layerSize;
      var visible = selLayer.getAttribute("visible");
      layer.visible = !(visible == "0");
      var opacity = selLayer.getAttribute("opacity") || 1;
      if(opacity) {
        layer._opacity = parseInt(255 * parseFloat(opacity))
      }else {
        layer._opacity = 255
      }
      layer.offset = cc.p(parseFloat(selLayer.getAttribute("x")) || 0, parseFloat(selLayer.getAttribute("y")) || 0);
      var nodeValue = "";
      for(j = 0;j < data.childNodes.length;j++) {
        nodeValue += data.childNodes[j].nodeValue
      }
      nodeValue = nodeValue.trim();
      var compression = data.getAttribute("compression");
      var encoding = data.getAttribute("encoding");
      cc.Assert(compression == null || compression === "gzip" || compression === "zlib", "TMX: unsupported compression method");
      switch(compression) {
        case "gzip":
          layer._tiles = cc.unzipBase64AsArray(nodeValue, 4);
          break;
        case "zlib":
          var inflator = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(nodeValue, 1));
          layer._tiles = cc.uint8ArrayToUint32Array(inflator.decompress());
          break;
        case null:
        ;
        case "":
          if(encoding == "base64") {
            layer._tiles = cc.Codec.Base64.decodeAsArray(nodeValue, 4)
          }else {
            if(encoding === "csv") {
              layer._tiles = [];
              var csvTiles = nodeValue.split(",");
              for(var csvIdx = 0;csvIdx < csvTiles.length;csvIdx++) {
                layer._tiles.push(parseInt(csvTiles[csvIdx]))
              }
            }else {
              var selDataTiles = data.getElementsByTagName("tile");
              layer._tiles = [];
              for(var xmlIdx = 0;xmlIdx < selDataTiles.length;xmlIdx++) {
                layer._tiles.push(parseInt(selDataTiles[xmlIdx].getAttribute("gid")))
              }
            }
          }
          break;
        default:
          cc.Assert(this.getLayerAttribs() != cc.TMX_LAYER_ATTRIB_NONE, "TMX tile map: Only base64 and/or gzip/zlib maps are supported")
      }
      var layerProps = selLayer.querySelectorAll("properties > property");
      if(layerProps) {
        var layerProp = {};
        for(j = 0;j < layerProps.length;j++) {
          layerProp[layerProps[j].getAttribute("name")] = layerProps[j].getAttribute("value")
        }
        layer.setProperties(layerProp)
      }
      this.setLayers(layer)
    }
  }
  var objectGroups = map.getElementsByTagName("objectgroup");
  if(objectGroups) {
    for(i = 0;i < objectGroups.length;i++) {
      var selGroup = objectGroups[i];
      var objectGroup = new cc.TMXObjectGroup;
      objectGroup.setGroupName(selGroup.getAttribute("name"));
      objectGroup.setPositionOffset(cc.p(parseFloat(selGroup.getAttribute("x")) * this.getTileSize().width || 0, parseFloat(selGroup.getAttribute("y")) * this.getTileSize().height || 0));
      var groupProps = selGroup.querySelectorAll("objectgroup > properties > property");
      if(groupProps) {
        for(j = 0;j < groupProps.length;j++) {
          var groupProp = {};
          groupProp[groupProps[j].getAttribute("name")] = groupProps[j].getAttribute("value");
          objectGroup.setProperties(groupProp)
        }
      }
      var objects = selGroup.querySelectorAll("object");
      if(objects) {
        for(j = 0;j < objects.length;j++) {
          var selObj = objects[j];
          var objectProp = {};
          objectProp["name"] = selObj.getAttribute("name") || "";
          objectProp["type"] = selObj.getAttribute("type") || "";
          objectProp["x"] = parseInt(selObj.getAttribute("x") || 0) + objectGroup.getPositionOffset().x;
          var y = parseInt(selObj.getAttribute("y") || 0) + objectGroup.getPositionOffset().y;
          objectProp["width"] = parseInt(selObj.getAttribute("width")) || 0;
          objectProp["height"] = parseInt(selObj.getAttribute("height")) || 0;
          objectProp["y"] = parseInt(this.getMapSize().height * this.getTileSize().height) - y - objectProp["height"];
          var docObjProps = selObj.querySelectorAll("properties > property");
          if(docObjProps) {
            for(var k = 0;k < docObjProps.length;k++) {
              objectProp[docObjProps[k].getAttribute("name")] = docObjProps[k].getAttribute("value")
            }
          }
          objectGroup.setObjects(objectProp)
        }
      }
      this.setObjectGroups(objectGroup)
    }
  }
  return map
}, parseXMLString:function(xmlString) {
  return this.parseXMLFile(xmlString, true)
}, getTileProperties:function() {
  return this._tileProperties
}, setTileProperties:function(tileProperties) {
  this._tileProperties.push(tileProperties)
}, getCurrentString:function() {
  return this._currentString
}, setCurrentString:function(currentString) {
  this._currentString = currentString
}, getTMXFileName:function() {
  return this._TMXFileName
}, setTMXFileName:function(fileName) {
  this._TMXFileName = fileName
}, _internalInit:function(tmxFileName, resourcePath) {
  this._tileSets = [];
  this._layers = [];
  this._TMXFileName = cc.FileUtils.getInstance().fullPathFromRelativePath(tmxFileName);
  if(resourcePath) {
    this._resources = resourcePath
  }
  this._objectGroups = [];
  this._properties = [];
  this._tileProperties = [];
  this._currentString = "";
  this._storingCharacters = false;
  this._layerAttribs = cc.TMX_LAYER_ATTRIB_NONE;
  this._parentElement = cc.TMX_PROPERTY_NONE
}});
cc.TMXMapInfo.create = function(tmxFile, resourcePath) {
  var ret = new cc.TMXMapInfo;
  if(ret.initWithTMXFile(tmxFile, resourcePath)) {
    return ret
  }
  return null
};
cc.TMXMapInfo.createWithXML = function(tmxString, resourcePath) {
  var ret = new cc.TMXMapInfo;
  if(ret.initWithXML(tmxString, resourcePath)) {
    return ret
  }
  return null
};
cc.TMXObjectGroup = cc.Class.extend({_groupName:"", _positionOffset:null, _properties:null, _objects:null, ctor:function() {
  this._properties = [];
  this._objects = [];
  this._positionOffset = cc.PointZero()
}, getPositionOffset:function() {
  return this._positionOffset
}, setPositionOffset:function(Var) {
  this._positionOffset = Var
}, getProperties:function() {
  return this._properties
}, setProperties:function(Var) {
  this._properties.push(Var)
}, getGroupName:function() {
  return this._groupName.toString()
}, setGroupName:function(groupName) {
  this._groupName = groupName
}, propertyNamed:function(propertyName) {
  return this._properties[propertyName]
}, objectNamed:function(objectName) {
  if(this._objects && this._objects.length > 0) {
    for(var i = 0, len = this._objects.length;i < len;i++) {
      var name = this._objects[i]["name"];
      if(name && name == objectName) {
        return this._objects[i]
      }
    }
  }
  return null
}, getObjects:function() {
  return this._objects
}, setObjects:function(objects) {
  this._objects.push(objects)
}});
cc.TMXLayer = cc.SpriteBatchNode.extend({_layerSize:null, _mapTileSize:null, _tiles:null, _tileSet:null, _layerOrientation:null, _properties:null, _layerName:"", _opacity:255, _minGID:null, _maxGID:null, _vertexZvalue:null, _useAutomaticVertexZ:null, _alphaFuncValue:null, _reusedTile:null, _atlasIndexArray:null, _contentScaleFactor:null, ctor:function() {
  this._super();
  this._children = [];
  this._descendants = [];
  this._useCache = true;
  this._layerSize = cc.SizeZero();
  this._mapTileSize = cc.SizeZero()
}, getLayerSize:function() {
  return this._layerSize
}, setLayerSize:function(Var) {
  this._layerSize = Var
}, getMapTileSize:function() {
  return this._mapTileSize
}, setMapTileSize:function(Var) {
  this._mapTileSize = Var
}, getTiles:function() {
  return this._tiles
}, setTiles:function(Var) {
  this._tiles = Var
}, getTileSet:function() {
  return this._tileSet
}, setTileSet:function(Var) {
  this._tileSet = Var
}, getLayerOrientation:function() {
  return this._layerOrientation
}, setLayerOrientation:function(Var) {
  this._layerOrientation = Var
}, getProperties:function() {
  return this._properties
}, setProperties:function(Var) {
  this._properties = Var
}, initWithTilesetInfo:function(tilesetInfo, layerInfo, mapInfo) {
  var size = layerInfo._layerSize;
  var totalNumberOfTiles = parseInt(size.width * size.height);
  var capacity = totalNumberOfTiles * 0.35 + 1;
  var texture;
  if(tilesetInfo) {
    texture = cc.TextureCache.getInstance().addImage(tilesetInfo.sourceImage)
  }
  if(this.initWithTexture(texture, capacity)) {
    this._layerName = layerInfo.name;
    this._layerSize = size;
    this._tiles = layerInfo._tiles;
    this._minGID = layerInfo._minGID;
    this._maxGID = layerInfo._maxGID;
    this._opacity = layerInfo._opacity;
    this.setProperties(layerInfo.getProperties());
    this._contentScaleFactor = cc.Director.getInstance().getContentScaleFactor();
    this._tileSet = tilesetInfo;
    this._mapTileSize = mapInfo.getTileSize();
    this._layerOrientation = mapInfo.getOrientation();
    var offset = this._calculateLayerOffset(layerInfo.offset);
    this.setPosition(cc.POINT_PIXELS_TO_POINTS(offset));
    this._atlasIndexArray = [];
    this.setContentSize(cc.SIZE_PIXELS_TO_POINTS(cc.size(this._layerSize.width * this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height)));
    this._useAutomaticVertexZ = false;
    this._vertexZvalue = 0;
    return true
  }
  return false
}, releaseMap:function() {
  if(this._tiles) {
    this._tiles = null
  }
  if(this._atlasIndexArray) {
    this._atlasIndexArray = null
  }
}, getTileAt:function(pos) {
  cc.Assert(pos.x < this._layerSize.width && pos.y < this._layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
  cc.Assert(this._tiles && this._atlasIndexArray, "TMXLayer: the tiles map has been released");
  var tile = null;
  var gid = this.getTileGIDAt(pos);
  if(gid === 0) {
    return tile
  }
  var z = 0 | pos.x + pos.y * this._layerSize.width;
  tile = this.getChildByTag(z);
  if(!tile) {
    var rect = this._tileSet.rectForGID(gid);
    rect = cc.RECT_PIXELS_TO_POINTS(rect);
    tile = new cc.Sprite;
    tile.initWithTexture(this.getTexture(), rect);
    tile.setBatchNode(this);
    tile.setPosition(this.getPositionAt(pos));
    tile.setVertexZ(this._vertexZForPos(pos));
    tile.setAnchorPoint(cc.PointZero());
    tile.setOpacity(this._opacity);
    var indexForZ = this._atlasIndexForExistantZ(z);
    this.addSpriteWithoutQuad(tile, indexForZ, z)
  }
  return tile
}, getTileGIDAt:function(pos) {
  cc.Assert(pos.x < this._layerSize.width && pos.y < this._layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
  cc.Assert(this._tiles && this._atlasIndexArray, "TMXLayer: the tiles map has been released");
  var idx = 0 | pos.x + pos.y * this._layerSize.width;
  var tile = this._tiles[idx];
  return(tile & cc.TMX_TILE_FLIPPED_MASK) >>> 0
}, getTileFlagsAt:function(pos) {
  cc.Assert(pos.x < this._layerSize.width && pos.y < this._layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
  cc.Assert(this._tiles && this._atlasIndexArray, "TMXLayer: the tiles map has been released");
  var idx = 0 | pos.x + pos.y * this._layerSize.width;
  var tile = this._tiles[idx];
  return(tile & cc.TMX_TILE_FLIPPED_ALL) >>> 0
}, setTileGID:function(gid, pos, flags) {
  cc.Assert(pos.x < this._layerSize.width && pos.y < this._layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
  cc.Assert(this._tiles && this._atlasIndexArray, "TMXLayer: the tiles map has been released");
  cc.Assert(gid !== 0 || !(gid >= this._tileSet.firstGid), "TMXLayer: invalid gid:" + gid);
  flags = flags || 0;
  this._setNodeDirtyForCache();
  var currentFlags = this.getTileFlagsAt(pos);
  var currentGID = this.getTileGIDAt(pos);
  if(currentGID != gid || currentFlags != flags) {
    var gidAndFlags = (gid | flags) >>> 0;
    if(gid === 0) {
      this.removeTileAt(pos)
    }else {
      if(currentGID === 0) {
        this._insertTileForGID(gidAndFlags, pos)
      }else {
        var z = pos.x + pos.y * this._layerSize.width;
        var sprite = this.getChildByTag(z);
        if(sprite) {
          var rect = this._tileSet.rectForGID(gid);
          rect = cc.RECT_PIXELS_TO_POINTS(rect);
          sprite.setTextureRect(rect, false, rect.size);
          if(flags != null) {
            this._setupTileSprite(sprite, pos, gidAndFlags)
          }
          this._tiles[z] = gidAndFlags
        }else {
          this._updateTileForGID(gidAndFlags, pos)
        }
      }
    }
  }
}, removeTileAt:function(pos) {
  cc.Assert(pos.x < this._layerSize.width && pos.y < this._layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
  cc.Assert(this._tiles && this._atlasIndexArray, "TMXLayer: the tiles map has been released");
  var gid = this.getTileGIDAt(pos);
  if(gid !== 0) {
    if(cc.renderContextType === cc.CANVAS) {
      this._setNodeDirtyForCache()
    }
    var z = 0 | pos.x + pos.y * this._layerSize.width;
    var atlasIndex = this._atlasIndexForExistantZ(z);
    this._tiles[z] = 0;
    cc.ArrayRemoveObjectAtIndex(this._atlasIndexArray, atlasIndex);
    var sprite = this.getChildByTag(z);
    if(sprite) {
      cc.SpriteBatchNode.prototype.removeChild.call(this, sprite, true)
    }else {
      if(cc.renderContextType === cc.WEBGL) {
        this._textureAtlas.removeQuadAtIndex(atlasIndex)
      }
      if(this._children) {
        for(var i = 0;i < this._children.length;i++) {
          var child = this._children[i];
          if(child) {
            var ai = child.getAtlasIndex();
            if(ai >= atlasIndex) {
              child.setAtlasIndex(ai - 1)
            }
          }
        }
      }
    }
  }
}, getPositionAt:function(pos) {
  var ret = cc.PointZero();
  switch(this._layerOrientation) {
    case cc.TMX_ORIENTATION_ORTHO:
      ret = this._positionForOrthoAt(pos);
      break;
    case cc.TMX_ORIENTATION_ISO:
      ret = this._positionForIsoAt(pos);
      break;
    case cc.TMX_ORIENTATION_HEX:
      ret = this._positionForHexAt(pos);
      break
  }
  return cc.POINT_PIXELS_TO_POINTS(ret)
}, getProperty:function(propertyName) {
  return this._properties[propertyName]
}, setupTiles:function() {
  if(cc.renderContextType === cc.CANVAS) {
    var textureCache = this._originalTexture;
    this._tileSet.imageSize = cc.size(textureCache.width, textureCache.height)
  }else {
    this._tileSet.imageSize = this._textureAtlas.getTexture().getContentSizeInPixels();
    this._textureAtlas.getTexture().setAliasTexParameters()
  }
  this._parseInternalProperties();
  if(cc.renderContextType === cc.CANVAS) {
    this._setNodeDirtyForCache()
  }
  for(var y = 0;y < this._layerSize.height;y++) {
    for(var x = 0;x < this._layerSize.width;x++) {
      var pos = x + this._layerSize.width * y;
      var gid = this._tiles[pos];
      if(gid !== 0) {
        this._appendTileForGID(gid, cc.p(x, y));
        this._minGID = Math.min(gid, this._minGID);
        this._maxGID = Math.max(gid, this._maxGID)
      }
    }
  }
  if(!(this._maxGID >= this._tileSet.firstGid && this._minGID >= this._tileSet.firstGid)) {
    cc.log("cocos2d:TMX: Only 1 tileset per layer is supported")
  }
}, addChild:function(child, zOrder, tag) {
  cc.Assert(0, "addChild: is not supported on cc.TMXLayer. Instead use setTileGID:at:/tileAt:")
}, removeChild:function(sprite, cleanup) {
  if(!sprite) {
    return
  }
  cc.Assert(cc.ArrayContainsObject(this._children, sprite), "Tile does not belong to TMXLayer");
  if(cc.renderContextType === cc.CANVAS) {
    this._setNodeDirtyForCache()
  }
  var atlasIndex = sprite.getAtlasIndex();
  var zz = this._atlasIndexArray[atlasIndex];
  this._tiles[zz] = 0;
  cc.ArrayRemoveObjectAtIndex(this._atlasIndexArray, atlasIndex);
  this._super(sprite, cleanup)
}, getLayerName:function() {
  return this._layerName.toString()
}, setLayerName:function(layerName) {
  this._layerName = layerName
}, _positionForIsoAt:function(pos) {
  return cc.p(this._mapTileSize.width / 2 * (this._layerSize.width + pos.x - pos.y - 1), this._mapTileSize.height / 2 * (this._layerSize.height * 2 - pos.x - pos.y - 2))
}, _positionForOrthoAt:function(pos) {
  return cc.p(pos.x * this._mapTileSize.width, (this._layerSize.height - pos.y - 1) * this._mapTileSize.height)
}, _positionForHexAt:function(pos) {
  var diffY = pos.x % 2 == 1 ? -this._mapTileSize.height / 2 : 0;
  return cc.p(pos.x * this._mapTileSize.width * 3 / 4, (this._layerSize.height - pos.y - 1) * this._mapTileSize.height + diffY)
}, _calculateLayerOffset:function(pos) {
  var ret = cc.PointZero();
  switch(this._layerOrientation) {
    case cc.TMX_ORIENTATION_ORTHO:
      ret = cc.p(pos.x * this._mapTileSize.width, -pos.y * this._mapTileSize.height);
      break;
    case cc.TMX_ORIENTATION_ISO:
      ret = cc.p(this._mapTileSize.width / 2 * (pos.x - pos.y), this._mapTileSize.height / 2 * (-pos.x - pos.y));
      break;
    case cc.TMX_ORIENTATION_HEX:
      cc.Assert(cc.pointEqualToPoint(pos, cc.PointZero()), "offset for hexagonal map not implemented yet");
      break
  }
  return ret
}, _appendTileForGID:function(gid, pos) {
  var rect = this._tileSet.rectForGID(gid);
  rect = cc.RECT_PIXELS_TO_POINTS(rect);
  var z = 0 | pos.x + pos.y * this._layerSize.width;
  var tile = this._reusedTileWithRect(rect);
  this._setupTileSprite(tile, pos, gid);
  var indexForZ = this._atlasIndexArray.length;
  this.insertQuadFromSprite(tile, indexForZ);
  this._atlasIndexArray = cc.ArrayAppendObjectToIndex(this._atlasIndexArray, z, indexForZ);
  return tile
}, _insertTileForGID:function(gid, pos) {
  var rect = this._tileSet.rectForGID(gid);
  rect = cc.RECT_PIXELS_TO_POINTS(rect);
  var z = 0 | pos.x + pos.y * this._layerSize.width;
  var tile = this._reusedTileWithRect(rect);
  this._setupTileSprite(tile, pos, gid);
  var indexForZ = this._atlasIndexForNewZ(z);
  this.insertQuadFromSprite(tile, indexForZ);
  this._atlasIndexArray = cc.ArrayAppendObjectToIndex(this._atlasIndexArray, z, indexForZ);
  if(this._children) {
    for(var i = 0;i < this._children.length;i++) {
      var child = this._children[i];
      if(child) {
        var ai = child.getAtlasIndex();
        if(ai >= indexForZ) {
          child.setAtlasIndex(ai + 1)
        }
      }
    }
  }
  this._tiles[z] = gid;
  return tile
}, _updateTileForGID:function(gid, pos) {
  var rect = this._tileSet.rectForGID(gid);
  rect = cc.rect(rect.origin.x / this._contentScaleFactor, rect.origin.y / this._contentScaleFactor, rect.size.width / this._contentScaleFactor, rect.size.height / this._contentScaleFactor);
  var z = pos.x + pos.y * this._layerSize.width;
  var tile = this._reusedTileWithRect(rect);
  this._setupTileSprite(tile, pos, gid);
  var indexForZ = this._atlasIndexForExistantZ(z);
  tile.setAtlasIndex(indexForZ);
  tile.setDirty(true);
  tile.updateTransform();
  this._tiles[z] = gid;
  return tile
}, _parseInternalProperties:function() {
  var vertexz = this.getProperty("cc_vertexz");
  if(vertexz) {
    if(vertexz == "automatic") {
      this._useAutomaticVertexZ = true;
      var alphaFuncVal = this.getProperty("cc_alpha_func");
      var alphaFuncValue = 0;
      if(alphaFuncVal) {
        alphaFuncValue = parseFloat(alphaFuncVal)
      }
      if(cc.renderContextType === cc.WEBGL) {
        this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST));
        var alphaValueLocation = cc.renderContext.getUniformLocation(this.getShaderProgram().getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S);
        this.getShaderProgram().use();
        this.getShaderProgram().setUniformLocationWith1f(alphaValueLocation, alphaFuncValue)
      }
    }else {
      this._vertexZvalue = parseInt(vertexz, 10)
    }
  }
}, _setupTileSprite:function(sprite, pos, gid) {
  var z = pos.x + pos.y * this._layerSize.width;
  sprite.setPosition(this.getPositionAt(pos));
  if(cc.renderContextType === cc.WEBGL) {
    sprite.setVertexZ(this._vertexZForPos(pos))
  }else {
    sprite.setTag(z)
  }
  sprite.setAnchorPoint(cc.PointZero());
  sprite.setOpacity(this._opacity);
  if(cc.renderContextType === cc.WEBGL) {
    sprite.setRotation(0)
  }
  sprite.setFlipX(false);
  sprite.setFlipY(false);
  if((gid & cc.TMX_TILE_DIAGONAL_FLAG) >>> 0) {
    sprite.setAnchorPoint(cc.p(0.5, 0.5));
    sprite.setPosition(cc.p(this.getPositionAt(pos).x + sprite.getContentSize().height / 2, this.getPositionAt(pos).y + sprite.getContentSize().width / 2));
    var flag = (gid & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0) >>> 0;
    if(flag == cc.TMX_TILE_HORIZONTAL_FLAG) {
      sprite.setRotation(90)
    }else {
      if(flag == cc.TMX_TILE_VERTICAL_FLAG) {
        sprite.setRotation(270)
      }else {
        if(flag == (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0) {
          sprite.setRotation(90);
          sprite.setFlipX(true)
        }else {
          sprite.setRotation(270);
          sprite.setFlipX(true)
        }
      }
    }
  }else {
    if((gid & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0) {
      sprite.setFlipX(true)
    }
    if((gid & cc.TMX_TILE_VERTICAL_FLAG) >>> 0) {
      sprite.setFlipY(true)
    }
  }
}, _reusedTileWithRect:function(rect) {
  if(cc.renderContextType === cc.WEBGL) {
    if(!this._reusedTile) {
      this._reusedTile = new cc.Sprite;
      this._reusedTile.initWithTexture(this.getTexture(), rect, false);
      this._reusedTile.setBatchNode(this)
    }else {
      this._reusedTile.setBatchNode(null);
      this._reusedTile.setTextureRect(rect, false, rect.size);
      this._reusedTile.setBatchNode(this)
    }
  }else {
    this._reusedTile = new cc.Sprite;
    this._reusedTile.initWithTexture(this._textureForCanvas, rect, false);
    this._reusedTile.setBatchNode(this);
    this._reusedTile.setParent(this);
    return this._reusedTile
  }
  return this._reusedTile
}, _vertexZForPos:function(pos) {
  var ret = 0;
  var maxVal = 0;
  if(this._useAutomaticVertexZ) {
    switch(this._layerOrientation) {
      case cc.TMX_ORIENTATION_ISO:
        maxVal = this._layerSize.width + this._layerSize.height;
        ret = -(maxVal - (pos.x + pos.y));
        break;
      case cc.TMX_ORIENTATION_ORTHO:
        ret = -(this._layerSize.height - pos.y);
        break;
      case cc.TMX_ORIENTATION_HEX:
        cc.Assert(0, "TMX Hexa zOrder not supported");
        break;
      default:
        cc.Assert(0, "TMX invalid value");
        break
    }
  }else {
    ret = this._vertexZvalue
  }
  return ret
}, _atlasIndexForExistantZ:function(z) {
  var item;
  if(this._atlasIndexArray) {
    for(var i = 0;i < this._atlasIndexArray.length;i++) {
      item = this._atlasIndexArray[i];
      if(item == z) {
        break
      }
    }
  }
  cc.Assert(item != null, "TMX atlas index not found. Shall not happen");
  return i
}, _atlasIndexForNewZ:function(z) {
  for(var i = 0;i < this._atlasIndexArray.length;i++) {
    var val = this._atlasIndexArray[i];
    if(z < val) {
      break
    }
  }
  return i
}});
cc.TMXLayer.create = function(tilesetInfo, layerInfo, mapInfo) {
  var ret = new cc.TMXLayer;
  if(ret.initWithTilesetInfo(tilesetInfo, layerInfo, mapInfo)) {
    return ret
  }
  return null
};
cc.PointObject = cc.Class.extend({_ratio:null, _offset:null, _child:null, getRatio:function() {
  return this._ratio
}, setRatio:function(value) {
  this._ratio = value
}, getOffset:function() {
  return this._offset
}, setOffset:function(value) {
  this._offset = value
}, getChild:function() {
  return this._child
}, setChild:function(value) {
  this._child = value
}, initWithCCPoint:function(ratio, offset) {
  this._ratio = ratio;
  this._offset = offset;
  this._child = null;
  return true
}});
cc.PointObject.create = function(ratio, offset) {
  var ret = new cc.PointObject;
  ret.initWithCCPoint(ratio, offset);
  return ret
};
cc.ParallaxNode = cc.Node.extend({_lastPosition:null, _parallaxArray:[], getParallaxArray:function() {
  return this._parallaxArray
}, setParallaxArray:function(value) {
  this._parallaxArray = value
}, ctor:function() {
  this._super();
  this._parallaxArray = [];
  this._lastPosition = cc.p(-100, -100)
}, addChild:function(child, z, ratio, offset) {
  if(arguments.length == 3) {
    cc.Assert(0, "ParallaxNode: use addChild:z:parallaxRatio:positionOffset instead");
    return
  }
  cc.Assert(child != null, "Argument must be non-nil");
  var obj = cc.PointObject.create(ratio, offset);
  obj.setChild(child);
  this._parallaxArray.push(obj);
  var pos = cc.p(this._position.x, this._position.y);
  pos.x = pos.x * ratio.x + offset.x;
  pos.y = pos.y * ratio.y + offset.y;
  child.setPosition(pos);
  this._super(child, z, child.getTag())
}, removeChild:function(child, cleanup) {
  for(var i = 0;i < this._parallaxArray.length;i++) {
    var point = this._parallaxArray[i];
    if(point.getChild() == child) {
      this._parallaxArray.splice(i, 1);
      break
    }
  }
  this._super(child, cleanup)
}, removeAllChildren:function(cleanup) {
  this._parallaxArray = [];
  this._super(cleanup)
}, visit:function() {
  var pos = this._absolutePosition();
  if(!cc.Point.CCPointEqualToPoint(pos, this._lastPosition)) {
    for(var i = 0;i < this._parallaxArray.length;i++) {
      var point = this._parallaxArray[i];
      var x = -pos.x + pos.x * point.getRatio().x + point.getOffset().x;
      var y = -pos.y + pos.y * point.getRatio().y + point.getOffset().y;
      point.getChild().setPosition(cc.p(x, y))
    }
    this._lastPosition = pos
  }
  this._super()
}, _absolutePosition:function() {
  var ret = this._position;
  var cn = this;
  while(cn.getParent() != null) {
    cn = cn.getParent();
    ret = cc.pAdd(ret, cn.getPosition())
  }
  return ret
}});
cc.ParallaxNode.create = function() {
  return new cc.ParallaxNode
};
cc.DOM = {};
cc.DOMEditMode = true;
cc.DOM.addMethods = function(x) {
  for(funcs in cc.DOM.methods) {
    x[funcs] = cc.DOM.methods[funcs]
  }
};
cc.DOM.methods = {setPosition:function(x, y) {
  if(arguments.length == 2) {
    this._position.x = x;
    this._position.y = y
  }else {
    this._position = x
  }
  this.setNodeDirty();
  this.dom.translates(this._position.x, -this._position.y)
}, setPositionY:function(y) {
  this._position.y = y;
  this.setNodeDirty();
  this.dom.translates(this._position.x, -this._position.y)
}, setPositionX:function(x) {
  this._position.x = x;
  this.setNodeDirty();
  this.dom.translates(this._position.x, -this._position.y)
}, setScale:function(scale, scaleY) {
  this._scaleX = scale;
  this._scaleY = scaleY || scale;
  this.setNodeDirty();
  this.dom.resize(this._scaleX, this._scaleY)
}, setScaleX:function(x) {
  this._scaleX = x;
  this.setNodeDirty();
  this.dom.resize(this._scaleX, this._scaleY)
}, setScaleY:function(y) {
  this._scaleY = y;
  this.setNodeDirty();
  this.dom.resize(this._scaleX, this._scaleY)
}, setAnchorPoint:function(point) {
  this._anchorPoint = point;
  this._anchorPointInPoints = cc.p(this._contentSize.width * this._anchorPoint.x, this._contentSize.height * this._anchorPoint.y);
  this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + this._anchorPointInPoints.x + "px " + this._anchorPointInPoints.y + "px";
  if(this.isIgnoreAnchorPointForPosition()) {
    this.dom.style.marginLeft = 0;
    this.dom.style.marginBottom = 0
  }else {
    this.dom.style.marginLeft = this.isToggler ? 0 : -this._anchorPointInPoints.x + "px";
    this.dom.style.marginBottom = -this._anchorPointInPoints.y + "px"
  }
  this.setNodeDirty()
}, setContentSize:function(size) {
  if(!cc.Size.CCSizeEqualToSize(size, this._contentSize)) {
    this._contentSize = size;
    this._anchorPointInPoints = cc.p(this._contentSize.width * this._anchorPoint.x, this._contentSize.height * this._anchorPoint.y);
    this.dom.width = size.width;
    this.dom.height = size.height;
    this.setAnchorPoint(this.getAnchorPoint())
  }
  if(this.canvas) {
    this.canvas.width = this._contentSize.width;
    this.canvas.height = this._contentSize.height
  }
  if(cc.DOMEditMode && !this.placeholder) {
    this.dom.style.width = this._contentSize.width + "px";
    this.dom.style.height = this._contentSize.height + "px";
    this.dom.addClass("CCDOMEdit")
  }
  this.setNodeDirty();
  this.redraw()
}, setRotation:function(newRotation) {
  if(this._rotation == newRotation) {
    return
  }
  this._rotation = newRotation;
  this._rotationRadians = this._rotation * (Math.PI / 180);
  this.setNodeDirty();
  this.dom.rotate(newRotation)
}, setSkewX:function(x) {
  this._skewX = x;
  this.setNodeDirty();
  this.dom.setSkew(this._skewX, this._skewY)
}, setSkewY:function(y) {
  this._skewY = y;
  this.setNodeDirty();
  this.dom.setSkew(this._skewX, this._skewY)
}, setVisible:function(x) {
  this._visible = x;
  this.setNodeDirty();
  if(this.dom) {
    this.dom.style.visibility = x ? "visible" : "hidden"
  }
}, _setZOrder:function(z) {
  this._zOrder = z;
  this.setNodeDirty();
  if(this.dom) {
    this.dom.zIndex = z
  }
}, setParent:function(p) {
  this._parent = p;
  this.setNodeDirty();
  cc.DOM.parentDOM(this)
}, resumeSchedulerAndActions:function() {
  this.getScheduler().resumeTarget(this);
  this.getActionManager().resumeTarget(this);
  if(this.dom && !this.dom.parentNode) {
    if(!this.getParent()) {
      this.dom.appendTo(cc.container)
    }else {
      cc.DOM.parentDOM(this)
    }
  }
  if(this.dom) {
    this.dom.style.visibility = "visible"
  }
}, pauseSchedulerAndActions:function() {
  this.getScheduler().pauseTarget(this);
  this.getActionManager().pauseTarget(this);
  if(this.dom) {
    this.dom.style.visibility = "hidden"
  }
}, cleanup:function() {
  this.stopAllActions();
  this.unscheduleAllCallbacks();
  this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.cleanup);
  if(this.dom) {
    this.dom.remove()
  }
}, removeFromParentAndCleanup:function() {
  this.dom.remove()
}, setOpacity:function(o) {
  this._opacity = o;
  this.dom.style.opacity = o / 255
}, redraw:function() {
  if(this.isSprite) {
    var tmp = this._children;
    this._children = null;
    cc.Sprite.prototype.visit.call(this, this.ctx);
    this._children = tmp
  }else {
    cc.Sprite.prototype.visit.call(this, this.ctx)
  }
}};
cc.DOM.parentDOM = function(x) {
  var p = x.getParent();
  if(!p || !x.dom) {
    return false
  }
  if(!p.dom) {
    cc.DOM.placeHolder(p);
    p.setParent = cc.DOM.methods.setParent
  }
  x.dom.appendTo(p.dom);
  var pp;
  if(pp = p.getParent()) {
    cc.DOM.parentDOM(p)
  }else {
    if(p.isRunning()) {
      p.dom.appendTo(cc.container)
    }
  }
  return true
};
cc.DOM.setTransform = function(x) {
  if(x.ctx) {
    x.ctx.translate(x.getAnchorPointInPoints().x, x.getAnchorPointInPoints().y);
    if(x.isSprite) {
      var tmp = x._children;
      x._children = null;
      cc.Sprite.prototype.visit.call(x, x.ctx);
      x._children = tmp
    }else {
      cc.Sprite.prototype.visit.call(x, x.ctx)
    }
  }
  if(x.dom) {
    x.dom.position.x = x.getPosition().x;
    x.dom.position.y = -x.getPosition().y;
    x.dom.rotation = x.getRotation();
    x.dom.scale = {x:x.getScaleX(), y:x.getScaleY()};
    x.dom.skew = {x:x.getSkewX(), y:x.getSkewY()};
    if(x.setAnchorPoint) {
      x.setAnchorPoint(x.getAnchorPoint())
    }
    x.dom.transforms();
    x.dom.position.y = -x.getPosition().y;
    x.dom.rotation = x.getRotation();
    x.dom.scale = {x:x.getScaleX(), y:x.getScaleY()};
    x.dom.skew = {x:x.getSkewX(), y:x.getSkewY()};
    if(x.setAnchorPoint) {
      x.setAnchorPoint(x.getAnchorPoint())
    }
    x.dom.transforms()
  }
};
cc.DOM.forSprite = function(x) {
  x.dom = cc.$new("div");
  x.canvas = cc.$new("canvas");
  x.canvas.width = x.getContentSize().width;
  x.canvas.height = x.getContentSize().height;
  if(cc.DOMEditMode) {
    x.dom.style.width = x.getContentSize().width + "px";
    x.dom.style.height = x.getContentSize().height + "px";
    x.dom.addClass("CCDOMEdit")
  }
  x.dom.style.position = "absolute";
  x.dom.style.bottom = 0;
  x.ctx = x.canvas.getContext("2d");
  x.dom.appendChild(x.canvas);
  if(x.getParent()) {
    cc.DOM.parentDOM(x)
  }
  x.isSprite = true
};
cc.DOM.forMenuToggler = function(x) {
  x.dom = cc.$new("div");
  x.dom2 = cc.$new("div");
  x.dom.appendChild(x.dom2);
  for(var i = 0;i < x._subItems.length;i++) {
    cc.DOM.convert(x._subItems[i]);
    x.dom2.appendChild(x._subItems[i].dom);
    x._subItems[i].setPosition(cc.p(0, 0))
  }
  x.dom.style.marginLeft = 0;
  x.setSelectedIndex = function(SelectedIndex) {
    this._selectedIndex = SelectedIndex;
    for(var i = 0;i < this._subItems.length;i++) {
      this._subItems[i].setVisible(false)
    }
    this._subItems[SelectedIndex].setVisible(true)
  };
  x.setSelectedIndex(x.getSelectedIndex());
  x.dom2.addEventListener("click", function() {
    x.activate()
  });
  x.dom2.addEventListener("mousedown", function() {
    for(var i = 0;i < x._subItems.length;i++) {
      x._subItems[i]._isEnabled = true;
      x._subItems[i]._running = true;
      x._subItems[i].selected();
      x._subItems[i]._isEnabled = false;
      x._subItems[i]._running = false
    }
    x._subItems[x.getSelectedIndex()]._isEnabled = true;
    x._subItems[x.getSelectedIndex()]._running = true
  });
  x.dom2.addEventListener("mouseup", function() {
    for(var i = 0;i < x._subItems.length;i++) {
      x._subItems[i]._isEnabled = true;
      x._subItems[i].unselected();
      x._subItems[i]._isEnabled = false
    }
    x._subItems[x.getSelectedIndex()]._isEnabled = true
  });
  x.dom2.addEventListener("mouseout", function() {
    if(x.mouseDown) {
      for(var i = 0;i < x._subItems.length;i++) {
        x._subItems[i]._isEnabled = true;
        x._subItems[i].unselected();
        x._subItems[i]._isEnabled = false
      }
      x._subItems[x.getSelectedIndex()]._isEnabled = true;
      x.mouseDown = false
    }
  });
  x.dom.style.position = "absolute";
  x.isToggler = true
};
cc.DOM.forMenuItem = function(x) {
  x.dom = cc.$new("div");
  x.canvas = cc.$new("canvas");
  x.canvas.width = x.getContentSize().width;
  x.canvas.height = x.getContentSize().height;
  if(cc.DOMEditMode) {
    x.dom.style.width = x.getContentSize().width + "px";
    x.dom.style.height = x.getContentSize().height + "px";
    x.dom.addClass("CCDOMEdit")
  }
  x.dom.style.position = "absolute";
  x.dom.style.bottom = 0;
  x.ctx = x.canvas.getContext("2d");
  x.dom.appendChild(x.canvas);
  if(x.getParent()) {
    cc.DOM.parentDOM(x)
  }
  if(x._selector) {
    x.canvas.addEventListener("click", function() {
      x.activate()
    });
    x.canvas.addEventListener("mousedown", function() {
      x.selected();
      x.ctx.save();
      x.ctx.setTransform(1, 0, 0, 1, 0, 0);
      x.ctx.clearRect(0, 0, x.canvas.width, x.canvas.height);
      x.ctx.restore();
      x.mouseDown = true;
      cc.Sprite.prototype.visit.call(x, x.ctx)
    });
    x.canvas.addEventListener("mouseup", function() {
      x.unselected();
      x.ctx.save();
      x.ctx.setTransform(1, 0, 0, 1, 0, 0);
      x.ctx.clearRect(0, 0, x.canvas.width, x.canvas.height);
      x.ctx.restore();
      cc.Sprite.prototype.visit.call(x, x.ctx)
    });
    x.canvas.addEventListener("mouseout", function() {
      if(x.mouseDown) {
        x.unselected();
        x.ctx.save();
        x.ctx.setTransform(1, 0, 0, 1, 0, 0);
        x.ctx.clearRect(0, 0, x.canvas.width, x.canvas.height);
        x.ctx.restore();
        cc.Sprite.prototype.visit.call(x, x.ctx);
        x.mouseDown = false
      }
    })
  }
};
cc.DOM.placeHolder = function(x) {
  x.dom = cc.$new("div");
  x.placeholder = true;
  x.dom.style.position = "absolute";
  x.dom.style.bottom = 0;
  x.dom.style.width = (x.getContentSize().width || cc.Director.getInstance().getWinSize().width) + "px";
  x.dom.style.maxHeight = (x.getContentSize().height || cc.Director.getInstance().getWinSize().height) + "px";
  x.dom.style.margin = 0;
  cc.DOM.setTransform(x);
  x.dom.transforms();
  cc.DOM.addMethods(x)
};
cc.DOM.convert = function() {
  if(arguments.length > 1) {
    return cc.DOM.convert(arguments)
  }else {
    if(arguments.length == 1 && !arguments[0].length) {
      return cc.DOM.convert([arguments[0]])
    }
  }
  var args = arguments[0];
  for(var i = 0;i < args.length;i++) {
    if(args[i] instanceof cc.Sprite) {
      if(!args[i].dom) {
        cc.DOM.forSprite(args[i])
      }
    }else {
      if(args[i] instanceof cc.MenuItemToggle) {
        if(!args[i].dom) {
          cc.DOM.forMenuToggler(args[i])
        }
      }else {
        if(args[i] instanceof cc.MenuItem) {
          if(!args[i].dom) {
            cc.DOM.forMenuItem(args[i])
          }
        }else {
          cc.log("DOM converter only supports sprite and menuitems yet")
        }
      }
    }
    cc.DOM.addMethods(args[i]);
    args[i].visit = function() {
    };
    args[i].transform = function() {
    };
    cc.DOM.setTransform(args[i]);
    args[i].setVisible(args[i].isVisible());
    if(cc.DOMEditMode) {
      if(!cc.DOM.tooltip) {
        var style = cc.$new("style");
        style.textContent = ".CCDOMEdit:hover{border: rgba(255,0,0,0.5) 2px dashed;left: -2px;} .CCDOMEdit " + " #CCCloseButton{width:80px;height:15px;background: rgba(0,0,0,0.4);border:1px solid #aaaaaa;font-size: 9px;line-height:9px;color:#bbbbbb;} " + " .CCTipWindow .CCTipMove{cursor:move;} .CCTipWindow .CCTipRotate{cursor:w-resize;} .CCTipWindow .CCTipScale{cursor:ne-resize;} " + ".CCTipWindow .CCTipSkew{cursor:se-resize;} .CCTipWindow input{width:40px;background: rgba(0,0,0,0.5);color:white;border:none;border-bottom: 1px solid #fff;} " + 
        "div.CCTipWindow:hover{color:rgb(50,50,255);}";
        document.body.appendChild(style);
        cc.container.style.overflow = "visible";
        var tip = cc.DOM.tooltip = cc.$new("div");
        tip.mouseDown = false;
        document.body.appendChild(tip);
        tip.addClass("CCTipWindow");
        tip.style.width = "140px";
        tip.style.height = "134px";
        tip.style.background = "rgba(50,50,50,0.5)";
        tip.style.border = "1px rgba(255,255,255,0.5) solid";
        tip.style.borderRadius = "5px";
        tip.style.color = "rgb(255,255,255)";
        tip.style.boxShadow = "0 0 10px 1px rgba(0,0,0,0.5)";
        tip.style.position = "absolute";
        tip.style.display = "none";
        tip.style.top = 0;
        tip.style.left = "-150px";
        tip.style[cc.$.pfx + "Transform"] = "translate3d(0,0,100px)";
        tip.style[cc.$.pfx + "UserSelect"] = "none";
        tip.innerHTML = "<table><tr>" + '<td><label class="CCTipMove">Move</label></td><td><input type="text" value="12" id="posx"/></td><td><input type="text" value="12" id="posy"/></td></tr>' + '<tr><td><label class="CCTipRotate">Rotate</label></td><td><input type="text" value="12" id="rot"/></td></tr>' + '<tr><td><label class="CCTipScale">Scale</label></td><td><input type="text" value="12" id="scalex"/></td><td><input type="text" value="12" id="scaley"/></td></tr>' + '<tr><td><label class="CCTipSkew">Skew</label></td><td><input type="text" value="12" id="skewx"/></td><td><input type="text" value="12" id="skewy"/></td></tr>' + 
        '</table><button id="CCCloseButton">Close</button>';
        tip.updateNumbers = function() {
          var t = cc.DOM.tooltip;
          if(t.target) {
            t.find("#posx").value = t.target._position.x;
            t.find("#posy").value = t.target._position.y;
            t.find("#rot").value = t.target._rotation;
            t.find("#scalex").value = t.target._scaleX;
            t.find("#scaley").value = t.target._scaleY;
            t.find("#skewx").value = t.target._skewX;
            t.find("#skewy").value = t.target._skewY
          }
        };
        tip.find(".CCTipMove").addEventListener("mousedown", function(e) {
          tip.mode = "move";
          tip.initialpos = {x:e.clientX, y:e.clientY};
          tip.mouseDown = true
        });
        tip.find(".CCTipRotate").addEventListener("mousedown", function(e) {
          var canvaspos = cc.$.findpos(cc.canvas);
          var canvaspos = {x:canvaspos.x, y:canvaspos.y + cc.canvas.height};
          tip.nodepos = tip.target.getPosition();
          tip.nodepos = {x:canvaspos.x + tip.nodepos.x, y:canvaspos.y - tip.nodepos.y};
          tip.startPos = {x:e.x, y:e.y};
          tip.mode = "rot";
          tip.initialpos = {x:e.clientX, y:e.clientY};
          tip.mouseDown = true;
          var C = {x:tip.startPos.x, y:tip.nodepos.y};
          var A = tip.startPos;
          var B = tip.nodepos;
          var a = Math.sqrt(Math.pow(B.x - C.x, 2) + Math.pow(B.y - C.y, 2));
          var b = Math.sqrt(Math.pow(A.x - C.x, 2) + Math.pow(A.y - C.y, 2));
          var c = Math.sqrt(Math.pow(A.x - B.x, 2) + Math.pow(A.y - B.y, 2));
          var theta = (a * a + c * c - b * b) / (2 * a * c);
          var theta = Math.acos(theta) * (180 / cc.PI);
          tip.startAngle = theta;
          tip.startRot = tip.target.getRotation()
        });
        tip.find(".CCTipScale").addEventListener("mousedown", function(e) {
          tip.mode = "scale";
          tip.initialpos = {x:e.clientX, y:e.clientY};
          tip.mouseDown = true
        });
        tip.find(".CCTipSkew").addEventListener("mousedown", function(e) {
          tip.mode = "skew";
          tip.initialpos = {x:e.clientX, y:e.clientY};
          tip.mouseDown = true
        });
        document.body.addEventListener("mousemove", function(e) {
          if(tip.mode == "move") {
            var movex = e.clientX - tip.initialpos.x;
            var movey = e.clientY - tip.initialpos.y;
            var nodepos = tip.target.getPosition();
            tip.target.setPosition(movex + nodepos.x, -movey + nodepos.y);
            tip.initialpos = {x:e.clientX, y:e.clientY};
            tip.updateNumbers()
          }else {
            if(tip.mode == "rot") {
              var C = {x:e.x, y:e.y};
              var A = tip.startPos;
              var B = tip.nodepos;
              var a = Math.sqrt(Math.pow(B.x - C.x, 2) + Math.pow(B.y - C.y, 2));
              var b = Math.sqrt(Math.pow(A.x - C.x, 2) + Math.pow(A.y - C.y, 2));
              var c = Math.sqrt(Math.pow(A.x - B.x, 2) + Math.pow(A.y - B.y, 2));
              var theta = (a * a + c * c - b * b) / (2 * a * c);
              var theta = Math.acos(theta) * (180 / cc.PI);
              var movey = e.clientY - tip.initialpos.y;
              var movex = e.clientX - tip.initialpos.x;
              if(e.y > tip.startPos.y) {
                tip.target.setRotation(-theta + tip.startRot)
              }else {
                tip.target.setRotation(theta + tip.startRot)
              }
              tip.updateNumbers()
            }else {
              if(tip.mode == "scale") {
                var movey = e.clientY - tip.initialpos.y;
                var movex = e.clientX - tip.initialpos.x;
                var nodescalex = tip.target.getScaleX();
                var nodescaley = tip.target.getScaleY();
                tip.target.setScale(nodescalex - movex / 150, nodescaley + movey / 150);
                tip.initialpos = {x:e.clientX, y:e.clientY};
                tip.updateNumbers()
              }else {
                if(tip.mode == "skew") {
                  var movey = e.clientY - tip.initialpos.y;
                  var movex = e.clientX - tip.initialpos.x;
                  var nodeskewx = tip.target.getSkewX();
                  var nodeskewy = tip.target.getSkewY();
                  tip.target.setSkewX(nodeskewx - movex / 4);
                  tip.target.setSkewY(nodeskewy + movey / 4);
                  tip.initialpos = {x:e.clientX, y:e.clientY};
                  tip.updateNumbers()
                }
              }
            }
          }
        });
        tip.find("#CCCloseButton").addEventListener("click", function() {
          tip.mode = null;
          tip.style.display = "none";
          tip.mouseDown = false
        });
        document.addEventListener("mouseup", function() {
          tip.mode = null;
          tip.mouseDown = false
        })
      }
      args[i].dom.ccnode = args[i];
      var that = args[i];
      args[i].dom.addEventListener("mouseover", function() {
        this.style.zIndex = 999999;
        if(this.showTooltipDiv !== undefined && this.showTooltipDiv === false) {
          return
        }
        if(!cc.DOM.tooltip.mouseDown) {
          var pos = cc.$.findpos(this);
          cc.DOM.tooltip.style.display = "block";
          cc.DOM.tooltip.prependTo(this);
          cc.DOM.tooltip.target = that;
          this.style.zIndex = 999999;
          cc.DOM.tooltip.updateNumbers()
        }
      });
      args[i].dom.addEventListener("mouseout", function() {
        this.style.zIndex = this.ccnode._zOrder
      })
    }
  }
};
(function() {
  var box2dAPI = {_ignoreBodyRotation:false, _body:null, _PTMRatio:32, _rotation:1, setBody:function(body) {
    this._body = body
  }, getBody:function() {
    return this._body
  }, setPTMRatio:function(r) {
    this._PTMRatio = r
  }, getPTMRatio:function() {
    return this._PTMRatio
  }, getPosition:function() {
    var pos = this._body.GetPosition();
    return cc.p(pos.x * this._PTMRatio, pos.y * this._PTMRatio)
  }, setPosition:function(p) {
    var angle = this._body.GetAngle();
    this._body.setTransform(Box2D.b2Vec2(p.x / this._PTMRatio, p.y / this._PTMRatio), angle);
    this.setNodeDirty()
  }, getRotation:function() {
    return this._ignoreBodyRotation ? cc.RADIANS_TO_DEGREES(this._rotationRadians) : cc.RADIANS_TO_DEGREES(this._body.GetAngle())
  }, setRotation:function(r) {
    if(this._ignoreBodyRotation) {
      this._rotation = r
    }else {
      var p = this._body.GetPosition();
      this._body.SetTransform(p, cc.DEGREES_TO_RADIANS(r))
    }
    this.setNodeDirty()
  }, _syncPosition:function() {
    var pos = this._body.GetPosition();
    this._position = cc.p(pos.x * this._PTMRatio, pos.y * this._PTMRatio);
    this._rotationRadians = this._rotation * (Math.PI / 180)
  }, _syncRotation:function() {
    this._rotationRadians = this._body.GetAngle()
  }, visit:function() {
    if(this._body && this._PTMRatio) {
      this._syncPosition();
      if(!this._ignoreBodyRotation) {
        this._syncRotation()
      }
    }else {
      cc.log("PhysicsSprite body or PTIMRatio was not set")
    }
    this._super()
  }};
  var chipmunkAPI = {_ignoreBodyRotation:false, _body:null, _rotation:1, setBody:function(body) {
    this._body = body
  }, getBody:function() {
    return this._body
  }, getPosition:function() {
    return{x:this._body.p.x, y:this._body.p.y}
  }, setPosition:function(pos) {
    this._body.p.x = pos.x;
    this._body.p.y = pos.y
  }, _syncPosition:function() {
    if(this._position.x != this._body.p.x || this._position.y != this._body.p.y) {
      cc.Sprite.prototype.setPosition.call(this, {x:this._body.p.x, y:this._body.p.y})
    }
  }, getRotation:function() {
    return this._ignoreBodyRotation ? cc.RADIANS_TO_DEGREES(this._rotationRadiansX) : -cc.RADIANS_TO_DEGREES(this._body.a)
  }, setRotation:function(r) {
    if(this._ignoreBodyRotation) {
      this._super(r)
    }else {
      this._body.a = -cc.DEGREES_TO_RADIANS(r)
    }
  }, _syncRotation:function() {
    if(this._rotationRadiansX != -this._body.a) {
      cc.Sprite.prototype.setRotation.call(this, -cc.RADIANS_TO_DEGREES(this._body.a))
    }
  }, nodeToParentTransform:function() {
    if(cc.renderContextType === cc.CANVAS) {
      return this._nodeToParentTransformForCanvas()
    }
    var x = this._body.p.x;
    var y = this._body.p.y;
    if(this._ignoreAnchorPointForPosition) {
      x += this._anchorPointInPoints.x;
      y += this._anchorPointInPoints.y
    }
    var radians = this._body.a;
    var c = Math.cos(radians);
    var s = Math.sin(radians);
    if(!cc.pointEqualToPoint(this._anchorPointInPoints, cc.PointZero())) {
      x += c * -this._anchorPointInPoints.x * this._scaleX + -s * -this._anchorPointInPoints.y * this._scaleY;
      y += s * -this._anchorPointInPoints.x * this._scaleX + c * -this._anchorPointInPoints.y * this._scaleY
    }
    this._transform = cc.AffineTransformMake(c * this._scaleX, s * this._scaleX, -s * this._scaleY, c * this._scaleY, x, y);
    return this._transform
  }, _nodeToParentTransformForCanvas:function() {
    if(!this._transform) {
      this._transform = {a:1, b:0, c:0, d:1, tx:0, ty:0}
    }
    if(this.isDirty()) {
      var t = this._transform;
      t.tx = this._body.p.x;
      t.ty = this._body.p.y;
      var radians = -this._body.a;
      var Cos = 1, Sin = 0;
      if(radians) {
        Cos = Math.cos(radians);
        Sin = Math.sin(radians)
      }
      t.a = t.d = Cos;
      t.c = -Sin;
      t.b = Sin;
      if(this._scaleX !== 1 || this._scaleY !== 1) {
        t.a *= this._scaleX;
        t.b *= this._scaleX;
        t.c *= this._scaleY;
        t.d *= this._scaleY
      }
      t.tx += Cos * -this._anchorPointInPoints.x * this._scaleX + -Sin * this._anchorPointInPoints.y * this._scaleY;
      t.ty -= Sin * -this._anchorPointInPoints.x * this._scaleX + Cos * this._anchorPointInPoints.y * this._scaleY;
      if(this._ignoreAnchorPointForPosition) {
        t.tx += this._anchorPointInPoints.x;
        t.ty += this._anchorPointInPoints.y
      }
      this._transformDirty = false
    }
    return this._transform
  }, isDirty:function() {
    return!this._body.isSleeping()
  }};
  cc.PhysicsSprite = cc.Sprite.extend(chipmunkAPI);
  cc.PhysicsSprite.create = function(fileName, rect) {
    var argnum = arguments.length;
    var sprite = new cc.PhysicsSprite;
    if(argnum === 0) {
      if(sprite.init()) {
        return sprite
      }
      return null
    }else {
      if(argnum < 2) {
        if(sprite && sprite.initWithFile(fileName)) {
          return sprite
        }
        return null
      }else {
        if(sprite && sprite.initWithFile(fileName, rect)) {
          return sprite
        }
        return null
      }
    }
  };
  cc.PhysicsSprite.createWithSpriteFrameName = function(spriteFrameName) {
    var spriteFrame = null;
    if(typeof spriteFrameName == "string") {
      spriteFrame = cc.SpriteFrameCache.getInstance().getSpriteFrame(spriteFrameName);
      if(!spriteFrame) {
        cc.log("Invalid spriteFrameName: " + spriteFrameName);
        return null
      }
    }else {
      cc.log("Invalid argument. Expecting string.");
      return null
    }
    var sprite = new cc.PhysicsSprite;
    if(sprite && sprite.initWithSpriteFrame(spriteFrame)) {
      return sprite
    }
    return null
  };
  cc.PhysicsSprite.createWithSpriteFrame = function(spriteFrame) {
    var sprite = new cc.PhysicsSprite;
    if(sprite && sprite.initWithSpriteFrame(spriteFrame)) {
      return sprite
    }
    return null
  }
})();
cc.__convertVerts = function(verts) {
  var ret = [];
  for(var i = 0;i < verts.length / 2;i++) {
    ret[i] = {x:verts[i * 2], y:verts[i * 2 + 1]}
  }
  return ret
};
cc.ColorForBody = function(body) {
  if(body.isRogue() || body.isSleeping()) {
    return cc.c4f(0.5, 0.5, 0.5, 0.5)
  }else {
    if(body.nodeIdleTime > body.space.sleepTimeThreshold) {
      return cc.c4f(0.33, 0.33, 0.33, 0.5)
    }else {
      return cc.c4f(1, 0, 0, 0.5)
    }
  }
};
cc.DrawShape = function(shape, renderer) {
  var body = shape.body;
  var color = cc.ColorForBody(body);
  switch(shape.collisionCode) {
    case cp.CircleShape.prototype.collisionCode:
      this.drawDot(shape.tc, Math.max(shape.r, 1), color);
      this.drawSegment(shape.tc, cp.v.add(shape.tc, cp.v.mult(body.rot, shape.r)), 1, color);
      break;
    case cp.SegmentShape.prototype.collisionCode:
      this.drawSegment(shape.ta, shape.tb, Math.max(shape.r, 2), color);
      break;
    case cp.PolyShape.prototype.collisionCode:
      var line = cc.c4f(color.r, color.g, color.b, cc.lerp(color.a, 1, 0.5));
      this.drawPoly(cc.__convertVerts(shape.tVerts), color, 1, line);
      break;
    default:
      cc.Assert(false, "Bad assertion in DrawShape()")
  }
};
cc.DrawConstraint = function(constraint, renderer) {
  var body_a = constraint.a;
  var body_b = constraint.b;
  var a, b;
  if(constraint instanceof cp.PinJoint) {
    a = body_a.local2World(constraint.anchr1);
    b = body_b.local2World(constraint.anchr2);
    this.drawDot(a, 3, cc.CONSTRAINT_COLOR);
    this.drawDot(b, 3, cc.CONSTRAINT_COLOR);
    this.drawSegment(a, b, 1, cc.CONSTRAINT_COLOR)
  }else {
    if(constraint instanceof cp.SlideJoint) {
      a = body_a.local2World(constraint.anchr1);
      b = body_b.local2World(constraint.anchr2);
      this.drawDot(a, 3, cc.CONSTRAINT_COLOR);
      this.drawDot(b, 3, cc.CONSTRAINT_COLOR);
      this.drawSegment(a, b, 1, cc.CONSTRAINT_COLOR)
    }else {
      if(constraint instanceof cp.PivotJoint) {
        a = body_a.local2World(constraint.anchr1);
        b = body_b.local2World(constraint.anchr2);
        this.drawDot(a, 3, cc.CONSTRAINT_COLOR);
        this.drawDot(b, 3, cc.CONSTRAINT_COLOR)
      }else {
        if(constraint instanceof cp.GrooveJoint) {
          a = body_a.local2World(constraint.grv_a);
          b = body_a.local2World(constraint.grv_b);
          var c = body_b.local2World(constraint.anchr2);
          this.drawDot(c, 3, cc.CONSTRAINT_COLOR);
          this.drawSegment(a, b, 1, cc.CONSTRAINT_COLOR)
        }else {
          if(constraint instanceof cp.DampedSpring) {
          }else {
          }
        }
      }
    }
  }
};
cc.CONSTRAINT_COLOR = cc.c4f(0, 1, 0, 0.5);
cc.PhysicsDebugNode = cc.DrawNode.extend({_spaceObj:null, _spacePtr:null, getSpace:function() {
  return this._spacePtr
}, setSpace:function(space) {
  this._spacePtr = space
}, draw:function(context) {
  if(!this._spacePtr) {
    return
  }
  this._spacePtr.eachShape(cc.DrawShape.bind(this));
  this._spacePtr.eachConstraint(cc.DrawConstraint.bind(this));
  this._super();
  this.clear()
}});
cc.PhysicsDebugNode.debugNodeForChipmunkSpace = function(space) {
  var node = new cc.PhysicsDebugNode;
  if(node.init()) {
    node._spaceObj = space;
    node._spacePtr = space.space;
    return node
  }
  return null
};
cc.PhysicsDebugNode.debugNodeForCPSpace = function(space) {
  var node = new cc.PhysicsDebugNode;
  if(node.init()) {
    node._spacePtr = space;
    return node
  }
  return null
};
cc.PhysicsDebugNode.create = cc.PhysicsDebugNode.debugNodeForCPSpace;
var cc = cc || {};
cc.SFX = function(audio, ext) {
  this.audio = audio;
  this.ext = ext || ".ogg"
};
cc.AudioEngine = cc.Class.extend({_supportedFormat:[], _soundEnable:false, _effectList:{}, _soundList:{}, _playingMusic:null, _effectsVolume:1, _maxAudioInstance:10, _canPlay:true, _capabilities:{mp3:false, ogg:false, wav:false, mp4:false, m4a:false}, ctor:function() {
  this._supportedFormat = [];
  var au = document.createElement("audio");
  if(au.canPlayType) {
    this._capabilities.mp3 = "no" != au.canPlayType("audio/mpeg") && "" != au.canPlayType("audio/mpeg");
    this._capabilities.mp4 = "no" != au.canPlayType("audio/mp4") && "" != au.canPlayType("audio/mp4");
    this._capabilities.m4a = "no" != au.canPlayType("audio/x-m4a") && "" != au.canPlayType("audio/x-m4a") || "no" != au.canPlayType("audio/aac") && "" != au.canPlayType("audio/aac");
    this._capabilities.ogg = "no" != au.canPlayType('audio/ogg; codecs="vorbis"') && "" != au.canPlayType('audio/ogg; codecs="vorbis"');
    this._capabilities.wav = "no" != au.canPlayType('audio/wav; codecs="1"') && "" != au.canPlayType('audio/wav; codecs="1"');
    this._soundEnable = this._capabilities.mp3 || this._capabilities.mp4 || this._capabilities.m4a || this._capabilities.ogg || this._capabilities.wav
  }
  var ua = navigator.userAgent;
  if(/Mobile/.test(ua) && (/iPhone OS/.test(ua) || /iPad/.test(ua) || /Firefox/.test(ua)) || /MSIE/.test(ua)) {
    this._canPlay = false
  }
}, init:function() {
  this._getSupportedAudioFormat();
  return this._soundEnable
}, preloadSound:function(path) {
  if(this._soundEnable) {
    var extName = this._getExtFromFullPath(path);
    var keyname = this._getPathWithoutExt(path);
    if(this._checkAudioFormatSupported(extName) && !this._soundList.hasOwnProperty(keyname)) {
      if(this._canPlay) {
        var sfxCache = new cc.SFX;
        sfxCache.ext = extName;
        sfxCache.audio = new Audio(path);
        sfxCache.audio.preload = "auto";
        sfxCache.audio.addEventListener("canplaythrough", function(e) {
          cc.Loader.getInstance().onResLoaded();
          this.removeEventListener("canplaythrough", arguments.callee, false)
        }, false);
        sfxCache.audio.addEventListener("error", function(e) {
          cc.Loader.getInstance().onResLoadingErr(e.srcElement.src);
          this.removeEventListener("error", arguments.callee, false)
        }, false);
        this._soundList[keyname] = sfxCache;
        sfxCache.audio.load()
      }else {
        cc.Loader.getInstance().onResLoaded()
      }
    }else {
      cc.Loader.getInstance().onResLoaded()
    }
  }
}, playMusic:function(path, loop) {
  var keyname = this._getPathWithoutExt(path);
  var extName = this._getExtFromFullPath(path);
  var au;
  if(this._soundList.hasOwnProperty(this._playingMusic)) {
    this._soundList[this._playingMusic].audio.pause()
  }
  this._playingMusic = keyname;
  if(this._soundList.hasOwnProperty(this._playingMusic)) {
    au = this._soundList[this._playingMusic].audio
  }else {
    var sfxCache = new cc.SFX;
    sfxCache.ext = extName;
    au = sfxCache.audio = new Audio(path);
    sfxCache.audio.preload = "auto";
    this._soundList[keyname] = sfxCache;
    sfxCache.audio.load()
  }
  au.addEventListener("pause", this._musicListener, false);
  au.loop = loop || false;
  au.play();
  cc.AudioEngine.isMusicPlaying = true
}, _musicListener:function(e) {
  cc.AudioEngine.isMusicPlaying = false;
  this.removeEventListener("pause", arguments.callee, false)
}, stopMusic:function(releaseData) {
  if(this._soundList.hasOwnProperty(this._playingMusic)) {
    var au = this._soundList[this._playingMusic].audio;
    au.pause();
    au.currentTime = au.duration;
    if(releaseData) {
      delete this._soundList[this._playingMusic]
    }
    cc.AudioEngine.isMusicPlaying = false
  }
}, pauseMusic:function() {
  if(this._soundList.hasOwnProperty(this._playingMusic)) {
    var au = this._soundList[this._playingMusic].audio;
    au.pause();
    cc.AudioEngine.isMusicPlaying = false
  }
}, resumeMusic:function() {
  if(this._soundList.hasOwnProperty(this._playingMusic)) {
    var au = this._soundList[this._playingMusic].audio;
    au.play();
    au.addEventListener("pause", this._musicListener, false);
    cc.AudioEngine.isMusicPlaying = true
  }
}, rewindMusic:function() {
  if(this._soundList.hasOwnProperty(this._playingMusic)) {
    var au = this._soundList[this._playingMusic].audio;
    au.currentTime = 0;
    au.play();
    au.addEventListener("pause", this._musicListener, false);
    cc.AudioEngine.isMusicPlaying = true
  }
}, willPlayMusic:function() {
  return false
}, isMusicPlaying:function() {
  return cc.AudioEngine.isMusicPlaying
}, getMusicVolume:function() {
  if(this._soundList.hasOwnProperty(this._playingMusic)) {
    return this._soundList[this._playingMusic].audio.volume
  }
  return 0
}, setMusicVolume:function(volume) {
  if(this._soundList.hasOwnProperty(this._playingMusic)) {
    var music = this._soundList[this._playingMusic].audio;
    if(volume > 1) {
      music.volume = 1
    }else {
      if(volume < 0) {
        music.volume = 0
      }else {
        music.volume = volume
      }
    }
  }
}, playEffect:function(path, loop) {
  var keyname = this._getPathWithoutExt(path), actExt;
  if(this._soundList.hasOwnProperty(keyname)) {
    actExt = this._soundList[keyname].ext
  }else {
    actExt = this._getExtFromFullPath(path)
  }
  var reclaim = this._getEffectList(keyname), au;
  if(reclaim.length > 0) {
    for(var i = 0;i < reclaim.length;i++) {
      if(reclaim[i].ended) {
        au = reclaim[i];
        au.currentTime = 0;
        break
      }
    }
  }
  if(!au) {
    if(reclaim.length >= this._maxAudioInstance) {
      cc.log("Error: " + path + " greater than " + this._maxAudioInstance);
      return path
    }
    au = new Audio(keyname + "." + actExt);
    au.volume = this._effectsVolume;
    reclaim.push(au)
  }
  if(loop) {
    au.loop = loop
  }
  au.play();
  return path
}, getEffectsVolume:function() {
  return this._effectsVolume
}, setEffectsVolume:function(volume) {
  if(volume > 1) {
    this._effectsVolume = 1
  }else {
    if(volume < 0) {
      this._effectsVolume = 0
    }else {
      this._effectsVolume = volume
    }
  }
  var tmpArr, au;
  for(var i in this._effectList) {
    tmpArr = this._effectList[i];
    if(tmpArr.length > 0) {
      for(var j = 0;j < tmpArr.length;j++) {
        au = tmpArr[j];
        au.volume = this._effectsVolume
      }
    }
  }
}, pauseEffect:function(path) {
  if(!path) {
    return
  }
  var keyname = this._getPathWithoutExt(path);
  if(this._effectList.hasOwnProperty(keyname)) {
    var tmpArr = this._effectList[keyname], au;
    for(var i = tmpArr.length - 1;i >= 0;i--) {
      au = tmpArr[i];
      if(!au.ended) {
        au.pause()
      }
    }
  }
}, pauseAllEffects:function() {
  var tmpArr, au;
  for(var i in this._effectList) {
    tmpArr = this._effectList[i];
    for(var j = 0;j < tmpArr.length;j++) {
      au = tmpArr[j];
      if(!au.ended) {
        au.pause()
      }
    }
  }
}, resumeEffect:function(path) {
  if(!path) {
    return
  }
  var tmpArr, au;
  var keyname = this._getPathWithoutExt(path);
  if(this._effectList.hasOwnProperty(keyname)) {
    tmpArr = this._effectList[keyname];
    if(tmpArr.length > 0) {
      for(var i = 0;i < tmpArr.length;i++) {
        au = tmpArr[i];
        if(!au.ended) {
          au.play()
        }
      }
    }
  }
}, resumeAllEffects:function() {
  var tmpArr, au;
  for(var i in this._effectList) {
    tmpArr = this._effectList[i];
    if(tmpArr.length > 0) {
      for(var j = 0;j < tmpArr.length;j++) {
        au = tmpArr[j];
        if(!au.ended) {
          au.play()
        }
      }
    }
  }
}, stopEffect:function(path) {
  if(!path) {
    return
  }
  var tmpArr, au;
  var keyname = this._getPathWithoutExt(path);
  if(this._effectList.hasOwnProperty(keyname)) {
    tmpArr = this._effectList[keyname];
    if(tmpArr.length > 0) {
      for(var i = 0;i < tmpArr.length;i++) {
        au = tmpArr[i];
        if(!au.ended) {
          au.loop = false;
          au.currentTime = au.duration
        }
      }
    }
  }
}, stopAllEffects:function() {
  var tmpArr, au;
  for(var i in this._effectList) {
    tmpArr = this._effectList[i];
    for(var j = 0;j < tmpArr.length;j++) {
      au = tmpArr[j];
      if(!au.ended) {
        au.loop = false;
        au.currentTime = au.duration
      }
    }
  }
}, unloadEffect:function(path) {
  if(!path) {
    return
  }
  var keyname = this._getPathWithoutExt(path);
  if(this._effectList.hasOwnProperty(keyname)) {
    this.stopEffect(path);
    delete this._effectList[keyname]
  }
}, _getEffectList:function(elt) {
  if(this._effectList.hasOwnProperty(elt)) {
    return this._effectList[elt]
  }else {
    this._effectList[elt] = [];
    return this._effectList[elt]
  }
}, _getPathWithoutExt:function(fullpath) {
  if(typeof fullpath != "string") {
    return
  }
  var endPos = fullpath.lastIndexOf(".");
  if(endPos != -1) {
    return fullpath.substring(0, endPos)
  }
  return fullpath
}, _getExtFromFullPath:function(fullpath) {
  var startPos = fullpath.lastIndexOf(".");
  if(startPos != -1) {
    return fullpath.substring(startPos + 1, fullpath.length)
  }
  return-1
}, _checkAudioFormatSupported:function(ext) {
  var tmpExt;
  for(var i = 0;i < this._supportedFormat.length;i++) {
    tmpExt = this._supportedFormat[i];
    if(tmpExt == ext) {
      return true
    }
  }
  return false
}, _getSupportedAudioFormat:function() {
  if(!this._soundEnable) {
    return
  }
  if(this._capabilities.ogg) {
    this._supportedFormat.push("ogg")
  }
  if(this._capabilities.mp3) {
    this._supportedFormat.push("mp3")
  }
  if(this._capabilities.wav) {
    this._supportedFormat.push("wav")
  }
  if(this._capabilities.mp4) {
    this._supportedFormat.push("mp4")
  }
  if(this._capabilities.m4a) {
    this._supportedFormat.push("m4a")
  }
}});
cc.AudioEngine._instance = null;
cc.AudioEngine.isMusicPlaying = false;
cc.AudioEngine.getInstance = function() {
  if(!this._instance) {
    this._instance = new cc.AudioEngine;
    this._instance.init()
  }
  return this._instance
};
cc.AudioEngine.end = function() {
  if(this._instance) {
    this._instance.stopMusic();
    this._instance.stopAllEffects()
  }
  this._instance = null
};
cc.CONTROL_EVENT_TOTAL_NUMBER = 9;
cc.CONTROL_EVENT_TOUCH_DOWN = 1 << 0;
cc.CONTROL_EVENT_TOUCH_DRAG_INSIDE = 1 << 1;
cc.CONTROL_EVENT_TOUCH_DRAG_OUTSIDE = 1 << 2;
cc.CONTROL_EVENT_TOUCH_DRAG_ENTER = 1 << 3;
cc.CONTROL_EVENT_TOUCH_DRAG_EXIT = 1 << 4;
cc.CONTROL_EVENT_TOUCH_UP_INSIDE = 1 << 5;
cc.CONTROL_EVENT_TOUCH_UP_OUTSIDE = 1 << 6;
cc.CONTROL_EVENT_TOUCH_CANCEL = 1 << 7;
cc.CONTROL_EVENT_VALUECHANGED = 1 << 8;
cc.CONTROL_STATE_NORMAL = 1 << 0;
cc.CONTROL_STATE_HIGHLIGHTED = 1 << 1;
cc.CONTROL_STATE_DISABLED = 1 << 2;
cc.CONTROL_STATE_SELECTED = 1 << 3;
cc.CONTROL_STATE_INITIAL = 1 << 3;
cc.Control = cc.Layer.extend({RGBAProtocol:true, _opacity:0, _color:null, _opacityModifyRGB:false, isOpacityModifyRGB:function() {
  return this._opacityModifyRGB
}, setOpacityModifyRGB:function(opacityModifyRGB) {
  this._opacityModifyRGB = opacityModifyRGB;
  var children = this.getChildren();
  for(var i = 0;i < children.length;i++) {
    var selNode = children[i];
    if(selNode && selNode.RGBAProtocol) {
      selNode.setOpacityModifyRGB(opacityModifyRGB)
    }
  }
}, _defaultTouchPriority:0, getDefaultTouchPriority:function() {
  return this._defaultTouchPriority
}, setDefaultTouchPriority:function(defaultTouchPriority) {
  this._defaultTouchPriority = defaultTouchPriority
}, _state:cc.CONTROL_STATE_NORMAL, getState:function() {
  return this._state
}, _enabled:false, _selected:false, _highlighted:false, _dispatchTable:{}, setOpacity:function(opacity) {
  this._opacity = opacity;
  var children = this.getChildren();
  for(var i = 0;i < children.length;i++) {
    var selNode = children[i];
    if(selNode && selNode.RGBAProtocol) {
      selNode.setOpacity(opacity)
    }
  }
}, getOpacity:function() {
  return this._opacity
}, getColor:function() {
  return this._color
}, setColor:function(color) {
  this._color = color;
  var children = this.getChildren();
  for(var i = 0;i < children.length;i++) {
    var selNode = children[i];
    if(selNode && selNode.RGBAProtocol) {
      selNode.setColor(color)
    }
  }
}, setEnabled:function(enabled) {
  this._enabled = enabled
}, isEnabled:function() {
  return this._enabled
}, setSelected:function(selected) {
  this._selected = selected
}, isSelected:function() {
  return this._selected
}, setHighlighted:function(highlighted) {
  this._highlighted = highlighted
}, isHighlighted:function() {
  return this._highlighted
}, ctor:function() {
  this._super();
  this._dispatchTable = {};
  this._color = cc.white()
}, init:function() {
  if(this._super()) {
    this._state = cc.CONTROL_STATE_NORMAL;
    this._enabled = true;
    this._selected = false;
    this._highlighted = false;
    this._defaultTouchPriority = 1;
    this.setDefaultTouchPriority(this._defaultTouchPriority);
    this._dispatchTable = {};
    return true
  }else {
    return false
  }
}, onEnter:function() {
  this._super()
}, onExit:function() {
  this._super()
}, registerWithTouchDispatcher:function() {
  cc.Director.getInstance().getTouchDispatcher().addTargetedDelegate(this, cc.MENU_HANDLER_PRIORITY, true)
}, sendActionsForControlEvents:function(controlEvents) {
  for(var i = 0;i < cc.CONTROL_EVENT_TOTAL_NUMBER;i++) {
    if(controlEvents & 1 << i) {
      var invocationList = this._dispatchListforControlEvent(1 << i);
      for(var j = 0;j < invocationList.length;j++) {
        invocationList[j].invoke(this)
      }
    }
  }
}, addTargetWithActionForControlEvents:function(target, action, controlEvents) {
  for(var i = 0;i < cc.CONTROL_EVENT_TOTAL_NUMBER;i++) {
    if(controlEvents & 1 << i) {
      this.addTargetWithActionForControlEvent(target, action, 1 << i)
    }
  }
}, removeTargetWithActionForControlEvents:function(target, action, controlEvents) {
  for(var i = 0;i < cc.CONTROL_EVENT_TOTAL_NUMBER;i++) {
    if(controlEvents & 1 << i) {
      this.removeTargetWithActionForControlEvent(target, action, 1 << i)
    }
  }
}, getTouchLocation:function(touch) {
  var touchLocation = touch.getLocation();
  touchLocation = this.getParent().convertToNodeSpace(touchLocation);
  return touchLocation
}, isTouchInside:function(touch) {
  var touchLocation = this.getTouchLocation(touch);
  var bBox = this.getBoundingBox();
  return cc.Rect.CCRectContainsPoint(bBox, touchLocation)
}, _invocationWithTargetAndActionForControlEvent:function(target, action, controlEvent) {
}, _dispatchListforControlEvent:function(controlEvent) {
  controlEvent = controlEvent.toString();
  if(this._dispatchTable.hasOwnProperty(controlEvent)) {
    return this._dispatchTable[controlEvent]
  }
  var invocationList = [];
  this._dispatchTable[controlEvent] = invocationList;
  return invocationList
}, addTargetWithActionForControlEvent:function(target, action, controlEvent) {
  var invocation = new cc.Invocation(target, action, controlEvent);
  var eventInvocationList = this._dispatchListforControlEvent(controlEvent);
  eventInvocationList.push(invocation)
}, removeTargetWithActionForControlEvent:function(target, action, controlEvent) {
  var eventInvocationList = this._dispatchListforControlEvent(controlEvent);
  var bDeleteObjects = true;
  if(!target && !action) {
    eventInvocationList.length = 0
  }else {
    for(var i = 0;i < eventInvocationList.length;i++) {
      var invocation = eventInvocationList[i];
      var shouldBeRemoved = true;
      if(target) {
        shouldBeRemoved = target == invocation.getTarget()
      }
      if(action) {
        shouldBeRemoved = shouldBeRemoved && action == invocation.getAction()
      }
      if(shouldBeRemoved) {
        cc.ArrayRemoveObject(eventInvocationList, invocation)
      }
    }
  }
}});
cc.Control.create = function() {
  var retControl = new cc.Control;
  if(retControl && retControl.init()) {
    return retControl
  }
  return null
};
cc.CONTROL_ZOOM_ACTION_TAG = 3435855873;
cc.ControlButton = cc.Control.extend({_adjustBackgroundImage:false, _zoomOnTouchDown:false, _preferredSize:new cc.Size(0, 0), _labelAnchorPoint:new cc.Point(0, 0), _currentTitle:"", _currentTitleColor:cc.white(), _titleLabel:null, _backgroundSprite:null, _opacity:0, _pushed:false, _titleDispatchTable:null, _titleColorDispatchTable:null, _titleLabelDispatchTable:null, _backgroundSpriteDispatchTable:null, _marginV:0, _marginH:0, ctor:function() {
  this._super();
  this._preferredSize = new cc.Size(0, 0);
  this._labelAnchorPoint = new cc.Point(0, 0);
  this._currentTitleColor = cc.white();
  this._titleDispatchTable = {};
  this._titleColorDispatchTable = {};
  this._titleLabelDispatchTable = {};
  this._backgroundSpriteDispatchTable = {}
}, init:function(isDirectCall) {
  if(isDirectCall != null && isDirectCall == true) {
    return this._super()
  }
  return this.initWithLabelAndBackgroundSprite(cc.LabelTTF.create("", "Helvetica", 12), cc.Scale9Sprite.create())
}, needsLayout:function() {
  this._titleLabel.setVisible(false);
  this._backgroundSprite.setVisible(false);
  this.setLabelAnchorPoint(this.m_labelAnchorPoint);
  this._currentTitle = this.getTitleForState(this._state);
  this._currentTitleColor = this.getTitleColorForState(this._state);
  this._titleLabel = this.getTitleLabelForState(this._state);
  var label = this._titleLabel;
  if(label && label.setString) {
    label.setString(this._currentTitle)
  }
  if(this._titleLabel && this._titleLabel.RGBAProtocol) {
    this._titleLabel.setColor(this._currentTitleColor)
  }
  this._titleLabel.setPosition(cc.p(this.getContentSize().width / 2, this.getContentSize().height / 2));
  this._backgroundSprite = this.getBackgroundSpriteForState(this._state);
  this._backgroundSprite.setPosition(cc.p(this.getContentSize().width / 2, this.getContentSize().height / 2));
  var titleLabelSize = this._titleLabel.getBoundingBox().size;
  if(this._adjustBackgroundImage) {
    this._backgroundSprite.setContentSize(cc.SizeMake(titleLabelSize.width + this._marginH * 2, titleLabelSize.height + this._marginV * 2))
  }else {
    var preferredSize = this._backgroundSprite.getPreferredSize();
    if(preferredSize.width <= 0) {
      preferredSize.width = titleLabelSize.width
    }
    if(preferredSize.height <= 0) {
      preferredSize.height = titleLabelSize.height
    }
    this._backgroundSprite.setContentSize(preferredSize)
  }
  var maxRect = cc.ControlUtils.CCRectUnion(this._titleLabel.getBoundingBox(), this._backgroundSprite.getBoundingBox());
  this.setContentSize(cc.SizeMake(maxRect.size.width, maxRect.size.height));
  this._titleLabel.setPosition(cc.p(this.getContentSize().width / 2, this.getContentSize().height / 2));
  this._backgroundSprite.setPosition(cc.p(this.getContentSize().width / 2, this.getContentSize().height / 2));
  this._titleLabel.setVisible(true);
  this._backgroundSprite.setVisible(true)
}, initWithLabelAndBackgroundSprite:function(label, backgroundSprite) {
  if(this.init(true)) {
    cc.Assert(label != null, "node must not be nil");
    cc.Assert(label != null || label.RGBAProtocol || backgroundSprite != null, "");
    this.setTouchEnabled(true);
    this._pushed = false;
    this._zoomOnTouchDown = true;
    this._state = cc.CONTROL_STATE_INITIAL;
    this._currentTitle = null;
    this._adjustBackgroundImage = true;
    this._zoomOnTouchDown = true;
    this.ignoreAnchorPointForPosition(false);
    this.setAnchorPoint(cc.p(0.5, 0.5));
    this._titleLabel = label;
    this._backgroundSprite = backgroundSprite;
    this._titleDispatchTable = {};
    this._titleColorDispatchTable = {};
    this._titleLabelDispatchTable = {};
    this._backgroundSpriteDispatchTable = {};
    this.setColor(cc.c3(255, 255, 255));
    this.setOpacity(255);
    this.setOpacityModifyRGB(true);
    var tempString = label.getString();
    this.setTitleForState(tempString, cc.CONTROL_STATE_NORMAL);
    this.setTitleColorForState(label.getColor(), cc.CONTROL_STATE_NORMAL);
    this.setTitleLabelForState(label, cc.CONTROL_STATE_NORMAL);
    this.setBackgroundSpriteForState(backgroundSprite, cc.CONTROL_STATE_NORMAL);
    this._state = cc.CONTROL_STATE_NORMAL;
    this._marginH = 24;
    this._marginV = 12;
    this.m_labelAnchorPoint = new cc.Point(0.5, 0.5);
    this.needsLayout();
    return true
  }else {
    return false
  }
}, initWithTitleAndFontNameAndFontSize:function(title, fontName, fontSize) {
  var label = cc.LabelTTF.create(title, fontName, fontSize);
  return this.initWithLabelAndBackgroundSprite(label, cc.Scale9Sprite.create())
}, initWithBackgroundSprite:function(sprite) {
  var label = cc.LabelTTF.create("", "Arial", 30);
  return this.initWithLabelAndBackgroundSprite(label, sprite)
}, getAdjustBackgroundImage:function() {
  return this._adjustBackgroundImage
}, setAdjustBackgroundImage:function(adjustBackgroundImage) {
  this._adjustBackgroundImage = adjustBackgroundImage;
  this.needsLayout()
}, getZoomOnTouchDown:function() {
  return this._zoomOnTouchDown
}, setZoomOnTouchDown:function(zoomOnTouchDown) {
  return this._zoomOnTouchDown = zoomOnTouchDown
}, getPreferredSize:function() {
  return this._preferredSize
}, setPreferredSize:function(preferredSize) {
  if(preferredSize.width == 0 && preferredSize.height == 0) {
    this._adjustBackgroundImage = true
  }else {
    this._adjustBackgroundImage = false;
    for(var itemKey in this._backgroundSpriteDispatchTable) {
      this._backgroundSpriteDispatchTable[itemKey].setPreferredSize(preferredSize)
    }
    this._preferredSize = preferredSize
  }
  this.needsLayout()
}, getLabelAnchorPoint:function() {
  return this._labelAnchorPoint
}, setLabelAnchorPoint:function(labelAnchorPoint) {
  this.m_labelAnchorPoint = labelAnchorPoint;
  this._titleLabel.setAnchorPoint(labelAnchorPoint)
}, getCurrentTitle:function() {
  return this._currentTitle
}, getCurrentTitleColor:function() {
  return this._currentTitleColor
}, getOpacity:function() {
  return this._opacity
}, setOpacity:function(opacity) {
  this._opacity = opacity;
  var controlChildren = this.getChildren();
  for(var i = 0;i < controlChildren.length;i++) {
    if(controlChildren[i] && controlChildren[i].RGBAProtocol) {
      controlChildren[i].setOpacity(opacity)
    }
  }
  for(var itemKey in this._backgroundSpriteDispatchTable) {
    this._backgroundSpriteDispatchTable[itemKey].setOpacity(opacity)
  }
}, getIsPushed:function() {
  return this._pushed
}, getVerticalMargin:function() {
  return this._marginV
}, getHorizontalOrigin:function() {
  return this._marginH
}, setMargins:function(marginH, marginV) {
  this._marginV = marginV;
  this._marginH = marginH;
  this.needsLayout()
}, setEnabled:function(enabled) {
  this._super(enabled);
  this.needsLayout()
}, setSelected:function(enabled) {
  this._super(enabled);
  this.needsLayout()
}, setHighlighted:function(enabled) {
  this._super(enabled);
  var action = this.getActionByTag(cc.CONTROL_ZOOM_ACTION_TAG);
  if(action) {
    this.stopAction(action)
  }
  this.needsLayout();
  if(this._zoomOnTouchDown) {
    var scaleValue = this.isHighlighted() && this.isEnabled() && !this.isSelected() ? 1.1 : 1;
    var zoomAction = cc.ScaleTo.create(0.05, scaleValue);
    zoomAction.setTag(cc.CONTROL_ZOOM_ACTION_TAG);
    this.runAction(zoomAction)
  }
}, onTouchBegan:function(touch, event) {
  if(!this.isTouchInside(touch) || !this.isEnabled()) {
    return false
  }
  this._state = cc.CONTROL_STATE_HIGHLIGHTED;
  this._pushed = true;
  this.setHighlighted(true);
  this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DOWN);
  return true
}, onTouchMoved:function(touch, event) {
  if(!this._enabled || !this._pushed || this._selected) {
    if(this._highlighted) {
      this.setHighlighted(false)
    }
    return
  }
  var isTouchMoveInside = this.isTouchInside(touch);
  if(isTouchMoveInside && !this._highlighted) {
    this._state = cc.CONTROL_STATE_HIGHLIGHTED;
    this.setHighlighted(true);
    this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_ENTER)
  }else {
    if(isTouchMoveInside && this._highlighted) {
      this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_INSIDE)
    }else {
      if(!isTouchMoveInside && this._highlighted) {
        this._state = cc.CONTROL_STATE_NORMAL;
        this.setHighlighted(false);
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_EXIT)
      }else {
        if(!isTouchMoveInside && !this._highlighted) {
          this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_OUTSIDE)
        }
      }
    }
  }
}, onTouchEnded:function(touch, event) {
  this._state = cc.CONTROL_STATE_NORMAL;
  this._pushed = false;
  this.setHighlighted(false);
  if(this.isTouchInside(touch)) {
    this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_UP_INSIDE)
  }else {
    this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_UP_OUTSIDE)
  }
}, onTouchCancelled:function(touch, event) {
  this._state = cc.CONTROL_STATE_NORMAL;
  this._pushed = false;
  this.setHighlighted(false);
  this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_CANCEL)
}, getTitleForState:function(state) {
  if(this._titleDispatchTable.hasOwnProperty(state)) {
    if(this._titleDispatchTable[state]) {
      return this._titleDispatchTable[state]
    }
  }
  return this._titleDispatchTable[cc.CONTROL_STATE_NORMAL]
}, setTitleForState:function(title, state) {
  if(title) {
    this._titleDispatchTable[state] = title
  }else {
    this._titleDispatchTable[state] = ""
  }
  if(this.getState() == state) {
    this.needsLayout()
  }
}, getTitleColorForState:function(state) {
  if(this._titleColorDispatchTable.hasOwnProperty(state)) {
    if(this._titleColorDispatchTable[state]) {
      return this._titleColorDispatchTable[state]
    }
  }
  return this._titleColorDispatchTable[cc.CONTROL_STATE_NORMAL]
}, setTitleColorForState:function(color, state) {
  this._titleColorDispatchTable[state] = color;
  if(this.getState() == state) {
    this.needsLayout()
  }
}, getTitleLabelForState:function(state) {
  if(this._titleLabelDispatchTable.hasOwnProperty(state) && this._titleLabelDispatchTable[state]) {
    return this._titleLabelDispatchTable[state]
  }
  return this._titleLabelDispatchTable[cc.CONTROL_STATE_NORMAL]
}, setTitleLabelForState:function(titleLabel, state) {
  if(this._titleLabelDispatchTable.hasOwnProperty(state)) {
    var previousLabel = this._titleLabelDispatchTable[state];
    if(previousLabel) {
      this.removeChild(previousLabel, true)
    }
  }
  this._titleLabelDispatchTable[state] = titleLabel;
  titleLabel.setVisible(false);
  titleLabel.setAnchorPoint(cc.p(0.5, 0.5));
  this.addChild(titleLabel, 1);
  if(this.getState() == state) {
    this.needsLayout()
  }
}, setTitleTTFForState:function(fntFile, state) {
  var title = this.getTitleForState(state);
  if(!title) {
    title = ""
  }
  this.setTitleLabelForState(cc.LabelTTF.create(title, fntFile, 12), state)
}, getTitleTTFForState:function(state) {
  var labelTTF = this.getTitleLabelForState(state);
  if(labelTTF != null && labelTTF instanceof cc.LabelTTF) {
    return labelTTF.getFontName()
  }else {
    return""
  }
}, setTitleTTFSizeForState:function(size, state) {
  var labelTTF = this.getTitleLabelForState(state);
  if(labelTTF != null && labelTTF instanceof cc.LabelTTF) {
    labelTTF.setFontSize(size)
  }
}, getTitleTTFSizeForState:function(state) {
  var labelTTF = this.getTitleLabelForState(state);
  if(labelTTF != null && labelTTF instanceof cc.LabelTTF) {
    return labelTTF.getFontSize()
  }
  return 0
}, setTitleBMFontForState:function(fntFile, state) {
  var title = this.getTitleForState(state);
  if(!title) {
    title = ""
  }
  this.setTitleLabelForState(cc.LabelBMFont.create(title, fntFile), state)
}, getTitleBMFontForState:function(state) {
  var labelBMFont = this.getTitleLabelForState(state);
  if(labelBMFont != null && labelBMFont instanceof cc.LabelBMFont) {
    return labelBMFont.getFntFile()
  }
  return""
}, getBackgroundSpriteForState:function(state) {
  if(this._backgroundSpriteDispatchTable.hasOwnProperty(state) && this._backgroundSpriteDispatchTable[state]) {
    return this._backgroundSpriteDispatchTable[state]
  }
  return this._backgroundSpriteDispatchTable[cc.CONTROL_STATE_NORMAL]
}, setBackgroundSpriteForState:function(sprite, state) {
  if(this._backgroundSpriteDispatchTable.hasOwnProperty(state)) {
    var previousSprite = this._backgroundSpriteDispatchTable[state];
    if(previousSprite) {
      this.removeChild(previousSprite, true)
    }
  }
  this._backgroundSpriteDispatchTable[state] = sprite;
  sprite.setVisible(false);
  sprite.setAnchorPoint(cc.p(0.5, 0.5));
  this.addChild(sprite);
  if(this._preferredSize.width != 0 || this._preferredSize.height != 0) {
    sprite.setPreferredSize(this._preferredSize)
  }
  if(this.getState() == state) {
    this.needsLayout()
  }
}, setBackgroundSpriteFrameForState:function(spriteFrame, state) {
  var sprite = cc.Scale9Sprite.createWithSpriteFrame(spriteFrame);
  this.setBackgroundSpriteForState(sprite, state)
}});
cc.ControlButton.create = function(label, backgroundSprite) {
  var controlButton;
  if(arguments.length == 0) {
    controlButton = new cc.ControlButton;
    if(controlButton && controlButton.init()) {
      return controlButton
    }
    return null
  }else {
    if(arguments.length == 1) {
      controlButton = new cc.ControlButton;
      controlButton.initWithBackgroundSprite(arguments[0]);
      return controlButton
    }else {
      if(arguments.length == 2) {
        controlButton = new cc.ControlButton;
        controlButton.initWithLabelAndBackgroundSprite(label, backgroundSprite);
        return controlButton
      }else {
        if(arguments.length == 3) {
          controlButton = new cc.ControlButton;
          controlButton.initWithTitleAndFontNameAndFontSize(arguments[0], arguments[1], arguments[2]);
          return controlButton
        }
      }
    }
  }
};
cc.RGBA = function(r, g, b, a) {
  this.r = r;
  this.g = g;
  this.b = b;
  this.a = a
};
cc.HSV = function(h, s, v) {
  this.h = h;
  this.s = s;
  this.v = v
};
cc.ControlUtils = {};
cc.ControlUtils.addSpriteToTargetWithPosAndAnchor = function(spriteName, target, pos, anchor) {
  var sprite = cc.Sprite.createWithSpriteFrameName(spriteName);
  if(!sprite) {
    return null
  }
  sprite.setPosition(pos);
  sprite.setAnchorPoint(anchor);
  target.addChild(sprite);
  return sprite
};
cc.ControlUtils.HSVfromRGB = function(rgbaValue) {
  var out = new cc.HSV;
  var min, max, delta;
  min = rgbaValue.r < rgbaValue.g ? rgbaValue.r : rgbaValue.g;
  min = min < rgbaValue.b ? min : rgbaValue.b;
  max = rgbaValue.r > rgbaValue.g ? rgbaValue.r : rgbaValue.g;
  max = max > rgbaValue.b ? max : rgbaValue.b;
  out.v = max;
  delta = max - min;
  if(max > 0) {
    out.s = delta / max
  }else {
    out.s = 0;
    out.h = -1;
    return out
  }
  if(rgbaValue.r >= max) {
    out.h = (rgbaValue.g - rgbaValue.b) / delta
  }else {
    if(rgbaValue.g >= max) {
      out.h = 2 + (rgbaValue.b - rgbaValue.r) / delta
    }else {
      out.h = 4 + (rgbaValue.r - rgbaValue.g) / delta
    }
  }
  out.h *= 60;
  if(out.h < 0) {
    out.h += 360
  }
  return out
};
cc.ControlUtils.RGBfromHSV = function(hsvValue) {
  var hh, p, q, t, ff;
  var i;
  var out = new cc.RGBA;
  out.a = 1;
  if(hsvValue.s <= 0) {
    if(!hsvValue.h) {
      out.r = hsvValue.v;
      out.g = hsvValue.v;
      out.b = hsvValue.v;
      return out
    }
    out.r = 0;
    out.g = 0;
    out.b = 0;
    return out
  }
  hh = hsvValue.h;
  if(hh >= 360) {
    hh = 0
  }
  hh /= 60;
  i = 0 | hh;
  ff = hh - i;
  p = hsvValue.v * (1 - hsvValue.s);
  q = hsvValue.v * (1 - hsvValue.s * ff);
  t = hsvValue.v * (1 - hsvValue.s * (1 - ff));
  switch(i) {
    case 0:
      out.r = hsvValue.v;
      out.g = t;
      out.b = p;
      break;
    case 1:
      out.r = q;
      out.g = hsvValue.v;
      out.b = p;
      break;
    case 2:
      out.r = p;
      out.g = hsvValue.v;
      out.b = t;
      break;
    case 3:
      out.r = p;
      out.g = q;
      out.b = hsvValue.v;
      break;
    case 4:
      out.r = t;
      out.g = p;
      out.b = hsvValue.v;
      break;
    case 5:
    ;
    default:
      out.r = hsvValue.v;
      out.g = p;
      out.b = q;
      break
  }
  return out
};
cc.ControlUtils.CCRectUnion = function(rect1, rect2) {
  return cc.Rect.CCRectUnion(rect1, rect2)
};
cc.Invocation = cc.Class.extend({_action:null, _target:null, _controlEvent:null, ctor:function(target, action, controlEvent) {
  this._target = target;
  this._action = action;
  this._controlEvent = controlEvent
}, getAction:function() {
  return this._action
}, getTarget:function() {
  return this._target
}, getControlEvent:function() {
  return this._controlEvent
}, invoke:function(sender) {
  if(this._target && this._action) {
    if(typeof this._action == "string") {
      this._target[this._action](sender, this._controlEvent)
    }else {
      this._action.call(this._target, sender, this._controlEvent)
    }
  }
}});
cc.POSITIONS_CENTRE = 0;
cc.POSITIONS_TOP = 1;
cc.POSITIONS_LEFT = 2;
cc.POSITIONS_RIGHT = 3;
cc.POSITIONS_BOTTOM = 4;
cc.POSITIONS_TOPRIGHT = 5;
cc.POSITIONS_TOPLEFT = 6;
cc.POSITIONS_BOTTOMRIGHT = 7;
cc.POSITIONS_BOTTOMLEFT = 8;
cc.Scale9Sprite = cc.Node.extend({RGBAProtocol:true, _spriteRect:null, _capInsetsInternal:null, _positionsAreDirty:false, _scale9Image:null, _topLeft:null, _top:null, _topRight:null, _left:null, _centre:null, _right:null, _bottomLeft:null, _bottom:null, _bottomRight:null, _colorUnmodified:null, _opacityModifyRGB:false, _originalSize:null, _preferredSize:null, _opacity:0, _color:null, _capInsets:null, _insetLeft:0, _insetTop:0, _insetRight:0, _insetBottom:0, _spritesGenerated:false, _spriteFrameRotated:false, 
_updateCapInset:function() {
  var insets;
  if(this._insetLeft == 0 && this._insetTop == 0 && this._insetRight == 0 && this._insetBottom == 0) {
    insets = cc.RectZero()
  }else {
    insets = this._spriteFrameRotated ? cc.RectMake(this._insetBottom, this._insetLeft, this._spriteRect.size.width - this._insetRight - this._insetLeft, this._spriteRect.size.height - this._insetTop - this._insetBottom) : cc.RectMake(this._insetLeft, this._insetTop, this._spriteRect.size.width - this._insetLeft - this._insetRight, this._spriteRect.size.height - this._insetTop - this._insetBottom)
  }
  this.setCapInsets(insets)
}, _updatePositions:function() {
  if(!(this._topLeft && this._topRight && this._bottomRight && this._bottomLeft && this._centre)) {
    return
  }
  var size = this._contentSize;
  var sizableWidth = size.width - this._topLeft.getContentSize().width - this._topRight.getContentSize().width;
  var sizableHeight = size.height - this._topLeft.getContentSize().height - this._bottomRight.getContentSize().height;
  var horizontalScale = sizableWidth / this._centre.getContentSize().width;
  var verticalScale = sizableHeight / this._centre.getContentSize().height;
  this._centre.setScaleX(horizontalScale);
  this._centre.setScaleY(verticalScale);
  var rescaledWidth = this._centre.getContentSize().width * horizontalScale;
  var rescaledHeight = this._centre.getContentSize().height * verticalScale;
  var leftWidth = this._bottomLeft.getContentSize().width;
  var bottomHeight = this._bottomLeft.getContentSize().height;
  this._bottomLeft.setAnchorPoint(cc.p(0, 0));
  this._bottomRight.setAnchorPoint(cc.p(0, 0));
  this._topLeft.setAnchorPoint(cc.p(0, 0));
  this._topRight.setAnchorPoint(cc.p(0, 0));
  this._left.setAnchorPoint(cc.p(0, 0));
  this._right.setAnchorPoint(cc.p(0, 0));
  this._top.setAnchorPoint(cc.p(0, 0));
  this._bottom.setAnchorPoint(cc.p(0, 0));
  this._centre.setAnchorPoint(cc.p(0, 0));
  this._bottomLeft.setPosition(cc.p(0, 0));
  this._bottomRight.setPosition(cc.p(leftWidth + rescaledWidth, 0));
  this._topLeft.setPosition(cc.p(0, bottomHeight + rescaledHeight));
  this._topRight.setPosition(cc.p(leftWidth + rescaledWidth, bottomHeight + rescaledHeight));
  this._left.setPosition(cc.p(0, bottomHeight));
  this._left.setScaleY(verticalScale);
  this._right.setPosition(cc.p(leftWidth + rescaledWidth, bottomHeight));
  this._right.setScaleY(verticalScale);
  this._bottom.setPosition(cc.p(leftWidth, 0));
  this._bottom.setScaleX(horizontalScale);
  this._top.setPosition(cc.p(leftWidth, bottomHeight + rescaledHeight));
  this._top.setScaleX(horizontalScale);
  this._centre.setPosition(cc.p(leftWidth, bottomHeight))
}, ctor:function() {
  this._super();
  this._spriteRect = cc.RectZero();
  this._capInsetsInternal = cc.RectZero();
  this._colorUnmodified = cc.white();
  this._originalSize = new cc.Size(0, 0);
  this._preferredSize = new cc.Size(0, 0);
  this._color = cc.white();
  this._opacity = 255;
  this._capInsets = cc.RectZero()
}, getOriginalSize:function() {
  return this._originalSize
}, getPreferredSize:function() {
  return this._preferredSize
}, setPreferredSize:function(preferredSize) {
  this.setContentSize(preferredSize);
  this._preferredSize = preferredSize
}, getOpacity:function() {
  return this._opacity
}, setOpacity:function(opacity) {
  this._opacity = opacity
}, getColor:function() {
  return this._color
}, setColor:function(color) {
  this._color = color;
  var scaleChildren = this._scale9Image.getChildren();
  if(scaleChildren && scaleChildren.length != 0) {
    for(var i = 0;i < scaleChildren.length;i++) {
      if(scaleChildren[i] && scaleChildren[i].RGBAProtocol) {
        scaleChildren[i].setColor(this._color)
      }
    }
  }
}, getCapInsets:function() {
  return this._capInsets
}, setCapInsets:function(capInsets) {
  var contentSize = this._contentSize;
  this.updateWithBatchNode(this._scale9Image, this._spriteRect, this._spriteFrameRotated, capInsets);
  this.setContentSize(contentSize)
}, getInsetLeft:function() {
  return this._insetLeft
}, setInsetLeft:function(insetLeft) {
  this._insetLeft = insetLeft;
  this._updateCapInset()
}, getInsetTop:function() {
  return this._insetTop
}, setInsetTop:function(insetTop) {
  this._insetTop = insetTop;
  this._updateCapInset()
}, getInsetRight:function() {
  return this._insetRight
}, setInsetRight:function(insetRight) {
  this._insetRight = insetRight;
  this._updateCapInset()
}, getInsetBottom:function() {
  return this._insetBottom
}, setInsetBottom:function(insetBottom) {
  this._insetBottom = insetBottom;
  this._updateCapInset()
}, setContentSize:function(size) {
  this._super(size);
  this.m_positionsAreDirty = true
}, visit:function() {
  if(this.m_positionsAreDirty) {
    this._updatePositions();
    this.m_positionsAreDirty = false
  }
  this._super()
}, init:function() {
  return this.initWithBatchNode(null, cc.RectZero(), false, cc.RectZero())
}, initWithBatchNode:function(batchNode, rect, rotated, capInsets) {
  if(arguments.length == 3) {
    capInsets = rotated;
    rotated = false
  }
  if(batchNode) {
    this.updateWithBatchNode(batchNode, rect, rotated, capInsets)
  }
  this.setAnchorPoint(cc.p(0.5, 0.5));
  this.m_positionsAreDirty = true;
  return true
}, initWithFile:function(file, rect, capInsets) {
  if(file instanceof cc.Rect) {
    file = arguments[1];
    capInsets = arguments[0];
    rect = cc.RectZero()
  }else {
    rect = rect || cc.RectZero();
    capInsets = capInsets || cc.RectZero()
  }
  cc.Assert(file != null, "Invalid file for sprite");
  var batchnode = cc.SpriteBatchNode.create(file, 9);
  return this.initWithBatchNode(batchnode, rect, false, capInsets)
}, initWithSpriteFrame:function(spriteFrame, capInsets) {
  capInsets = capInsets || cc.RectZero();
  cc.Assert(spriteFrame != null, "Sprite frame must not be nil");
  var selTexture = spriteFrame.getTexture();
  cc.Assert(selTexture != null, "Texture must be not nil");
  var batchNode = cc.SpriteBatchNode.createWithTexture(selTexture, 9);
  return this.initWithBatchNode(batchNode, spriteFrame.getRect(), cc.Browser.supportWebGL ? spriteFrame.isRotated() : false, capInsets)
}, initWithSpriteFrameName:function(spriteFrameName, capInsets) {
  capInsets = capInsets || cc.RectZero();
  cc.Assert(spriteFrameName != null, "Invalid spriteFrameName for sprite");
  var frame = cc.SpriteFrameCache.getInstance().getSpriteFrame(spriteFrameName);
  cc.Assert(frame != null, "cc.SpriteFrame must be non-NULL");
  if(frame == null) {
    return false
  }
  return this.initWithSpriteFrame(frame, capInsets)
}, resizableSpriteWithCapInsets:function(capInsets) {
  var pReturn = new cc.Scale9Sprite;
  if(pReturn && pReturn.initWithBatchNode(this._scale9Image, this._spriteRect, false, capInsets)) {
    return pReturn
  }
  return null
}, setOpacityModifyRGB:function(value) {
  this._opacityModifyRGB = value;
  var scaleChildren = this._scale9Image.getChildren();
  if(scaleChildren) {
    for(var i = 0;i < scaleChildren.length;i++) {
      scaleChildren[i].setOpacityModifyRGB(this._opacityModifyRGB)
    }
  }
}, isOpacityModifyRGB:function() {
  return this._opacityModifyRGB
}, updateWithBatchNode:function(batchNode, rect, rotated, capInsets) {
  var opacity = this.getOpacity();
  var color = this.getColor();
  this.removeAllChildren(true);
  if(this._scale9Image != batchNode) {
    this._scale9Image = batchNode
  }
  this._scale9Image.removeAllChildren(true);
  this._capInsets = capInsets;
  var selTexture = this._scale9Image.getTexture();
  var rectZero = cc.RectZero();
  if(cc.Rect.CCRectEqualToRect(rect, rectZero)) {
    if(selTexture instanceof cc.Texture2D) {
      var textureSize = selTexture.getContentSize();
      rect = cc.RectMake(0, 0, textureSize.width, textureSize.height)
    }else {
      rect = cc.RectMake(0, 0, selTexture.width, selTexture.height)
    }
  }
  this._spriteRect = rect;
  var rectSize = rect.size;
  this._originalSize = new cc.Size(rectSize.width, rectSize.height);
  this._preferredSize = new cc.Size(rectSize.width, rectSize.height);
  this._capInsetsInternal = capInsets || cc.RectZero();
  var w = rectSize.width;
  var h = rectSize.height;
  if(cc.Rect.CCRectEqualToRect(this._capInsetsInternal, rectZero)) {
    this._capInsetsInternal = cc.rect(w / 3, h / 3, w / 3, h / 3)
  }
  var left_w = this._capInsetsInternal.origin.x;
  var center_w = this._capInsetsInternal.size.width;
  var right_w = w - (left_w + center_w);
  var top_h = this._capInsetsInternal.origin.y;
  var center_h = this._capInsetsInternal.size.height;
  var bottom_h = h - (top_h + center_h);
  var x = 0;
  var y = 0;
  var lefttopbounds = cc.RectMake(x, y, left_w, top_h);
  x += left_w;
  var centertopbounds = cc.RectMake(x, y, center_w, top_h);
  x += center_w;
  var righttopbounds = cc.RectMake(x, y, right_w, top_h);
  x = 0;
  y = 0;
  y += top_h;
  var leftcenterbounds = cc.RectMake(x, y, left_w, center_h);
  x += left_w;
  var centerbounds = cc.RectMake(x, y, center_w, center_h);
  x += center_w;
  var rightcenterbounds = cc.RectMake(x, y, right_w, center_h);
  x = 0;
  y = 0;
  y += top_h;
  y += center_h;
  var leftbottombounds = cc.RectMake(x, y, left_w, bottom_h);
  x += left_w;
  var centerbottombounds = cc.RectMake(x, y, center_w, bottom_h);
  x += center_w;
  var rightbottombounds = cc.RectMake(x, y, right_w, bottom_h);
  if(!rotated) {
    var t = cc.AffineTransformMakeIdentity();
    t = cc.AffineTransformTranslate(t, rect.origin.x, rect.origin.y);
    centerbounds = cc.RectApplyAffineTransform(centerbounds, t);
    rightbottombounds = cc.RectApplyAffineTransform(rightbottombounds, t);
    leftbottombounds = cc.RectApplyAffineTransform(leftbottombounds, t);
    righttopbounds = cc.RectApplyAffineTransform(righttopbounds, t);
    lefttopbounds = cc.RectApplyAffineTransform(lefttopbounds, t);
    rightcenterbounds = cc.RectApplyAffineTransform(rightcenterbounds, t);
    leftcenterbounds = cc.RectApplyAffineTransform(leftcenterbounds, t);
    centerbottombounds = cc.RectApplyAffineTransform(centerbottombounds, t);
    centertopbounds = cc.RectApplyAffineTransform(centertopbounds, t);
    this._centre = new cc.Sprite;
    this._centre.initWithTexture(selTexture, centerbounds);
    this._scale9Image.addChild(this._centre, 0, cc.POSITIONS_CENTRE);
    this._top = new cc.Sprite;
    this._top.initWithTexture(selTexture, centertopbounds);
    this._scale9Image.addChild(this._top, 1, cc.POSITIONS_TOP);
    this._bottom = new cc.Sprite;
    this._bottom.initWithTexture(selTexture, centerbottombounds);
    this._scale9Image.addChild(this._bottom, 1, cc.POSITIONS_BOTTOM);
    this._left = new cc.Sprite;
    this._left.initWithTexture(selTexture, leftcenterbounds);
    this._scale9Image.addChild(this._left, 1, cc.POSITIONS_LEFT);
    this._right = new cc.Sprite;
    this._right.initWithTexture(selTexture, rightcenterbounds);
    this._scale9Image.addChild(this._right, 1, cc.POSITIONS_RIGHT);
    this._topLeft = new cc.Sprite;
    this._topLeft.initWithTexture(selTexture, lefttopbounds);
    this._scale9Image.addChild(this._topLeft, 2, cc.POSITIONS_TOPLEFT);
    this._topRight = new cc.Sprite;
    this._topRight.initWithTexture(selTexture, righttopbounds);
    this._scale9Image.addChild(this._topRight, 2, cc.POSITIONS_TOPRIGHT);
    this._bottomLeft = new cc.Sprite;
    this._bottomLeft.initWithTexture(selTexture, leftbottombounds);
    this._scale9Image.addChild(this._bottomLeft, 2, cc.POSITIONS_BOTTOMLEFT);
    this._bottomRight = new cc.Sprite;
    this._bottomRight.initWithTexture(selTexture, rightbottombounds);
    this._scale9Image.addChild(this._bottomRight, 2, cc.POSITIONS_BOTTOMRIGHT)
  }else {
    var t = cc.AffineTransformMakeIdentity();
    var rotatedcenterbounds = centerbounds;
    var rotatedrightbottombounds = rightbottombounds;
    var rotatedleftbottombounds = leftbottombounds;
    var rotatedrighttopbounds = righttopbounds;
    var rotatedlefttopbounds = lefttopbounds;
    var rotatedrightcenterbounds = rightcenterbounds;
    var rotatedleftcenterbounds = leftcenterbounds;
    var rotatedcenterbottombounds = centerbottombounds;
    var rotatedcentertopbounds = centertopbounds;
    t = cc.AffineTransformTranslate(t, rect.size.height + rect.origin.x, rect.origin.y);
    t = cc.AffineTransformRotate(t, 1.57079633);
    centerbounds = cc.RectApplyAffineTransform(centerbounds, t);
    rightbottombounds = cc.RectApplyAffineTransform(rightbottombounds, t);
    leftbottombounds = cc.RectApplyAffineTransform(leftbottombounds, t);
    righttopbounds = cc.RectApplyAffineTransform(righttopbounds, t);
    lefttopbounds = cc.RectApplyAffineTransform(lefttopbounds, t);
    rightcenterbounds = cc.RectApplyAffineTransform(rightcenterbounds, t);
    leftcenterbounds = cc.RectApplyAffineTransform(leftcenterbounds, t);
    centerbottombounds = cc.RectApplyAffineTransform(centerbottombounds, t);
    centertopbounds = cc.RectApplyAffineTransform(centertopbounds, t);
    rotatedcenterbounds.origin = {x:centerbounds.origin.x, y:centerbounds.origin.y};
    rotatedrightbottombounds.origin = {x:rightbottombounds.origin.x, y:rightbottombounds.origin.y};
    rotatedleftbottombounds.origin = {x:leftbottombounds.origin.x, y:leftbottombounds.origin.y};
    rotatedrighttopbounds.origin = {x:righttopbounds.origin.x, y:righttopbounds.origin.y};
    rotatedlefttopbounds.origin = {x:lefttopbounds.origin.x, y:lefttopbounds.origin.y};
    rotatedrightcenterbounds.origin = {x:rightcenterbounds.origin.x, y:rightcenterbounds.origin.y};
    rotatedleftcenterbounds.origin = {x:leftcenterbounds.origin.x, y:leftcenterbounds.origin.y};
    rotatedcenterbottombounds.origin = {x:centerbottombounds.origin.x, y:centerbottombounds.origin.y};
    rotatedcentertopbounds.origin = {x:centertopbounds.origin.x, y:centertopbounds.origin.y};
    this._centre = new cc.Sprite;
    this._centre.initWithTexture(selTexture, rotatedcenterbounds, true);
    this._scale9Image.addChild(this._centre, 0, cc.POSITIONS_CENTRE);
    this._top = new cc.Sprite;
    this._top.initWithTexture(selTexture, rotatedcentertopbounds, true);
    this._scale9Image.addChild(this._top, 1, cc.POSITIONS_TOP);
    this._bottom = new cc.Sprite;
    this._bottom.initWithTexture(selTexture, rotatedcenterbottombounds, true);
    this._scale9Image.addChild(this._bottom, 1, cc.POSITIONS_BOTTOM);
    this._left = new cc.Sprite;
    this._left.initWithTexture(selTexture, rotatedleftcenterbounds, true);
    this._scale9Image.addChild(this._left, 1, cc.POSITIONS_LEFT);
    this._right = new cc.Sprite;
    this._right.initWithTexture(selTexture, rotatedrightcenterbounds, true);
    this._scale9Image.addChild(this._right, 1, cc.POSITIONS_RIGHT);
    this._topLeft = new cc.Sprite;
    this._topLeft.initWithTexture(selTexture, rotatedlefttopbounds, true);
    this._scale9Image.addChild(this._topLeft, 2, cc.POSITIONS_TOPLEFT);
    this._topRight = new cc.Sprite;
    this._topRight.initWithTexture(selTexture, rotatedrighttopbounds, true);
    this._scale9Image.addChild(this._topRight, 2, cc.POSITIONS_TOPRIGHT);
    this._bottomLeft = new cc.Sprite;
    this._bottomLeft.initWithTexture(selTexture, rotatedleftbottombounds, true);
    this._scale9Image.addChild(this._bottomLeft, 2, cc.POSITIONS_BOTTOMLEFT);
    this._bottomRight = new cc.Sprite;
    this._bottomRight.initWithTexture(selTexture, rotatedrightbottombounds, true);
    this._scale9Image.addChild(this._bottomRight, 2, cc.POSITIONS_BOTTOMRIGHT)
  }
  this.setContentSize(rect.size);
  this.addChild(this._scale9Image);
  if(this._spritesGenerated) {
    this.setOpacity(opacity);
    this.setColor(color)
  }
  this._spritesGenerated = true;
  return true
}, setSpriteFrame:function(spriteFrame) {
  var batchNode = cc.SpriteBatchNode.createWithTexture(spriteFrame.getTexture(), 9);
  this.updateWithBatchNode(batchNode, spriteFrame.getRect(), cc.Browser.supportWebGL ? spriteFrame.isRotated() : false, cc.RectZero());
  this._insetLeft = 0;
  this._insetTop = 0;
  this._insetRight = 0;
  this._insetBottom = 0
}, setColor:function(color) {
  this._color = color;
  var scaleChildren = this._scale9Image.getChildren();
  if(scaleChildren) {
    for(var i = 0;i < scaleChildren.length;i++) {
      scaleChildren[i].setColor(this._color)
    }
  }
}, setOpacity:function(opacity) {
  this._opacity = opacity;
  var scaleChildren = this._scale9Image.getChildren();
  if(scaleChildren) {
    for(var i = 0;i < scaleChildren.length;i++) {
      scaleChildren[i].setOpacity(this._color)
    }
  }
}});
cc.Scale9Sprite.create = function(file, rect, capInsets) {
  var pReturn;
  if(arguments.length === 2) {
    if(typeof file == "string") {
      pReturn = new cc.Scale9Sprite;
      if(pReturn && pReturn.initWithFile(file, rect)) {
        return pReturn
      }
    }else {
      if(file instanceof cc.Rect) {
        pReturn = new cc.Scale9Sprite;
        if(pReturn && pReturn.initWithFile(file, capInsets)) {
          return pReturn
        }
      }
    }
  }else {
    if(arguments.length === 3) {
      pReturn = new cc.Scale9Sprite;
      if(pReturn && pReturn.initWithFile(file, rect, capInsets)) {
        return pReturn
      }
    }else {
      if(arguments.length === 1) {
        pReturn = new cc.Scale9Sprite;
        if(pReturn && pReturn.initWithFile(file)) {
          return pReturn
        }
      }else {
        if(arguments.length === 0) {
          pReturn = new cc.Scale9Sprite;
          if(pReturn && pReturn.init()) {
            return pReturn
          }
        }
      }
    }
  }
  return null
};
cc.Scale9Sprite.createWithSpriteFrame = function(spriteFrame, capInsets) {
  var pReturn = new cc.Scale9Sprite;
  if(pReturn && pReturn.initWithSpriteFrame(spriteFrame, capInsets)) {
    return pReturn
  }
  return null
};
cc.Scale9Sprite.createWithSpriteFrameName = function(spriteFrameName, capInsets) {
  cc.Assert(spriteFrameName != null, "spriteFrameName must be non-NULL");
  var pReturn = new cc.Scale9Sprite;
  if(pReturn && pReturn.initWithSpriteFrameName(spriteFrameName, capInsets)) {
    return pReturn
  }
  return null
};
cc.Spacer = cc.Layer.extend({});
cc.Spacer.verticalSpacer = function(space) {
  var pRet = new cc.Spacer;
  pRet.init();
  pRet.setContentSize(cc.SizeMake(0, space));
  return pRet
};
cc.Spacer.horizontalSpacer = function(space) {
  var pRet = new cc.Spacer;
  pRet.init();
  pRet.setContentSize(cc.SizeMake(space, 0));
  return pRet
};
cc.MenuPassive = cc.Layer.extend({RGBAProtocol:true, _color:null, _opacity:0, ctor:function() {
}, getColor:function() {
  return this._color
}, setColor:function(color) {
  this._color = color;
  if(this._children && this._children.length > 0) {
    for(var i = 0;i < this._children.length;i++) {
      if(this._children[i] && this._children[i].RGBAProtocol) {
        this._children[i].setColor(color)
      }
    }
  }
}, getOpacity:function() {
  return this._opacity
}, setOpacity:function(opacity) {
  this._opacity = opacity;
  if(this._children && this._children.length > 0) {
    for(var i = 0;i < this._children.length;i++) {
      if(this._children[i] && this._children[i].RGBAProtocol) {
        this._children[i].setOpacity(opacity)
      }
    }
  }
}, initWithItems:function(item, args) {
  if(this.init()) {
    var winSize = cc.Director.getInstance().getWinSize();
    this.ignoreAnchorPointForPosition(true);
    this.setAnchorPoint(cc.p(0.5, 0.5));
    this.setContentSize(winSize);
    this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
    var z = 0;
    if(item) {
      this.addChild(item, z);
      for(var i = 0;i < args.length;i++) {
        if(args[i]) {
          z++;
          this.addChild(args[i], z)
        }
      }
    }
    return true
  }
  return false
}, alignItemsVertically:function() {
  this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
}, alignItemsVerticallyWithPadding:function(padding) {
  var height = -padding;
  var i;
  if(this._children && this._children.length > 0) {
    for(i = 0;i < this._children.length;i++) {
      if(this._children[i]) {
        height += this._children[i].getContentSize().height * this._children[i].getScaleY() + padding
      }
    }
  }
  var width = 0;
  var y = height / 2;
  if(this._children && this._children.length > 0) {
    for(i = 0;i < this._children.length;i++) {
      if(this._children[i]) {
        width = Math.max(width, this._children[i].getContentSize().width);
        this._children[i].setPosition(cc.p(0, y - this._children[i].getContentSize().height * this._children[i].getScaleY() / 2));
        y -= this._children[i].getContentSize().height * this._children[i].getScaleY() + padding
      }
    }
  }
  this.setContentSize(cc.SizeMake(width, height))
}, alignItemsHorizontally:function() {
  this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
}, alignItemsHorizontallyWithPadding:function(padding) {
  var width = -padding;
  var i;
  if(this._children && this._children.length > 0) {
    for(i = 0;i < this._children.length;i++) {
      if(this._children[i]) {
        width += this._children[i].getContentSize().width * this._children[i].getScaleX() + padding
      }
    }
  }
  var height = 0;
  var x = -width / 2;
  if(this._children && this._children.length > 0) {
    for(i = 0;i < this._children.length;i++) {
      if(this._children[i]) {
        height = Math.max(height, this._children[i].getContentSize().height);
        this._children[i].setPosition(cc.p(x + this._children[i].getContentSize().width * this._children[i].getScaleX() / 2, 0));
        x += this._children[i].getContentSize().width * this._children[i].getScaleX() + padding
      }
    }
  }
  this.setContentSize(cc.SizeMake(width, height))
}, alignItemsInColumns:function(columns) {
  var rows = [];
  var i;
  for(i = 1;i < arguments.length;i++) {
    rows.push(arguments[i])
  }
  var height = -5;
  var row = 0;
  var rowHeight = 0;
  var columnsOccupied = 0;
  var rowColumns;
  var tmp;
  if(this._children && this._children.length > 0) {
    for(i = 0;i < this._children.length;i++) {
      if(this._children[i]) {
        cc.Assert(row < rows.size(), "");
        rowColumns = rows[row];
        cc.Assert(rowColumns, "");
        tmp = this._children[i].getContentSize().height;
        rowHeight = 0 | (rowHeight >= tmp || tmp == null ? rowHeight : tmp);
        ++columnsOccupied;
        if(columnsOccupied >= rowColumns) {
          height += rowHeight + 5;
          columnsOccupied = 0;
          rowHeight = 0;
          ++row
        }
      }
    }
  }
  cc.Assert(!columnsOccupied, "");
  var winSize = cc.Director.getInstance().getWinSize();
  row = 0;
  rowHeight = 0;
  rowColumns = 0;
  var w = 0;
  var x = 0;
  var y = height / 2;
  if(this._children && this._children.length > 0) {
    for(i = 0;i < this._children.length;i++) {
      if(this._children[i]) {
        if(rowColumns == 0) {
          rowColumns = rows[row];
          w = winSize.width / (1 + rowColumns);
          x = w
        }
        tmp = this._children[i].getContentSize().height;
        rowHeight = 0 | (rowHeight >= tmp || tmp == null ? rowHeight : tmp);
        this._children[i].setPosition(cc.p(x - winSize.width / 2, y - this._children[i].getContentSize().height / 2));
        x += w;
        ++columnsOccupied;
        if(columnsOccupied >= rowColumns) {
          y -= rowHeight + 5;
          columnsOccupied = 0;
          rowColumns = 0;
          rowHeight = 0;
          ++row
        }
      }
    }
  }
}, alignItemsInRows:function(rows) {
  var columns = [];
  var i;
  for(i = 1;i < arguments.length;i++) {
    columns.push(arguments[i])
  }
  var columnWidths = [];
  var columnHeights = [];
  var width = -10;
  var columnHeight = -5;
  var column = 0;
  var columnWidth = 0;
  var rowsOccupied = 0;
  var columnRows;
  var tmp;
  if(this._children && this._children.length > 0) {
    for(i = 0;i < this._children.length;i++) {
      if(this._children[i]) {
        cc.Assert(column < columns.size(), "");
        columnRows = columns[column];
        cc.Assert(columnRows, "");
        tmp = this._children[i].getContentSize().width;
        columnWidth = 0 | (columnWidth >= tmp || tmp == null ? columnWidth : tmp);
        columnHeight += 0 | this._children[i].getContentSize().height + 5;
        ++rowsOccupied;
        if(rowsOccupied >= columnRows) {
          columnWidths.push(columnWidth);
          columnHeights.push(columnHeight);
          width += columnWidth + 10;
          rowsOccupied = 0;
          columnWidth = 0;
          columnHeight = -5;
          ++column
        }
      }
    }
  }
  cc.Assert(!rowsOccupied, "");
  var winSize = cc.Director.getInstance().getWinSize();
  column = 0;
  columnWidth = 0;
  columnRows = null;
  var x = -width / 2;
  var y = 0;
  if(this._children && this._children.length > 0) {
    for(i = 0;i < this._children.length;i++) {
      if(this._children[i]) {
        if(columnRows == null) {
          columnRows = columns[column];
          y = columnHeights[column]
        }
        tmp = this._children[i].getContentSize().width;
        columnWidth = 0 | (columnWidth >= tmp || tmp == null ? columnWidth : tmp);
        this._children[i].setPosition(cc.p(x + columnWidths[column] / 2, y - winSize.height / 2));
        y -= this._children[i].getContentSize().height + 10;
        ++rowsOccupied;
        if(rowsOccupied >= columnRows) {
          x += columnWidth + 5;
          rowsOccupied = 0;
          columnRows = 0;
          columnWidth = 0;
          ++column
        }
      }
    }
  }
}, setOpacityModifyRGB:function(bValue) {
}, isOpacityModifyRGB:function() {
  return false
}});
cc.MenuPassive.create = function(item) {
  if(arguments.length == 0) {
    item = null
  }
  var argArr = [];
  for(var i = 1;i < arguments.length;i++) {
    argArr.push(arguments[i])
  }
  var pRet = new cc.MenuPassive;
  if(pRet && pRet.initWithItems(item, argArr)) {
    return pRet
  }
  return null
};
cc.MenuPassive.createWithItem = function(item) {
  return cc.MenuPassive.create(item, null)
};
cc.ControlSaturationBrightnessPicker = cc.Control.extend({_saturation:0, _brightness:0, _background:null, _overlay:null, _shadow:null, _slider:null, _startPos:null, _boxPos:0, _boxSize:0, getSaturation:function() {
  return this._saturation
}, getBrightness:function() {
  return this._brightness
}, getBackground:function() {
  return this._background
}, getOverlay:function() {
  return this._brightness
}, getShadow:function() {
  return this._shadow
}, getSlider:function() {
  return this._slider
}, getStartPos:function() {
  return this._startPos
}, initWithTargetAndPos:function(target, pos) {
  if(this.init()) {
    this.setTouchEnabled(true);
    this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerBackground.png", target, pos, cc.p(0, 0));
    this._overlay = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerOverlay.png", target, pos, cc.p(0, 0));
    this._shadow = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerShadow.png", target, pos, cc.p(0, 0));
    this._slider = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPicker.png", target, pos, cc.p(0.5, 0.5));
    this._startPos = pos;
    this._boxPos = 35;
    this._boxSize = 150;
    return true
  }else {
    return false
  }
}, updateWithHSV:function(hsv) {
  var hsvTemp = new cc.HSV;
  hsvTemp.s = 1;
  hsvTemp.h = hsv.h;
  hsvTemp.v = 1;
  var rgb = cc.ControlUtils.RGBfromHSV(hsvTemp);
  this._background.setColor(cc.c3(0 | rgb.r * 255, 0 | rgb.g * 255, 0 | rgb.b * 255))
}, updateDraggerWithHSV:function(hsv) {
  var pos = cc.PointMake(this._startPos.x + this._boxPos + this._boxSize * (1 - hsv.s), this._startPos.y + this._boxPos + this._boxSize * hsv.v);
  this._updateSliderPosition(pos)
}, _updateSliderPosition:function(sliderPosition) {
  var centerX = this._startPos.x + this._background.getBoundingBox().size.width * 0.5;
  var centerY = this._startPos.y + this._background.getBoundingBox().size.height * 0.5;
  var dx = sliderPosition.x - centerX;
  var dy = sliderPosition.y - centerY;
  var dist = Math.sqrt(dx * dx + dy * dy);
  var angle = Math.atan2(dy, dx);
  var limit = this._background.getBoundingBox().size.width * 0.5;
  if(dist > limit) {
    sliderPosition.x = centerX + limit * Math.cos(angle);
    sliderPosition.y = centerY + limit * Math.sin(angle)
  }
  this._slider.setPosition(sliderPosition);
  if(sliderPosition.x < this._startPos.x + this._boxPos) {
    sliderPosition.x = this._startPos.x + this._boxPos
  }else {
    if(sliderPosition.x > this._startPos.x + this._boxPos + this._boxSize - 1) {
      sliderPosition.x = this._startPos.x + this._boxPos + this._boxSize - 1
    }
  }
  if(sliderPosition.y < this._startPos.y + this._boxPos) {
    sliderPosition.y = this._startPos.y + this._boxPos
  }else {
    if(sliderPosition.y > this._startPos.y + this._boxPos + this._boxSize) {
      sliderPosition.y = this._startPos.y + this._boxPos + this._boxSize
    }
  }
  this._saturation = 1 - Math.abs((this._startPos.x + this._boxPos - sliderPosition.x) / this._boxSize);
  this._brightness = Math.abs((this._startPos.y + this._boxPos - sliderPosition.y) / this._boxSize)
}, _checkSliderPosition:function(location) {
  var centerX = this._startPos.x + this._background.getBoundingBox().size.width * 0.5;
  var centerY = this._startPos.y + this._background.getBoundingBox().size.height * 0.5;
  var dx = location.x - centerX;
  var dy = location.y - centerY;
  var dist = Math.sqrt(dx * dx + dy * dy);
  if(dist <= this._background.getBoundingBox().size.width * 0.5) {
    this._updateSliderPosition(location);
    this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED);
    return true
  }
  return false
}, onTouchBegan:function(touch, event) {
  var touchLocation = this.getTouchLocation(touch);
  return this._checkSliderPosition(touchLocation)
}, onTouchMoved:function(touch, event) {
  var touchLocation = this.getTouchLocation(touch);
  this._updateSliderPosition(touchLocation);
  this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
}});
cc.ControlSaturationBrightnessPicker.create = function(target, pos) {
  var pRet = new cc.ControlSaturationBrightnessPicker;
  pRet.initWithTargetAndPos(target, pos);
  return pRet
};
cc.ControlHuePicker = cc.Control.extend({_hue:0, _huePercentage:0, _background:null, _slider:null, _startPos:null, getHue:function() {
  return this._hue
}, setHue:function(hueValue) {
  m_hue = hueValue;
  this.setHuePercentage(m_hue / 360)
}, getHuePercentage:function() {
  return this._huePercentage
}, setHuePercentage:function(hueValueInPercent) {
  this._huePercentage = hueValueInPercent;
  this._hue = this._huePercentage * 360;
  var backgroundBox = this._background.getBoundingBox();
  var centerX = this._startPos.x + backgroundBox.size.width * 0.5;
  var centerY = this._startPos.y + backgroundBox.size.height * 0.5;
  var limit = backgroundBox.size.width * 0.5 - 15;
  var angleDeg = this._huePercentage * 360 - 180;
  var angle = cc.DEGREES_TO_RADIANS(angleDeg);
  var x = centerX + limit * Math.cos(angle);
  var y = centerY + limit * Math.sin(angle);
  this._slider.setPosition(cc.p(x, y))
}, getBackground:function() {
  return this._background
}, getSlider:function() {
  return this._slider
}, getStartPos:function() {
  return this._startPos
}, initWithTargetAndPos:function(target, pos) {
  if(this.init()) {
    this.setTouchEnabled(true);
    this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("huePickerBackground.png", target, pos, cc.p(0, 0));
    this._slider = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPicker.png", target, pos, cc.p(0.5, 0.5));
    this._slider.setPosition(cc.p(pos.x, pos.y + this._background.getBoundingBox().size.height * 0.5));
    this._startPos = pos;
    this._hue = 0;
    this._huePercentage = 0;
    return true
  }else {
    return false
  }
}, _updateSliderPosition:function(location) {
  var backgroundBox = this._background.getBoundingBox();
  var centerX = this._startPos.x + backgroundBox.size.width * 0.5;
  var centerY = this._startPos.y + backgroundBox.size.height * 0.5;
  var dx = location.x - centerX;
  var dy = location.y - centerY;
  var angle = Math.atan2(dy, dx);
  var angleDeg = cc.RADIANS_TO_DEGREES(angle) + 180;
  this.setHue(angleDeg);
  this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
}, _checkSliderPosition:function(location) {
  if(cc.Rect.CCRectContainsPoint(this._background.getBoundingBox(), location)) {
    this._updateSliderPosition(location);
    return true
  }
  return false
}, onTouchBegan:function(touch, event) {
  var touchLocation = this.getTouchLocation(touch);
  return this._checkSliderPosition(touchLocation)
}, onTouchMoved:function(touch, event) {
  var touchLocation = this.getTouchLocation(touch);
  this._updateSliderPosition(touchLocation);
  this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
}});
cc.ControlHuePicker.create = function(target, pos) {
  var pRet = new cc.ControlHuePicker;
  pRet.initWithTargetAndPos(target, pos);
  return pRet
};
cc.ControlColourPicker = cc.Control.extend({_colorValue:null, _hsv:null, _colourPicker:null, _huePicker:null, _background:null, hueSliderValueChanged:function(sender, controlEvent) {
  this._hsv.h = sender.getHue();
  var rgb = cc.ControlUtils.RGBfromHSV(this._hsv);
  this._colorValue = cc.c3(0 | rgb.r * 255, 0 | rgb.g * 255, 0 | rgb.b * 255);
  this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED);
  this._updateControlPicker()
}, colourSliderValueChanged:function(sender, controlEvent) {
  this._hsv.s = sender.getSaturation();
  this._hsv.v = sender.getBrightness();
  var rgb = cc.ControlUtils.RGBfromHSV(this._hsv);
  this._colorValue = cc.c3(0 | rgb.r * 255, 0 | rgb.g * 255, 0 | rgb.b * 255);
  this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
}, getColorValue:function() {
  return this._colorValue
}, setColorValue:function(colorValue) {
  this._colorValue = colorValue;
  var rgba = new cc.RGBA;
  rgba.r = colorValue.r / 255;
  rgba.g = colorValue.g / 255;
  rgba.b = colorValue.b / 255;
  rgba.a = 1;
  this._hsv = cc.ControlUtils.HSVfromRGB(rgba);
  this._updateHueAndControlPicker()
}, getBackground:function() {
  return this._background
}, init:function() {
  if(this._super()) {
    this.setTouchEnabled(true);
    cc.SpriteFrameCache.getInstance().addSpriteFrames("extensions/CCControlColourPickerSpriteSheet.plist");
    var spriteSheet = cc.SpriteBatchNode.create("extensions/CCControlColourPickerSpriteSheet.png");
    this.addChild(spriteSheet);
    var params = [GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR, GL_REPEAT, GL_REPEAT];
    spriteSheet.getTexture().setAliasTexParameters();
    spriteSheet.getTexture().setTexParameters(params);
    spriteSheet.getTexture().generateMipmap();
    this._hsv.h = 0;
    this._hsv.s = 0;
    this._hsv.v = 0;
    this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("menuColourPanelBackground.png", spriteSheet, cc.PointZero, cc.p(0.5, 0.5));
    var backgroundPointZero = cc.pSub(this._background.getPosition(), cc.p(this._background.getContentSize().width / 2, this._background.getContentSize().height / 2));
    var hueShift = 8;
    var colourShift = 28;
    this._huePicker = cc.ControlHuePicker.create(spriteSheet, cc.p(backgroundPointZero.x + hueShift, backgroundPointZero.y + hueShift));
    this._colourPicker = cc.ControlSaturationBrightnessPicker.create(spriteSheet, cc.p(backgroundPointZero.x + colourShift, backgroundPointZero.y + colourShift));
    this._huePicker.addTargetWithActionForControlEvents(this, this.hueSliderValueChanged, cc.CONTROL_EVENT_VALUECHANGED);
    this._colourPicker.addTargetWithActionForControlEvents(this, this.colourSliderValueChanged, cc.CONTROL_EVENT_VALUECHANGED);
    this._updateHueAndControlPicker();
    this.addChild(this._huePicker);
    this.addChild(this._colourPicker);
    this.setContentSize(this._background.getContentSize());
    return true
  }else {
    return false
  }
}, _updateControlPicker:function() {
  this._huePicker.setHue(this._hsv.h);
  this._colourPicker.updateWithHSV(this._hsv)
}, _updateHueAndControlPicker:function() {
  this._huePicker.setHue(this._hsv.h);
  this._colourPicker.updateWithHSV(this._hsv);
  this._colourPicker.updateDraggerWithHSV(this._hsv)
}, onTouchBegan:function() {
  return false
}});
cc.ControlColourPicker.create = function() {
  var pRet = new cc.ControlColourPicker;
  pRet.init();
  return pRet
};
cc.SLIDER_MARGIN_H = 24;
cc.SLIDER_MARGIN_V = 8;
cc.ControlSlider = cc.Control.extend({_value:0, _minimumValue:0, _maximumValue:0, _minimumAllowedValue:0, _maximumAllowedValue:0, _snappingInterval:0, _thumbItem:null, _progressSprite:null, _backgroundSprite:null, getValue:function() {
  return this._value
}, setValue:function(value) {
  value = Math.max(value, this._minimumValue);
  value = Math.min(value, this._maximumValue);
  if(this._snappingInterval >= 0) {
    value = Math.floor(0.5 + value / this._snappingInterval) * this._snappingInterval
  }
  this._value = value;
  var percent = (this._value - this._minimumValue) / (this._maximumValue - this._minimumValue);
  var pos = this._thumbItem.getPosition();
  pos.x = percent * this._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H;
  this._thumbItem.setPosition(pos);
  var textureRect = this._progressSprite.getTextureRect();
  textureRect = cc.RectMake(textureRect.origin.x, textureRect.origin.y, percent * this._backgroundSprite.getContentSize().width, textureRect.size.height);
  this._progressSprite.setTextureRect(textureRect, this._progressSprite.isTextureRectRotated(), textureRect.size);
  this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
}, getMinimumValue:function() {
  return this._minimumValue
}, setMinimumValue:function(minimumValue) {
  this._minimumValue = minimumValue;
  this._minimumAllowedValue = minimumValue;
  if(this._minimumValue >= this._maximumValue) {
    this._maximumValue = this._minimumValue + 1
  }
  this.setValue(this._value)
}, getMaximumValue:function() {
  return this._maximumValue
}, setMaximumValue:function(maximumValue) {
  this._maximumValue = maximumValue;
  this._maximumAllowedValue = maximumValue;
  if(this._maximumValue <= this._minimumValue) {
    this._minimumValue = this._maximumValue - 1
  }
  this.setValue(this._value)
}, getMinimumAllowedValue:function() {
  return this._minimumAllowedValue
}, setMinimumAllowedValue:function(val) {
  this._minimumAllowedValue = val
}, getMaximumAllowedValue:function() {
  return this._maximumAllowedValue
}, setMaximumAllowedValue:function(val) {
  this._maximumAllowedValue = val
}, getSnappingInterval:function() {
  return this._snappingInterval
}, setSnappingInterval:function(val) {
  this._snappingInterval = val
}, getThumbItem:function() {
  return this._thumbItem
}, getProgressSprite:function() {
  return this._progressSprite
}, getBackgroundSprite:function() {
  return this._backgroundSprite
}, initWithSprites:function(backgroundSprite, progressSprite, thumbItem) {
  if(this.init()) {
    this.ignoreAnchorPointForPosition(false);
    this.setTouchEnabled(true);
    this._backgroundSprite = backgroundSprite;
    this._progressSprite = progressSprite;
    this._thumbItem = thumbItem;
    var maxRect = cc.ControlUtils.CCRectUnion(backgroundSprite.getBoundingBox(), thumbItem.getBoundingBox());
    var size = cc.SizeMake(maxRect.size.width + 2 * cc.SLIDER_MARGIN_H, maxRect.size.height + 2 * cc.SLIDER_MARGIN_V);
    this.setContentSize(size);
    this._backgroundSprite.setAnchorPoint(cc.p(0.5, 0.5));
    this._backgroundSprite.setPosition(cc.p(size.width / 2, size.height / 2));
    this.addChild(this._backgroundSprite);
    this._progressSprite.setAnchorPoint(cc.p(0, 0.5));
    this._progressSprite.setPosition(cc.p(0 + cc.SLIDER_MARGIN_H, size.height / 2));
    this.addChild(this._progressSprite);
    this._thumbItem.setPosition(cc.p(0 + cc.SLIDER_MARGIN_H, size.height / 2));
    this.addChild(this._thumbItem);
    this._minimumValue = 0;
    this._maximumValue = 1;
    this._snappingInterval = -1;
    this.setValue(this._minimumValue);
    return true
  }else {
    return false
  }
}, sliderBegan:function(location) {
  this._thumbItem.selected();
  this.setValue(this.valueForLocation(location))
}, sliderMoved:function(location) {
  this.setValue(this.valueForLocation(location))
}, sliderEnded:function(location) {
  if(this._thumbItem.isSelected()) {
    this._thumbItem.unselected();
    this.setValue(this.valueForLocation(this._thumbItem.getPosition()))
  }
}, getTouchLocationInControl:function(touch) {
  var touchLocation = touch.getLocation();
  touchLocation = this.convertToNodeSpace(touchLocation);
  if(touchLocation.x < 0) {
    touchLocation.x = 0
  }else {
    if(touchLocation.x > this._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H) {
      touchLocation.x = this._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H
    }
  }
  return touchLocation
}, onTouchBegan:function(touch, event) {
  if(!this.isTouchInside(touch)) {
    return false
  }
  var location = this.getTouchLocationInControl(touch);
  this.sliderBegan(location);
  return true
}, onTouchMoved:function(touch, event) {
  var location = this.getTouchLocationInControl(touch);
  this.sliderMoved(location)
}, onTouchEnded:function(touch, event) {
  this.sliderEnded(cc.PointZero())
}, valueForLocation:function(location) {
  var percent = (location.x - cc.SLIDER_MARGIN_H) / this._backgroundSprite.getContentSize().width;
  return Math.max(Math.min(this._minimumValue + percent * (this._maximumValue - this._minimumValue), this._maximumAllowedValue), this._minimumAllowedValue)
}});
cc.ControlSlider.create = function(bgFile, progressFile, thumbFile) {
  if(typeof bgFile == "string") {
    bgFile = cc.Sprite.create(bgFile);
    progressFile = cc.Sprite.create(progressFile);
    var thumbNormal = cc.Sprite.create(thumbFile);
    var thumbSelected = cc.Sprite.create(thumbFile);
    thumbSelected.setColor(cc.gray());
    thumbFile = cc.MenuItemSprite.create(thumbNormal, thumbSelected)
  }
  var pRet = new cc.ControlSlider;
  pRet.initWithSprites(bgFile, progressFile, thumbFile);
  return pRet
};
cc.ControlSwitch = cc.Control.extend({_switchSprite:null, _initialTouchXPosition:0, _moved:false, _on:false, ctor:function() {
}, initWithMaskSprite:function(maskSprite, onSprite, offSprite, thumbSprite, onLabel, offLabel) {
  if(this.init()) {
    cc.Assert(maskSprite, "Mask must not be nil.");
    cc.Assert(onSprite, "onSprite must not be nil.");
    cc.Assert(offSprite, "offSprite must not be nil.");
    cc.Assert(thumbSprite, "thumbSprite must not be nil.");
    this.setTouchEnabled(true);
    this._on = true;
    this._switchSprite = new cc.ControlSwitchSprite;
    this._switchSprite.initWithMaskSprite(maskSprite, onSprite, offSprite, thumbSprite, onLabel, offLabel);
    this._switchSprite.setPosition(cc.p(this._switchSprite.getContentSize().width / 2, this._switchSprite.getContentSize().height / 2));
    this.addChild(this._switchSprite);
    this.ignoreAnchorPointForPosition(false);
    this.setAnchorPoint(cc.p(0.5, 0.5));
    this.setContentSize(this._switchSprite.getContentSize());
    return true
  }
  return false
}, setOn:function(isOn, animated) {
  animated = animated || false;
  this._on = isOn;
  this._switchSprite.runAction(cc.ActionTween.create(0.2, "sliderXPosition", this._switchSprite.getSliderXPosition(), this._on ? this._switchSprite.getOnPosition() : this._switchSprite.getOffPosition()));
  this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
}, isOn:function() {
  return this._on
}, hasMoved:function() {
  return this._moved
}, setEnabled:function(enabled) {
  this._enabled = enabled;
  this._switchSprite.setOpacity(enabled ? 255 : 128)
}, locationFromTouch:function(touch) {
  var touchLocation = touch.getLocation();
  touchLocation = this.convertToNodeSpace(touchLocation);
  return touchLocation
}, onTouchBegan:function(touch, event) {
  if(!this.isTouchInside(touch) || !this.isEnabled()) {
    return false
  }
  this._moved = false;
  var location = this.locationFromTouch(touch);
  this._initialTouchXPosition = location.x - this._switchSprite.getSliderXPosition();
  this._switchSprite.getThumbSprite().setColor(cc.gray());
  this._switchSprite.needsLayout();
  return true
}, onTouchMoved:function(touch, event) {
  var location = this.locationFromTouch(touch);
  location = cc.p(location.x - this._initialTouchXPosition, 0);
  this._moved = true;
  this._switchSprite.setSliderXPosition(location.x)
}, onTouchEnded:function(touch, event) {
  var location = this.locationFromTouch(touch);
  this._switchSprite.getThumbSprite().setColor(cc.white());
  if(this.hasMoved()) {
    this.setOn(!(location.x < this._switchSprite.getContentSize().width / 2), true)
  }else {
    this.setOn(!this._on, true)
  }
}, onTouchCancelled:function(touch, event) {
  var location = this.locationFromTouch(touch);
  this._switchSprite.getThumbSprite().setColor(cc.white());
  if(this.hasMoved()) {
    this.setOn(!(location.x < this._switchSprite.getContentSize().width / 2), true)
  }else {
    this.setOn(!this._on, true)
  }
}});
cc.ControlSwitch.create = function(maskSprite, onSprite, offSprite, thumbSprite, onLabel, offLabel) {
  var pRet = new cc.ControlSwitch;
  if(pRet && pRet.initWithMaskSprite(maskSprite, onSprite, offSprite, thumbSprite, onLabel, offLabel)) {
    return pRet
  }
  return null
};
cc.ControlSwitchSprite = cc.Sprite.extend({_sliderXPosition:0, _onPosition:0, _offPosition:0, _maskTexture:null, _textureLocation:0, _maskLocation:0, _onSprite:null, _offSprite:null, _thumbSprite:null, _onLabel:null, _offLabel:null, ctor:function() {
}, initWithMaskSprite:function(maskSprite, onSprite, offSprite, thumbSprite, onLabel, offLabel) {
  if(this.initWithTexture(maskSprite.getTexture())) {
    this._onPosition = 0;
    this._offPosition = -onSprite.getContentSize().width + thumbSprite.getContentSize().width / 2;
    this._sliderXPosition = this._onPosition;
    this.setOnSprite(onSprite);
    this.setOffSprite(offSprite);
    this.setThumbSprite(thumbSprite);
    this.setOnLabel(onLabel);
    this.setOffLabel(offLabel);
    this.addChild(this._thumbSprite);
    this.setMaskTexture(maskSprite.getTexture());
    this.setContentSize(this._maskTexture.getContentSize());
    this.needsLayout();
    return true
  }
  return false
}, draw:function() {
  cc.NODE_DRAW_SETUP()
}, needsLayout:function() {
  this._onSprite.setPosition(cc.p(this._onSprite.getContentSize().width / 2 + this._sliderXPosition, this._onSprite.getContentSize().height / 2));
  this._offSprite.setPosition(cc.p(this._onSprite.getContentSize().width + this._offSprite.getContentSize().width / 2 + this._sliderXPosition, this._offSprite.getContentSize().height / 2));
  this._thumbSprite.setPosition(cc.p(this._onSprite.getContentSize().width + this._sliderXPosition, this._maskTexture.getContentSize().height / 2));
  if(this._onLabel) {
    this._onLabel.setPosition(cc.p(this._onSprite.getPosition().x - this._thumbSprite.getContentSize().width / 6, this._onSprite.getContentSize().height / 2))
  }
  if(this._offLabel) {
    this._offLabel.setPosition(cc.p(this._offSprite.getPosition().x + this._thumbSprite.getContentSize().width / 6, this._offSprite.getContentSize().height / 2))
  }
  var rt = cc.RenderTexture.create(this._maskTexture.getContentSize().width, this._maskTexture.getContentSize().height);
  rt.begin();
  this._onSprite.visit();
  this._offSprite.visit();
  if(this._onLabel) {
    this._onLabel.visit()
  }
  if(this._offLabel) {
    this._offLabel.visit()
  }
  rt.end();
  this.setTexture(rt.getSprite().getTexture());
  this.setFlipY(true)
}, setSliderXPosition:function(sliderXPosition) {
  if(sliderXPosition <= this._offPosition) {
    sliderXPosition = this._offPosition
  }else {
    if(sliderXPosition >= this._onPosition) {
      sliderXPosition = this._onPosition
    }
  }
  this._sliderXPosition = sliderXPosition;
  this.needsLayout()
}, getSliderXPosition:function() {
  return this._sliderXPosition
}, onSideWidth:function() {
  return this._onSprite.getContentSize().width
}, offSideWidth:function() {
  return this._offSprite.getContentSize().height
}, updateTweenAction:function(value, key) {
  cc.log("key = " + key + ", value = " + value);
  this.setSliderXPosition(value)
}, setOnPosition:function(onPosition) {
  this._onPosition = onPosition
}, getOnPosition:function() {
  return this._onPosition
}, setOffPosition:function(offPosition) {
  this._offPosition = offPosition
}, getOffPosition:function() {
  return this._offPosition
}, setMaskTexture:function(maskTexture) {
  this._maskTexture = maskTexture
}, getMaskTexture:function() {
  return this._maskTexture
}, setTextureLocation:function(textureLocation) {
  this._textureLocation = textureLocation
}, getTextureLocation:function() {
  return this._textureLocation
}, setMaskLocation:function(maskLocation) {
  this._maskLocation = maskLocation
}, getMaskLocation:function() {
  return this._maskLocation
}, setOnSprite:function(onSprite) {
  this._onSprite = onSprite
}, getOnSprite:function() {
  return this._onSprite
}, setOffSprite:function(offSprite) {
  this._offSprite = offSprite
}, getOffSprite:function() {
  return this._offSprite
}, setThumbSprite:function(thumbSprite) {
  this._thumbSprite = thumbSprite
}, getThumbSprite:function() {
  return this._thumbSprite
}, setOnLabel:function(onLabel) {
  this._onLabel = onLabel
}, getOnLabel:function() {
  return this._onLabel
}, setOffLabel:function(offLabel) {
  this._offLabel = offLabel
}, getOffLabel:function() {
  return this._offLabel
}});
cc.SCROLLVIEW_DIRECTION_NONE = -1;
cc.SCROLLVIEW_DIRECTION_HORIZONTAL = 0;
cc.SCROLLVIEW_DIRECTION_VERTICAL = 1;
cc.SCROLLVIEW_DIRECTION_BOTH = 2;
var SCROLL_DEACCEL_RATE = 0.95;
var SCROLL_DEACCEL_DIST = 1;
var BOUNCE_DURATION = 0.15;
var INSET_RATIO = 0.2;
cc.ScrollViewDelegate = cc.Class.extend({scrollViewDidScroll:function(view) {
}, scrollViewDidZoom:function(view) {
}});
cc.ScrollView = cc.Layer.extend({_zoomScale:0, _minZoomScale:0, _maxZoomScale:0, _delegate:null, _direction:cc.SCROLLVIEW_DIRECTION_BOTH, _dragging:false, _contentOffset:null, _container:null, _touchMoved:false, _maxInset:null, _minInset:null, _bounceable:false, _clippingToBounds:false, _scrollDistance:null, _touchPoint:null, _touchLength:0, _touches:null, _viewSize:null, _minScale:0, _maxScale:0, ctor:function() {
  this._super();
  this._maxInset = new cc.Point(0, 0);
  this._minInset = new cc.Point(0, 0);
  this._scrollDistance = new cc.Point(0, 0);
  this._touchPoint = new cc.Point(0, 0);
  this._touches = [];
  this._viewSize = new cc.Size(0, 0);
  this._isTouched = false
}, init:function(isDirectCall) {
  if(isDirectCall != null && isDirectCall == true) {
    return this._super()
  }
  return this.initWithViewSize(cc.SizeMake(200, 200), null)
}, registerWithTouchDispatcher:function() {
  cc.Director.getInstance().getTouchDispatcher().addTargetedDelegate(this, 0, false)
}, initWithViewSize:function(size, container) {
  if(cc.Layer.prototype.init.call(this)) {
    this._container = container;
    if(!this._container) {
      this._container = cc.Layer.create();
      this._container.ignoreAnchorPointForPosition(false);
      this._container.setAnchorPoint(cc.p(0, 0))
    }
    this.setViewSize(size);
    this.setTouchEnabled(true);
    this._touches = [];
    this._delegate = null;
    this._bounceable = true;
    this._clippingToBounds = true;
    this._direction = cc.SCROLLVIEW_DIRECTION_BOTH;
    this._container.setPosition(cc.p(0, 0));
    this._touchLength = 0;
    this.addChild(this._container);
    this._minScale = this._maxScale = 1;
    return true
  }
  return false
}, setContentOffset:function(offset, animated) {
  if(animated) {
    this.setContentOffsetInDuration(offset, BOUNCE_DURATION)
  }else {
    if(!this._bounceable) {
      var minOffset = this.minContainerOffset();
      var maxOffset = this.maxContainerOffset();
      offset.x = Math.max(minOffset.x, Math.min(maxOffset.x, offset.x));
      offset.y = Math.max(minOffset.y, Math.min(maxOffset.y, offset.y))
    }
    this._container.setPosition(offset);
    if(this._delegate != null && this._delegate.scrollViewDidScroll) {
      this._delegate.scrollViewDidScroll(this)
    }
  }
}, getContentOffset:function() {
  return this._container.getPosition()
}, setContentOffsetInDuration:function(offset, dt) {
  var scroll = cc.MoveTo.create(dt, offset);
  var expire = cc.CallFunc.create(this._stoppedAnimatedScroll, this);
  this._container.runAction(cc.Sequence.create(scroll, expire));
  this.schedule(this._performedAnimatedScroll)
}, setZoomScale:function(scale, animated) {
  if(arguments.length === 1) {
    if(this._container.getScale() != scale) {
      var oldCenter, newCenter;
      var center;
      if(this._touchLength == 0) {
        center = cc.p(this._viewSize.width * 0.5, this._viewSize.height * 0.5);
        center = this.convertToWorldSpace(center)
      }else {
        center = this._touchPoint
      }
      oldCenter = this._container.convertToNodeSpace(center);
      this._container.setScale(Math.max(this._minScale, Math.min(this._maxScale, scale)));
      newCenter = this._container.convertToWorldSpace(oldCenter);
      var offset = cc.pSub(center, newCenter);
      if(this._delegate != null) {
        this._delegate.scrollViewDidZoom(this)
      }
      this.setContentOffset(cc.pAdd(this._container.getPosition(), offset))
    }
  }else {
    if(arguments.length === 2) {
      if(animated) {
        this.setZoomScaleInDuration(scale, BOUNCE_DURATION)
      }else {
        this.setZoomScale(scale)
      }
    }
  }
}, getZoomScale:function() {
  return this._container.getScale()
}, setZoomScaleInDuration:function(s, dt) {
  if(dt > 0) {
    if(this._container.getScale() != s) {
      var scaleAction = cc.ActionTween.create(dt, "zoomScale", this._container.getScale(), s);
      this.runAction(scaleAction)
    }
  }else {
    this.setZoomScale(s)
  }
}, minContainerOffset:function() {
  return cc.p(this._viewSize.width - this._container.getContentSize().width * this._container.getScaleX(), this._viewSize.height - this._container.getContentSize().height * this._container.getScaleY())
}, maxContainerOffset:function() {
  return cc.p(0, 0)
}, isNodeVisible:function(node) {
  var offset = this.getContentOffset();
  var size = this.getViewSize();
  var scale = this.getZoomScale();
  var viewRect = cc.RectMake(-offset.x / scale, -offset.y / scale, size.width / scale, size.height / scale);
  return cc.CCRectIntersectsRect(viewRect, node.getBoundingBox())
}, pause:function(sender) {
  this._container.pauseSchedulerAndActions();
  var selChildren = this._container.getChildren();
  for(var i = 0;i < selChildren.length;i++) {
    selChildren[i].pauseSchedulerAndActions()
  }
}, resume:function(sender) {
  var selChildren = this._container.getChildren();
  for(var i = 0;i < selChildren.length;i++) {
    selChildren[i].resumeSchedulerAndActions()
  }
  this._container.resumeSchedulerAndActions()
}, isDragging:function() {
  return this._dragging
}, isTouchMoved:function() {
  return this._touchMoved
}, isBounceable:function() {
  return this._bounceable
}, setBounceable:function(bounceable) {
  this._bounceable = bounceable
}, getViewSize:function() {
  return this._viewSize
}, setViewSize:function(size) {
  this._viewSize = size;
  this.setContentSize(size, true)
}, getContainer:function() {
  return this._container
}, setContainer:function(container) {
  this.removeAllChildren(true);
  if(!container) {
    return
  }
  this._container = container;
  this._container.ignoreAnchorPointForPosition(false);
  this._container.setAnchorPoint(cc.p(0, 0));
  this.addChild(this._container);
  this.setViewSize(this._viewSize)
}, getDirection:function() {
  return this._direction
}, setDirection:function(direction) {
  this._direction = direction
}, getDelegate:function() {
  return this._delegate
}, setDelegate:function(delegate) {
  this._delegate = delegate
}, onTouchBegan:function(touch, event) {
  if(!this.isVisible()) {
    return false
  }
  var frameOriginal = this.getParent().convertToWorldSpace(this.getPosition());
  var frame = cc.RectMake(frameOriginal.x, frameOriginal.y, this._viewSize.width, this._viewSize.height);
  var locPoint = this._container.convertToWorldSpace(this._container.convertTouchToNodeSpace(touch));
  if(this._touches.length > 2 || this._touchMoved || !cc.Rect.CCRectContainsPoint(frame, locPoint)) {
    return false
  }
  this._touches.push(touch);
  if(this._touches.length == 1) {
    this._touchPoint = this.convertTouchToNodeSpace(touch);
    this._touchMoved = false;
    this._dragging = true;
    this._scrollDistance = cc.p(0, 0);
    this._touchLength = 0
  }else {
    if(this._touches.length == 2) {
      this._touchPoint = cc.pMidpoint(this.convertTouchToNodeSpace(this._touches[0]), this.convertTouchToNodeSpace(this._touches[1]));
      this._touchLength = cc.pDistance(this._container.convertTouchToNodeSpace(this._touches[0]), this._container.convertTouchToNodeSpace(this._touches[1]));
      this._dragging = false
    }
  }
  return true
}, onTouchMoved:function(touch, event) {
  if(!this.isVisible()) {
    return
  }
  if(this._touches.length == 1 && this._dragging) {
    this._touchMoved = true;
    var frameOriginal = this.getParent().convertToWorldSpace(this.getPosition());
    var frame = cc.RectMake(frameOriginal.x, frameOriginal.y, this._viewSize.width, this._viewSize.height);
    var newPoint = this.convertTouchToNodeSpace(touch);
    var moveDistance = cc.pSub(newPoint, this._touchPoint);
    this._touchPoint = newPoint;
    if(cc.Rect.CCRectContainsPoint(frame, this.convertToWorldSpace(newPoint))) {
      switch(this._direction) {
        case cc.SCROLLVIEW_DIRECTION_VERTICAL:
          moveDistance = cc.p(0, moveDistance.y);
          break;
        case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
          moveDistance = cc.p(moveDistance.x, 0);
          break;
        default:
          break
      }
      var newX = this._container.getPosition().x + moveDistance.x;
      var newY = this._container.getPosition().y + moveDistance.y;
      this._scrollDistance = moveDistance;
      this.setContentOffset(cc.p(newX, newY))
    }
  }else {
    if(this._touches.length == 2 && !this._dragging) {
      var len = cc.pDistance(this._container.convertTouchToNodeSpace(this._touches[0]), this._container.convertTouchToNodeSpace(this._touches[1]));
      this.setZoomScale(this.getZoomScale() * len / this._touchLength)
    }
  }
}, onTouchEnded:function(touch, event) {
  if(!this.isVisible()) {
    return
  }
  if(this._touches.length == 1 && this._touchMoved) {
    this.schedule(this._deaccelerateScrolling)
  }
  this._touches.length = 0;
  this._dragging = false;
  this._touchMoved = false
}, onTouchCancelled:function(touch, event) {
  if(!this.isVisible()) {
    return
  }
  this._touches.length = 0;
  this._dragging = false;
  this._touchMoved = false
}, setContentSize:function(size, isDirectCall) {
  if(isDirectCall != null && isDirectCall == true) {
    this._super(size)
  }else {
    if(this.getContainer() != null) {
      this.getContainer().setContentSize(size);
      this.updateInset()
    }
  }
}, getContentSize:function() {
  return this._container.getContentSize()
}, updateInset:function() {
  if(this.getContainer() != null) {
    this._maxInset = this.maxContainerOffset();
    this._maxInset = cc.p(this._maxInset.x + this._viewSize.width * INSET_RATIO, this._maxInset.y + this._viewSize.height * INSET_RATIO);
    this._minInset = this.minContainerOffset();
    this._minInset = cc.p(this._minInset.x - this._viewSize.width * INSET_RATIO, this._minInset.y - this._viewSize.height * INSET_RATIO)
  }
}, isClippingToBounds:function() {
  return this._clippingToBounds
}, setClippingToBounds:function(clippingToBounds) {
  this._clippingToBounds = clippingToBounds
}, visit:function(ctx) {
  if(!this.isVisible()) {
    return
  }
  var context = ctx || cc.renderContext;
  var i;
  if(cc.renderContextType == cc.CANVAS) {
    context.save();
    this.transform(context);
    this._beforeDraw(context);
    if(this._children && this._children.length > 0) {
      this.sortAllChildren();
      for(i = 0;i < this._children.length;i++) {
        if(this._children[i] && this._children[i]._zOrder < 0) {
          this._children[i].visit(context)
        }else {
          break
        }
      }
      this.draw(context);
      if(this._children) {
        for(;i < this._children.length;i++) {
          if(this._children[i] && this._children[i]._zOrder >= 0) {
            this._children[i].visit(context)
          }
        }
      }
    }else {
      this.draw(context)
    }
    this._afterDraw();
    context.restore()
  }else {
    cc.kmGLPushMatrix();
    if(this._grid && this._grid.isActive()) {
      this._grid.beforeDraw();
      this.transformAncestors()
    }
    this.transform(context);
    this._beforeDraw(context);
    if(this._children) {
      i = 0;
      for(;i < this._children.length;i++) {
        if(this._children[i].getZOrder() < 0) {
          this._children[i].visit(context)
        }else {
          break
        }
      }
      this.draw(context);
      for(;i < this._children.length;i++) {
        this._children[i].visit(context)
      }
    }else {
      this.draw(context)
    }
    this._afterDraw(context);
    if(this._grid && this._grid.isActive()) {
      this._grid.afterDraw(this)
    }
    cc.kmGLPopMatrix()
  }
}, addChild:function(child, zOrder, tag) {
  if(!child) {
    throw new Error("child must not nil!");
  }
  zOrder = zOrder || child.getZOrder();
  tag = tag || child.getTag();
  child.ignoreAnchorPointForPosition(false);
  child.setAnchorPoint(cc.p(0, 0));
  if(this._container != child) {
    this._container.addChild(child, zOrder, tag)
  }else {
    this._super(child, zOrder, tag)
  }
}, setTouchEnabled:function(e) {
  this._super(e);
  if(!e) {
    this._dragging = false;
    this._touchMoved = false;
    this._touches.length = 0
  }
}, _initWithViewSize:function(size) {
  return null
}, _relocateContainer:function(animated) {
  var min = this.minContainerOffset();
  var max = this.maxContainerOffset();
  var oldPoint = this._container.getPosition();
  var newX = oldPoint.x;
  var newY = oldPoint.y;
  if(this._direction == cc.SCROLLVIEW_DIRECTION_BOTH || this._direction == cc.SCROLLVIEW_DIRECTION_HORIZONTAL) {
    newX = Math.min(newX, max.x);
    newX = Math.max(newX, min.x)
  }
  if(this._direction == cc.SCROLLVIEW_DIRECTION_BOTH || this._direction == cc.SCROLLVIEW_DIRECTION_VERTICAL) {
    newY = Math.min(newY, max.y);
    newY = Math.max(newY, min.y)
  }
  if(newY != oldPoint.y || newX != oldPoint.x) {
    this.setContentOffset(cc.p(newX, newY), animated)
  }
}, _deaccelerateScrolling:function(dt) {
  if(this._dragging) {
    this.unschedule(this._deaccelerateScrolling);
    return
  }
  var maxInset, minInset;
  this._container.setPosition(cc.pAdd(this._container.getPosition(), this._scrollDistance));
  if(this._bounceable) {
    maxInset = this._maxInset;
    minInset = this._minInset
  }else {
    maxInset = this.maxContainerOffset();
    minInset = this.minContainerOffset()
  }
  var newX = this._container.getPosition().x;
  var newY = this._container.getPosition().y;
  this._scrollDistance = cc.pSub(this._scrollDistance, cc.p(newX - this._container.getPosition().x, newY - this._container.getPosition().y));
  this._scrollDistance = cc.pMult(this._scrollDistance, SCROLL_DEACCEL_RATE);
  this.setContentOffset(cc.p(newX, newY));
  if(Math.abs(this._scrollDistance.x) <= SCROLL_DEACCEL_DIST && Math.abs(this._scrollDistance.y) <= SCROLL_DEACCEL_DIST || newX == maxInset.x || newX == minInset.x || newY == maxInset.y || newY == minInset.y) {
    this.unschedule(this._deaccelerateScrolling);
    this._relocateContainer(true)
  }
}, _performedAnimatedScroll:function(dt) {
  if(this._dragging) {
    this.unschedule(this._performedAnimatedScroll);
    return
  }
  if(this._delegate != null) {
    this._delegate.scrollViewDidScroll(this)
  }
}, _stoppedAnimatedScroll:function(node) {
  this.unschedule(this._performedAnimatedScroll);
  if(this._delegate != null) {
    this._delegate.scrollViewDidScroll(this)
  }
}, _beforeDraw:function(context) {
  if(this._clippingToBounds) {
    var screenPos;
    var scaleValue = this.getScale();
    var ctx = context || cc.renderContext;
    if(cc.renderContextType == cc.CANVAS) {
      screenPos = this.getParent().getPosition();
      var getWidth = this._viewSize.width * scaleValue;
      var getHeight = this._viewSize.height * scaleValue;
      var startX = screenPos.x * scaleValue;
      var startY = screenPos.y * scaleValue;
      ctx.beginPath();
      ctx.rect(startX, startY, getWidth, -getHeight);
      ctx.clip();
      ctx.closePath()
    }else {
      screenPos = this.convertToWorldSpace(this.getParent().getPosition());
      ctx.enable(ctx.SCISSOR_TEST);
      cc.EGLView.getInstance().setScissorInPoints(screenPos.x * scaleValue, screenPos.y * scaleValue, this._viewSize.width * scaleValue, this._viewSize.height * scaleValue)
    }
  }
}, _afterDraw:function(context) {
  if(this._clippingToBounds) {
    if(cc.renderContextType === cc.WEBGL) {
      var ctx = context || cc.renderContext;
      ctx.disable(ctx.SCISSOR_TEST)
    }
  }
}, _handleZoom:function() {
}});
cc.ScrollView.create = function(size, container) {
  var pRet = new cc.ScrollView;
  if(arguments.length == 2) {
    if(pRet && pRet.initWithViewSize(size, container)) {
      return pRet
    }
  }else {
    if(pRet && pRet.init()) {
      return pRet
    }
  }
  return null
};
cc.SortableObject = cc.Class.extend({setObjectID:function(objectId) {
}, getObjectID:function() {
  return 0
}});
cc.SortedObject = cc.SortableObject.extend({_objectID:0, ctor:function() {
  this._objectID = 0
}, setObjectID:function(objectID) {
  this._objectID = objectID
}, getObjectID:function() {
  return this._objectID
}});
var _compareObject = function(val1, val2) {
  return val1.getObjectID() - val2.getObjectID()
};
cc.ArrayForObjectSorting = cc.Class.extend({_saveObjectArr:[], ctor:function() {
  this._saveObjectArr = []
}, insertSortedObject:function(addObject) {
  cc.Assert(addObject instanceof cc.Class, "Invalid parameter.");
  var idx = this.indexOfSortedObject(addObject);
  this.insertObject(addObject, idx)
}, removeSortedObject:function(delObject) {
  if(this.count() == 0) {
    return
  }
  var idx = this.indexOfSortedObject(delObject);
  if(idx < this.count() && idx != cc.INVALID_INDEX) {
    var foundObj = this.objectAtIndex(idx);
    if(foundObj.getObjectID() == delObject.getObjectID()) {
      this.removeObjectAtIndex(idx)
    }
  }
}, setObjectID_ofSortedObject:function(tag, setObject) {
  var idx = this.indexOfSortedObject(setObject);
  if(idx < this.count() && idx != cc.INVALID_INDEX) {
    var foundObj = this.objectAtIndex(idx);
    if(foundObj.getObjectID() == setObject.getObjectID()) {
      this.removeObjectAtIndex(idx);
      foundObj.setObjectID(tag);
      this.insertSortedObject(foundObj)
    }
  }
}, objectWithObjectID:function(tag) {
  if(this.count() == 0) {
    return null
  }
  var foundObj = new cc.SortedObject;
  foundObj.setObjectID(tag);
  var idx = this.indexOfSortedObject(foundObj);
  if(idx < this.count() && idx != cc.INVALID_INDEX) {
    foundObj = this.objectAtIndex(idx);
    if(foundObj.getObjectID() != tag) {
      foundObj = null
    }
  }
  return foundObj
}, getObjectWithObjectID:function(tag) {
  return null
}, indexOfSortedObject:function(idxObj) {
  var idx = 0;
  if(idxObj) {
    var uPrevObjectID = 0;
    var uOfSortObjectID = idxObj.getObjectID();
    for(var i = 0;i < this._saveObjectArr.length;i++) {
      var pSortableObj = this._saveObjectArr[i];
      var curObjectID = pSortableObj.getObjectID();
      if(uOfSortObjectID == curObjectID || uOfSortObjectID >= uPrevObjectID && uOfSortObjectID < curObjectID) {
        break
      }
      uPrevObjectID = curObjectID;
      idx++
    }
  }else {
    idx = cc.INVALID_INDEX
  }
  return idx
}, count:function() {
  return this._saveObjectArr.length
}, lastObject:function() {
  if(this._saveObjectArr.length == 0) {
    return null
  }
  return this._saveObjectArr[this._saveObjectArr.length - 1]
}, objectAtIndex:function(idx) {
  return this._saveObjectArr[idx]
}, addObject:function(addObj) {
  this._saveObjectArr.push(addObj);
  this._saveObjectArr.sort(_compareObject)
}, removeObjectAtIndex:function(idx) {
  cc.ArrayRemoveObjectAtIndex(this._saveObjectArr, idx);
  this._saveObjectArr.sort(_compareObject)
}, insertObject:function(addObj, idx) {
  this._saveObjectArr = cc.ArrayAppendObjectToIndex(this._saveObjectArr, addObj, idx);
  this._saveObjectArr.sort(_compareObject)
}});
cc.TABLEVIEW_FILL_TOPDOWN = 0;
cc.TABLEVIEW_FILL_BOTTOMUP = 1;
cc.TableViewCell = cc.Node.extend({_idx:0, getIdx:function() {
  return this._idx
}, setIdx:function(idx) {
  this._idx = idx
}, reset:function() {
  this._idx = cc.INVALID_INDEX
}, setObjectID:function(idx) {
  this._idx = idx
}, getObjectID:function() {
  return this._idx
}});
cc.TableViewDelegate = cc.ScrollViewDelegate.extend({tableCellTouched:function(table, cell) {
}});
cc.TableViewDataSource = cc.Class.extend({cellSizeForTable:function(table) {
  return 0
}, tableCellAtIndex:function(table, idx) {
  return 0
}, numberOfCellsInTableView:function(table) {
  return 0
}});
cc.TableView = cc.ScrollView.extend({_vOrdering:null, _indices:null, _cellsFreed:null, _dataSource:null, _tableViewDelegate:null, _oldDirection:null, ctor:function() {
  this._super();
  this._oldDirection = cc.SCROLLVIEW_DIRECTION_NONE
}, __indexFromOffset:function(offset) {
  var index = 0;
  var cellSize = this._dataSource.cellSizeForTable(this);
  switch(this.getDirection()) {
    case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
      index = offset.x / cellSize.width;
      break;
    default:
      index = offset.y / cellSize.height;
      break
  }
  return index
}, _indexFromOffset:function(offset) {
  var maxIdx = this._dataSource.numberOfCellsInTableView(this) - 1;
  var offset1 = new cc.Point(offset.x, offset.y);
  var cellSize = this._dataSource.cellSizeForTable(this);
  if(this._vOrdering == cc.TABLEVIEW_FILL_TOPDOWN) {
    offset1.y = this.getContainer().getContentSize().height - offset.y - cellSize.height
  }
  var index = Math.max(0, this.__indexFromOffset(offset1));
  index = Math.min(index, maxIdx);
  return index
}, __offsetFromIndex:function(index) {
  var offset;
  var cellSize;
  cellSize = this._dataSource.cellSizeForTable(this);
  switch(this.getDirection()) {
    case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
      offset = cc.p(cellSize.width * index, 0);
      break;
    default:
      offset = cc.p(0, cellSize.height * index);
      break
  }
  return offset
}, _offsetFromIndex:function(index) {
  var offset = this.__offsetFromIndex(index);
  var cellSize = this._dataSource.cellSizeForTable(this);
  if(this._vOrdering == cc.TABLEVIEW_FILL_TOPDOWN) {
    offset.y = this.getContainer().getContentSize().height - offset.y - cellSize.height
  }
  return offset
}, _updateContentSize:function() {
  var size;
  var cellSize = this._dataSource.cellSizeForTable(this);
  var cellCount = this._dataSource.numberOfCellsInTableView(this);
  switch(this.getDirection()) {
    case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
      size = cc.SizeMake(cellCount * cellSize.width, cellSize.height);
      break;
    default:
      size = cc.SizeMake(cellSize.width, cellCount * cellSize.height);
      break
  }
  this.setContentSize(size);
  if(this._oldDirection != this._direction) {
    if(this._direction == cc.SCROLLVIEW_DIRECTION_HORIZONTAL) {
      this.setContentOffset(cc.p(0, 0))
    }else {
      this.setContentOffset(cc.p(0, this.minContainerOffset().y))
    }
    this._oldDirection = this._direction
  }
}, _cellWithIndex:function(cellIndex) {
  var found = null;
  if(this._indices.containsObject(cellIndex)) {
    found = this._cellsUsed.objectWithObjectID(cellIndex)
  }
  return found
}, _moveCellOutOfSight:function(cell) {
  this._cellsFreed.addObject(cell);
  this._cellsUsed.removeSortedObject(cell);
  this._indices.removeObject(cell.getIdx());
  cell.reset();
  if(cell.getParent() == this.getContainer()) {
    this.getContainer().removeChild(cell, true)
  }
}, _setIndexForCell:function(index, cell) {
  cell.setAnchorPoint(cc.p(0, 0));
  cell.setPosition(this._offsetFromIndex(index));
  cell.setIdx(index)
}, _addCellIfNecessary:function(cell) {
  if(cell.getParent() != this.getContainer()) {
    this.getContainer().addChild(cell)
  }
  this._cellsUsed.insertSortedObject(cell);
  this._indices.addObject(cell.getIdx())
}, getDataSource:function() {
  return this._dataSource
}, setDataSource:function(source) {
  this._dataSource = source
}, getDelegate:function() {
  return this._tableViewDelegate
}, setDelegate:function(delegate, isDirectCall) {
  if(isDirectCall != null && isDirectCall == true) {
    this._super(delegate);
    return
  }
  this._tableViewDelegate = delegate
}, setVerticalFillOrder:function(fillOrder) {
  if(this._vOrdering != fillOrder) {
    this._vOrdering = fillOrder;
    if(this._cellsUsed.count() > 0) {
      this.reloadData()
    }
  }
}, getVerticalFillOrder:function() {
  return this._vOrdering
}, initWithViewSize:function(size, container) {
  if(this._super(size, container)) {
    this._cellsUsed = new cc.ArrayForObjectSorting;
    this._cellsFreed = new cc.ArrayForObjectSorting;
    this._indices = new cc.Set;
    this._tableViewDelegate = null;
    this._vOrdering = cc.TABLEVIEW_FILL_BOTTOMUP;
    this.setDirection(cc.SCROLLVIEW_DIRECTION_VERTICAL);
    this.setDelegate(this, true);
    return true
  }
  return false
}, updateCellAtIndex:function(idx) {
  if(idx == cc.INVALID_INDEX || idx > this._dataSource.numberOfCellsInTableView(this) - 1) {
    return
  }
  var cell = this._cellWithIndex(idx);
  if(cell) {
    this._moveCellOutOfSight(cell)
  }
  cell = this._dataSource.tableCellAtIndex(this, idx);
  this._setIndexForCell(idx, cell);
  this._addCellIfNecessary(cell)
}, insertCellAtIndex:function(idx) {
  if(idx == cc.INVALID_INDEX || idx > this._dataSource.numberOfCellsInTableView(this) - 1) {
    return
  }
  var newIdx;
  var cell = this._cellsUsed.objectWithObjectID(idx);
  if(cell) {
    newIdx = this._cellsUsed.indexOfSortedObject(cell);
    for(var i = newIdx;i < this._cellsUsed.count();i++) {
      cell = this._cellsUsed.objectAtIndex(i);
      this._setIndexForCell(cell.getIdx() + 1, cell)
    }
  }
  cell = this._dataSource.tableCellAtIndex(this, idx);
  this._setIndexForCell(idx, cell);
  this._addCellIfNecessary(cell);
  this._updateContentSize()
}, removeCellAtIndex:function(idx) {
  if(idx == cc.INVALID_INDEX || idx > this._dataSource.numberOfCellsInTableView(this) - 1) {
    return
  }
  var cell = this._cellWithIndex(idx);
  if(!cell) {
    return
  }
  var newIdx = this._cellsUsed.indexOfSortedObject(cell);
  this._moveCellOutOfSight(cell);
  this._indices.removeObject(idx);
  for(var i = this._cellsUsed.count() - 1;i > newIdx;i--) {
    cell = this._cellsUsed.objectAtIndex(i);
    this._setIndexForCell(cell.getIdx() - 1, cell)
  }
}, reloadData:function() {
  for(var i = 0;i < this._cellsUsed.count();i++) {
    var cell = this._cellsUsed.objectAtIndex(i);
    this._cellsFreed.addObject(cell);
    cell.reset();
    if(cell.getParent() == this.getContainer()) {
      this.getContainer().removeChild(cell, true)
    }
  }
  this._indices = new cc.Set;
  this._cellsUsed = new cc.ArrayForObjectSorting;
  this._updateContentSize();
  if(this._dataSource.numberOfCellsInTableView(this) > 0) {
    this.scrollViewDidScroll(this)
  }
}, dequeueCell:function() {
  if(this._cellsFreed.count() == 0) {
    return null
  }else {
    var cell = this._cellsFreed.objectAtIndex(0);
    this._cellsFreed.removeObjectAtIndex(0);
    return cell
  }
}, cellAtIndex:function(idx) {
  return this._cellWithIndex(idx)
}, scrollViewDidScroll:function(view) {
  var countOfItems = this._dataSource.numberOfCellsInTableView(this);
  if(0 === countOfItems) {
    return
  }
  if(this._tableViewDelegate != null) {
    this._tableViewDelegate.scrollViewDidScroll(this)
  }
  var idx = 0;
  var offset = cc.pMult(this.getContentOffset(), -1);
  var maxIdx = Math.max(this._dataSource.numberOfCellsInTableView(this) - 1, 0);
  var cellSize = this._dataSource.cellSizeForTable(this);
  if(this._vOrdering == cc.TABLEVIEW_FILL_TOPDOWN) {
    offset.y = offset.y + this._viewSize.height / this.getContainer().getScaleY() - cellSize.height
  }
  var startIdx = 0 | this._indexFromOffset(offset);
  if(this._vOrdering == cc.TABLEVIEW_FILL_TOPDOWN) {
    offset.y -= this._viewSize.height / this.getContainer().getScaleY()
  }else {
    offset.y += this._viewSize.height / this.getContainer().getScaleY()
  }
  offset.x += this._viewSize.width / this.getContainer().getScaleX();
  var endIdx = 0 | this._indexFromOffset(offset);
  var cell;
  if(this._cellsUsed.count() > 0) {
    cell = this._cellsUsed.objectAtIndex(0);
    idx = cell.getIdx();
    while(idx < startIdx) {
      this._moveCellOutOfSight(cell);
      if(this._cellsUsed.count() > 0) {
        cell = this._cellsUsed.objectAtIndex(0);
        idx = cell.getIdx()
      }else {
        break
      }
    }
  }
  if(this._cellsUsed.count() > 0) {
    cell = this._cellsUsed.lastObject();
    idx = cell.getIdx();
    while(idx <= maxIdx && idx > endIdx) {
      this._moveCellOutOfSight(cell);
      if(this._cellsUsed.count() > 0) {
        cell = this._cellsUsed.lastObject();
        idx = cell.getIdx()
      }else {
        break
      }
    }
  }
  for(var i = startIdx;i <= endIdx;i++) {
    if(this._indices.containsObject(i)) {
      continue
    }
    this.updateCellAtIndex(i)
  }
}, scrollViewDidZoom:function(view) {
}, onTouchEnded:function(touch, event) {
  if(!this.isVisible()) {
    return
  }
  if(this._touches.length == 1 && !this.isTouchMoved()) {
    var point = this.getContainer().convertTouchToNodeSpace(touch);
    if(this._vOrdering == cc.TABLEVIEW_FILL_TOPDOWN) {
      var cellSize = this._dataSource.cellSizeForTable(this);
      point.y -= cellSize.height
    }
    var index = 0 | this._indexFromOffset(point);
    var cell = this._cellWithIndex(index);
    if(cell) {
      this._tableViewDelegate.tableCellTouched(this, cell)
    }
  }
  this._super(touch, event)
}});
cc.TableView.create = function(dataSource, size, container) {
  var table = new cc.TableView;
  table.initWithViewSize(size, container);
  table.setDataSource(dataSource);
  table._updateContentSize();
  return table
};
var PROPERTY_POSITION = "position";
var PROPERTY_CONTENTSIZE = "contentSize";
var PROPERTY_SKEW = "skew";
var PROPERTY_ANCHORPOINT = "anchorPoint";
var PROPERTY_SCALE = "scale";
var PROPERTY_ROTATION = "rotation";
var PROPERTY_TAG = "tag";
var PROPERTY_IGNOREANCHORPOINTFORPOSITION = "ignoreAnchorPointForPosition";
var PROPERTY_VISIBLE = "visible";
var ASSERT_FAIL_UNEXPECTED_PROPERTY = function(propertyName) {
  cc.log("Unexpected property: '" + propertyName + "'!");
  cc.Assert(false, "Unexpected property: '" + propertyName + "'!")
};
var ASSERT_FAIL_UNEXPECTED_PROPERTYTYPE = function(propertyName) {
  cc.log("Unexpected property type: '" + propertyName + "'!");
  cc.Assert(false, "Unexpected property type: '" + propertyName + "'!")
};
function BlockData(selMenuHander, target) {
  this.selMenuHander = selMenuHander;
  this.target = target
}
function BlockCCControlData(selCCControlHandler, target, controlEvents) {
  this.selCCControlHandler = selCCControlHandler;
  this.target = target;
  this.controlEvents = controlEvents
}
cc.NodeLoader = cc.Class.extend({_customProperties:null, ctor:function() {
  this._customProperties = new cc._Dictionary
}, loadCCNode:function(parent, ccbReader) {
  return this._createCCNode(parent, ccbReader)
}, parseProperties:function(node, parent, ccbReader) {
  var numRegularProps = ccbReader.readInt(false);
  var numExturaProps = ccbReader.readInt(false);
  var propertyCount = numRegularProps + numExturaProps;
  for(var i = 0;i < propertyCount;i++) {
    var isExtraProp = i >= numRegularProps;
    var type = ccbReader.readInt(false);
    var propertyName = ccbReader.readCachedString();
    var setProp = false;
    var platform = ccbReader.readByte();
    if(platform == CCB_PLATFORM_ALL || platform == CCB_PLATFORM_IOS || platform == CCB_PLATFORM_MAC) {
      setProp = true
    }
    if(node instanceof cc.BuilderFile) {
      if(node.getCCBFileNode() && isExtraProp) {
        node = node.getCCBFileNode();
        var getExtraPropsNames = node.getUserObject();
        setProp = cc.ArrayContainsObject(getExtraPropsNames, propertyName)
      }
    }else {
      if(isExtraProp && node == ccbReader.getAnimationManager().getRootNode()) {
        var extraPropsNames = node.getUserObject();
        if(!extraPropsNames) {
          extraPropsNames = [];
          node.setUserObject(extraPropsNames)
        }
        extraPropsNames.push(propertyName)
      }
    }
    switch(type) {
      case CCB_PROPTYPE_POSITION:
        var position = this.parsePropTypePosition(node, parent, ccbReader, propertyName);
        if(setProp) {
          this.onHandlePropTypePosition(node, parent, propertyName, position, ccbReader)
        }
        break;
      case CCB_PROPTYPE_POINT:
        var point = this.parsePropTypePoint(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypePoint(node, parent, propertyName, point, ccbReader)
        }
        break;
      case CCB_PROPTYPE_POINTLOCK:
        var pointLock = this.parsePropTypePointLock(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypePointLock(node, parent, propertyName, pointLock, ccbReader)
        }
        break;
      case CCB_PROPTYPE_SIZE:
        var size = this.parsePropTypeSize(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeSize(node, parent, propertyName, size, ccbReader)
        }
        break;
      case CCB_PROPTYPE_SCALELOCK:
        var scaleLock = this.parsePropTypeScaleLock(node, parent, ccbReader, propertyName);
        if(setProp) {
          this.onHandlePropTypeScaleLock(node, parent, propertyName, scaleLock, ccbReader)
        }
        break;
      case CCB_PROPTYPE_FLOATXY:
        var xy = this.parsePropTypeFloatXY(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeFloatXY(node, parent, propertyName, xy, ccbReader)
        }
        break;
      case CCB_PROPTYPE_FLOAT:
        var f = this.parsePropTypeFloat(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeFloat(node, parent, propertyName, f, ccbReader)
        }
        break;
      case CCB_PROPTYPE_DEGREES:
        var degrees = this.parsePropTypeDegrees(node, parent, ccbReader, propertyName);
        if(setProp) {
          this.onHandlePropTypeDegrees(node, parent, propertyName, degrees, ccbReader)
        }
        break;
      case CCB_PROPTYPE_FLOATSCALE:
        var floatScale = this.parsePropTypeFloatScale(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeFloatScale(node, parent, propertyName, floatScale, ccbReader)
        }
        break;
      case CCB_PROPTYPE_INTEGER:
        var integer = this.parsePropTypeInteger(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeInteger(node, parent, propertyName, integer, ccbReader)
        }
        break;
      case CCB_PROPTYPE_INTEGERLABELED:
        var integerLabeled = this.parsePropTypeIntegerLabeled(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeIntegerLabeled(node, parent, propertyName, integerLabeled, ccbReader)
        }
        break;
      case CCB_PROPTYPE_FLOATVAR:
        var floatVar = this.parsePropTypeFloatVar(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeFloatVar(node, parent, propertyName, floatVar, ccbReader)
        }
        break;
      case CCB_PROPTYPE_CHECK:
        var check = this.parsePropTypeCheck(node, parent, ccbReader, propertyName);
        if(setProp) {
          this.onHandlePropTypeCheck(node, parent, propertyName, check, ccbReader)
        }
        break;
      case CCB_PROPTYPE_SPRITEFRAME:
        var ccSpriteFrame = this.parsePropTypeSpriteFrame(node, parent, ccbReader, propertyName);
        if(setProp) {
          this.onHandlePropTypeSpriteFrame(node, parent, propertyName, ccSpriteFrame, ccbReader)
        }
        break;
      case CCB_PROPTYPE_ANIMATION:
        var ccAnimation = this.parsePropTypeAnimation(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeAnimation(node, parent, propertyName, ccAnimation, ccbReader)
        }
        break;
      case CCB_PROPTYPE_TEXTURE:
        var ccTexture2D = this.parsePropTypeTexture(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeTexture(node, parent, propertyName, ccTexture2D, ccbReader)
        }
        break;
      case CCB_PROPTYPE_BYTE:
        var byteValue = this.parsePropTypeByte(node, parent, ccbReader, propertyName);
        if(setProp) {
          this.onHandlePropTypeByte(node, parent, propertyName, byteValue, ccbReader)
        }
        break;
      case CCB_PROPTYPE_COLOR3:
        var color3B = this.parsePropTypeColor3(node, parent, ccbReader, propertyName);
        if(setProp) {
          this.onHandlePropTypeColor3(node, parent, propertyName, color3B, ccbReader)
        }
        break;
      case CCB_PROPTYPE_COLOR4VAR:
        var color4FVar = this.parsePropTypeColor4FVar(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeColor4FVar(node, parent, propertyName, color4FVar, ccbReader)
        }
        break;
      case CCB_PROPTYPE_FLIP:
        var flip = this.parsePropTypeFlip(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeFlip(node, parent, propertyName, flip, ccbReader)
        }
        break;
      case CCB_PROPTYPE_BLENDMODE:
        var blendFunc = this.parsePropTypeBlendFunc(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeBlendFunc(node, parent, propertyName, blendFunc, ccbReader)
        }
        break;
      case CCB_PROPTYPE_FNTFILE:
        var fntFile = ccbReader.getCCBRootPath() + this.parsePropTypeFntFile(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeFntFile(node, parent, propertyName, fntFile, ccbReader)
        }
        break;
      case CCB_PROPTYPE_FONTTTF:
        var fontTTF = this.parsePropTypeFontTTF(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeFontTTF(node, parent, propertyName, fontTTF, ccbReader)
        }
        break;
      case CCB_PROPTYPE_STRING:
        var stringValue = this.parsePropTypeString(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeString(node, parent, propertyName, stringValue, ccbReader)
        }
        break;
      case CCB_PROPTYPE_TEXT:
        var textValue = this.parsePropTypeText(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeText(node, parent, propertyName, textValue, ccbReader)
        }
        break;
      case CCB_PROPTYPE_BLOCK:
        var blockData = this.parsePropTypeBlock(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeBlock(node, parent, propertyName, blockData, ccbReader)
        }
        break;
      case CCB_PROPTYPE_BLOCKCCCONTROL:
        var blockCCControlData = this.parsePropTypeBlockCCControl(node, parent, ccbReader);
        if(setProp && blockCCControlData != null) {
          this.onHandlePropTypeBlockCCControl(node, parent, propertyName, blockCCControlData, ccbReader)
        }
        break;
      case CCB_PROPTYPE_CCBFILE:
        var ccbFileNode = this.parsePropTypeCCBFile(node, parent, ccbReader);
        if(setProp) {
          this.onHandlePropTypeCCBFile(node, parent, propertyName, ccbFileNode, ccbReader)
        }
        break;
      default:
        ASSERT_FAIL_UNEXPECTED_PROPERTYTYPE(type);
        break
    }
  }
}, getCustomProperties:function() {
  return this._customProperties
}, _createCCNode:function(parent, ccbReader) {
  return cc.Node.create()
}, parsePropTypePosition:function(node, parent, ccbReader, propertyName) {
  var x = ccbReader.readFloat();
  var y = ccbReader.readFloat();
  var type = ccbReader.readInt(false);
  var containerSize = ccbReader.getAnimationManager().getContainerSize(parent);
  var pt = cc.getAbsolutePosition(cc.p(x, y), type, containerSize, propertyName);
  node.setPosition(cc.getAbsolutePosition(pt, type, containerSize, propertyName));
  if(ccbReader.getAnimatedProperties().indexOf(propertyName) > -1) {
    var baseValue = [x, y, type];
    ccbReader.getAnimationManager().setBaseValue(baseValue, node, propertyName)
  }
  return pt
}, parsePropTypePoint:function(node, parent, ccbReader) {
  var x = ccbReader.readFloat();
  var y = ccbReader.readFloat();
  return new cc.Point(x, y)
}, parsePropTypePointLock:function(node, parent, ccbReader) {
  var x = ccbReader.readFloat();
  var y = ccbReader.readFloat();
  return new cc.Point(x, y)
}, parsePropTypeSize:function(node, parent, ccbReader) {
  var width = ccbReader.readFloat();
  var height = ccbReader.readFloat();
  var type = ccbReader.readInt(false);
  var containerSize = ccbReader.getAnimationManager().getContainerSize(parent);
  switch(type) {
    case CCB_SIZETYPE_ABSOLUTE:
      break;
    case CCB_SIZETYPE_RELATIVE_CONTAINER:
      width = containerSize.width - width;
      height = containerSize.height - height;
      break;
    case CCB_SIZETYPE_PERCENT:
      width = containerSize.width * width / 100;
      height = containerSize.height * height / 100;
      break;
    case CCB_SIZETYPE_HORIZONTAL_PERCENT:
      width = containerSize.width * width / 100;
      break;
    case CCB_SIZETYPE_VERTICAL_PERCENT:
      height = containerSize.height * height / 100;
      break;
    case CCB_SIZETYPE_MULTIPLY_RESOLUTION:
      var resolutionScale = cc.BuilderReader.getResolutionScale();
      width *= resolutionScale;
      height *= resolutionScale;
      break;
    default:
      cc.log("Unknown CCB type.");
      break
  }
  return new cc.Size(width, height)
}, parsePropTypeScaleLock:function(node, parent, ccbReader, propertyName) {
  var x = ccbReader.readFloat();
  var y = ccbReader.readFloat();
  var type = ccbReader.readInt(false);
  cc.setRelativeScale(node, x, y, type, propertyName);
  if(ccbReader.getAnimatedProperties().indexOf(propertyName) > -1) {
    ccbReader.getAnimationManager().setBaseValue([x, y, type], node, propertyName)
  }
  if(type == CCB_SCALETYPE_MULTIPLY_RESOLUTION) {
    x *= cc.BuilderReader.getResolutionScale();
    y *= cc.BuilderReader.getResolutionScale()
  }
  return[x, y]
}, parsePropTypeFloat:function(node, parent, ccbReader) {
  return ccbReader.readFloat()
}, parsePropTypeDegrees:function(node, parent, ccbReader, propertyName) {
  var ret = ccbReader.readFloat();
  if(ccbReader.getAnimatedProperties().indexOf(propertyName) > -1) {
    ccbReader.getAnimationManager().setBaseValue(ret, node, propertyName)
  }
  return ret
}, parsePropTypeFloatScale:function(node, parent, ccbReader) {
  var f = ccbReader.readFloat();
  var type = ccbReader.readInt(false);
  if(type == CCB_SCALETYPE_MULTIPLY_RESOLUTION) {
    f *= cc.BuilderReader.getResolutionScale()
  }
  return f
}, parsePropTypeInteger:function(node, parent, ccbReader) {
  return ccbReader.readInt(true)
}, parsePropTypeIntegerLabeled:function(node, parent, ccbReader) {
  return ccbReader.readInt(true)
}, parsePropTypeFloatVar:function(node, parent, ccbReader) {
  var f = ccbReader.readFloat();
  var fVar = ccbReader.readFloat();
  return[f, fVar]
}, parsePropTypeCheck:function(node, parent, ccbReader, propertyName) {
  var ret = ccbReader.readBool();
  if(ccbReader.getAnimatedProperties().indexOf(propertyName) > -1) {
    ccbReader.getAnimationManager().setBaseValue(ret, node, propertyName)
  }
  return ret
}, parsePropTypeSpriteFrame:function(node, parent, ccbReader, propertyName) {
  var spriteSheet = ccbReader.readCachedString();
  var spriteFile = ccbReader.readCachedString();
  var spriteFrame;
  if(spriteFile != null && spriteFile.length != 0) {
    if(spriteSheet.length == 0) {
      spriteFile = ccbReader.getCCBRootPath() + spriteFile;
      var texture = cc.TextureCache.getInstance().addImage(spriteFile);
      var bounds;
      if(texture instanceof cc.Texture2D) {
        bounds = cc.RectMake(0, 0, texture.getContentSize().width, texture.getContentSize().height)
      }else {
        bounds = cc.RectMake(0, 0, texture.width, texture.height)
      }
      spriteFrame = cc.SpriteFrame.createWithTexture(texture, bounds)
    }else {
      var frameCache = cc.SpriteFrameCache.getInstance();
      spriteSheet = ccbReader.getCCBRootPath() + spriteSheet;
      if(ccbReader.getLoadedSpriteSheet().indexOf(spriteSheet) == -1) {
        frameCache.addSpriteFrames(spriteSheet);
        ccbReader.getLoadedSpriteSheet().push(spriteSheet)
      }
      spriteFrame = frameCache.getSpriteFrame(spriteFile)
    }
    if(ccbReader.getAnimatedProperties().indexOf(propertyName) > -1) {
      ccbReader.getAnimationManager().setBaseValue(spriteFrame, node, propertyName)
    }
  }
  return spriteFrame
}, parsePropTypeAnimation:function(node, parent, ccbReader) {
  var animationFile = ccbReader.getCCBRootPath() + ccbReader.readCachedString();
  var animation = ccbReader.readCachedString();
  var ccAnimation = null;
  animation = cc.BuilderReader.lastPathComponent(animation);
  animationFile = cc.BuilderReader.lastPathComponent(animationFile);
  if(animation != null && animation != "") {
    var animationCache = cc.AnimationCache.getInstance();
    animationCache.addAnimations(animationFile);
    ccAnimation = animationCache.getAnimation(animation)
  }
  return ccAnimation
}, parsePropTypeTexture:function(node, parent, ccbReader) {
  var spriteFile = ccbReader.getCCBRootPath() + ccbReader.readCachedString();
  if(spriteFile != "") {
    return cc.TextureCache.getInstance().addImage(spriteFile)
  }
  return null
}, parsePropTypeByte:function(node, parent, ccbReader, propertyName) {
  var ret = ccbReader.readByte();
  if(ccbReader.getAnimatedProperties().indexOf(propertyName) > -1) {
    ccbReader.getAnimationManager().setBaseValue(ret, node, propertyName)
  }
  return ret
}, parsePropTypeColor3:function(node, parent, ccbReader, propertyName) {
  var red = ccbReader.readByte();
  var green = ccbReader.readByte();
  var blue = ccbReader.readByte();
  var color = {r:red, g:green, b:blue};
  if(ccbReader.getAnimatedProperties().indexOf(propertyName) > -1) {
    ccbReader.getAnimationManager().setBaseValue(cc.Color3BWapper.create(color), node, propertyName)
  }
  return color
}, parsePropTypeColor4FVar:function(node, parent, ccbReader) {
  var red = ccbReader.readFloat();
  var green = ccbReader.readFloat();
  var blue = ccbReader.readFloat();
  var alpha = ccbReader.readFloat();
  var redVar = ccbReader.readFloat();
  var greenVar = ccbReader.readFloat();
  var blueVar = ccbReader.readFloat();
  var alphaVar = ccbReader.readFloat();
  var colors = [];
  colors[0] = {r:red, g:green, b:blue, a:alpha};
  colors[1] = {r:redVar, g:greenVar, b:blueVar, a:alphaVar};
  return colors
}, parsePropTypeFlip:function(node, parent, ccbReader) {
  var flipX = ccbReader.readBool();
  var flipY = ccbReader.readBool();
  return[flipX, flipY]
}, parsePropTypeBlendFunc:function(node, parent, ccbReader) {
  var source = ccbReader.readInt(false);
  var destination = ccbReader.readInt(false);
  return new cc.BlendFunc(source, destination)
}, parsePropTypeFntFile:function(node, parent, ccbReader) {
  return ccbReader.readCachedString()
}, parsePropTypeString:function(node, parent, ccbReader) {
  return ccbReader.readCachedString()
}, parsePropTypeText:function(node, parent, ccbReader) {
  return ccbReader.readCachedString()
}, parsePropTypeFontTTF:function(node, parent, ccbReader) {
  return ccbReader.readCachedString()
}, parsePropTypeBlock:function(node, parent, ccbReader) {
  var selectorName = ccbReader.readCachedString();
  var selectorTarget = ccbReader.readInt(false);
  if(selectorTarget != CCB_TARGETTYPE_NONE) {
    var target = null;
    if(!ccbReader.isJSControlled()) {
      if(selectorTarget == CCB_TARGETTYPE_DOCUMENTROOT) {
        target = ccbReader.getAnimationManager().getRootNode()
      }else {
        if(selectorTarget == CCB_TARGETTYPE_OWNER) {
          target = ccbReader.getOwner()
        }
      }
      if(target != null) {
        if(selectorName.length > 0) {
          var selMenuHandler = 0;
          if(target != null && target.onResolveCCBCCMenuItemSelector) {
            selMenuHandler = target.onResolveCCBCCMenuItemSelector(target, selectorName)
          }
          if(selMenuHandler == 0) {
            var ccbSelectorResolver = ccbReader.getCCBSelectorResolver();
            if(ccbSelectorResolver != null) {
              selMenuHandler = ccbSelectorResolver.onResolveCCBCCMenuItemSelector(target, selectorName)
            }
          }
          if(selMenuHandler == 0) {
            cc.log("Skipping selector '" + selectorName + "' since no CCBSelectorResolver is present.")
          }else {
            return new BlockData(selMenuHandler, target)
          }
        }else {
          cc.log("Unexpected empty selector.")
        }
      }else {
        cc.log("Unexpected NULL target for selector.")
      }
    }else {
      if(selectorTarget == CCB_TARGETTYPE_DOCUMENTROOT) {
        ccbReader.addDocumentCallbackNode(node);
        ccbReader.addDocumentCallbackName(selectorName)
      }else {
        ccbReader.addOwnerCallbackNode(node);
        ccbReader.addOwnerCallbackName(selectorName)
      }
    }
  }
  return null
}, parsePropTypeBlockCCControl:function(node, parent, ccbReader) {
  var selectorName = ccbReader.readCachedString();
  var selectorTarget = ccbReader.readInt(false);
  var controlEvents = ccbReader.readInt(false);
  if(selectorTarget != CCB_TARGETTYPE_NONE) {
    if(!ccbReader.isJSControlled()) {
      var target = null;
      if(selectorTarget == CCB_TARGETTYPE_DOCUMENTROOT) {
        target = ccbReader.getAnimationManager().getRootNode()
      }else {
        if(selectorTarget == CCB_TARGETTYPE_OWNER) {
          target = ccbReader.getOwner()
        }
      }
      if(target != null) {
        if(selectorName.length > 0) {
          var selCCControlHandler = 0;
          if(target != null && target.onResolveCCBCCControlSelector) {
            selCCControlHandler = target.onResolveCCBCCControlSelector(target, selectorName)
          }
          if(selCCControlHandler == 0) {
            var ccbSelectorResolver = ccbReader.getCCBSelectorResolver();
            if(ccbSelectorResolver != null) {
              selCCControlHandler = ccbSelectorResolver.onResolveCCBCCControlSelector(target, selectorName)
            }
          }
          if(selCCControlHandler == 0) {
            cc.log("Skipping selector '" + selectorName + "' since no CCBSelectorResolver is present.")
          }else {
            return new BlockCCControlData(selCCControlHandler, target, controlEvents)
          }
        }else {
          cc.log("Unexpected empty selector.")
        }
      }else {
        cc.log("Unexpected NULL target for selector.")
      }
    }else {
      if(selectorTarget == CCB_TARGETTYPE_DOCUMENTROOT) {
        ccbReader.addDocumentCallbackName(node);
        ccbReader.addDocumentCallbackName(selectorName)
      }else {
        ccbReader.addOwnerCallbackNode(node);
        ccbReader.addOwnerCallbackName(selectorName)
      }
    }
  }
  return null
}, parsePropTypeCCBFile:function(node, parent, ccbReader) {
  var ccbFileName = ccbReader.getCCBRootPath() + ccbReader.readCachedString();
  var ccbFileWithoutPathExtension = cc.BuilderReader.deletePathExtension(ccbFileName);
  ccbFileName = ccbFileWithoutPathExtension + ".ccbi";
  var path = cc.FileUtils.getInstance().fullPathFromRelativePath(ccbFileName);
  var myCCBReader = new cc.BuilderReader(ccbReader);
  var size;
  var bytes = cc.FileUtils.getInstance().getByteArrayFromFile(path, "rb", size);
  myCCBReader.initWithData(bytes, ccbReader.getOwner());
  myCCBReader.getAnimationManager().setRootContainerSize(parent.getContentSize());
  myCCBReader.setAnimationManagers(ccbReader.getAnimationManagers());
  myCCBReader.getAnimationManager().setOwner(ccbReader.getOwner());
  var ccbFileNode = myCCBReader.readFileWithCleanUp(false);
  ccbReader.setAnimationManagers(myCCBReader.getAnimationManagers());
  if(ccbFileNode && myCCBReader.getAnimationManager().getAutoPlaySequenceId() != -1) {
    myCCBReader.getAnimationManager().runAnimations(myCCBReader.getAnimationManager().getAutoPlaySequenceId(), 0)
  }
  return ccbFileNode
}, parsePropTypeFloatXY:function(node, parent, ccbReader) {
  var x = ccbReader.readFloat();
  var y = ccbReader.readFloat();
  return[x, y]
}, onHandlePropTypePosition:function(node, parent, propertyName, position, ccbReader) {
  if(propertyName === PROPERTY_POSITION) {
    node.setPosition(position)
  }else {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
  }
}, onHandlePropTypePoint:function(node, parent, propertyName, position, ccbReader) {
  if(propertyName === PROPERTY_ANCHORPOINT) {
    node.setAnchorPoint(position)
  }else {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
  }
}, onHandlePropTypePointLock:function(node, parent, propertyName, pointLock, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeSize:function(node, parent, propertyName, sizeValue, ccbReader) {
  if(propertyName === PROPERTY_CONTENTSIZE) {
    node.setContentSize(sizeValue)
  }else {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
  }
}, onHandlePropTypeScaleLock:function(node, parent, propertyName, scaleLock, ccbReader) {
  if(propertyName === PROPERTY_SCALE) {
    node.setScaleX(scaleLock[0]);
    node.setScaleY(scaleLock[1])
  }else {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
  }
}, onHandlePropTypeFloatXY:function(node, parent, propertyName, xy, ccbReader) {
  if(propertyName === PROPERTY_SKEW) {
    node.setSkewX(xy[0]);
    node.setSkewY(xy[1])
  }else {
    var nameX = propertyName + "X";
    var nameY = propertyName + "Y";
    if(!node[nameX] || !node[nameY]) {
      ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
    }
    node[nameX](xy[0]);
    node[nameY](xy[1])
  }
}, onHandlePropTypeFloat:function(node, parent, propertyName, floatValue, ccbReader) {
  this._customProperties.setObject(floatValue, propertyName)
}, onHandlePropTypeDegrees:function(node, parent, propertyName, degrees, ccbReader) {
  if(propertyName === PROPERTY_ROTATION) {
    node.setRotation(degrees)
  }else {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
  }
}, onHandlePropTypeFloatScale:function(node, parent, propertyName, floatScale, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeInteger:function(node, parent, propertyName, integer, ccbReader) {
  if(propertyName === PROPERTY_TAG) {
    node.setTag(integer)
  }else {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
  }
}, onHandlePropTypeIntegerLabeled:function(node, parent, propertyName, integerLabeled, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeFloatVar:function(node, parent, propertyName, floatVar, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeCheck:function(node, parent, propertyName, check, ccbReader) {
  if(propertyName === PROPERTY_VISIBLE) {
    node.setVisible(check)
  }else {
    if(propertyName == PROPERTY_IGNOREANCHORPOINTFORPOSITION) {
      node.ignoreAnchorPointForPosition(check)
    }else {
      ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
    }
  }
}, onHandlePropTypeSpriteFrame:function(node, parent, propertyName, spriteFrame, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeAnimation:function(node, parent, propertyName, ccAnimation, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeTexture:function(node, parent, propertyName, ccTexture2D, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeByte:function(node, parent, propertyName, byteValue, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeColor3:function(node, parent, propertyName, ccColor3B, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeColor4FVar:function(node, parent, propertyName, ccColor4FVar, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeFlip:function(node, parent, propertyName, flip, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeBlendFunc:function(node, parent, propertyName, ccBlendFunc, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeFntFile:function(node, parent, propertyName, fntFile, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeString:function(node, parent, propertyName, strValue, ccbReader) {
  this._customProperties.setObject(strValue, propertyName)
}, onHandlePropTypeText:function(node, parent, propertyName, textValue, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeFontTTF:function(node, parent, propertyName, fontTTF, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeBlock:function(node, parent, propertyName, blockData, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeBlockCCControl:function(node, parent, propertyName, blockCCControlData, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}, onHandlePropTypeCCBFile:function(node, parent, propertyName, ccbFileNode, ccbReader) {
  ASSERT_FAIL_UNEXPECTED_PROPERTY(propertyName)
}});
cc.NodeLoader.loader = function() {
  return new cc.NodeLoader
};
cc.NodeLoaderListener = cc.Class.extend({onNodeLoaded:function(node, nodeLoader) {
}});
cc.BuilderSelectorResolver = cc.Class.extend({onResolveCCBCCMenuItemSelector:function(target, selectorName) {
}, onResolveCCBCCCallFuncSelector:function(target, selectorName) {
}, onResolveCCBCCControlSelector:function(target, selectorName) {
}});
cc.BuilderScriptOwnerProtocol = cc.Class.extend({createNew:function() {
}});
cc.BuilderMemberVariableAssigner = cc.Class.extend({onAssignCCBMemberVariable:function(target, memberVariableName, node) {
}, onAssignCCBCustomProperty:function(target, memberVariableName, value) {
}});
var PROPERTY_CCBFILE = "ccbFile";
cc.BuilderFileLoader = cc.NodeLoader.extend({_createCCNode:function(parent, ccbReader) {
  return cc.BuilderFile.create()
}, onHandlePropTypeCCBFile:function(node, parent, propertyName, ccbFileNode, ccbReader) {
  if(propertyName == PROPERTY_CCBFILE) {
    node.setCCBFileNode(ccbFileNode)
  }else {
    this._super(node, parent, propertyName, ccbFileNode, ccbReader)
  }
}});
cc.BuilderFileLoader.loader = function() {
  return new cc.BuilderFileLoader
};
var PROPERTY_ENABLED = "enabled";
var PROPERTY_SELECTED = "selected";
var PROPERTY_CCCONTROL = "ccControl";
cc.ControlLoader = cc.NodeLoader.extend({_createCCNode:function(parent, ccbReander) {
}, onHandlePropTypeBlockCCControl:function(node, parent, propertyName, blockCCControlData, ccbReader) {
  if(propertyName == PROPERTY_CCCONTROL) {
    node.addTargetWithActionForControlEvents(blockCCControlData.target, blockCCControlData.selCCControlHandler, blockCCControlData.controlEvents)
  }else {
    this._super(node, parent, propertyName, blockCCControlData, ccbReader)
  }
}, onHandlePropTypeCheck:function(node, parent, propertyName, check, ccbReader) {
  if(propertyName == PROPERTY_ENABLED) {
    node.setEnabled(check)
  }else {
    if(propertyName == PROPERTY_SELECTED) {
      node.setSelected(check)
    }else {
      this._super(node, parent, propertyName, check, ccbReader)
    }
  }
}});
var PROPERTY_ZOOMONTOUCHDOWN = "zoomOnTouchDown";
var PROPERTY_TITLE_NORMAL = "title|1";
var PROPERTY_TITLE_HIGHLIGHTED = "title|2";
var PROPERTY_TITLE_DISABLED = "title|3";
var PROPERTY_TITLECOLOR_NORMAL = "titleColor|1";
var PROPERTY_TITLECOLOR_HIGHLIGHTED = "titleColor|2";
var PROPERTY_TITLECOLOR_DISABLED = "titleColor|3";
var PROPERTY_TITLETTF_NORMAL = "titleTTF|1";
var PROPERTY_TITLETTF_HIGHLIGHTED = "titleTTF|2";
var PROPERTY_TITLETTF_DISABLED = "titleTTF|3";
var PROPERTY_TITLETTFSIZE_NORMAL = "titleTTFSize|1";
var PROPERTY_TITLETTFSIZE_HIGHLIGHTED = "titleTTFSize|2";
var PROPERTY_TITLETTFSIZE_DISABLED = "titleTTFSize|4";
var PROPERTY_LABELANCHORPOINT = "labelAnchorPoint";
var PROPERTY_PREFEREDSIZE = "preferedSize";
var PROPERTY_BACKGROUNDSPRITEFRAME_NORMAL = "backgroundSpriteFrame|1";
var PROPERTY_BACKGROUNDSPRITEFRAME_HIGHLIGHTED = "backgroundSpriteFrame|2";
var PROPERTY_BACKGROUNDSPRITEFRAME_DISABLED = "backgroundSpriteFrame|3";
cc.ControlButtonLoader = cc.ControlLoader.extend({_createCCNode:function(parent, ccbReader) {
  return cc.ControlButton.create()
}, onHandlePropTypeCheck:function(node, parent, propertyName, check, ccbReader) {
  if(propertyName == PROPERTY_ZOOMONTOUCHDOWN) {
    node.setZoomOnTouchDown(check)
  }else {
    this._super(node, parent, propertyName, check, ccbReader)
  }
}, onHandlePropTypeString:function(node, parent, propertyName, stringValue, ccbReader) {
  if(propertyName == PROPERTY_TITLE_NORMAL) {
    node.setTitleForState(stringValue, cc.CONTROL_STATE_NORMAL)
  }else {
    if(propertyName == PROPERTY_TITLE_HIGHLIGHTED) {
      node.setTitleForState(stringValue, cc.CONTROL_STATE_HIGHLIGHTED)
    }else {
      if(propertyName == PROPERTY_TITLE_DISABLED) {
        node.setTitleForState(stringValue, cc.CONTROL_STATE_DISABLED)
      }else {
        this._super(node, parent, propertyName, stringValue, ccbReader)
      }
    }
  }
}, onHandlePropTypeFontTTF:function(node, parent, propertyName, fontTTF, ccbReader) {
  if(propertyName == PROPERTY_TITLETTF_NORMAL) {
    node.setTitleTTFForState(fontTTF, cc.CONTROL_STATE_NORMAL)
  }else {
    if(propertyName == PROPERTY_TITLETTF_HIGHLIGHTED) {
      node.setTitleTTFForState(fontTTF, cc.CONTROL_STATE_HIGHLIGHTED)
    }else {
      if(propertyName == PROPERTY_TITLETTF_DISABLED) {
        node.setTitleTTFForState(fontTTF, cc.CONTROL_STATE_DISABLED)
      }else {
        this._super(node, parent, propertyName, fontTTF, ccbReader)
      }
    }
  }
}, onHandlePropTypeFloatScale:function(node, parent, propertyName, floatScale, ccbReader) {
  if(propertyName == PROPERTY_TITLETTFSIZE_NORMAL) {
    node.setTitleTTFSizeForState(floatScale, cc.CONTROL_STATE_NORMAL)
  }else {
    if(propertyName == PROPERTY_TITLETTFSIZE_HIGHLIGHTED) {
      node.setTitleTTFSizeForState(floatScale, cc.CONTROL_STATE_HIGHLIGHTED)
    }else {
      if(propertyName == PROPERTY_TITLETTFSIZE_DISABLED) {
        node.setTitleTTFSizeForState(floatScale, cc.CONTROL_STATE_DISABLED)
      }else {
        this._super(node, parent, propertyName, floatScale, ccbReader)
      }
    }
  }
}, onHandlePropTypePoint:function(node, parent, propertyName, point, ccbReader) {
  if(propertyName == PROPERTY_LABELANCHORPOINT) {
    node.setLabelAnchorPoint(point)
  }else {
    this._super(node, parent, propertyName, point, ccbReader)
  }
}, onHandlePropTypeSize:function(node, parent, propertyName, size, ccbReader) {
  if(propertyName == PROPERTY_PREFEREDSIZE) {
    node.setPreferredSize(size)
  }else {
    this._super(node, parent, propertyName, size, ccbReader)
  }
}, onHandlePropTypeSpriteFrame:function(node, parent, propertyName, spriteFrame, ccbReader) {
  if(propertyName == PROPERTY_BACKGROUNDSPRITEFRAME_NORMAL) {
    if(spriteFrame != null) {
      node.setBackgroundSpriteFrameForState(spriteFrame, cc.CONTROL_STATE_NORMAL)
    }
  }else {
    if(propertyName == PROPERTY_BACKGROUNDSPRITEFRAME_HIGHLIGHTED) {
      if(spriteFrame != null) {
        node.setBackgroundSpriteFrameForState(spriteFrame, cc.CONTROL_STATE_HIGHLIGHTED)
      }
    }else {
      if(propertyName == PROPERTY_BACKGROUNDSPRITEFRAME_DISABLED) {
        if(spriteFrame != null) {
          node.setBackgroundSpriteFrameForState(spriteFrame, cc.CONTROL_STATE_DISABLED)
        }
      }else {
        this._super(node, parent, propertyName, spriteFrame, ccbReader)
      }
    }
  }
}, onHandlePropTypeColor3:function(node, parent, propertyName, ccColor3B, ccbReader) {
  if(propertyName == PROPERTY_TITLECOLOR_NORMAL) {
    node.setTitleColorForState(ccColor3B, cc.CONTROL_STATE_NORMAL)
  }else {
    if(propertyName == PROPERTY_TITLECOLOR_HIGHLIGHTED) {
      node.setTitleColorForState(ccColor3B, cc.CONTROL_STATE_HIGHLIGHTED)
    }else {
      if(propertyName == PROPERTY_TITLECOLOR_DISABLED) {
        node.setTitleColorForState(ccColor3B, cc.CONTROL_STATE_DISABLED)
      }else {
        this._super(node, parent, propertyName, ccColor3B, ccbReader)
      }
    }
  }
}});
cc.ControlButtonLoader.loader = function() {
  return new cc.ControlButtonLoader
};
var PROPERTY_CONTAINER = "container";
var PROPERTY_DIRECTION = "direction";
var PROPERTY_CLIPSTOBOUNDS = "clipsToBounds";
var PROPERTY_BOUNCES = "bounces";
var PROPERTY_SCALE = "scale";
cc.ScrollViewLoader = cc.NodeLoader.extend({_createCCNode:function(parent, ccbReader) {
  return cc.ScrollView.create()
}, onHandlePropTypeSize:function(node, parent, propertyName, size, ccbReader) {
  if(propertyName == PROPERTY_CONTENTSIZE) {
    node.setViewSize(size)
  }else {
    this._super(node, parent, propertyName.size, ccbReader)
  }
}, onHandlePropTypeCCBFile:function(node, parent, propertyName, ccbFileNode, ccbReader) {
  if(propertyName == PROPERTY_CONTAINER) {
    node.setContainer(ccbFileNode);
    node.updateInset()
  }else {
    this._super(node, parent, propertyName, ccbFileNode, ccbReader)
  }
}, onHandlePropTypeCheck:function(node, parent, propertyName, check, ccbReader) {
  if(propertyName == PROPERTY_CLIPSTOBOUNDS) {
    node.setClippingToBounds(check)
  }else {
    if(propertyName == PROPERTY_BOUNCES) {
      node.setBounceable(check)
    }else {
      this._super(node, parent, propertyName, check, ccbReader)
    }
  }
}, onHandlePropTypeFloat:function(node, parent, propertyName, floatValue, ccbReader) {
  if(propertyName == PROPERTY_SCALE) {
    node.setScale(floatValue)
  }else {
    this._super(node, parent, propertyName, floatValue, ccbReader)
  }
}, onHandlePropTypeIntegerLabeled:function(node, parent, propertyName, integerLabeled, ccbReader) {
  if(propertyName == PROPERTY_DIRECTION) {
    node.setDirection(integerLabeled)
  }else {
    this._super(node, parent, propertyName, integerLabeled, ccbReader)
  }
}});
cc.ScrollViewLoader.loader = function() {
  return new cc.ScrollViewLoader
};
var PROPERTY_CONTENTSIZE = "contentSize";
var PROPERTY_SPRITEFRAME = "spriteFrame";
var PROPERTY_COLOR = "color";
var PROPERTY_OPACITY = "opacity";
var PROPERTY_BLENDFUNC = "blendFunc";
var PROPERTY_INSETLEFT = "insetLeft";
var PROPERTY_INSETTOP = "insetTop";
var PROPERTY_INSETRIGHT = "insetRight";
var PROPERTY_INSETBOTTOM = "insetBottom";
cc.Scale9SpriteLoader = cc.NodeLoader.extend({_createCCNode:function(parent, ccbReader) {
  return cc.Scale9Sprite.create()
}, onHandlePropTypeColor3:function(node, parent, propertyName, ccColor3B, ccbReader) {
  if(propertyName == PROPERTY_COLOR) {
    node.setColor(ccColor3B)
  }else {
    this._super(node, parent, propertyName, ccColor3B, ccbReader)
  }
}, onHandlePropTypeByte:function(node, parent, propertyName, byteValue, ccbReader) {
  if(propertyName == PROPERTY_OPACITY) {
    node.setOpacity(byteValue)
  }else {
    this._super(node, parent, propertyName, byteValue, ccbReader)
  }
}, onHandlePropTypeBlendFunc:function(node, parent, propertyName, ccBlendFunc, ccbReader) {
  if(propertyName == PROPERTY_BLENDFUNC) {
  }else {
    this._super(node, parent, propertyName, ccBlendFunc, ccbReader)
  }
}, onHandlePropTypeSpriteFrame:function(node, parent, propertyName, spriteFrame, ccbReader) {
  if(propertyName == PROPERTY_SPRITEFRAME) {
    node.initWithSpriteFrame(spriteFrame)
  }else {
    this._super(node, parent, propertyName, spriteFrame, ccbReader)
  }
}, onHandlePropTypeSize:function(node, parent, propertyName, size, ccbReader) {
  if(propertyName == PROPERTY_CONTENTSIZE) {
  }else {
    if(propertyName == PROPERTY_PREFEREDSIZE) {
      node.setPreferredSize(size)
    }else {
      this._super(node, parent, propertyName, size, ccbReader)
    }
  }
}, onHandlePropTypeFloat:function(node, parent, propertyName, floatValue, ccbReader) {
  if(propertyName == PROPERTY_INSETLEFT) {
    node.setInsetLeft(floatValue)
  }else {
    if(propertyName == PROPERTY_INSETTOP) {
      node.setInsetTop(floatValue)
    }else {
      if(propertyName == PROPERTY_INSETRIGHT) {
        node.setInsetRight(floatValue)
      }else {
        if(propertyName == PROPERTY_INSETBOTTOM) {
          node.setInsetBottom(floatValue)
        }else {
          this._super(node, parent, propertyName, floatValue, ccbReader)
        }
      }
    }
  }
}});
cc.Scale9SpriteLoader.loader = function() {
  return new cc.Scale9SpriteLoader
};
var PROPERTY_FLIP = "flip";
var PROPERTY_DISPLAYFRAME = "displayFrame";
var PROPERTY_COLOR = "color";
var PROPERTY_OPACITY = "opacity";
var PROPERTY_BLENDFUNC = "blendFunc";
cc.SpriteLoader = cc.NodeLoader.extend({_createCCNode:function(parent, ccbReader) {
  return cc.Sprite.create()
}, onHandlePropTypeColor3:function(node, parent, propertyName, color3BValue, ccbReader) {
  if(propertyName == PROPERTY_COLOR) {
    node.setColor(color3BValue)
  }else {
    this._super(node, parent, propertyName, color3BValue, ccbReader)
  }
}, onHandlePropTypeByte:function(node, parent, propertyName, byteValue, ccbReader) {
  if(propertyName == PROPERTY_OPACITY) {
    node.setOpacity(byteValue)
  }else {
    this._super(node, parent, propertyName, byteValue, ccbReader)
  }
}, onHandlePropTypeBlendFunc:function(node, parent, propertyName, ccbBlendFunc, ccbReader) {
  if(propertyName == PROPERTY_BLENDFUNC) {
    node.setBlendFunc(ccbBlendFunc)
  }else {
    this._super(node, parent, propertyName, ccbBlendFunc, ccbReader)
  }
}, onHandlePropTypeSpriteFrame:function(node, parent, propertyName, ccSpriteFrame, ccbReader) {
  if(propertyName == PROPERTY_DISPLAYFRAME) {
    node.setDisplayFrame(ccSpriteFrame)
  }else {
    this._super(node, parent, propertyName, ccSpriteFrame, ccbReader)
  }
}, onHandlePropTypeFlip:function(node, parent, propertyName, flip, ccbReader) {
  if(propertyName == PROPERTY_FLIP) {
    node.setFlipX(flip[0]);
    node.setFlipY(flip[1])
  }else {
    this._super(node, parent, propertyName, flip, ccbReader)
  }
}});
cc.SpriteLoader.loader = function() {
  return new cc.SpriteLoader
};
var PROPERTY_TOUCH_ENABLED = "touchEnabled";
var PROPERTY_ACCELEROMETER_ENABLED = "accelerometerEnabled";
var PROPERTY_IS_MOUSE_ENABLED = "isMouseEnabled";
var PROPERTY_MOUSE_ENABLED = "mouseEnabled";
var PROPERTY_KEYBOARD_ENABLED = "keyboardEnabled";
cc.LayerLoader = cc.NodeLoader.extend({_createCCNode:function(parent, ccbReader) {
  return cc.Layer.create()
}, onHandlePropTypeCheck:function(node, parent, propertyName, check, ccbReader) {
  if(propertyName == PROPERTY_TOUCH_ENABLED) {
    node.setTouchEnabled(check)
  }else {
    if(propertyName == PROPERTY_ACCELEROMETER_ENABLED) {
      node.setAccelerometerEnabled(check)
    }else {
      if(propertyName == PROPERTY_IS_MOUSE_ENABLED || propertyName == PROPERTY_MOUSE_ENABLED) {
        node.setMouseEnabled(check)
      }else {
        if(propertyName == PROPERTY_KEYBOARD_ENABLED) {
          if(node.setKeyboardEnabled && sys.platform == "browser") {
            node.setKeyboardEnabled(check)
          }else {
            cc.log("The property '" + PROPERTY_KEYBOARD_ENABLED + "' is not supported!")
          }
        }else {
          this._super(node, parent, propertyName, check, ccbReader)
        }
      }
    }
  }
}});
cc.LayerLoader.loader = function() {
  return new cc.LayerLoader
};
cc.LayerColorLoader = cc.LayerLoader.extend({_createCCNode:function(parent, ccbReader) {
  return cc.LayerColor.create()
}, onHandlePropTypeColor3:function(node, parent, propertyName, ccColor3B, ccbReader) {
  if(propertyName == PROPERTY_COLOR) {
    node.setColor(ccColor3B)
  }else {
    this._super(node, parent, propertyName, ccColor3B, ccbReader)
  }
}, onHandlePropTypeByte:function(node, parent, propertyName, byteValue, ccbReader) {
  if(propertyName == PROPERTY_OPACITY) {
    node.setOpacity(byteValue)
  }else {
    this._super(node, parent, propertyName, byteValue, ccbReader)
  }
}, onHandlePropTypeBlendFunc:function(node, parent, propertyName, ccBlendFunc, ccbReader) {
  if(propertyName == PROPERTY_BLENDFUNC) {
    node.setBlendFunc(ccBlendFunc)
  }else {
    this._super(node, parent, propertyName, ccBlendFunc, ccbReader)
  }
}});
cc.LayerColorLoader.loader = function() {
  return new cc.LayerColorLoader
};
var PROPERTY_STARTCOLOR = "startColor";
var PROPERTY_ENDCOLOR = "endColor";
var PROPERTY_STARTOPACITY = "startOpacity";
var PROPERTY_ENDOPACITY = "endOpacity";
var PROPERTY_VECTOR = "vector";
cc.LayerGradientLoader = cc.LayerLoader.extend({_createCCNode:function(parent, ccbReader) {
  return cc.LayerGradient.create()
}, onHandlePropTypeColor3:function(node, parent, propertyName, ccColor3B, ccbReader) {
  if(propertyName == PROPERTY_STARTCOLOR) {
    node.setStartColor(ccColor3B)
  }else {
    if(propertyName == PROPERTY_ENDCOLOR) {
      node.setEndColor(ccColor3B)
    }else {
      this._super(node, parent, propertyName, ccColor3B, ccbReader)
    }
  }
}, onHandlePropTypeByte:function(node, parent, propertyName, byteValue, ccbReader) {
  if(propertyName == PROPERTY_STARTOPACITY) {
    node.setStartOpacity(byteValue)
  }else {
    if(propertyName == PROPERTY_ENDOPACITY) {
      node.setEndOpacity(byteValue)
    }else {
      this._super(node, parent, propertyName, byteValue, ccbReader)
    }
  }
}, onHandlePropTypePoint:function(node, parent, propertyName, point, ccbReader) {
  if(propertyName == PROPERTY_VECTOR) {
    node.setVector(point)
  }else {
    this._super(node, parent, propertyName, point, ccbReader)
  }
}, onHandlePropTypeBlendFunc:function(node, parent, propertyName, ccBlendFunc, ccbReader) {
  if(propertyName == PROPERTY_BLENDFUNC) {
    node.setBlendFunc(ccBlendFunc)
  }else {
    this._super(node, parent, propertyName, ccBlendFunc, ccbReader)
  }
}});
cc.LayerGradientLoader.loader = function() {
  return new cc.LayerGradientLoader
};
cc.MenuLoader = cc.LayerLoader.extend({_createCCNode:function(parent, ccbReader) {
  return cc.Menu.create()
}});
cc.MenuLoader.loader = function() {
  return new cc.MenuLoader
};
var PROPERTY_BLOCK = "block";
var PROPERTY_ISENABLED = "isEnabled";
cc.MenuItemLoader = cc.NodeLoader.extend({_createCCNode:function(parent, ccbReader) {
  return null
}, onHandlePropTypeBlock:function(node, parent, propertyName, blockData, ccbReader) {
  if(propertyName == PROPERTY_BLOCK) {
    if(null != blockData) {
      node.setTarget(blockData.selMenuHander, blockData.target)
    }
  }else {
    this._super(node, parent, propertyName, blockData, ccbReader)
  }
}, onHandlePropTypeCheck:function(node, parent, propertyName, check, ccbReader) {
  if(propertyName == PROPERTY_ISENABLED) {
    node.setEnabled(check)
  }else {
    this._super(node, parent, propertyName, check, ccbReader)
  }
}});
var PROPERTY_NORMALDISPLAYFRAME = "normalSpriteFrame";
var PROPERTY_SELECTEDDISPLAYFRAME = "selectedSpriteFrame";
var PROPERTY_DISABLEDDISPLAYFRAME = "disabledSpriteFrame";
cc.MenuItemImageLoader = cc.MenuItemLoader.extend({_createCCNode:function(parent, ccbReader) {
  return cc.MenuItemImage.create()
}, onHandlePropTypeSpriteFrame:function(node, parent, propertyName, spriteFrame, ccbReader) {
  if(propertyName == PROPERTY_NORMALDISPLAYFRAME) {
    if(spriteFrame != null) {
      node.setNormalSpriteFrame(spriteFrame)
    }
  }else {
    if(propertyName == PROPERTY_SELECTEDDISPLAYFRAME) {
      if(spriteFrame != null) {
        node.setSelectedSpriteFrame(spriteFrame)
      }
    }else {
      if(propertyName == PROPERTY_DISABLEDDISPLAYFRAME) {
        if(spriteFrame != null) {
          node.setDisabledSpriteFrame(spriteFrame)
        }
      }else {
        this._super(node, parent, propertyName, spriteFrame, ccbReader)
      }
    }
  }
}});
cc.MenuItemImageLoader.loader = function() {
  return new cc.MenuItemImageLoader
};
var PROPERTY_FONTNAME = "fontName";
var PROPERTY_FONTSIZE = "fontSize";
var PROPERTY_HORIZONTALALIGNMENT = "horizontalAlignment";
var PROPERTY_VERTICALALIGNMENT = "verticalAlignment";
var PROPERTY_STRING = "string";
var PROPERTY_DIMENSIONS = "dimensions";
cc.LabelTTFLoader = cc.NodeLoader.extend({_createCCNode:function(parent, ccbReader) {
  return cc.LabelTTF.create()
}, onHandlePropTypeColor3:function(node, parent, propertyName, ccColor3B, ccbReader) {
  if(propertyName == PROPERTY_COLOR) {
    node.setColor(ccColor3B)
  }else {
    this._super(node, parent, propertyName, ccColor3B, ccbReader)
  }
}, onHandlePropTypeByte:function(node, parent, propertyName, byteValue, ccbReader) {
  if(propertyName == PROPERTY_OPACITY) {
    node.setOpacity(byteValue)
  }else {
    this._super(node, parent, propertyName, byteValue, ccbReader)
  }
}, onHandlePropTypeBlendFunc:function(node, parent, propertyName, ccBlendFunc, ccbReader) {
  if(propertyName == PROPERTY_BLENDFUNC) {
    node.setBlendFunc(ccBlendFunc)
  }else {
    this._super(pNode, pParent, propertyName, ccBlendFunc, ccbReader)
  }
}, onHandlePropTypeFontTTF:function(node, parent, propertyName, fontTTF, ccbReader) {
  if(propertyName == PROPERTY_FONTNAME) {
    node.setFontName(fontTTF)
  }else {
    this._super(node, parent, propertyName, fontTTF, ccbReader)
  }
}, onHandlePropTypeText:function(node, parent, propertyName, textValue, ccbReader) {
  if(propertyName == PROPERTY_STRING) {
    node.setString(textValue)
  }else {
    this._super(node, parent, propertyName, textValue, ccbReader)
  }
}, onHandlePropTypeFloatScale:function(node, parent, propertyName, floatScale, ccbReader) {
  if(propertyName == PROPERTY_FONTSIZE) {
    node.setFontSize(floatScale)
  }else {
    this._super(node, parent, propertyName, floatScale, ccbReader)
  }
}, onHandlePropTypeIntegerLabeled:function(node, parent, propertyName, integerLabeled, ccbReader) {
  if(propertyName == PROPERTY_HORIZONTALALIGNMENT) {
    node.setHorizontalAlignment(integerLabeled)
  }else {
    if(propertyName == PROPERTY_VERTICALALIGNMENT) {
      node.setVerticalAlignment(integerLabeled)
    }else {
      this._super(node, parent, propertyName, integerLabeled, ccbReader)
    }
  }
}, onHandlePropTypeSize:function(node, parent, propertyName, size, ccbReader) {
  if(propertyName == PROPERTY_DIMENSIONS) {
    node.setDimensions(size)
  }else {
    this._super(node, parent, propertyName, size, ccbReader)
  }
}});
cc.LabelTTFLoader.loader = function() {
  return new cc.LabelTTFLoader
};
var PROPERTY_FNTFILE = "fntFile";
cc.LabelBMFontLoader = cc.NodeLoader.extend({_createCCNode:function(parent, ccbReader) {
  return cc.LabelBMFont.create()
}, onHandlePropTypeColor3:function(node, parent, propertyName, ccColor3B, ccbReader) {
  if(propertyName == PROPERTY_COLOR) {
    node.setColor(ccColor3B)
  }else {
    this._super(node, parent, propertyName, ccColor3B, ccbReader)
  }
}, onHandlePropTypeByte:function(node, parent, propertyName, byteValue, ccbReader) {
  if(propertyName == PROPERTY_OPACITY) {
    node.setOpacity(byteValue)
  }else {
    this._super(node, parent, propertyName, byteValue, ccbReader)
  }
}, onHandlePropTypeBlendFunc:function(node, parent, propertyName, ccBlendFunc, ccbReader) {
  if(propertyName == PROPERTY_BLENDFUNC) {
    node.setBlendFunc(ccBlendFunc)
  }else {
    this._super(node, parent, propertyName, ccBlendFunc, ccbReader)
  }
}, onHandlePropTypeFntFile:function(node, parent, propertyName, fntFile, ccbReader) {
  if(propertyName == PROPERTY_FNTFILE) {
    node.setFntFile(fntFile)
  }else {
    this._super(node, parent, propertyName, fntFile, ccbReader)
  }
}, onHandlePropTypeText:function(node, parent, propertyName, textValue, ccbReader) {
  if(propertyName == PROPERTY_STRING) {
    node.setString(textValue)
  }else {
    this._super(node, parent, propertyName, textValue, ccbReader)
  }
}});
cc.LabelBMFontLoader.loader = function() {
  return new cc.LabelBMFontLoader
};
var PROPERTY_EMITERMODE = "emitterMode";
var PROPERTY_POSVAR = "posVar";
var PROPERTY_EMISSIONRATE = "emissionRate";
var PROPERTY_DURATION = "duration";
var PROPERTY_TOTALPARTICLES = "totalParticles";
var PROPERTY_LIFE = "life";
var PROPERTY_STARTSIZE = "startSize";
var PROPERTY_ENDSIZE = "endSize";
var PROPERTY_STARTSPIN = "startSpin";
var PROPERTY_ENDSPIN = "endSpin";
var PROPERTY_ANGLE = "angle";
var PROPERTY_GRAVITY = "gravity";
var PROPERTY_SPEED = "speed";
var PROPERTY_TANGENTIALACCEL = "tangentialAccel";
var PROPERTY_RADIALACCEL = "radialAccel";
var PROPERTY_TEXTURE = "texture";
var PROPERTY_STARTRADIUS = "startRadius";
var PROPERTY_ENDRADIUS = "endRadius";
var PROPERTY_ROTATEPERSECOND = "rotatePerSecond";
cc.ParticleSystemQuadLoader = cc.NodeLoader.extend({_createCCNode:function(parent, ccbReader) {
  return cc.ParticleSystemQuad.create()
}, onHandlePropTypeIntegerLabeled:function(node, parent, propertyName, integerLabeled, ccbReader) {
  if(propertyName == PROPERTY_EMITERMODE) {
    node.setEmitterMode(integerLabeled)
  }else {
    this._super(node, parent, propertyName, integerLabeled, ccbReader)
  }
}, onHandlePropTypePoint:function(node, parent, propertyName, point, ccbReader) {
  if(propertyName == PROPERTY_POSVAR) {
    node.setPosVar(point)
  }else {
    if(propertyName == PROPERTY_GRAVITY) {
      node.setGravity(point)
    }else {
      this._super(node, parent, propertyName, point, ccbReader)
    }
  }
}, onHandlePropTypeFloat:function(node, parent, propertyName, floatValue, ccbReader) {
  if(propertyName == PROPERTY_EMISSIONRATE) {
    node.setEmissionRate(floatValue)
  }else {
    if(propertyName == PROPERTY_DURATION) {
      node.setDuration(floatValue)
    }else {
      this._super(node, parent, propertyName, floatValue, ccbReader)
    }
  }
}, onHandlePropTypeInteger:function(node, parent, propertyName, integerValue, ccbReader) {
  if(propertyName == PROPERTY_TOTALPARTICLES) {
    node.setTotalParticles(integerValue)
  }else {
    this._super(node, parent, propertyName, integerValue, ccbReader)
  }
}, onHandlePropTypeFloatVar:function(node, parent, propertyName, floatVar, ccbReader) {
  if(propertyName == PROPERTY_LIFE) {
    node.setLife(floatVar[0]);
    node.setLifeVar(floatVar[1])
  }else {
    if(propertyName == PROPERTY_STARTSIZE) {
      node.setStartSize(floatVar[0]);
      node.setStartSizeVar(floatVar[1])
    }else {
      if(propertyName == PROPERTY_ENDSIZE) {
        node.setEndSize(floatVar[0]);
        node.setEndSizeVar(floatVar[1])
      }else {
        if(propertyName == PROPERTY_STARTSPIN) {
          node.setStartSpin(floatVar[0]);
          node.setStartSpinVar(floatVar[1])
        }else {
          if(propertyName == PROPERTY_ENDSPIN) {
            node.setEndSpin(floatVar[0]);
            node.setEndSpinVar(floatVar[1])
          }else {
            if(propertyName == PROPERTY_ANGLE) {
              node.setAngle(floatVar[0]);
              node.setAngleVar(floatVar[1])
            }else {
              if(propertyName == PROPERTY_SPEED) {
                node.setSpeed(floatVar[0]);
                node.setSpeedVar(floatVar[1])
              }else {
                if(propertyName == PROPERTY_TANGENTIALACCEL) {
                  node.setTangentialAccel(floatVar[0]);
                  node.setTangentialAccelVar(floatVar[1])
                }else {
                  if(propertyName == PROPERTY_RADIALACCEL) {
                    node.setRadialAccel(floatVar[0]);
                    node.setRadialAccelVar(floatVar[1])
                  }else {
                    if(propertyName == PROPERTY_STARTRADIUS) {
                      node.setStartRadius(floatVar[0]);
                      node.setStartRadiusVar(floatVar[1])
                    }else {
                      if(propertyName == PROPERTY_ENDRADIUS) {
                        node.setEndRadius(floatVar[0]);
                        node.setEndRadiusVar(floatVar[1])
                      }else {
                        if(propertyName == PROPERTY_ROTATEPERSECOND) {
                          node.setRotatePerSecond(floatVar[0]);
                          node.setRotatePerSecondVar(floatVar[1])
                        }else {
                          this._super(node, parent, propertyName, floatVar, ccbReader)
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, onHandlePropTypeColor4FVar:function(node, parent, propertyName, ccColor4FVar, ccbReader) {
  if(propertyName == PROPERTY_STARTCOLOR) {
    node.setStartColor(ccColor4FVar[0]);
    node.setStartColorVar(ccColor4FVar[1])
  }else {
    if(propertyName == PROPERTY_ENDCOLOR) {
      node.setEndColor(ccColor4FVar[0]);
      node.setEndColorVar(ccColor4FVar[1])
    }else {
      this._super(node, parent, propertyName, ccColor4FVar, ccbReader)
    }
  }
}, onHandlePropTypeBlendFunc:function(node, parent, propertyName, ccBlendFunc, ccbReader) {
  if(propertyName == PROPERTY_BLENDFUNC) {
    node.setBlendFunc(ccBlendFunc)
  }else {
    this._super(node, parent, propertyName, ccBlendFunc, ccbReader)
  }
}, onHandlePropTypeTexture:function(node, parent, propertyName, ccTexture2D, ccbReader) {
  if(propertyName == PROPERTY_TEXTURE) {
    node.setTexture(ccTexture2D)
  }else {
    this._super(node, parent, propertyName, ccTexture2D, ccbReader)
  }
}});
cc.ParticleSystemQuadLoader.loader = function() {
  return new cc.ParticleSystemQuadLoader
};
cc.NodeLoaderLibrary = cc.Class.extend({_ccNodeLoaders:null, ctor:function() {
  this._ccNodeLoaders = {}
}, registerDefaultCCNodeLoaders:function() {
  this.registerCCNodeLoader("CCNode", cc.NodeLoader.loader());
  this.registerCCNodeLoader("CCLayer", cc.LayerLoader.loader());
  this.registerCCNodeLoader("CCLayerColor", cc.LayerColorLoader.loader());
  this.registerCCNodeLoader("CCLayerGradient", cc.LayerGradientLoader.loader());
  this.registerCCNodeLoader("CCSprite", cc.SpriteLoader.loader());
  this.registerCCNodeLoader("CCLabelBMFont", cc.LabelBMFontLoader.loader());
  this.registerCCNodeLoader("CCLabelTTF", cc.LabelTTFLoader.loader());
  this.registerCCNodeLoader("CCScale9Sprite", cc.Scale9SpriteLoader.loader());
  this.registerCCNodeLoader("CCScrollView", cc.ScrollViewLoader.loader());
  this.registerCCNodeLoader("CCBFile", cc.BuilderFileLoader.loader());
  this.registerCCNodeLoader("CCMenu", cc.MenuLoader.loader());
  this.registerCCNodeLoader("CCMenuItemImage", cc.MenuItemImageLoader.loader());
  this.registerCCNodeLoader("CCControlButton", cc.ControlButtonLoader.loader());
  this.registerCCNodeLoader("CCParticleSystemQuad", cc.ParticleSystemQuadLoader.loader())
}, registerCCNodeLoader:function(className, ccNodeLoader) {
  this._ccNodeLoaders[className] = ccNodeLoader
}, unregisterCCNodeLoader:function(className) {
  if(this._ccNodeLoaders.hasOwnProperty(className)) {
    delete this._ccNodeLoaders[className]
  }
}, getCCNodeLoader:function(className) {
  if(this._ccNodeLoaders.hasOwnProperty(className)) {
    return this._ccNodeLoaders[className]
  }
  return null
}, purge:function(releaseCCNodeLoaders) {
  if(releaseCCNodeLoaders) {
    for(var className in this._ccNodeLoaders) {
      delete this._ccNodeLoaders[className]
    }
  }
  this._ccNodeLoaders = {}
}});
cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = null;
cc.NodeLoaderLibrary.library = function() {
  return new cc.NodeLoaderLibrary
};
cc.NodeLoaderLibrary.sharedCCNodeLoaderLibrary = function() {
  if(cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary == null) {
    cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = new cc.NodeLoaderLibrary;
    cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary.registerDefaultCCNodeLoaders()
  }
  return cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary
};
cc.NodeLoaderLibrary.purgeSharedCCNodeLoaderLibrary = function() {
  cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = null
};
cc.NodeLoaderLibrary.newDefaultCCNodeLoaderLibrary = function() {
  var ccNodeLoaderLibrary = cc.NodeLoaderLibrary.library();
  ccNodeLoaderLibrary.registerDefaultCCNodeLoaders();
  return ccNodeLoaderLibrary
};
var CCB_VERSION = 5;
var CCB_PROPTYPE_POSITION = 0;
var CCB_PROPTYPE_SIZE = 1;
var CCB_PROPTYPE_POINT = 2;
var CCB_PROPTYPE_POINTLOCK = 3;
var CCB_PROPTYPE_SCALELOCK = 4;
var CCB_PROPTYPE_DEGREES = 5;
var CCB_PROPTYPE_INTEGER = 6;
var CCB_PROPTYPE_FLOAT = 7;
var CCB_PROPTYPE_FLOATVAR = 8;
var CCB_PROPTYPE_CHECK = 9;
var CCB_PROPTYPE_SPRITEFRAME = 10;
var CCB_PROPTYPE_TEXTURE = 11;
var CCB_PROPTYPE_BYTE = 12;
var CCB_PROPTYPE_COLOR3 = 13;
var CCB_PROPTYPE_COLOR4VAR = 14;
var CCB_PROPTYPE_FLIP = 15;
var CCB_PROPTYPE_BLENDMODE = 16;
var CCB_PROPTYPE_FNTFILE = 17;
var CCB_PROPTYPE_TEXT = 18;
var CCB_PROPTYPE_FONTTTF = 19;
var CCB_PROPTYPE_INTEGERLABELED = 20;
var CCB_PROPTYPE_BLOCK = 21;
var CCB_PROPTYPE_ANIMATION = 22;
var CCB_PROPTYPE_CCBFILE = 23;
var CCB_PROPTYPE_STRING = 24;
var CCB_PROPTYPE_BLOCKCCCONTROL = 25;
var CCB_PROPTYPE_FLOATSCALE = 26;
var CCB_PROPTYPE_FLOATXY = 27;
var CCB_FLOAT0 = 0;
var CCB_FLOAT1 = 1;
var CCB_FLOAT_MINUS1 = 2;
var CCB_FLOAT05 = 3;
var CCB_FLOAT_INTEGER = 4;
var CCB_FLOAT_FULL = 5;
var CCB_PLATFORM_ALL = 0;
var CCB_PLATFORM_IOS = 1;
var CCB_PLATFORM_MAC = 2;
var CCB_TARGETTYPE_NONE = 0;
var CCB_TARGETTYPE_DOCUMENTROOT = 1;
var CCB_TARGETTYPE_OWNER = 2;
var CCB_KEYFRAME_EASING_INSTANT = 0;
var CCB_KEYFRAME_EASING_LINEAR = 1;
var CCB_KEYFRAME_EASING_CUBIC_IN = 2;
var CCB_KEYFRAME_EASING_CUBIC_OUT = 3;
var CCB_KEYFRAME_EASING_CUBIC_INOUT = 4;
var CCB_KEYFRAME_EASING_ELASTIC_IN = 5;
var CCB_KEYFRAME_EASING_ELASTIC_OUT = 6;
var CCB_KEYFRAME_EASING_ELASTIC_INOUT = 7;
var CCB_KEYFRAME_EASING_BOUNCE_IN = 8;
var CCB_KEYFRAME_EASING_BOUNCE_OUT = 9;
var CCB_KEYFRAME_EASING_BOUNCE_INOUT = 10;
var CCB_KEYFRAME_EASING_BACK_IN = 11;
var CCB_KEYFRAME_EASING_BACK_OUT = 12;
var CCB_KEYFRAME_EASING_BACK_INOUT = 13;
var CCB_POSITIONTYPE_RELATIVE_BOTTOM_LEFT = 0;
var CCB_POSITIONTYPE_RELATIVE_TOP_LEFT = 1;
var CCB_POSITIONTYPE_RELATIVE_TOP_RIGHT = 2;
var CCB_POSITIONTYPE_RELATIVE_BOTTOM_RIGHT = 3;
var CCB_POSITIONTYPE_PERCENT = 4;
var CCB_POSITIONTYPE_MULTIPLY_RESOLUTION = 5;
var CCB_SIZETYPE_ABSOLUTE = 0;
var CCB_SIZETYPE_PERCENT = 1;
var CCB_SIZETYPE_RELATIVE_CONTAINER = 2;
var CCB_SIZETYPE_HORIZONTAL_PERCENT = 3;
var CCB_SIZETYPE_VERTICAL_PERCENT = 4;
var CCB_SIZETYPE_MULTIPLY_RESOLUTION = 5;
var CCB_SCALETYPE_ABSOLUTE = 0;
var CCB_SCALETYPE_MULTIPLY_RESOLUTION = 1;
var _ccbGlobalContext = _ccbGlobalContext || window;
cc.BuilderFile = cc.Node.extend({_ccbFileNode:null, getCCBFileNode:function() {
  return this._ccbFileNode
}, setCCBFileNode:function(node) {
  this._ccbFileNode = node
}});
cc.BuilderFile.create = function() {
  return new cc.BuilderFile
};
cc.BuilderReader = cc.Class.extend({_jsControlled:false, _data:null, _ccbRootPath:"", _bytes:0, _currentByte:0, _currentBit:0, _stringCache:null, _loadedSpriteSheets:null, _owner:null, _actionManager:null, _animationManagers:null, _animatedProps:null, _ccNodeLoaderLibrary:null, _ccNodeLoaderListener:null, _ccbMemberVariableAssigner:null, _ccbSelectorResolver:null, _ownerOutletNames:null, _ownerOutletNodes:null, _nodesWithAnimationManagers:null, _animationManagerForNodes:null, _ownerCallbackNames:null, 
_ownerCallbackNodes:null, _hasScriptingOwner:false, ctor:function(ccNodeLoaderLibrary, ccbMemberVariableAssigner, ccbSelectorResolver, ccNodeLoaderListener) {
  this._stringCache = [];
  this._loadedSpriteSheets = [];
  this._currentBit = -1;
  this._currentByte = -1;
  if(arguments.length != 0) {
    if(ccNodeLoaderLibrary instanceof cc.BuilderReader) {
      var ccbReader = ccNodeLoaderLibrary;
      this._loadedSpriteSheets = ccbReader._loadedSpriteSheets;
      this._ccNodeLoaderLibrary = ccbReader._ccNodeLoaderLibrary;
      this._ccbMemberVariableAssigner = ccbReader._ccbMemberVariableAssigner;
      this._ccbSelectorResolver = ccbReader._ccbSelectorResolver;
      this._ccNodeLoaderListener = ccbReader._ccNodeLoaderListener;
      this._ownerCallbackNames = ccbReader._ownerCallbackNames;
      this._ownerCallbackNodes = ccbReader._ownerCallbackNodes;
      this._ownerOutletNames = ccbReader._ownerOutletNames;
      this._ownerOutletNodes = ccbReader._ownerOutletNodes;
      this._ccbRootPath = ccbReader._ccbRootPath
    }else {
      this._ccNodeLoaderLibrary = ccNodeLoaderLibrary;
      this._ccbMemberVariableAssigner = ccbMemberVariableAssigner;
      this._ccbSelectorResolver = ccbSelectorResolver;
      this._ccNodeLoaderListener = ccNodeLoaderListener
    }
  }
}, getCCBRootPath:function() {
  return this._ccbRootPath
}, setCCBRootPath:function(rootPath) {
  this._ccbRootPath = rootPath
}, initWithData:function(data, owner) {
  this._actionManager = new cc.BuilderAnimationManager;
  this._data = data;
  this._bytes = data.length;
  this._currentBit = 0;
  this._currentByte = 0;
  this._owner = owner;
  this._actionManager.setRootContainerSize(cc.Director.getInstance().getWinSize());
  return true
}, readNodeGraphFromFile:function(ccbFileName, owner, parentSize, animationManager) {
  if(parentSize == null) {
    parentSize = cc.Director.getInstance().getWinSize()
  }else {
    if(parentSize instanceof cc.BuilderAnimationManager) {
      animationManager = parentSize;
      parentSize = cc.Director.getInstance().getWinSize()
    }
  }
  var path = cc.FileUtils.getInstance().fullPathFromRelativePath(ccbFileName);
  var data = cc.FileUtils.getInstance().getByteArrayFromFile(path);
  return this.readNodeGraphFromData(data, owner, parentSize, animationManager)
}, readNodeGraphFromData:function(data, owner, parentSize, animationManager) {
  this.initWithData(data, owner);
  this._actionManager.setRootContainerSize(parentSize);
  this._actionManager.setOwner(owner);
  this._ownerOutletNames = [];
  this._ownerOutletNodes = [];
  this._ownerCallbackNames = [];
  this._ownerCallbackNodes = [];
  this._animationManagers = new cc._Dictionary;
  var nodeGraph = this.readFileWithCleanUp(true);
  if(nodeGraph && this._actionManager.getAutoPlaySequenceId() != -1) {
    this._actionManager.runAnimations(this._actionManager.getAutoPlaySequenceId(), 0)
  }
  if(this._jsControlled) {
    this._nodesWithAnimationManagers = [];
    this._animationManagerForNodes = [];
    var getAllKeys = this._animationManagers.allKeys();
    for(var i = 0;i < getAllKeys.length;i++) {
      this._nodesWithAnimationManagers.push(getAllKeys[i]);
      this._animationManagerForNodes.push(this._animationManagers.objectForKey(getAllKeys[i]))
    }
  }
  return nodeGraph
}, createSceneWithNodeGraphFromFile:function(ccbFileName, owner, parentSize, animationManager) {
  var node = this.readNodeGraphFromFile(ccbFileName, owner, parentSize, animationManager);
  var scene = cc.Scene.create();
  scene.addChild(node);
  return scene
}, getCCBMemberVariableAssigner:function() {
  return this._ccbMemberVariableAssigner
}, getCCBSelectorResolver:function() {
  return this._ccbSelectorResolver
}, getAnimationManager:function() {
  return this._actionManager
}, setAnimationManager:function(animationManager) {
  this._actionManager = animationManager
}, getAnimatedProperties:function() {
  return this._animatedProps
}, getLoadedSpriteSheet:function() {
  return this._loadedSpriteSheets
}, getOwner:function() {
  return this._owner
}, readInt:function(signed) {
  var numBits = 0;
  while(!this._getBit()) {
    numBits++
  }
  var current = 0;
  for(var a = numBits - 1;a >= 0;a--) {
    if(this._getBit()) {
      current |= 1 << a
    }
  }
  current |= 1 << numBits;
  var num;
  if(signed) {
    var s = current % 2;
    if(s) {
      num = 0 | current / 2
    }else {
      num = 0 | -current / 2
    }
  }else {
    num = current - 1
  }
  this._alignBits();
  return num
}, readByte:function() {
  var byteValue = this._data[this._currentByte];
  this._currentByte++;
  return byteValue
}, readBool:function() {
  return 0 != this.readByte()
}, readFloat:function() {
  var type = this.readByte();
  switch(type) {
    case CCB_FLOAT0:
      return 0;
    case CCB_FLOAT1:
      return 1;
    case CCB_FLOAT_MINUS1:
      return-1;
    case CCB_FLOAT05:
      return 0.5;
    case CCB_FLOAT_INTEGER:
      return this.readInt(true);
    default:
      var pF = this._decodeFloat(23, 8);
      return pF
  }
}, _decodeFloat:function(precisionBits, exponentBits) {
  var length = precisionBits + exponentBits + 1;
  var size = length >> 3;
  this._checkSize(length);
  var bias = Math.pow(2, exponentBits - 1) - 1;
  var signal = this._readBitsOnly(precisionBits + exponentBits, 1, size);
  var exponent = this._readBitsOnly(precisionBits, exponentBits, size);
  var significand = 0;
  var divisor = 2;
  var curByte = 0;
  do {
    var byteValue = this._readByteOnly(++curByte, size);
    var startBit = precisionBits % 8 || 8;
    var mask = 1 << startBit;
    while(mask >>= 1) {
      if(byteValue & mask) {
        significand += 1 / divisor
      }
      divisor *= 2
    }
  }while(precisionBits -= startBit);
  this._currentByte += size;
  return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand) : 0)
}, _readBitsOnly:function(start, length, size) {
  var offsetLeft = (start + length) % 8;
  var offsetRight = start % 8;
  var curByte = size - (start >> 3) - 1;
  var lastByte = size + (-(start + length) >> 3);
  var diff = curByte - lastByte;
  var sum = this._readByteOnly(curByte, size) >> offsetRight & (1 << (diff ? 8 - offsetRight : length)) - 1;
  if(diff && offsetLeft) {
    sum += (this._readByteOnly(lastByte++, size) & (1 << offsetLeft) - 1) << (diff-- << 3) - offsetRight
  }
  while(diff) {
    sum += this._shl(this._readByteOnly(lastByte++, size), (diff-- << 3) - offsetRight)
  }
  return sum
}, _readByteOnly:function(i, size) {
  return this._data[this._currentByte + size - i - 1]
}, _shl:function(a, b) {
  for(++b;--b;a = ((a %= 2147483647 + 1) & 1073741824) == 1073741824 ? a * 2 : (a - 1073741824) * 2 + 2147483647 + 1) {
  }
  return a
}, _checkSize:function(neededBits) {
  if(!(this._currentByte + Math.ceil(neededBits / 8) < this._data.length)) {
    throw new Error("Index out of bound");
  }
}, readCachedString:function() {
  return this._stringCache[this.readInt(false)]
}, isJSControlled:function() {
  return this._jsControlled
}, getOwnerCallbackNames:function() {
  return this._ownerCallbackNames
}, getOwnerCallbackNodes:function() {
  return this._ownerCallbackNodes
}, getOwnerOutletNames:function() {
  return this._ownerOutletNames
}, getOwnerOutletNodes:function() {
  return this._ownerOutletNodes
}, getNodesWithAnimationManagers:function() {
  return this._nodesWithAnimationManagers
}, getAnimationManagersForNodes:function() {
  return this._animationManagerForNodes
}, getAnimationManagers:function() {
  return this._animationManagers
}, setAnimationManagers:function(animationManagers) {
  this._animationManagers = animationManagers
}, addOwnerCallbackName:function(name) {
  this._ownerCallbackNames.push(name)
}, addOwnerCallbackNode:function(node) {
  this._ownerCallbackNodes.push(node)
}, addDocumentCallbackName:function(name) {
  this._actionManager.addDocumentCallbackName(name)
}, addDocumentCallbackNode:function(node) {
  this._actionManager.addDocumentCallbackNode(node)
}, readFileWithCleanUp:function(cleanUp) {
  if(!this._readHeader()) {
    return null
  }
  if(!this._readStringCache()) {
    return null
  }
  if(!this._readSequences()) {
    return null
  }
  var node = this._readNodeGraph();
  this._animationManagers.setObject(this._actionManager, node);
  if(cleanUp) {
    this._cleanUpNodeGraph(node)
  }
  return node
}, _cleanUpNodeGraph:function(node) {
  node.setUserObject(null);
  var getChildren = node.getChildren();
  for(var i = 0;i < getChildren.length;i++) {
    this._cleanUpNodeGraph(getChildren[i])
  }
}, _readCallbackKeyframesForSeq:function(seq) {
  var numKeyframes = this.readInt(false);
  if(!numKeyframes) {
    return true
  }
  var channel = new cc.BuilderSequenceProperty;
  for(var i = 0;i < numKeyframes;i++) {
    var time = this.readFloat();
    var callbackName = this.readCachedString();
    var callbackType = this.readInt(false);
    var value = [callbackName, callbackType];
    var keyframe = new cc.BuilderKeyframe;
    keyframe.setTime(time);
    keyframe.setValue(value);
    if(this._jsControlled) {
      this._actionManager.getKeyframeCallbacks().push(callbackType + ":" + callbackName)
    }
    channel.getKeyframes().push(keyframe)
  }
  seq.setCallbackChannel(channel);
  return true
}, _readSoundKeyframesForSeq:function(seq) {
  var numKeyframes = this.readInt(false);
  if(!numKeyframes) {
    return true
  }
  var channel = new cc.BuilderSequenceProperty;
  for(var i = 0;i < numKeyframes;i++) {
    var time = this.readFloat();
    var soundFile = this.readCachedString();
    var pitch = this.readFloat();
    var pan = this.readFloat();
    var gain = this.readFloat();
    var value = [soundFile, pitch, pan, gain];
    var keyframe = new cc.BuilderKeyframe;
    keyframe.setTime(time);
    keyframe.setValue(value);
    channel.getKeyframes().push(keyframe)
  }
  seq.setSoundChannel(channel);
  return true
}, _readSequences:function() {
  var sequences = this._actionManager.getSequences();
  var numSeqs = this.readInt(false);
  for(var i = 0;i < numSeqs;i++) {
    var seq = new cc.BuilderSequence;
    seq.setDuration(this.readFloat());
    seq.setName(this.readCachedString());
    seq.setSequenceId(this.readInt(false));
    seq.setChainedSequenceId(this.readInt(true));
    if(!this._readCallbackKeyframesForSeq(seq)) {
      return false
    }
    if(!this._readSoundKeyframesForSeq(seq)) {
      return false
    }
    sequences.push(seq)
  }
  this._actionManager.setAutoPlaySequenceId(this.readInt(true));
  return true
}, readKeyframe:function(type) {
  var keyframe = new cc.BuilderKeyframe;
  keyframe.setTime(this.readFloat());
  var easingType = this.readInt(false);
  var easingOpt = 0;
  var value = null;
  if(easingType === CCB_KEYFRAME_EASING_CUBIC_IN || easingType === CCB_KEYFRAME_EASING_CUBIC_OUT || easingType === CCB_KEYFRAME_EASING_CUBIC_INOUT || easingType === CCB_KEYFRAME_EASING_ELASTIC_IN || easingType === CCB_KEYFRAME_EASING_ELASTIC_OUT || easingType === CCB_KEYFRAME_EASING_ELASTIC_INOUT) {
    easingOpt = this.readFloat()
  }
  keyframe.setEasingType(easingType);
  keyframe.setEasingOpt(easingOpt);
  if(type == CCB_PROPTYPE_CHECK) {
    value = this.readBool()
  }else {
    if(type == CCB_PROPTYPE_BYTE) {
      value = this.readByte()
    }else {
      if(type == CCB_PROPTYPE_COLOR3) {
        var c = cc.c3(this.readByte(), this.readByte(), this.readByte());
        value = cc.Color3BWapper.create(c)
      }else {
        if(type == CCB_PROPTYPE_FLOATXY) {
          value = [this.readFloat(), this.readFloat()]
        }else {
          if(type == CCB_PROPTYPE_DEGREES) {
            value = this.readFloat()
          }else {
            if(type == CCB_PROPTYPE_SCALELOCK || type == CCB_PROPTYPE_POSITION || type == CCB_PROPTYPE_FLOATXY) {
              value = [this.readFloat(), this.readFloat()]
            }else {
              if(type == CCB_PROPTYPE_SPRITEFRAME) {
                var spriteSheet = this.readCachedString();
                var spriteFile = this.readCachedString();
                if(spriteSheet == "") {
                  spriteFile = this._ccbRootPath + spriteFile;
                  var texture = cc.TextureCache.getInstance().addImage(spriteFile);
                  var bounds;
                  if(cc.renderContextType == cc.CANVAS) {
                    bounds = cc.RectMake(0, 0, texture.width, texture.height)
                  }else {
                    bounds = cc.RectMake(0, 0, texture.getContentSize().width, texture.getContentSize().height)
                  }
                  value = cc.SpriteFrame.createWithTexture(texture, bounds)
                }else {
                  spriteSheet = this._ccbRootPath + spriteSheet;
                  var frameCache = cc.SpriteFrameCache.getInstance();
                  if(this._loadedSpriteSheets.indexOf(spriteSheet) == -1) {
                    frameCache.addSpriteFrames(spriteSheet);
                    this._loadedSpriteSheets.push(spriteSheet)
                  }
                  value = frameCache.getSpriteFrame(spriteFile)
                }
              }
            }
          }
        }
      }
    }
  }
  keyframe.setValue(value);
  return keyframe
}, _readHeader:function() {
  if(this._data == null) {
    return false
  }
  var magicBytes = this._readStringFromBytes(this._currentByte, 4, true);
  this._currentByte += 4;
  if(magicBytes != "ccbi") {
    return false
  }
  var version = this.readInt(false);
  if(version != CCB_VERSION) {
    cc.log("WARNING! Incompatible ccbi file version (file: " + version + " reader: " + CCB_VERSION + ")");
    return false
  }
  this._jsControlled = this.readBool();
  this._actionManager._jsControlled = this._jsControlled;
  return true
}, _readStringFromBytes:function(startIndex, strLen, reverse) {
  reverse = reverse || false;
  var strValue = "";
  var i;
  if(reverse) {
    for(i = strLen - 1;i >= 0;i--) {
      strValue += String.fromCharCode(this._data[this._currentByte + i])
    }
  }else {
    for(i = 0;i < strLen;i++) {
      strValue += String.fromCharCode(this._data[this._currentByte + i])
    }
  }
  return strValue
}, _readStringCache:function() {
  var numStrings = this.readInt(false);
  for(var i = 0;i < numStrings;i++) {
    this._readStringCacheEntry()
  }
  return true
}, _readStringCacheEntry:function() {
  var b0 = this.readByte();
  var b1 = this.readByte();
  var numBytes = b0 << 8 | b1;
  var str = "";
  for(var i = 0;i < numBytes;i++) {
    var hexChar = this._data[this._currentByte + i].toString("16").toUpperCase();
    hexChar = hexChar.length > 1 ? hexChar : "0" + hexChar;
    str += "%" + hexChar
  }
  str = decodeURIComponent(str);
  this._currentByte += numBytes;
  this._stringCache.push(str)
}, _readNodeGraph:function(parent) {
  var className = this.readCachedString();
  var jsControlledName;
  if(this._jsControlled) {
    jsControlledName = this.readCachedString()
  }
  var memberVarAssignmentType = this.readInt(false);
  var memberVarAssignmentName;
  if(memberVarAssignmentType != CCB_TARGETTYPE_NONE) {
    memberVarAssignmentName = this.readCachedString()
  }
  var ccNodeLoader = this._ccNodeLoaderLibrary.getCCNodeLoader(className);
  if(!ccNodeLoader) {
    ccNodeLoader = this._ccNodeLoaderLibrary.getCCNodeLoader("CCNode")
  }
  var node = ccNodeLoader.loadCCNode(parent, this);
  if(!this._actionManager.getRootNode()) {
    this._actionManager.setRootNode(node)
  }
  if(this._jsControlled && node == this._actionManager.getRootNode()) {
    this._actionManager.setDocumentControllerName(jsControlledName)
  }
  var seqs = new cc._Dictionary;
  this._animatedProps = [];
  var i;
  var numSequence = this.readInt(false);
  for(i = 0;i < numSequence;++i) {
    var seqId = this.readInt(false);
    var seqNodeProps = new cc._Dictionary;
    var numProps = this.readInt(false);
    for(var j = 0;j < numProps;++j) {
      var seqProp = new cc.BuilderSequenceProperty;
      seqProp.setName(this.readCachedString());
      seqProp.setType(this.readInt(false));
      this._animatedProps.push(seqProp.getName());
      var numKeyframes = this.readInt(false);
      for(var k = 0;k < numKeyframes;++k) {
        var keyFrame = this.readKeyframe(seqProp.getType());
        seqProp.getKeyframes().push(keyFrame)
      }
      seqNodeProps.setObject(seqProp, seqProp.getName())
    }
    seqs.setObject(seqNodeProps, seqId)
  }
  if(seqs.count() > 0) {
    this._actionManager.addNode(node, seqs)
  }
  ccNodeLoader.parseProperties(node, parent, this);
  if(node instanceof cc.BuilderFile) {
    var embeddedNode = node.getCCBFileNode();
    embeddedNode.setPosition(node.getPosition());
    embeddedNode.setRotation(node.getRotation());
    embeddedNode.setScale(node.getScale());
    embeddedNode.setTag(node.getTag());
    embeddedNode.setVisible(true);
    embeddedNode.ignoreAnchorPointForPosition(node.isIgnoreAnchorPointForPosition());
    node.setCCBFileNode(null);
    node = embeddedNode
  }
  if(memberVarAssignmentType != CCB_TARGETTYPE_NONE) {
    if(!this._jsControlled) {
      var target = null;
      if(memberVarAssignmentType == CCB_TARGETTYPE_DOCUMENTROOT) {
        target = this._actionManager.getRootNode()
      }else {
        if(memberVarAssignmentType == CCB_TARGETTYPE_OWNER) {
          target = this._owner
        }
      }
      if(target != null) {
        var assigned = false;
        if(target != null && target.onAssignCCBMemberVariable) {
          assigned = target.onAssignCCBMemberVariable(target, memberVarAssignmentName, node)
        }
        if(!assigned && this._ccbMemberVariableAssigner != null && this._ccbMemberVariableAssigner.onAssignCCBMemberVariable) {
          this._ccbMemberVariableAssigner.onAssignCCBMemberVariable(target, memberVarAssignmentName, node)
        }
      }
    }else {
      if(memberVarAssignmentType == CCB_TARGETTYPE_DOCUMENTROOT) {
        this._actionManager.addDocumentOutletName(memberVarAssignmentName);
        this._actionManager.addDocumentOutletNode(node)
      }else {
        this._ownerOutletNames.push(memberVarAssignmentName);
        this._ownerOutletNodes.push(node)
      }
    }
  }
  if(ccNodeLoader.getCustomProperties().length > 0) {
    var customAssigned = false;
    if(!this._jsControlled) {
      var target = node;
      if(target != null && target.onAssignCCBCustomProperty != null) {
        var customProperties = ccNodeLoader.getCustomProperties();
        var customPropKeys = customProperties.allKeys();
        for(i = 0;i < customPropKeys.length;i++) {
          var customPropValue = customProperties.objectForKey(customPropKeys[i]);
          customAssigned = target.onAssignCCBCustomProperty(target, customPropKeys[i], customPropValue);
          if(!customAssigned && this._ccbMemberVariableAssigner != null && this._ccbMemberVariableAssigner.onAssignCCBCustomProperty != null) {
            customAssigned = this._ccbMemberVariableAssigner.onAssignCCBCustomProperty(target, customPropKeys[i], customPropValue)
          }
        }
      }
    }
  }
  this._animatedProps = null;
  var numChildren = this.readInt(false);
  for(i = 0;i < numChildren;i++) {
    var child = this._readNodeGraph(node);
    node.addChild(child)
  }
  if(node != null && node.onNodeLoaded) {
    node.onNodeLoaded(node, ccNodeLoader)
  }else {
    if(this._ccNodeLoaderListener != null) {
      this._ccNodeLoaderListener.onNodeLoaded(node, ccNodeLoader)
    }
  }
  return node
}, _getBit:function() {
  var bit = (this._data[this._currentByte] & 1 << this._currentBit) != 0;
  this._currentBit++;
  if(this._currentBit >= 8) {
    this._currentBit = 0;
    this._currentByte++
  }
  return bit
}, _alignBits:function() {
  if(this._currentBit) {
    this._currentBit = 0;
    this._currentByte++
  }
}, _readUTF8:function() {
}});
cc.BuilderReader._ccbResolutionScale = 1;
cc.BuilderReader.setResolutionScale = function(scale) {
  cc.BuilderReader._ccbResolutionScale = scale
};
cc.BuilderReader.getResolutionScale = function() {
  return cc.BuilderReader._ccbResolutionScale
};
cc.BuilderReader.loadAsScene = function(ccbFilePath, owner, parentSize, ccbRootPath) {
  ccbRootPath = ccbRootPath || cc.BuilderReader.getResourcePath();
  var getNode = cc.BuilderReader.load(ccbFilePath, owner, parentSize, ccbRootPath);
  var scene = cc.Scene.create();
  scene.addChild(getNode);
  return scene
};
cc.BuilderReader.load = function(ccbFilePath, owner, parentSize, ccbRootPath) {
  ccbRootPath = ccbRootPath || cc.BuilderReader.getResourcePath();
  var reader = new cc.BuilderReader(cc.NodeLoaderLibrary.newDefaultCCNodeLoaderLibrary());
  reader.setCCBRootPath(ccbRootPath);
  if(ccbFilePath.toLowerCase().lastIndexOf(".ccbi") != ccbFilePath.length - 5) {
    ccbFilePath = ccbFilePath + ".ccbi"
  }
  var node = reader.readNodeGraphFromFile(ccbFilePath, owner, parentSize);
  var i;
  var callbackName, callbackNode, outletName, outletNode;
  if(owner) {
    var ownerCallbackNames = reader.getOwnerCallbackNames();
    var ownerCallbackNodes = reader.getOwnerCallbackNodes();
    for(i = 0;i < ownerCallbackNames.length;i++) {
      callbackName = ownerCallbackNames[i];
      callbackNode = ownerCallbackNodes[i];
      callbackNode.setCallback(owner[callbackName], owner)
    }
    var ownerOutletNames = reader.getOwnerOutletNames();
    var ownerOutletNodes = reader.getOwnerOutletNodes();
    for(i = 0;i < ownerOutletNames.length;i++) {
      outletName = ownerOutletNames[i];
      outletNode = ownerOutletNodes[i];
      owner[outletName] = outletNode
    }
  }
  var nodesWithAnimationManagers = reader.getNodesWithAnimationManagers();
  var animationManagersForNodes = reader.getAnimationManagersForNodes();
  if(!nodesWithAnimationManagers || !animationManagersForNodes) {
    return node
  }
  for(i = 0;i < nodesWithAnimationManagers.length;i++) {
    var innerNode = nodesWithAnimationManagers[i];
    var animationManager = animationManagersForNodes[i];
    var j;
    innerNode.animationManager = animationManager;
    var documentControllerName = animationManager.getDocumentControllerName();
    if(!documentControllerName) {
      continue
    }
    var controller = new _ccbGlobalContext[documentControllerName];
    controller.controllerName = documentControllerName;
    innerNode.controller = controller;
    controller.rootNode = innerNode;
    var documentCallbackNames = animationManager.getDocumentCallbackNames();
    var documentCallbackNodes = animationManager.getDocumentCallbackNodes();
    for(j = 0;j < documentCallbackNames.length;j++) {
      callbackName = documentCallbackNames[j];
      callbackNode = documentCallbackNodes[j];
      callbackNode.setCallback(controller[callbackName], controller)
    }
    var documentOutletNames = animationManager.getDocumentOutletNames();
    var documentOutletNodes = animationManager.getDocumentOutletNodes();
    for(j = 0;j < documentOutletNames.length;j++) {
      outletName = documentOutletNames[j];
      outletNode = documentOutletNodes[j];
      controller[outletName] = outletNode
    }
    if(controller.onDidLoadFromCCB && typeof controller.onDidLoadFromCCB == "function") {
      controller.onDidLoadFromCCB()
    }
    var keyframeCallbacks = animationManager.getKeyframeCallbacks();
    for(j = 0;j < keyframeCallbacks.length;j++) {
      var callbackSplit = keyframeCallbacks[j].split(":");
      var callbackType = callbackSplit[0];
      var callbackName = callbackSplit[1];
      if(callbackType == 1) {
        var callfunc = cc.CallFunc.create(controller[callbackName], controller);
        animationManager.setCallFunc(callfunc, keyframeCallbacks[j])
      }else {
        if(callbackType == 2 && owner) {
          var callfunc = cc.CallFunc.create(owner[callbackName], owner);
          animationManager.setCallFunc(callfunc, keyframeCallbacks[j])
        }
      }
    }
  }
  return node
};
cc.BuilderReader._resourcePath = "";
cc.BuilderReader.setResourcePath = function(rootPath) {
  cc.BuilderReader._resourcePath = rootPath
};
cc.BuilderReader.getResourcePath = function() {
  return cc.BuilderReader._resourcePath
};
cc.BuilderReader.lastPathComponent = function(pathStr) {
  var slashPos = pathStr.lastIndexOf("/");
  if(slashPos != -1) {
    return pathStr.substring(slashPos + 1, pathStr.length - slashPos)
  }
  return pathStr
};
cc.BuilderReader.deletePathExtension = function(pathStr) {
  var dotPos = pathStr.lastIndexOf(".");
  if(dotPos != -1) {
    return pathStr.substring(0, dotPos)
  }
  return pathStr
};
cc.BuilderReader.toLowerCase = function(sourceStr) {
  return sourceStr.toLowerCase()
};
cc.BuilderReader.endsWith = function(sourceStr, ending) {
  if(sourceStr.length >= ending.length) {
    return sourceStr.lastIndexOf(ending) == 0
  }else {
    return false
  }
};
cc.BuilderReader.concat = function(stringA, stringB) {
  return stringA + stringB
};
cc.INT_VALUE = 0;
cc.FLOAT_VALUE = 1;
cc.POINTER_VALUE = 2;
cc.BOOL_VALUE = 3;
cc.UNSIGNEDCHAR_VALUE = 4;
cc.Color3BWapper = cc.Class.extend({_color:null, ctor:function() {
  this._color = new cc.Color3B(0, 0, 0)
}, getColor:function() {
  return this._color
}});
cc.Color3BWapper.create = function(color) {
  var ret = new cc.Color3BWapper;
  if(ret) {
    ret._color.r = color.r;
    ret._color.g = color.g;
    ret._color.b = color.b
  }
  return ret
};
cc.BuilderValue = cc.Class.extend({_value:null, _type:0, getIntValue:function() {
}, getFloatValue:function() {
}, getBoolValue:function() {
}, getByteValue:function() {
}, getPointer:function() {
}, getValue:function() {
  return this._value
}});
cc.BuilderValue.create = function(value) {
  var ret = new cc.BuilderValue;
  if(ret) {
    if(typeof value == "number") {
    }
  }
  return ret
};
cc.BuilderKeyframe = cc.Class.extend({_value:null, _time:0, _easingType:0, _easingOpt:0, getValue:function() {
  return this._value
}, setValue:function(value) {
  this._value = value
}, getTime:function() {
  return this._time
}, setTime:function(time) {
  this._time = time
}, getEasingType:function() {
  return this._easingType
}, setEasingType:function(easingType) {
  this._easingType = easingType
}, getEasingOpt:function() {
  return this._easingOpt
}, setEasingOpt:function(easingOpt) {
  this._easingOpt = easingOpt
}});
cc.BuilderSequence = cc.Class.extend({_duration:0, _name:"", _sequenceId:0, _chainedSequenceId:0, _callbackChannel:null, _soundChannel:null, ctor:function() {
  this._name = ""
}, getDuration:function() {
  return this._duration
}, setDuration:function(duration) {
  this._duration = duration
}, getName:function() {
  return this._name
}, setName:function(name) {
  this._name = name
}, getSequenceId:function() {
  return this._sequenceId
}, setSequenceId:function(sequenceId) {
  this._sequenceId = sequenceId
}, getChainedSequenceId:function() {
  return this._chainedSequenceId
}, setChainedSequenceId:function(chainedSequenceId) {
  this._chainedSequenceId = chainedSequenceId
}, getCallbackChannel:function() {
  return this._callbackChannel
}, setCallbackChannel:function(channel) {
  this._callbackChannel = channel
}, getSoundChannel:function() {
  return this._soundChannel
}, setSoundChannel:function(channel) {
  this._soundChannel = channel
}});
cc.BuilderSequenceProperty = cc.Class.extend({_name:null, _type:0, _keyFrames:null, ctor:function() {
  this.init()
}, init:function() {
  this._keyFrames = [];
  this._name = ""
}, getName:function() {
  return this._name
}, setName:function(name) {
  this._name = name
}, getType:function() {
  return this._type
}, setType:function(type) {
  this._type = type
}, getKeyframes:function() {
  return this._keyFrames
}});
cc.getAbsolutePosition = function(pt, type, containerSize, propName) {
  var absPt = cc.p(0, 0);
  if(type == CCB_POSITIONTYPE_RELATIVE_BOTTOM_LEFT) {
    absPt = pt
  }else {
    if(type == CCB_POSITIONTYPE_RELATIVE_TOP_LEFT) {
      absPt.x = pt.x;
      absPt.y = containerSize.height - pt.y
    }else {
      if(type == CCB_POSITIONTYPE_RELATIVE_TOP_RIGHT) {
        absPt.x = containerSize.width - pt.x;
        absPt.y = containerSize.height - pt.y
      }else {
        if(type == CCB_POSITIONTYPE_RELATIVE_BOTTOM_RIGHT) {
          absPt.x = containerSize.width - pt.x;
          absPt.y = pt.y
        }else {
          if(type == CCB_POSITIONTYPE_PERCENT) {
            absPt.x = containerSize.width * pt.x / 100;
            absPt.y = containerSize.height * pt.y / 100
          }else {
            if(type == CCB_POSITIONTYPE_MULTIPLY_RESOLUTION) {
              var resolutionScale = cc.BuilderReader.getResolutionScale();
              absPt.x = pt.x * resolutionScale;
              absPt.y = pt.y * resolutionScale
            }
          }
        }
      }
    }
  }
  return absPt
};
cc.setRelativeScale = function(node, scaleX, scaleY, type, propName) {
  cc.Assert(node, "pNode should not be null");
  if(type == CCB_POSITIONTYPE_MULTIPLY_RESOLUTION) {
    var resolutionScale = cc.BuilderReader.getResolutionScale();
    scaleX *= resolutionScale;
    scaleY *= resolutionScale
  }
  node.setScaleX(scaleX);
  node.setScaleY(scaleY)
};
cc.BuilderAnimationManagerDelegate = cc.Class.extend({completedAnimationSequenceNamed:function(name) {
}});
cc.BuilderAnimationManager = cc.Class.extend({_sequences:null, _nodeSequences:null, _baseValues:null, _autoPlaySequenceId:0, _rootNode:null, _owner:null, _rootContainerSize:null, _delegate:null, _runningSequence:null, _documentOutletNames:null, _documentOutletNodes:null, _documentCallbackNames:null, _documentCallbackNodes:null, _documentControllerName:"", _lastCompletedSequenceName:"", _keyframeCallbacks:null, _keyframeCallFuncs:null, _animationCompleteCallbackFunc:null, _target:null, _jsControlled:false, 
ctor:function() {
  this._rootContainerSize = cc.size(0, 0);
  this.init()
}, init:function() {
  this._sequences = [];
  this._nodeSequences = new cc._Dictionary;
  this._baseValues = new cc._Dictionary;
  this._documentOutletNames = [];
  this._documentOutletNodes = [];
  this._documentCallbackNames = [];
  this._documentCallbackNodes = [];
  this._keyframeCallbacks = [];
  this._keyframeCallFuncs = {};
  return true
}, getSequences:function() {
  return this._sequences
}, setSequences:function(seqs) {
  this._sequences = seqs
}, getAutoPlaySequenceId:function() {
  return this._autoPlaySequenceId
}, setAutoPlaySequenceId:function(autoPlaySequenceId) {
  this._autoPlaySequenceId = autoPlaySequenceId
}, getRootNode:function() {
  return this._rootNode
}, setRootNode:function(rootNode) {
  this._rootNode = rootNode
}, getOwner:function() {
  return this._owner
}, setOwner:function(owner) {
  this._owner = owner
}, addDocumentCallbackNode:function(node) {
  this._documentCallbackNodes.push(node)
}, addDocumentCallbackName:function(name) {
  this._documentCallbackNames.push(name)
}, addDocumentOutletNode:function(node) {
  this._documentOutletNodes.push(node)
}, addDocumentOutletName:function(name) {
  this._documentOutletNames.push(name)
}, setDocumentControllerName:function(name) {
  this._documentControllerName = name
}, getDocumentControllerName:function() {
  return this._documentControllerName
}, getDocumentCallbackNames:function() {
  return this._documentCallbackNames
}, getDocumentCallbackNodes:function() {
  return this._documentCallbackNodes
}, getDocumentOutletNames:function() {
  return this._documentOutletNames
}, getDocumentOutletNodes:function() {
  return this._documentOutletNodes
}, getLastCompletedSequenceName:function() {
  return this._lastCompletedSequenceName
}, getKeyframeCallbacks:function() {
  return this._keyframeCallbacks
}, getRootContainerSize:function() {
  return this._rootContainerSize
}, setRootContainerSize:function(rootContainerSize) {
  this._rootContainerSize = cc.size(rootContainerSize.width, rootContainerSize.height)
}, getDelegate:function() {
  return this._delegate
}, setDelegate:function(delegate) {
  this._delegate = delegate
}, getRunningSequenceName:function() {
  return this._runningSequence.getName()
}, getContainerSize:function(node) {
  if(node) {
    return node.getContentSize()
  }else {
    return this._rootContainerSize
  }
}, addNode:function(node, seq) {
  this._nodeSequences.setObject(seq, node)
}, setBaseValue:function(value, node, propName) {
  var props = this._baseValues.objectForKey(node);
  if(!props) {
    props = new cc._Dictionary;
    this._baseValues.setObject(props, node)
  }
  props.setObject(value, propName)
}, moveAnimationsFromNode:function(fromNode, toNode) {
  var baseValue = this._baseValues.objectForKey(fromNode);
  if(baseValue != null) {
    this._baseValues.setObject(baseValue, toNode);
    this._baseValues.removeObjectForKey(fromNode)
  }
  var seqs = this._nodeSequences.objectForKey(fromNode);
  if(seqs != null) {
    this._nodeSequences.setObject(seqs, toNode);
    this._nodeSequences.removeObjectForKey(fromNode)
  }
}, getActionForCallbackChannel:function(channel) {
  var lastKeyframeTime = 0;
  var actions = [];
  var keyframes = channel.getKeyframes();
  var numKeyframes = keyframes.length;
  for(var i = 0;i < numKeyframes;++i) {
    var keyframe = keyframes[i];
    var timeSinceLastKeyframe = keyframe.getTime() - lastKeyframeTime;
    lastKeyframeTime = keyframe.getTime();
    if(timeSinceLastKeyframe > 0) {
      actions.push(cc.DelayTime.create(timeSinceLastKeyframe))
    }
    var keyVal = keyframe.getValue();
    var selectorName = keyVal[0];
    var selectorTarget = keyVal[1];
    if(this._jsControlled) {
      var callbackName = selectorTarget + ":" + selectorName;
      var callback = this._keyframeCallFuncs[callbackName];
      if(callback != null) {
        actions.push(callback)
      }
    }else {
      var target;
      if(selectorTarget == CCB_TARGETTYPE_DOCUMENTROOT) {
        target = this._rootNode
      }else {
        if(selectorTarget == CCB_TARGETTYPE_OWNER) {
          target = this._owner
        }
      }
      if(target != null) {
        if(selectorName.length > 0) {
          var selCallFunc = 0;
          var targetAsCCBSelectorResolver = target;
          if(target.onResolveCCBCCCallFuncSelector != null) {
            selCallFunc = targetAsCCBSelectorResolver.onResolveCCBCCCallFuncSelector(target, selectorName)
          }
          if(selCallFunc == 0) {
            cc.log("Skipping selector '" + selectorName + "' since no CCBSelectorResolver is present.")
          }else {
            actions.push(cc.CallFunc.create(selCallFunc, target))
          }
        }else {
          cc.log("Unexpected empty selector.")
        }
      }
    }
  }
  if(actions.length < 1) {
    return null
  }
  return cc.Sequence.create(actions)
}, getActionForSoundChannel:function(channel) {
  var lastKeyframeTime = 0;
  var actions = [];
  var keyframes = channel.getKeyframes();
  var numKeyframes = keyframes.length;
  for(var i = 0;i < numKeyframes;++i) {
    var keyframe = keyframes[i];
    var timeSinceLastKeyframe = keyframe.getTime() - lastKeyframeTime;
    lastKeyframeTime = keyframe.getTime();
    if(timeSinceLastKeyframe > 0) {
      actions.push(cc.DelayTime.create(timeSinceLastKeyframe))
    }
    var keyVal = keyframe.getValue();
    var soundFile = cc.BuilderReader.getResourcePath() + keyVal[0];
    var pitch = parseFloat(keyVal[1]), pan = parseFloat(keyVal[2]), gain = parseFloat(keyVal[3]);
    actions.push(cc.BuilderSoundEffect.create(soundFile, pitch, pan, gain))
  }
  if(actions.length < 1) {
    return null
  }
  return cc.Sequence.create(actions)
}, runAnimationsForSequenceNamed:function(name) {
  this.runAnimations(name)
}, runAnimations:function(name, tweenDuration) {
  tweenDuration = tweenDuration || 0;
  var nSeqId;
  if(typeof name === "string") {
    nSeqId = this._getSequenceId(name)
  }else {
    nSeqId = name
  }
  cc.Assert(nSeqId != -1, "Sequence id couldn't be found");
  this._rootNode.stopAllActions();
  var allKeys = this._nodeSequences.allKeys();
  for(var i = 0;i < allKeys.length;i++) {
    var node = allKeys[i];
    node.stopAllActions();
    var seqs = this._nodeSequences.objectForKey(node);
    var seqNodeProps = seqs.objectForKey(nSeqId);
    var j;
    var seqNodePropNames = [];
    if(seqNodeProps) {
      var propKeys = seqNodeProps.allKeys();
      for(j = 0;j < propKeys.length;j++) {
        var propName = propKeys[j];
        var seqProp = seqNodeProps.objectForKey(propName);
        seqNodePropNames.push(propName);
        this._setFirstFrame(node, seqProp, tweenDuration);
        this._runAction(node, seqProp, tweenDuration)
      }
    }
    var nodeBaseValues = this._baseValues.objectForKey(node);
    if(nodeBaseValues) {
      var baseKeys = nodeBaseValues.allKeys();
      for(j = 0;j < baseKeys.length;j++) {
        var selBaseKey = baseKeys[j];
        if(seqNodePropNames.indexOf(selBaseKey) == -1) {
          var value = nodeBaseValues.objectForKey(selBaseKey);
          if(value != null) {
            this._setAnimatedProperty(selBaseKey, node, value, tweenDuration)
          }
        }
      }
    }
  }
  var seq = this._getSequence(nSeqId);
  var completeAction = cc.Sequence.create(cc.DelayTime.create(seq.getDuration() + tweenDuration), cc.CallFunc.create(this._sequenceCompleted, this));
  this._rootNode.runAction(completeAction);
  if(seq.getCallbackChannel()) {
    var action = this.getActionForCallbackChannel(seq.getCallbackChannel());
    if(action) {
      this._rootNode.runAction(action)
    }
  }
  if(seq.getSoundChannel()) {
    var action = this.getActionForSoundChannel(seq.getSoundChannel());
    if(action) {
      this._rootNode.runAction(action)
    }
  }
  this._runningSequence = this._getSequence(nSeqId)
}, setAnimationCompletedCallback:function(target, callbackFunc) {
  this._target = target;
  this._animationCompleteCallbackFunc = callbackFunc
}, setCompletedAnimationCallback:function(target, callbackFunc) {
  this.setAnimationCompletedCallback(target, callbackFunc)
}, setCallFunc:function(callFunc, callbackNamed) {
  this._keyframeCallFuncs[callbackNamed] = callFunc
}, debug:function() {
}, _getBaseValue:function(node, propName) {
  var props = this._baseValues.objectForKey(node);
  if(props) {
    return props.objectForKey(propName)
  }
  return null
}, _getSequenceId:function(sequenceName) {
  var element = null;
  for(var i = 0;i < this._sequences.length;i++) {
    element = this._sequences[i];
    if(element && element.getName() == sequenceName) {
      return element.getSequenceId()
    }
  }
  return-1
}, _getSequence:function(sequenceId) {
  var element = null;
  for(var i = 0;i < this._sequences.length;i++) {
    element = this._sequences[i];
    if(element && element.getSequenceId() === sequenceId) {
      return element
    }
  }
  return null
}, _getAction:function(keyframe0, keyframe1, propName, node) {
  var duration = keyframe1.getTime() - (keyframe0 ? keyframe0.getTime() : 0);
  var getArr, type, getValueArr, x, y;
  if(propName === "rotation") {
    return cc.BuilderRotateTo.create(duration, keyframe1.getValue())
  }else {
    if(propName === "rotationX") {
      return cc.BuilderRotateXTo.create(duration, keyframe1.getValue())
    }else {
      if(propName === "rotationY") {
        return cc.BuilderRotateYTo.create(duration, keyframe1.getValue())
      }else {
        if(propName === "opacity") {
          return cc.FadeTo.create(duration, keyframe1.getValue())
        }else {
          if(propName === "color") {
            var selColor = keyframe1.getValue().getColor();
            return cc.TintTo.create(duration, selColor.r, selColor.g, selColor.b)
          }else {
            if(propName === "visible") {
              var isVisible = keyframe1.getValue();
              if(isVisible) {
                return cc.Sequence.create(cc.DelayTime.create(duration), cc.Show.create())
              }else {
                return cc.Sequence.create(cc.DelayTime.create(duration), cc.Hide.create())
              }
            }else {
              if(propName === "displayFrame") {
                return cc.Sequence.create(cc.DelayTime.create(duration), cc.BuilderSetSpriteFrame.create(keyframe1.getValue()))
              }else {
                if(propName === "position") {
                  getArr = this._getBaseValue(node, propName);
                  type = getArr[2];
                  getValueArr = keyframe1.getValue();
                  x = getValueArr[0];
                  y = getValueArr[1];
                  var containerSize = this.getContainerSize(node.getParent());
                  var absPos = cc.getAbsolutePosition(cc.p(x, y), type, containerSize, propName);
                  return cc.MoveTo.create(duration, absPos)
                }else {
                  if(propName === "scale") {
                    getArr = this._getBaseValue(node, propName);
                    type = getArr[2];
                    getValueArr = keyframe1.getValue();
                    x = getValueArr[0];
                    y = getValueArr[1];
                    if(type == CCB_SCALETYPE_MULTIPLY_RESOLUTION) {
                      var resolutionScale = cc.BuilderReader.getResolutionScale()
                    }
                    return cc.ScaleTo.create(duration, x, y)
                  }else {
                    if(propName === "skew") {
                      getValueArr = keyframe1.getValue();
                      x = getValueArr[0];
                      y = getValueArr[1];
                      return cc.SkewTo.create(duration, x, y)
                    }else {
                      cc.log("BuilderReader: Failed to create animation for property: " + propName)
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return null
}, _setAnimatedProperty:function(propName, node, value, tweenDuration) {
  if(tweenDuration > 0) {
    var kf1 = new cc.BuilderKeyframe;
    kf1.setValue(value);
    kf1.setTime(tweenDuration);
    kf1.setEasingType(CCB_KEYFRAME_EASING_LINEAR);
    var tweenAction = this._getAction(null, kf1, propName, node);
    node.runAction(tweenAction)
  }else {
    var getArr, nType, x, y;
    if(propName === "position") {
      getArr = this._getBaseValue(node, propName);
      nType = getArr[2];
      x = value[0];
      y = value[1];
      node.setPosition(cc.getAbsolutePosition(cc.p(x, y), nType, this.getContainerSize(node.getParent()), propName))
    }else {
      if(propName === "scale") {
        getArr = this._getBaseValue(node, propName);
        nType = getArr[2];
        x = value[0];
        y = value[1];
        cc.setRelativeScale(node, x, y, nType, propName)
      }else {
        if(propName === "skew") {
          getArr = this._getBaseValue(node, propName);
          nType = getArr[2];
          x = value[0];
          y = value[1];
          node.setSkewX(x);
          node.setSkewY(y)
        }else {
          if(propName === "rotation") {
            node.setRotation(value)
          }else {
            if(propName === "opacity") {
              node.setOpacity(value)
            }else {
              if(propName === "displayFrame") {
                node.setDisplayFrame(value)
              }else {
                if(propName === "color") {
                  node.setColor(value.getColor())
                }else {
                  if(propName === "visible") {
                    value = value || false;
                    node.setVisible(value)
                  }else {
                    cc.log("unsupported property name is " + propName);
                    cc.Assert(false, "unsupported property now")
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, _setFirstFrame:function(node, seqProp, tweenDuration) {
  var keyframes = seqProp.getKeyframes();
  if(keyframes.length == 0) {
    var baseValue = this._getBaseValue(node, seqProp.getName());
    cc.Assert(baseValue, "No baseValue found for property");
    this._setAnimatedProperty(seqProp.getName(), node, baseValue, tweenDuration)
  }else {
    var keyframe = keyframes[0];
    this._setAnimatedProperty(seqProp.getName(), node, keyframe.getValue(), tweenDuration)
  }
}, _getEaseAction:function(action, easingType, easingOpt) {
  if(easingType === CCB_KEYFRAME_EASING_LINEAR || easingType === CCB_KEYFRAME_EASING_INSTANT) {
    return action
  }else {
    if(easingType === CCB_KEYFRAME_EASING_CUBIC_IN) {
      return cc.EaseIn.create(action, easingOpt)
    }else {
      if(easingType === CCB_KEYFRAME_EASING_CUBIC_OUT) {
        return cc.EaseOut.create(action, easingOpt)
      }else {
        if(easingType === CCB_KEYFRAME_EASING_CUBIC_INOUT) {
          return cc.EaseInOut.create(action, easingOpt)
        }else {
          if(easingType === CCB_KEYFRAME_EASING_BACK_IN) {
            return cc.EaseBackIn.create(action)
          }else {
            if(easingType === CCB_KEYFRAME_EASING_BACK_OUT) {
              return cc.EaseBackOut.create(action)
            }else {
              if(easingType === CCB_KEYFRAME_EASING_BACK_INOUT) {
                return cc.EaseBackInOut.create(action)
              }else {
                if(easingType === CCB_KEYFRAME_EASING_BOUNCE_IN) {
                  return cc.EaseBounceIn.create(action)
                }else {
                  if(easingType === CCB_KEYFRAME_EASING_BOUNCE_OUT) {
                    return cc.EaseBounceOut.create(action)
                  }else {
                    if(easingType === CCB_KEYFRAME_EASING_BOUNCE_INOUT) {
                      return cc.EaseBounceInOut.create(action)
                    }else {
                      if(easingType === CCB_KEYFRAME_EASING_ELASTIC_IN) {
                        return cc.EaseElasticIn.create(action, easingOpt)
                      }else {
                        if(easingType === CCB_KEYFRAME_EASING_ELASTIC_OUT) {
                          return cc.EaseElasticOut.create(action, easingOpt)
                        }else {
                          if(easingType === CCB_KEYFRAME_EASING_ELASTIC_INOUT) {
                            return cc.EaseElasticInOut.create(action, easingOpt)
                          }else {
                            cc.log("BuilderReader: Unkown easing type " + easingType);
                            return action
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, _runAction:function(node, seqProp, tweenDuration) {
  var keyframes = seqProp.getKeyframes();
  var numKeyframes = keyframes.length;
  if(numKeyframes > 1) {
    var actions = [];
    var keyframeFirst = keyframes[0];
    var timeFirst = keyframeFirst.getTime() + tweenDuration;
    if(timeFirst > 0) {
      actions.push(cc.DelayTime.create(timeFirst))
    }
    for(var i = 0;i < numKeyframes - 1;++i) {
      var kf0 = keyframes[i];
      var kf1 = keyframes[i + 1];
      var action = this._getAction(kf0, kf1, seqProp.getName(), node);
      if(action) {
        action = this._getEaseAction(action, kf0.getEasingType(), kf0.getEasingOpt());
        actions.push(action)
      }
    }
    var seq = cc.Sequence.create(actions);
    node.runAction(seq)
  }
}, _sequenceCompleted:function() {
  if(this._lastCompletedSequenceName != this._runningSequence.getName()) {
    this._lastCompletedSequenceName = this._runningSequence.getName()
  }
  if(this._delegate) {
    this._delegate.completedAnimationSequenceNamed(this._runningSequence.getName())
  }
  if(this._target && this._animationCompleteCallbackFunc) {
    this._animationCompleteCallbackFunc.call(this._target)
  }
  var nextSeqId = this._runningSequence.getChainedSequenceId();
  this._runningSequence = null;
  if(nextSeqId != -1) {
    this.runAnimations(nextSeqId, 0)
  }
}});
cc.BuilderSetSpriteFrame = cc.ActionInstant.extend({_spriteFrame:null, initWithSpriteFrame:function(spriteFrame) {
  this._spriteFrame = spriteFrame;
  return true
}, update:function(time) {
  this._target.setDisplayFrame(this._spriteFrame)
}});
cc.BuilderSetSpriteFrame.create = function(spriteFrame) {
  var ret = new cc.BuilderSetSpriteFrame;
  if(ret) {
    if(ret.initWithSpriteFrame(spriteFrame)) {
      return ret
    }
  }
  return null
};
cc.BuilderRotateTo = cc.ActionInterval.extend({_startAngle:0, _dstAngle:0, _diffAngle:0, initWithDuration:function(duration, angle) {
  if(this._super(duration)) {
    this._dstAngle = angle;
    return true
  }else {
    return false
  }
}, update:function(time) {
  this._target.setRotation(this._startAngle + this._diffAngle * time)
}, startWithTarget:function(node) {
  this._super(node);
  this._startAngle = this._target.getRotation();
  this._diffAngle = this._dstAngle - this._startAngle
}});
cc.BuilderRotateTo.create = function(duration, angle) {
  var ret = new cc.BuilderRotateTo;
  if(ret) {
    if(ret.initWithDuration(duration, angle)) {
      return ret
    }
  }
  return null
};
cc.BuilderRotateXTo = cc.ActionInterval.extend({});
cc.BuilderRotateXTo.create = function(duration, angle) {
  cc.Assert(false, "rotationX not implemented in cocos2d-html5");
  return null
};
cc.BuilderRotateYTo = cc.ActionInterval.extend({});
cc.BuilderRotateYTo.create = function(duration, angle) {
  cc.Assert(false, "rotationY not implemented in cocos2d-html5");
  return null
};
cc.BuilderSoundEffect = cc.ActionInstant.extend({init:function(file) {
  this._file = file;
  return true
}, update:function(dt) {
  cc.AudioEngine.getInstance().playEffect(this._file)
}});
cc.BuilderSoundEffect.create = function(file, pitch, pan, gain) {
  var ret = new cc.BuilderSoundEffect;
  if(ret && ret.init(file)) {
    return ret
  }
  return null
};
cc.KEYBOARD_RETURNTYPE_DEFAULT = 0;
cc.KEYBOARD_RETURNTYPE_DONE = 1;
cc.KEYBOARD_RETURNTYPE_SEND = 2;
cc.KEYBOARD_RETURNTYPE_SEARCH = 3;
cc.KEYBOARD_RETURNTYPE_GO = 4;
cc.EDITBOX_INPUT_MODE_ANY = 0;
cc.EDITBOX_INPUT_MODE_EMAILADDR = 1;
cc.EDITBOX_INPUT_MODE_NUMERIC = 2;
cc.EDITBOX_INPUT_MODE_PHONENUMBER = 3;
cc.EDITBOX_INPUT_MODE_URL = 4;
cc.EDITBOX_INPUT_MODE_DECIMAL = 5;
cc.EDITBOX_INPUT_MODE_SINGLELINE = 6;
cc.EDITBOX_INPUT_FLAG_PASSWORD = 0;
cc.EDITBOX_INPUT_FLAG_SENSITIVE = 1;
cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_WORD = 2;
cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_SENTENCE = 3;
cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_ALL_CHARACTERS = 4;
cc.EditBoxDelegate = cc.Class.extend({editBoxEditingDidBegin:function(sender) {
}, editBoxEditingDidEnd:function(sender) {
}, editBoxTextChanged:function(sender, text) {
}, editBoxReturn:function(sender) {
}});
cc.EditBox = cc.ControlButton.extend({_domInputSprite:null, _delegate:null, _editBoxInputMode:cc.EDITBOX_INPUT_MODE_ANY, _editBoxInputFlag:cc.EDITBOX_INPUT_FLAG_SENSITIVE, _keyboardReturnType:cc.KEYBOARD_RETURNTYPE_DEFAULT, _text:"", _placeholderText:"", _textColor:null, _placeholderColor:null, _maxLength:50, _adjustHeight:18, _edTxt:null, _edFontSize:14, _edFontName:"Arial", _placeholderFontName:"", _placeholderFontSize:14, _tooltip:false, ctor:function(boxSize) {
  this._super();
  this._textColor = cc.WHITE;
  this._placeholderColor = cc.GRAY;
  this._domInputSprite = new cc.Sprite;
  this._domInputSprite.setColor(cc.BLUE);
  this._domInputSprite.setContentSize(cc.size(boxSize.width - 10, boxSize.height - 10));
  this._domInputSprite.draw = function() {
  };
  this.addChild(this._domInputSprite);
  var selfPointer = this;
  this._edTxt = document.createElement("input");
  this._edTxt.type = "text";
  this._edTxt.style.fontSize = this._edFontSize + "px";
  this._edTxt.style.color = "#000000";
  this._edTxt.style.border = 0;
  this._edTxt.style.background = "transparent";
  this._edTxt.style.paddingLeft = "2px";
  this._edTxt.style.width = "100%";
  this._edTxt.style.height = "100%";
  this._edTxt.style.active = 0;
  this._edTxt.style.outline = "medium";
  this._edTxt.addEventListener("input", function() {
    if(selfPointer._delegate && selfPointer._delegate.editBoxTextChanged) {
      selfPointer._delegate.editBoxTextChanged(selfPointer, this.value)
    }
  });
  this._edTxt.addEventListener("keypress", function(e) {
    if(e.keyCode === cc.KEY.enter) {
      e.stopPropagation();
      e.preventDefault();
      cc.canvas.focus()
    }
  });
  this._edTxt.addEventListener("focus", function() {
    if(this.value == selfPointer._placeholderText) {
      this.value = "";
      this.style.color = cc.convertColor3BtoHexString(selfPointer._textColor)
    }
    if(selfPointer._delegate && selfPointer._delegate.editBoxEditingDidBegin) {
      selfPointer._delegate.editBoxEditingDidBegin(selfPointer)
    }
  });
  this._edTxt.addEventListener("blur", function() {
    if(this.value == "") {
      this.value = selfPointer._placeholderText;
      this.style.color = cc.convertColor3BtoHexString(selfPointer._placeholderColor)
    }
    if(selfPointer._delegate && selfPointer._delegate.editBoxEditingDidEnd) {
      selfPointer._delegate.editBoxEditingDidEnd(selfPointer)
    }
    if(selfPointer._delegate && selfPointer._delegate.editBoxReturn) {
      selfPointer._delegate.editBoxReturn(selfPointer)
    }
  });
  cc.DOM.convert(this._domInputSprite);
  this._domInputSprite.dom.appendChild(this._edTxt);
  this._domInputSprite.dom.showTooltipDiv = false;
  this._domInputSprite.dom.className = "";
  this._domInputSprite.canvas.remove()
}, setFont:function(fontName, fontSize) {
  this._edFontSize = fontSize;
  this._edFontName = fontName;
  if(this._edTxt.value == this._placeholderText) {
    this._setFontToEditBox()
  }
}, _setFontToEditBox:function() {
  this._edTxt.style.fontFamily = this._placeholderFontName;
  this._edTxt.style.fontSize = this._placeholderFontSize
}, setText:function(text) {
  if(text != null) {
    if(text == "") {
      this._edTxt.value = this._placeholderText;
      this._edTxt.style.color = cc.convertColor3BtoHexString(this._placeholderColor)
    }else {
      this._edTxt.value = text;
      this._edTxt.style.color = cc.convertColor3BtoHexString(this._textColor)
    }
  }
}, setFontColor:function(color) {
  this._textColor = color;
  if(this._edTxt.value != this._placeholderText) {
    this._edTxt.style.color = cc.convertColor3BtoHexString(color)
  }
}, setMaxLength:function(maxLength) {
  if(!isNaN(maxLength) && maxLength > 0) {
    this._maxLength = maxLength;
    this._edTxt.maxLength = maxLength
  }
}, getMaxLength:function() {
  return this._maxLength
}, setPlaceHolder:function(text) {
  if(text != null) {
    var oldPlaceholderText = this._placeholderText;
    this._placeholderText = text;
    if(this._edTxt.value == oldPlaceholderText) {
      this._edTxt.value = text;
      this._edTxt.style.color = cc.convertColor3BtoHexString(this._placeholderColor);
      this._setPlaceholderFontToEditText()
    }
  }
}, setPlaceholderFont:function(fontName, fontSize) {
  this._placeholderFontName = fontName;
  this._placeholderFontSize = fontSize;
  if(this._edTxt.value == this._placeholderText) {
    this._setPlaceholderFontToEditText()
  }
}, _setPlaceholderFontToEditText:function() {
  this._edTxt.style.fontFamily = this._placeholderFontName;
  this._edTxt.style.fontSize = this._placeholderFontSize
}, setPlaceholderFontColor:function(color) {
  this._placeholderColor = color;
  if(this._edTxt.value == this._placeholderText) {
    this._edTxt.style.color = cc.convertColor3BtoHexString(color)
  }
}, setInputFlag:function(inputFlag) {
  this._editBoxInputFlag = inputFlag;
  if(inputFlag == cc.EDITBOX_INPUT_FLAG_PASSWORD) {
    this._edTxt.type = "password"
  }else {
    this._edTxt.type = "text"
  }
}, getText:function() {
  return this._edTxt.value
}, initWithSizeAndBackgroundSprite:function(size, normal9SpriteBg) {
  if(this.initWithBackgroundSprite(normal9SpriteBg)) {
    this._domInputSprite.setPosition(cc.p(3, 3));
    this.setZoomOnTouchDown(false);
    this.setPreferredSize(size);
    this.setPosition(cc.p(0, 0));
    this.addTargetWithActionForControlEvent(this, this.touchDownAction, cc.CONTROL_EVENT_TOUCH_UP_INSIDE);
    return true
  }
  return false
}, setDelegate:function(delegate) {
  this._delegate = delegate
}, getPlaceHolder:function() {
  return this._placeholderText
}, setInputMode:function(inputMode) {
  this._editBoxInputMode = inputMode
}, setReturnType:function(returnType) {
  this._keyboardReturnType = returnType
}, keyboardWillShow:function(info) {
  var rectTracked = cc.EditBox.getRect(this);
  rectTracked.origin.y -= 4;
  if(!rectTracked.intersectsRect(info.end)) {
    cc.log("needn't to adjust view layout.");
    return
  }
  this._adjustHeight = info.end.getMaxY() - rectTracked.getMinY()
}, keyboardDidShow:function(info) {
}, keyboardWillHide:function(info) {
}, keyboardDidHide:function(info) {
}, touchDownAction:function(sender, controlEvent) {
}, initWithBackgroundColor:function(size, bgColor) {
  this._edWidth = size.width;
  this.dom.style.width = this._edWidth.toString() + "px";
  this._edHeight = size.height;
  this.dom.style.height = this._edHeight.toString() + "px";
  this.dom.style.backgroundColor = cc.convertColor3BtoHexString(bgColor)
}});
cc.EditBox.getRect = function(node) {
  var contentSize = node.getContentSize();
  var rect = cc.RectMake(0, 0, contentSize.width, contentSize.height);
  return cc.RectApplyAffineTransform(rect, node.nodeToWorldTransform())
};
cc.EditBox.create = function(size, normal9SpriteBg, press9SpriteBg, disabled9SpriteBg) {
  var edbox = new cc.EditBox(size);
  if(normal9SpriteBg instanceof cc.Color3B) {
    edbox.setBackgroundColor(normal9SpriteBg)
  }else {
    if(edbox.initWithSizeAndBackgroundSprite(size, normal9SpriteBg)) {
      if(press9SpriteBg) {
        edbox.setBackgroundSpriteForState(press9SpriteBg, cc.CONTROL_STATE_HIGHLIGHTED)
      }
      if(disabled9SpriteBg) {
        edbox.setBackgroundSpriteForState(disabled9SpriteBg, cc.CONTROL_STATE_DISABLED)
      }
    }
  }
  return edbox
};

